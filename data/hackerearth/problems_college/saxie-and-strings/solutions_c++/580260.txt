#include <iostream>
#include <unordered_set>
#include <set>

typedef std::unordered_set<std::string> substring_set;

template <typename Func>
void iterate_substrings(std::string const & str, Func f)
{
	for (int i = 0; i < str.size(); ++i) {
		int sizeLeft = str.size() - i;
		
		for (int j = 1; j <= sizeLeft; ++j) {
			if (f(str.substr(i, j))) {
				return;
			}
		}
	}
}

/*substring_set build_substring_set(std::string const & word)
{	
	substring_set substrings;
	
	iterate_substrings(word, [&substrings] (std::string && sub) {
		substrings.emplace(sub);
		return false;
	});
	
	return substrings;
}

bool passes_test(std::string const & word, substring_set const & set)
{
	bool passes = true;
	
	iterate_substrings(word, [&set, &passes] (std::string && sub) {
		if (set.find(sub) == set.end()) {
			passes = false;
			return true;
		}
		
		return false;
	});
	
	return passes;
}*/

bool passes_test(std::string const & word)
{
	std::string rev(word.rbegin(), word.rend());
	
	bool passes = true;
	
	iterate_substrings(word, [&rev, &passes] (std::string && sub) {
		if (rev.find(sub) == std::string::npos) {
			passes = false;
			return true;
		}
		
		return false;
	});
	
	return passes;
}

int main()
{
	int words;
	std::cin >> words;
	
	std::string word;
	
	while (words-- > 0) {
		std::cin >> word;
		
		//substring_set substrings = build_substring_set(std::string(word.rbegin(), word.rend()));
		
		std::cout << (passes_test(word) ? "YES" : "NO") << std::endl;
	}
	
	return 0;
}
