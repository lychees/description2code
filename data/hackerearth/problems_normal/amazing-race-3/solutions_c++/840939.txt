//Karol Kaszuba
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
#include <vector>
#include <cstdlib>
#include <ctime>
//#include <unordered_map>
//#include <unordered_set>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef pair<LL,LL> PII;
typedef double D;
typedef long double LD;
typedef vector<PII> VII;

#define FOR(i,x,y) for(int i=(x);i<=(y);++i)
#define REP(i,x) FOR(i,0,(x)-1)
#define FORD(i,x,y) for(int i=(x);i>=(y);--i)
#define VAR(i,c) __typeof(c) i=(c)
#define FORE(i,c) for(VAR(i,(c).begin());i!=(c).end();++i) 

#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)

#define SIZE(c) (int)((c).size())
#define ALL(c) (c).begin(),(c).end()
#define PB push_back
#define IN insert
#define ER erase
#define MP make_pair
#define ST first
#define ND second
#define IOSYNC ios_base::sync_with_stdio(0)

const int N=404;
VI kraw[N];
int lewy[N]; //czy wierzcholek jest w lewej czesci grafu dwudzielnego
int skoj[N]; //z czym jest skojarzony
int vis[N];

int dfs(int x){
  vis[x]=1;
  FOREACH(it,kraw[x]) if (skoj[*it]==-1 || !vis[skoj[*it]] && dfs(skoj[*it])){
    skoj[x]=*it; skoj[*it]=x;
    return 1;
  }
  return 0;
}

  //funkcja zwaraca wierzcholki nalezace do pewnego
  //minimalnego pokrycia wierzcholkowego, n to liczba wierzcholkow w grafie
  //krawedzie w grafie ida od wierzcholkow dla ktorych lewo[i]=1 do tych
  //dla ktorych lewo[j]=0
  //Pokrycie wierzcholkowe ma takim sam rozmiar jak skojarzenie
VI BipartiteVertexCover(int nn){
  REP(i,nn) skoj[i]=-1;
  int change;
  do{
    change=0;
    REP(i,nn) vis[i]=0;
    REP(i,nn) if (lewy[i] && !vis[i] && skoj[i]==-1 && dfs(i)) change=1; //powiekszylismy skojarzenie
  } while (change);
  VI res;
  REP(i,nn) if (lewy[i] && skoj[i]!=-1) res.PB(vis[i]?skoj[i]:i);
  return res;
}



LL funk(PII p, PII x, LL ss)
{
	LL k = ((p.ST - x.ST) * (p.ST - x.ST) +(p.ND - x.ND) * (p.ND - x.ND));
	LL l = k / (ss * ss);
	if(l * ss * ss == k)
		return l;
	return l + 1;
}

PII car[205], cp[205];
LL s[205];

LL tab[205][205];
int n, m, k;

bool czek(LL ile)
{
	int ed = 0;
	REP(i, n)
		REP(j, m)
			if(tab[i][j] <= ile)
			{
				ed++;
				kraw[i].PB(j + n);
			}
	
	VI v = BipartiteVertexCover(n + m);
	//cout << ile << " " << SIZE(v) << " " << ed << " " << n << " " << m << " " << k << "\n";
	REP(i, n)
		kraw[i].clear();
	REP(i, n + m)
	{
		vis[i] = 0;
		skoj[i] = 0;
	}
	return (SIZE(v) >= k);
}
LL binsercz(LL maks)
{
	LL pocz = 0, kon = maks, mid;
	while(true)
	{
		mid = (pocz + kon) / 2;
		if(czek(mid))
		{
			if(!czek(mid - 1))
				return mid;
			kon = mid - 1;
		}
		else
		{
			if(czek(mid + 1))
				return mid + 1;
			pocz = mid + 2;
		}
	}
}

void jebaj()
{
	cin >> n >> m >> k;
	REP(i, n)
		lewy[i] = 1;
	REP(i, n)
		cin >> car[i].ST >> car[i].ND;
	REP(i, m)
		cin >> cp[i].ST >> cp[i].ND;
	REP(i, n)
		cin >> s[i];
		
	LL maksi = 0;
	REP(i, n)
	{
		REP(j, m)
		{
			tab[i][j] = funk(car[i], cp[j], s[i]);
			maksi = max(maksi, tab[i][j]);
			//cout << tab[i][j] << " ";
		}
		//cout << "\n";
	}
	cout << binsercz(maksi) << "\n";
}

int main()
{
	IOSYNC;	
	int t;
	t = 1;
	//cin >> t;
	
	REP(i, t) 
	{
		jebaj();
	}
}
