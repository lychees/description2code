/*
Anton Gulikov
*/
#include <iostream>
#include <fstream>
#include <stack>
#include <cstdlib>
#include <cmath>
#include <string>
#include <set>
#include <map>
#include <vector>
#include <algorithm>
#include <ctime>
#include <cassert>
#include <stdio.h>
#include <queue>

#define mp make_pair
#define pb push_back
#define foru(i,n) for(int i = 0; i < n; i++)
#define ford(i,n) for(int i = n - 1; i >= 0; i++)
#define forab(i,l,r) for(int i = l; i <= r; i++)
#define forabd(i,r,l) for(int i = r; i >= l; i--)
#define sqr(x) ((x) * (x))

const long long base = 1000000000 + 7;
#define y1 sdfsf
#define y2 sdf
#define x1 sfsdff
#define x2 oiiie

using namespace std;

queue <int> q;
int f[111111];
char ch[11111];
int x1[11111], x2[11111], y1[11111], y2[11111];
int n,k;
set <int, greater <int> > tmp;
vector < pair <int, int> > g[11111];
int t[11111];
int a[1111][1111];

void solve()
{
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= k; i++)
	{
		scanf("%d%d%d%d", &x1[i], &y1[i], &x2[i], &y2[i]);
			if (x1[i] > x2[i])
			swap(x1[i], x2[i]);
		if (y1[i] > y2[i])
			swap(y1[i], y2[i]);	
	
		cin >> ch[i];
		t[i] = (ch[i] == 'b');
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
			g[j].clear();
		for (int j = 1; j <= k; j++)
		{
			if (x1[j] <= i && i <= x2[j])
			{
				g[y1[j]].push_back(make_pair(1, j));
				g[y2[j] + 1].push_back(make_pair(-1, j));				
			}
		}
		tmp.clear();
		for (int j = 1; j <= n; j++)
		{
			for (int k = 0; k < (int)g[j].size(); k++)
			{
				if (g[j][k].first == 1)
				{
					tmp.insert(g[j][k].second);
				} else
					tmp.erase(g[j][k].second);
			}
			if (tmp.size() >= 1)
			{
		//		cerr << i << " " << j << " " << *tmp.begin() << endl;
				int to = *tmp.begin();
				a[i][j] = t[to];
			}
		}		
	}
	int sum = n * n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			sum -= a[i][j];

	cout << sum << endl;
}

int main(){
	int test = 1;
	while (test--){
		solve();
	}
//2	cerr << (double)clock() / CLOCKS_PER_SEC << endl;
	return 0;
}