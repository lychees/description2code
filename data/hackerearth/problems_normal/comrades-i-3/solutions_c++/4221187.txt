#include <bits/stdc++.h>
using namespace std;
vector<int> adj[100001];
	bool v[100001];
	int dfsin[100001];
	int 	dfsout[100001];
	int ss=0;
	int he[100001];
	int root=0;
int n,m;
void dfs(int s,int h)
{
    ss++;
    he[s]=h;
    dfsin[s]=ss;
    int j;
    v[s]=1;
    for(j=0;j<adj[s].size();j++)
    {
        if(v[adj[s][j]]==0)
        dfs(adj[s][j],h+1);
    }
   ss++;
   dfsout[s]=ss;
}
int main() {
	// your code goes here
	int i,x,y,t;
	scanf("%d",&t);
	while(t--)
	{
	    //ss=0;
	  root=0;
	ss=0;
	// he[1000]={0};
	scanf("%d",&n);
	 i=0;
        while(i<=n)
        {
        	v[i]=0;
        	he[i]=0;
            adj[i].clear();
            dfsin[i]=0;
            dfsout[i]=0;
            i++;
        }

	for(i=0;i<n;i++)
	{
	    scanf("%d",&x);
	//scanf("%d",&y);
	if(x==0)
	{
	    root=i+1;
	    
	}
	else
	{
	adj[x].push_back(i+1);
		//adj[y].push_back(x);
	}
	}
	int cc=0;
	 dfs(root,0);
	for(i=0;i<n;i++)
	{
	    if(v[i]==0)
	    {
	       
	        cc++;
	       // cout<<i<<endl;
	    }
	}
	int q,aa,bb;
	scanf("%d",&q);
	while(q--)
	{
	    scanf("%d",&aa);
	    scanf("%d",&bb);
	    
	     if((dfsin[aa]>dfsin[bb] ) && (dfsout[aa]<dfsout[bb] ))
	    {
	         printf("%d\n",he[aa]-he[bb]-1);
	         
	    }
	    else
	    {
	         printf("-1\n");
	    }
	    
	}
//	cout<<"s"<<endl;
	
	}
	return 0;
}
/*
DFSIN and DFSOUT:

Use a global variable, step. Initialise it to zero. Increment this variable whenever you call an instance of dfs() or whenever you return from an instance of dfs().

When you enter dfs() for the ith node, increment step and assign dfsin[i]=step;

and when you are about to return from dfs() of the ith node, increment step and assign dfsout[i]=step;

All values in dfsin[] and dfsout[] will be unique. i.e. All the 2*n numbers in the two arrays dfsin[] and dfsout[] will be unique.

Now for each query:

(1) First check if y is superior of x.

If ( dfsin[y] < dfsin[x] && dfsout[x] < dfsout[y] ) is true, then y is the superior of x.

If it is false, then just print -1.

(2) If y is the superior of x, then the answer is heightof[x]-heightof[y]-1

*/
