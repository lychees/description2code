#include<bits/stdc++.h>
#define ALL(X)        X.begin(),X.end()
#define FOR(I,A,B)    for(int (I) = (A); (I) <= (B); (I)++)
#define FORW(I,A,B)   for(int (I) = (A); (I) < (B);  (I)++)
#define FORD(I,A,B)   for(int (I) = (A); (I) >= (B); (I)--)
#define FOREACH(I,A)  for(__typeof(A.begin()) I = A.begin(); I != A.end(); ++I)
#define CLEAR(X)      memset(X,0,sizeof(X))
#define SIZE(X)       int(X.size())
#define CONTAIN(A,X)  (A.find(X) != A.end())
#define PB            push_back
#define MP            make_pair
#define X             first
#define Y             second
#define LBOUND(P,R,Q) ({__typeof(P) X=P,RR=(R), PP = P; while(PP<RR) {X = (PP+(RR-PP)/2); if(Q) RR = X; else PP = X+1;} PP;})
using namespace std;
typedef signed long long slong;
typedef long double ldouble;
const slong Infinity = 1000000100;
const ldouble Epsilon = 1e-9;
template<typename T, typename U> ostream& operator << (ostream& os, const pair<T,U>&p) { return os << "(" << p.X << "," << p.Y << ")"; }
template<typename T> ostream& operator << (ostream &os, const vector<T>& V) { os << "["; FORW(i,0,SIZE(V)) os << V[i] << ((i==SIZE(V)-1) ? "" : ","); return os << "]"; }
template<typename T> ostream& operator << (ostream &os, const set<T>& S) {os << "("; FOREACH(i,S) os << *i << (*i==*S.rbegin()?"":","); return os << ")"; }
template<typename T, typename U> ostream& operator << (ostream &os, const map<T, U>& M){os << "{"; FOREACH(i,M) os << *i << (*i.X==M.rbegin()->X?"":","); return os << "}"; }

void read_data() {
}

void solve() {   
}

slong mod=1000000007;
const int N = 3400;
int dp[N][N], accu[N][N], diag[N][N];

int main() {
    read_data();
    solve();
    
    int n,l,t,k;
    scanf("%d %d %d %d", &n, &l, &t, &k);
    
    dp[0][0]=1;
    accu[1][0]=k;
    accu[l-1][0]=(accu[l-1][0]+mod-k)%mod;
    diag[l-1][0]=(mod+k)%mod;
    
    
    FOR(i,0,n)
    {
        FOR(j,0,t)
        {
            if(i)
            {
                dp[i][j]=((slong)dp[i][j]+accu[i][j]+diag[i][j])%mod;
                //printf("%d ", dp[i][j]);
                
                accu[i+1][j]=((slong)accu[i+1][j] + ((slong)dp[i][j]*(k-1))%mod)%mod;
                accu[i+l-1][j]=((slong)accu[i+l-1][j] + mod - ((slong)dp[i][j]*(k-1))%mod)%mod;
                
                diag[i+l-1][j]=((slong)diag[i+l-1][j] + ((slong)dp[i][j]*(k-1))%mod)%mod;
            }
            
            
            accu[i+1][j]=(accu[i+1][j]+accu[i][j])%mod;
            diag[i+1][j+1]=(diag[i+1][j+1]+diag[i][j])%mod;
        }
        //printf("\n");
    }
    
    printf("%d\n", dp[n][t]);
    return 0;
}
