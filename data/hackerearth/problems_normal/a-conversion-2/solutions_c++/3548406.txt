#include <bits/stdc++.h>
 
using namespace std;
 
#define ll long long int
#define pb push_back
#define mp make_pair
#define INF (ll)(1e18)
#define inf 0x7fffffff
#define inff 100000
#define ff first
#define ss second
#define sz(x) ((int) (x).size())
#define fast cin.sync_with_stdio(0);cin.tie(0)
#define rep(i,N) for(int i = 0;i < N;i++)
#define frep(i,a,b) for(int i = a;i <= b;i++)
#define pii pair<int , int>
#define pll pair<ll , ll>
#define vii vector<int>
#define fill(A,v) memset(A,v,sizeof(A))
#define setbits(x) __builtin_popcount(x)
#define print(A,j,k) for(int ii=j;ii<=k;ii++)cout<<A[ii]<<" ";cout<<"\n"
#define all(x) (x).begin(), (x).end()
#define gcd __gcd
#define SQRT 350
#define CASES int t;cin>>t;while(t--)
#define FILE freopen("inp.txt" , "r" , stdin);
#define ld long double

const int N = 1e3 + 5;
const int MOD = 1e9 + 7;

// map<string , int> dp;

// int solve(string a) {
// 	if (dp.count(a) > 0)
// 		return dp[a];
// 	// dp[a] = inf;
// 	if (a == b)
// 		return dp[a] = 0;

// 	int ans = inf;
// 	rep(i , a.size()) {
// 		if (a[i] != 'J') {
// 			char c = a[i];
// 			a[i] = ((a[i] - 'a') + 1) + 'a';
// 			ans = min(ans , solve(a));
// 			a[i] = c;
// 		}
// 	}

// 	rep(i , a.size()) {
// 		if (a[i] != 'A') {
// 			char c = a[i];
// 			a[i] = ((a[i] - 'a') - 1) + 'a';
// 			ans = min(ans , solve(a));
// 			a[i] = c;
// 		}
// 	}

// 	rep(i , a.size()) {
// 		for(int j = i + 1;j < a.size();j++) {
// 			if (a[i] != a[j])
// 		}
// 	}

// }

int  _mergeSort(int arr[], int temp[], int left, int right);
int merge(int arr[], int temp[], int left, int mid, int right);
  
/* This function sorts the input array and returns the
   number of inversions in the array */
int mergeSort(int arr[], int array_size)
{
    int *temp = (int *)malloc(sizeof(int)*array_size);
    return _mergeSort(arr, temp, 0, array_size - 1);
}
  
/* An auxiliary recursive function that sorts the input array and
  returns the number of inversions in the array. */
int _mergeSort(int arr[], int temp[], int left, int right)
{
  int mid, inv_count = 0;
  if (right > left)
  {
    /* Divide the array into two parts and call _mergeSortAndCountInv()
       for each of the parts */
    mid = (right + left)/2;
  
    /* Inversion count will be sum of inversions in left-part, right-part
      and number of inversions in merging */
    inv_count  = _mergeSort(arr, temp, left, mid);
    inv_count += _mergeSort(arr, temp, mid+1, right);
  
    /*Merge the two parts*/
    inv_count += merge(arr, temp, left, mid+1, right);
  }
  return inv_count;
}
  
/* This funt merges two sorted arrays and returns inversion count in
   the arrays.*/
int merge(int arr[], int temp[], int left, int mid, int right)
{
  int i, j, k;
  int inv_count = 0;
  
  i = left; /* i is index for left subarray*/
  j = mid;  /* i is index for right subarray*/
  k = left; /* i is index for resultant merged subarray*/
  while ((i <= mid - 1) && (j <= right))
  {
    if (arr[i] <= arr[j])
    {
      temp[k++] = arr[i++];
    }
    else
    {
      temp[k++] = arr[j++];
  
     /*this is tricky -- see above explanation/diagram for merge()*/
      inv_count = inv_count + (mid - i);
    }
  }
  
  /* Copy the remaining elements of left subarray
   (if there are any) to temp*/
  while (i <= mid - 1)
    temp[k++] = arr[i++];
  
  /* Copy the remaining elements of right subarray
   (if there are any) to temp*/
  while (j <= right)
    temp[k++] = arr[j++];
  
  /*Copy back the merged elements to original array*/
  for (i=left; i <= right; i++)
    arr[i] = temp[i];
  
  return inv_count;
}
  
// /* Driver progra to test above functions */
// int main(int argv, char** args)
// {
//   int arr[] = {1, 20, 6, 4, 5};
//   printf(" Number of inversions are %d \n", mergeSort(arr, 5));
//   getchar();
//   return 0;
// }

	// vii Q[30];
	// cout << "A " << a << "\n";
	// cout << "B " << b << "\n";
	// rep(i , a.size()) {
	// 	Q[b[i] - 'A'].pb(i);
	// }
	// int temp[30];
	// rep(i , 26)
	// 	temp[i] = 0;

	// rep(i , a.size()) {
	// 	P[i] = 1 + Q[a[i] - 'A'][temp[a[i] - 'A']++];
	// }

	// // cout << "merging\n";
	// return mergeSort(P , a.size());


int P[30] , pos[30] , X[30];

int swaps(int X[] , int n) {

	int swaps = 0;
	map<int , int> seen;
	rep(i , n) {
		if (!seen[i]) {
			int j = i;
			while (X[j] != i) {
				j = X[j];
				seen[j] = 1;
				swaps++;
			}
		}
	}
	return swaps;
}

string generate(int X[] , int n) {
	string a = "";
	rep(i , n) {
		a.pb(pos[X[i]]);
	}
	return a;
}

int solve(string a , string b) {

	int n = a.size();
	rep(i , n)
		X[i] = i;

	int ans = inf;

	do {
		string a = generate(X , n);
		int s = swaps(X , n);
		// cout << "swaps " << s << '\n';
		rep(i , a.size())
			s += abs(a[i] - b[i]);
		ans = min(ans , s);
	} while(next_permutation(X , X + n));

	return ans;
}


int main(int argc, char const *argv[])
{
	// fast;

	CASES {

		string a , b;
		cin >> a >> b;
		rep(i , a.size())
			pos[i] = a[i];
		cout << solve(a , b) << '\n';

	}
	
	return 0;
}