#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <fstream>
using namespace std;
 /*some important notes( ;) ) --- length of number n in base b = logb(n) + 1 (logb(n) is log n to base b)*/
/*base conversion algorithm -- vector<int> tobase(int base , int val) { vector<int> res; while(val){res.pb(val%base); val = val/base;}return res;}*/
/*what is first power of n that has k digits in base b -- doing log multiple times ans comes to x(first power) = roundup[(k - 1) * (ln(10)/ln(n))]*/
/*bezouts identity - gcd(a1,a2...an) = a1*x1 + a2*x2 + .... + an*xn , gcd(a1,a2..an) = smallest positive integer expressed in this form , every number of this form is a multiple of gcd(a1,a2..an) */
/*there are ~N/ln(N) primes less than N , if N is not a prime it has a prime divisor <= sqrt(N)*/
/*euler's theorem - if a and n are coprime then a^(totient(n)) mod n  = 1*/
/*summation((nCk)^2) from k = 0 to n  is (2n)Cn*/
/*the hockey stick sum == summation iCr from i = r to n is  (n+1)C(r+1)[n>r] ->>can be proved by pascals formula */
/*counter clockwise rotation by theta -->> [cos(theta) -sin(theta)] [x]*/
                                        /* [sin(theta) cos(theta)] [y]*/
        #define rep(i,n) for(int i = 0; i < n; ++i)
        #define REP(i,a,b) for(int i = a ; i <= b; ++i)
        #define rep1(i,n) for(int i = 1; i <=n ; ++i)
        #define s(n) scanf("%lf",&n)
        #define rev(i,n) for(int i = n-2; i >= 0 ; --i)
        #define REV(i,a,b) for(int i = a ; i >= b ; --i)
        #define INF 1000000000
        #define pii pair<int,int>
        #define pb(a) push_back(a)
        #define ll long long
        #define vi vector<int>
        #define mii map<int,int>
        #define msi map<string,int>
        #define vii vector<vector<int> >
        #define vpp vector<pair<int,int> >
        #define MOD 1000000007
        #define PDD pair<double,double>
        #define vl vector<long long>
        #define pil pair<int,long long>
        #define pll pair<long long,long long>
        #define sz(v) (int)v.size()
        #define mp make_pair
        #define pi 3.1415926536
        #define gc getchar_unlocked
        #define ios std::ios::sync_with_stdio(false)
        #define e(a) exp(a)
        #define limit 100000000
        #define gc getchar_unlocked
    ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }
    ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }
    ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }
    ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }
    ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/  return pwr(a,m-2,m); }
//vll v;
    const double EPS = 1e-9;  /*two numbers are deemed equal if their abs difference is less than some small epsilon , [less than operator- if(a<b-EPS){}],[less than or equal -if(a<b+EPS){}]*/
    
    int main(int argc, char const *argv[])
    {
    	int t;
    	cin >> t;

    	while(t--)
    	{ll c=0;
    		ll n;
    		cin >> n;
    		ll g=1;
    	    while(g<=n)
    		{
    			g=g*10;
    		}
    		g=g/10;
    		ll r= g;
    		ll c1=0;
    		while(r!=0){r=r/10;c1++;}
    		c=c+(abs(n-g)+1)*c1;
    		while(g!=1)
    		{
    			ll prev = g;
    			prev=prev-1;
    			g=g/10;
    			c=c+(abs(prev-g)+1)*(--c1);
    		}
    		cout << c << "\n";
    	}
    	
    	return 0;
    }