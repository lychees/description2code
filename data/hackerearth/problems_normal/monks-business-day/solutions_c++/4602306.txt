/*--.--.--.--.--.--.--.--.--.--.--.--.--*
 *      By-Rohit Singh                   *
 *    CS , MNNIT Allahabad               *
 *      rohitmnnit1459@gmail.com         *
 *--.--.--.--.--.--.--.--.--.--.--.--.--*/

#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <queue>
#include <stack>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <set>
#include <limits.h>
#include <assert.h>
using namespace std;

#define mp make_pair
#define pb push_back
#define X first
#define Y second
#define null NULL
#define ll long long
#define llu unsigned long long
#define MAX 200005
#define mod 100000007
#define inf 100000
#define dnf INT_MIN
#define pp pair <int, int>
//**********************************************HAPPY CODDING*****************************************************//
pair < int, pp > edge[MAX];
int n, adj, path[MAX];
bool vis[MAX];

bool solve(int root) {

    int i, node, j, u, v, wt;
    fill(path, path+n+1, dnf);
    path[root] = 0;
    for (i = 1 ; i <= n ; i++) {
        for (j = 1 ; j <= adj ; j++) {
            u = edge[j].Y.X;
            v = edge[j].Y.Y;
            wt = edge[j].X;
            if (path[u] != dnf && path[v] < path[u]+wt) {
                if (i == n)  return true;
                path[v] = path[u]+wt;
            }
        }
    }
    return false;
}

int main() {

    int t, u, v, wt, i, j;
    bool f;
    scanf("%d", &t);
    while (t--) {
        scanf("%d %d", &n, &adj);
        for (i = 1 ; i <= adj ; i++) {
            scanf("%d %d %d", &u, &v, &wt);
            edge[i] = mp(wt, mp(u, v));
        }
        f = solve(1);
        if (f) {
            printf("Yes\n");
        }
        else {
            printf("No\n");
        }
    }
    return 0;
}