/*

Paras Kumar Meena
~~~ Never Show Your Arrogance.Keep In Mind,You Were Born From A Drop Of Impure Liquid ~~~

*/

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000007
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){ return N=N | (1<<pos);}
int RESET(int N,int pos){   return N= N & ~(1<<pos);}
int check(int N,int pos){   return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){   printf("("); for(int i=6;i>=1;i--)  {bool x=check(N,i);cout<<x;}    puts(")");}
int mod(int a, int b) { return a - a/b * b;}
void Print(vector<int> Vec) { for(int i = 0; i < Vec.size(); ++i) cout<<Vec[i] << " ";puts("");}void Print(vector<ll> Vec) {for(int i = 0; i < Vec.size(); ++i) cout<< Vec[i] << "  "; puts("");}
void Print(vector<string> Vec) {for(int i = 0; i < Vec.size(); ++i) cout<< Vec[i] << " ";puts("");}
void Print(vector<double> Vec) {for(int i = 0; i < Vec.size(); ++i) cout<< Vec[i] << " ";puts("");}

int Tree[4 * MXN];
int Arr[MXN];
int N;

void build(int Node, int start, int end)
{
	if(start == end) {
		Tree[Node] = end;
		return;
	}
	
	int mid = (start + end) >> 1;
	int L = Node << 1;
	int R = L + 1;
	build(L, start, mid);
	build(R, mid + 1, end);
	
	if(Arr[Tree[L]] > Arr[Tree[R]])
		Tree[Node] = Tree[L];
	else
		Tree[Node] = Tree[R];
}

int Query(int Node, int start, int end, int lef, int rig) 
{
	if(start > rig || end < lef || start > end)
		return -1;
	
	if(start >= lef && end <= rig)
		return Tree[Node];
		
	int mid = (start + end) >> 1;
	int L = Node << 1;
	int R = L + 1;
	int p1 = Query(L, start, mid, lef, rig);
	int p2 = Query(R, mid + 1, end, lef, rig);
	
	if(p1 == -1)
		return p2;
	if(p2 == -1)
		return p1;
	if(Arr[p1] > Arr[p2])
		return p1;
	return p2;
}

int find(int start, int end)
{
	return Query(1, 0, N - 1, start, end);
}

ll rec(int start, int end)
{
	if(start > end)
		return 0;
	if(start + 1 == end)
		return max(Arr[start], Arr[end]);
	if(start == end)
		return 0;
		
	int mx_idx = find(start, end);
	
	ll p1 = 0;
	ll p2 = 0;
	
//	cout<<"mx_idx => " << mx_idx <<"\n";
	if(start <= mx_idx - 1) {
		p1 = rec(start, mx_idx - 1);
		p1 += Arr[mx_idx];
	} 
	
	if(mx_idx + 1 <= end) {
		p2 = rec(mx_idx + 1, end);
		p2 += Arr[mx_idx];
	}
	
	return p1 + p2;
}

int main()
{
	int T;
	scanf("%d", &T);
	
	while(T--) {
		scanf("%d", &N);
		for(int i = 0; i < N; ++i) {
			scanf("%d", &Arr[i]);
		}
		
		build(1, 0, N - 1);
		
		ll ans = rec(0, N - 1);
		printf("%lld\n", ans);
	}
	
	return 0;
}