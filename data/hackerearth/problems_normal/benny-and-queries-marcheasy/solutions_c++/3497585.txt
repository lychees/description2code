/*********************************ENTER THE DRAGON**********************************/

#include <cstdio>
#include <iostream>
#include <cmath>
#include <string>
#include <list>
#include <vector>
#include <algorithm>
#include <functional>
#include <utility>
#include <set>
#include <map>
#include <complex>
#include <queue>
#include <stack>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <string.h>
#include <cassert>
#include <climits>
using namespace std;

#define FOR(i,p,n) for(int i=p; i<n; i++)
#define ROF(i,a,b) for(int i=a; i>b; --i)

/************************************************************************************/

const int maxn = 500100;
const int BLOCK = 555;
int a[maxn], res[maxn];

int scan_d() 
{
    int ip = getchar_unlocked(), ret = 0, flag = 1;
	for (;ip < '0' || ip > '9'; ip = getchar_unlocked())
	   if (ip == '-'){
	      flag = -1;
		  ip = getchar_unlocked();
		  break;
	   }
	for (;ip >= '0' && ip <= '9'; ip = getchar_unlocked())
	    ret = ret * 10 + ip -'0';
	return flag * ret;
}

void print_d(int n)     
{
    if(n<0){
	   n=-n;
	   putchar_unlocked('-');
	}
	int i=10;char output_buffer[10];
	do{
	   output_buffer[--i]=(n%10)+'0';
	   n/=10;
	} while(n);
	do{
	   putchar_unlocked(output_buffer[i]);
	} while(++i<10);
}

int lessThanEqualTo(int val, vector< int >& sums) {
	  int res = -1;
	  int lo = 0, hi = (int)sums.size() - 1;
	  while(lo <= hi) {
		    int mi = (lo + hi) >> 1;
		    if(sums[mi] <= val) {
		      res = sums[mi];
		      lo = mi + 1;
		    } else {
		      hi = mi - 1;
		    }
	  }
	  return res;
}

int greaterThanEqualTo(int val, vector< int >& sums) {
	  int res = -1;
	  int lo = 0, hi = (int)sums.size() - 1;
	  while(lo <= hi) {
		    int mi = (lo + hi) >> 1;
		    if(sums[mi] >= val) {
		      res = sums[mi];
		      hi = mi - 1;
		    } else {
		      lo = mi + 1;
		    }
	  }
	  return res;
}

struct trie_node {
	   trie_node* bit[2];
	   vector<int> came;
	   trie_node (trie_node * a, trie_node * b)
	   {
	       bit[0] = a; 
		   bit[1] = b;
	   }
};
trie_node* root = new trie_node(NULL, NULL);
 
void insert(int x, int id)
{
	 trie_node* node = root;
	 
	 ROF (level, 31, -1) {
	 	 int Bit = (x >> level) & 1;
	     if (node->bit[Bit] == NULL) {
	 	     node->bit[Bit] = new trie_node(NULL, NULL);
	     } 
	     node->bit[Bit]->came.push_back(id);
	     
	     node = node->bit[Bit];
	 }
	 return;
}
 
int query(int l, int r, int x)
{
	trie_node* node = root;
	int ans = 0;
	
	ROF (level, 31, -1) {
		int Bit = (x >> level) & 1;
	    int id = Bit == 1 ? 0 : 1;
	    bool done = false;
	    if (node->bit[id] != NULL) {
	    	int hi = greaterThanEqualTo(l, node->bit[id]->came);
	        int lo = lessThanEqualTo(r, node->bit[id]->came);
	        if (hi != -1 && lo != -1 && hi <= r && lo >= l) {
			    ans += (1 << level);
			    node = node->bit[id];
			    done = true;
	        }
	    } 
	    if (!done && node->bit[Bit] != NULL) {
	    	 node = node->bit[Bit];
	    } 
	    
	}
	return ans;
}

int main()
{
   int n, q;
   n = scan_d();
   q = scan_d();
   for (int i = 0; i < n; i++) {
   	    a[i] = scan_d();;
   }
   
   for (int i = 0; i < n; i++) {
   	    insert(a[i], i);
   }
   
   for (int i = 0; i < q; i++) {
   	    int l, r, x;
   	    l = scan_d();
   	    r = scan_d();
   	    x = scan_d();
   	    print_d(query(l - 1, r - 1, x));
   	    puts("");
   }
  
   
   return 0;
}


