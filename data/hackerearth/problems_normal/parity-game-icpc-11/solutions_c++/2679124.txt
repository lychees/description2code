//why not TLE!!!!!!!!!!!!!!!!!!!!!!!111

#include <bits/stdc++.h>
#define bs 1000000007
using namespace std;
struct edge
{
	int a,b,cap,flow;
};
int n,s,t,d[1<<20],ptr[1<<20],q[1<<20];
vector<edge> e;
vector<int> g[1<<20];
int N;
void add_edge(int a,int b,int cap)
{
	edge e1={a,b,cap,0};
	edge e2={b,a,0,0};
	g[a].push_back(e.size());
	e.push_back(e1);
	g[b].push_back(e.size());
	e.push_back(e2);
}
bool bfs()
{
	int qh,qt;
	q[0]=s;
	qh=0;
	qt=1;
	for (int i=0;i<=N;i++)
		d[i]=-1;
	d[s]=0;
	
	while (qh<qt&&d[t]==-1)
	{
		int v=q[qh];
		++qh;
		for (int i=0;i<g[v].size();i++)
		{
			int id=g[v][i];
			int to=e[id].b;
			if (d[to]==-1&&e[id].flow<e[id].cap)
			{
				q[qt]=to;
				++qt;
				d[to]=d[v]+1;
			}
		}
	}
	
	return d[t]!=-1;
}
int dfs(int v,int flow)
{
	if (flow==0||v==t)
		return flow;
	for (;ptr[v]<g[v].size();++ptr[v])
	{
		int id=g[v][ptr[v]];
		int to=e[id].b;
		if (d[to]!=d[v]+1)
			continue;
		int pushed=dfs(to,min(flow,e[id].cap-e[id].flow));
		if (pushed)
		{
			e[id].flow+=pushed;
			e[id^1].flow-=pushed;
			return pushed;
		}
	}
	return 0;
}
int ans;
int dinic()
{
	int flow=0;
	while (true)
	{
		if (!bfs())
			break;
		for (int i=0;i<=N;i++)	
			ptr[i]=0;
		while (true)
		{
			int pushed=dfs(s,1000000);
			if (pushed==0)
				break;
			flow+=pushed;
			if (flow>=ans)
				break;
		}
		if (flow>=ans)
			break;
	}
	return flow;
}
int m;
int main(){
ios_base::sync_with_stdio(0);
//cin.tie(0);
cin>>n>>m;
assert(1<=n&&n<=400&&m>=1&&m<=60000);
for (int i=1;i<=m;i++)
{
	int a,b;
	cin>>a>>b;
	assert(a<=b&&1<=a&&b<=n);
	++b;
	add_edge(a,b,1);
	add_edge(b,a,1);
}
ans=1e9;
for (int to=2;to<=n+1;to++)
{
	s=1;
	t=to;
	N=n+2;
	for (int i=0;i<e.size();i++)
		e[i].flow=0;
	ans=min(ans,dinic());
}
cout<<ans<<endl;
return 0;}