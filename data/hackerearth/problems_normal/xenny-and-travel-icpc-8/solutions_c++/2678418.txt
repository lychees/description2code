#include<bits/stdc++.h>
using namespace std;

#define REP(i,a,b) for(int i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long
#define ull unsigned ll
#define pii pair<int,int>
#define piii pair<int,pii >
#define INF 1000000000
struct comp {
    bool operator() (const pii &a, const pii &b) {
        return a.second > b.second;
    }
};

priority_queue< pii, vector< pii >, comp > q;
int n;
int d1[1500][1500];
int d2[1500][1500];
bool visit[1500];
int roadU[1500];
int roadV[1500];
int railU[1500];
int railV[1500];

void dijkstra1(int st){

    for(int i=0;i<n;i++)
    {
        roadU[i]=INF;
        visit[i]=false;
    }
    roadU[st] = 0;
    q.push(pii(st,0));
    while(!q.empty())
    {
        int u = q.top().first;
        q.pop();
        if(visit[u])
        continue;
        for(int i=0;i<n;i++)
        {
            if(i==u)continue;
            int v =i;
            int wt = d1[u][v];
            if(!visit[v] && roadU[u]+wt<roadU[v])
            {
                roadU[v] = roadU[u]+wt;
                q.push(pii(v,roadU[v]));
            }
        }
        visit[u] = true;

    }


}

void dijkstra2(int st){

    for(int i=0;i<n;i++)
    {
        roadV[i]=INF;
        visit[i]=false;
    }
    roadV[st] = 0;
    q.push(pii(st,0));
    while(!q.empty())
    {
        int u = q.top().first;
        q.pop();
        if(visit[u])
        continue;
        for(int i=0;i<n;i++)
        {
            if(i==u)continue;
            int v =i;
            int wt = d1[u][v];
            if(!visit[v] && roadV[u]+wt<roadV[v])
            {
                roadV[v] = roadV[u]+wt;
                q.push(pii(v,roadV[v]));
            }
        }
        visit[u] = true;

    }


}

void dijkstra3(int st){

    for(int i=0;i<n;i++)
    {
        railU[i]=INF;
        visit[i]=false;
    }
    railU[st] = 0;
    q.push(pii(st,0));
    while(!q.empty())
    {
        int u = q.top().first;
        q.pop();
        if(visit[u])
        continue;
        for(int i=0;i<n;i++)
        {
            if(i==u)continue;
            int v =i;
            int wt = d2[u][v];
            if(!visit[v] && railU[u]+wt<railU[v])
            {
                railU[v] = railU[u]+wt;
                q.push(pii(v,railU[v]));
            }
        }
        visit[u] = true;

    }


}

void dijkstra4(int st){

    for(int i=0;i<n;i++)
    {
        railV[i]=INF;
        visit[i]=false;
    }
    railV[st] = 0;
    q.push(pii(st,0));
    while(!q.empty())
    {
        int u = q.top().first;
        q.pop();
        if(visit[u])
        continue;
        for(int i=0;i<n;i++)
        {
            if(i==u)continue;
            int v =i;
            int wt = d2[u][v];
            if(!visit[v] && railV[u]+wt<railV[v])
            {
                railV[v] = railV[u]+wt;
                q.push(pii(v,railV[v]));
            }
        }
        visit[u] = true;

    }


}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
    {
        scanf("%d",&d1[i][j]);
    }

    for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
    {
        scanf("%d",&d2[i][j]);
    }
    int u,v;
    scanf("%d %d",&u,&v);
    u--;v--;
    dijkstra1(u);
    dijkstra3(u);
    for(int i=0;i<n;i++)
    for(int j=i;j<n;j++)
    {
        int temp;
        temp = d1[i][j];
        d1[i][j] = d1[j][i];
        d1[j][i] = temp;

        temp = d2[i][j];
        d2[i][j] = d2[j][i];
        d2[j][i] = temp;
    }

    dijkstra2(v);
    dijkstra4(v);
    int ans = INF;
    for(int i=0;i<n;i++)
    {
        if(i==u || i==v)continue;
        ans = min(ans,roadU[i]+railV[i]);
        ans = min(ans,railU[i]+roadV[i]);
    }
    printf("%d\n",ans);
    return 0;
}
