#include<iostream>
#include<cstdio>
#include<cmath>
#include<vector>
#include<map>
#include<set>
#include<algorithm>
#include<list>
#include<cstring>
#include<stack>
#include<queue>
using namespace std;
#define ll long long
#define vi vector<int>
#define vii vector<vi >
#define pp pair<int,int>
#define pb push_back
#define mp make_pair
#define ppl pair<ll,ll>
#define vl vector<ll>
#define vll vector<vl >
#define llu unsigned ll
#define all(c) c.begin(),c.end()
#define mod 1000000007
#define sc scanf
#define pf printf
 
ll power(ll a,ll b)
{
	if(!b)
		return 1;
	if(b==1)
		return a;
	ll temp=power(a,b/2);
	temp=(temp*temp);
	if(b&1)
		temp=(temp*a);
	return temp;
}
 
const int maxn = 1e5;
 
int tree [26][24*maxn];
 
 
void build( int node, int a, int b,char s[])
{
	
	if( a==b )
	{
		
		tree[s[a]-97][node] = 1;
		return;
	}
	int mid = (a+b)/2;
	build( node*2, a, mid, s);
	build( node*2+1, mid+1, b, s);
	int i;
	for( i=0;i<26;i++ )
	{
		tree[i][node] = tree[i][node*2] + tree[i][node*2+1];
	}
}
 
void update( int node, int a, int b,int otype,int ntype, int pos)
{
	
	if( a==b )
	{
		tree[otype][node] = 0;
		tree[ntype][node] = 1;
		return;
	}
	int mid = (a+b)/2;
	if( pos <= mid )
	{
		update( node*2, a, mid, otype, ntype, pos);
	}
	else
		update( node*2+1, mid+1, b, otype, ntype, pos);
	/*	tree[otype][node] = tree[otype][node*2] + tree[otype][node*2+1];
		tree[ntype][node] = tree[ntype][node*2] + tree[ntype][node*2+1];
	*/
	int i;
	for( i=0;i<26;i++ )
	{
		tree[i][node] = tree[i][node*2] + tree[i][node*2+1];
	}
	
}
int query( int node, int a, int b, int i, int j, int type)
{
 
	if( (a>b) || (i>b) || (a>j) )
		return 0;
	if( (a>=i) && (b<=j) )
		return tree[type][node];
	int mid = (a+b)/2;
	int q1 = query( node*2, a, mid, i, j, type);
	int q2 = query( node*2+1, mid+1, b, i, j, type);
	return (q1+q2);
}
int main()
    {
		//ios_base::sync_with_stdio(false);
		//memset( tree, 0 , sizeof(tree) );
		int i, n, q, ans, op, l ,r, oval, nval, k, j;
		bool flag;
		char ch;
		char s[1000001];
		sc("%d%d",&n,&q);
		//cin >> n >> q;
		//sc("%c",&ch);
		sc("%s",s);
		//cout << s;
		vi freq(26);
		build( 1, 0, n-1, s);
		while( q-- )
		{
			sc("%d",&op);
			if( !op )
			{
				sc("%d %c",&l,&ch);
				l--;
				oval = s[l] - 97;;
				s[l] = ch;
				nval = ch - 97;
				update( 1, 0 , n-1, oval, nval, l);
			}
			else
			{
				sc("%d%d%d",&l,&r,&k);
				l--;
				r--;
			/*	int mini = min(l,r);
				int maxi = max(l,r);
				l = mini;
				r = maxi;*/
				
				flag = false;
				if( k <= (r-l+1) )
				{
					flag =true;
					for( i=0;i<26;i++ )
					{
						freq[i] = query( 1, 0 , n-1, l , r, i);
					}
					int cnt = k, c = 0;
					i = 0;
					for( i=0;i<26;i++ )
					{
						if((freq[i]>=cnt))
						{
							ch = i+97;
							break;
						}
						cnt -=freq[i];
					}
					pf("%c\n",ch);
					//cout << ch << "\n";
				}
				else
					pf("Out of range\n");
			}
		}
    return 0;
}