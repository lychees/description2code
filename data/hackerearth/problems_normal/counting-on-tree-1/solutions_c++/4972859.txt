//
//  main.cpp
//  Counting on Tree
//
//  Created by Matrix.code on 8/28/16.
//  Copyright Â© 2016 Matrix.code. All rights reserved.
//

#include<bits/stdc++.h>
using namespace std;
/*------- Constants---- */

#define Long                    long long
#define Ulong                   unsigned long long
#define FOR(I,A,B)              for(int I = (A); I < (B) ; ++ I)
#define REP(i,n)                for( int i=0 ; i < n ; i++ )
#define mp                      make_pair
#define pb                      push_back
#define all(x)                  (x).begin(),(x).end()
#define PI                      acos(-1.0)
#define EPS                     1e-9
#define F                       first
#define S                       second
#define lc                      ((n)<<1)
#define rc                      ((n)<<1|1)
#define db(x)                   cout << #x << " -> " << x << endl;
#define Di(x)                   int x;scanf("%d",&x)
#define Si(x)                   scanf("%d",&x);
#define ms(ara_name,value)      memset(ara_name,value,sizeof(ara_name))
#define IO                      ios_base::sync_with_stdio(0);cin.tie(0)

template <class T> inline T bigmod(T p,T e,T M){
    long long ret = 1;
    for(; e > 0; e >>= 1){
        if(e & 1) ret = (ret * p) % M;
        p = (p * p) % M;
    } return (T)ret;
}
template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}
template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}

/***************************** END OF TEMPLATE *******************************/

const int N = 50005;
const int MOD = 1e9+7;
int n,K;
long long dp[N][101];
vector<int>G[N];

int A[N];
void dfs(int u,int p)
{
    long long Buf[101];
    ms(Buf,0);
    Buf[A[u]] = 1;
    REP(i,G[u].size()){
        int v = G[u][i];
        if(v==p) continue;
        dfs(v,u);
        for(int i = K; i >= 0; i -- ) {
            for(int j = 0; j <= i; j ++ ) {
                Buf[i] = (Buf[i] + Buf[i-j] * dp[v][j]) % MOD ;
            }
        }
    }
    REP(i,K+1) dp[u][i]=  Buf[i];
}
int main()
{
    
    Di(t);
    while(t--) {
        cin>>n>>K;
        REP(i,n)cin >> A[i];
        REP(i,n-1) {
            int u,v;
            cin >> u >> v;
            u--,v--;
            G[u].pb(v);
            G[v].pb(u);
        }
        dfs(0,-1);
        long long ans = 0;
        REP(i,n) {
            ans = (ans + dp[i][K])%MOD;
        }
        cout << ans << endl;
        REP(i,n)G[i].clear();
    }
    return 0;
}