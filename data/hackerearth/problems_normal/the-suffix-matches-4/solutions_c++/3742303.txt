#include <iostream>
#include<bits/stdc++.h>
using namespace std;
#define ll long long  int
#define inf 1000000000000000000
#define mod 1000000007
#define pb push_back
#define mp make_pair
#define all(v) v.begin(),v.end()
#define S second
#define F first
#define boost ios::sync_with_stdio(false);
#define maxn 300001
string S;
int sa[maxn], pos[maxn], tmp[maxn], ans[100001],lcp[maxn], N, gap, freq[maxn],t[4*maxn],tree[7000001];
 
bool Sufcmp(int i, int j){
	if(pos[i] != pos[j]){
		return pos[i] < pos[j];
	}
	i += gap; j += gap;
	return (i < N && j < N) ? pos[i] < pos[j] : i > j;
}
 
void buildSA(){
	N = S.size();
	for(int i = 0; i < N; i++){
		sa[i] = i;
		pos[i] = S[i];
	}
	tmp[0] = 0;
	for(gap = 1; ; gap = (gap << 1)){
		sort(sa, sa + N, Sufcmp);
		for(int i = 0; i < N-1; i++) tmp[i+1] = tmp[i] + Sufcmp(sa[i], sa[i+1]);
		for(int i = 0; i < N; i++) pos[sa[i]] = tmp[i];
		if(tmp[N-1] == N-1) break;
	}
}
 
void buildLCP(){
	N = S.size();
	lcp[0] = 0;
	for(int i = 0, k = 0; i < N; i++){
		if(pos[i] != N-1){
			for(int j = sa[pos[i]+1]; S[i+k] == S[j+k]; )
				k++;
			lcp[pos[i]+1] = k;
			if(k) k--;
		}
	}
}

void build(ll node,ll a,ll b)
{
	if(a==b)
	{
		tree[node]=lcp[a];
		return ;
	}
	ll mid=(a+b)/2;
	build(2*node,a,mid);
	build(2*node+1,mid+1,b);
	tree[node]=min(tree[2*node],tree[2*node+1]);
}
ll query(ll node,ll a,ll b,ll l,ll r)
{
	if(a>b || b<l || a>r)
	return inf;
	if(a>=l && b<=r)
	return tree[node];
	ll mid=(a+b)/2;
	return min(query(2*node,a,mid,l,r),query(2*node+1,mid+1,b,l,r));
}
int main() 
{
	string T;
	ll i,j,x,y,q;
	cin>>T;
	S=T;
	reverse(S.begin(),S.end());
	buildSA();
	buildLCP();
	build(1,0,T.length()-1);
	for(i=0;i<T.length();i++)
	{
		x=pos[0];
		y=pos[T.length()-1-i];
		if(x<y)
		ans[i]=query(1,0,T.length()-1,x+1,y);
		else 
		ans[i]=query(1,0,T.length()-1,y+1,x);
	}
	ans[T.length()-1]=T.length();
	cin>>q;
	while(q--)
	{
		cin>>x;
		cout<<ans[x-1]<<endl;
	}
	return 0;
}