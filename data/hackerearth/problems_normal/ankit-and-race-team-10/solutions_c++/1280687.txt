#include <bits/stdc++.h>
#define max 100000
#define mod 1000000007
#define LL long long

using namespace std;

LL power(LL base,LL index)  //method to find fast power fo numbers
{
    LL x=1,y=base;
    while(index>0)
    {
        if(index%2==0) //if index divisible by 2 .ie. if(index&1)
        {
            x=(x*y)%mod;
        }
        y=(y*y)%mod;
        index/=2; //right shift index>>=1
    }
    return x;
}
LL fast_pow(LL base,LL index)
{
    if(index==0)return 1;
    if(index==1)return base;
    long long halfn = fast_pow(base,index/2);
    if(index%2==0)
    {
        return (halfn*halfn)%mod;
    }
    else
    {
        return (((halfn*halfn)%mod)*base)%mod;
    }
}

LL fermat_MMI(LL num)  //fermar method of finding modulo multiplicative inverse
{
    //return power(num,mod-2);
    return fast_pow(num,mod-2);
}


int main()
{
    int t;
    LL n,k,i,j,ans;
    LL arr[max],fact[max];
    LL numerator,denominator,combination;
    fact[0]=fact[1]=1;
    for(i=2;i<=max;i++)
    {
        fact[i]=(fact[i-1]*i)%mod; //preparing the factorial that'll be required for the nCr combinatorics
    }

    cin>>t;
    while(t--)
    {
        cin>>n>>k;
        ans=0;
        for(i=0;i<n;i++)
        {
            scanf("%lld",&arr[i]);
        }
        sort(arr,arr+n); //sorting the array
        for(i=0;i<=n-k;i++)
        {
            //denominator=(fact[k-1]*fact[n-i-k])%mod;
            //denominator=fermat_MMI(denominator);
            numerator=fact[n-1-i];
            //combination=(numerator*denominator)%mod;
            combination=((numerator*fermat_MMI(fact[k-1]))%mod*fermat_MMI(fact[n-i-k]))%mod;
            ans=(ans+(arr[i]*combination)%mod)%mod;
        }
        cout<<ans<<endl;
        memset(arr,0,sizeof(ans));

    }



    return 0;
}
