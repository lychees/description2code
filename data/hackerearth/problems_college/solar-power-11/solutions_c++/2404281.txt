/* -----Segment tree source code taken from: https://github.com/shivam217/SPOJ/blob/master/SEGSQRSS.cpp----- */
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <set>
#include <cstring>
#include <vector>
#include <map>
#include <climits>

using namespace std;

#define FOR(i,a,b) for(long long int i=a;i<b;++i)
#define INT(x) scanf("%d",&x)
#define LLD(x) scanf("%lld",&x)
#define PLLD(x) printf("%lld\n",x)
#define CLR(x) memset(x,0,sizeof(x));
#define CLR1(x) memset(x,1,sizeof(x));

const long long int MAX = 1000000;
const long long int MOD = 1e9 + 7;

typedef unsigned long long ULL;

long long arr[MAX+15];

struct data
{
	long long  sum;

	long long mulval;

	void Sum(data &l, data &r)
	{
		sum = l.sum;
		sum = (sum + r.sum)%MOD;
	}
};

data tree[10*MAX+15];



void pushdown(long int node,long int segs,long int sege)
{
	long int mid = segs+sege; mid /= 2;
	
	
	if(tree[node].mulval)
	{

			if(tree[2*node].mulval) tree[2*node].mulval  = (tree[2*node].mulval *tree[node].mulval)%MOD;
			else tree[2*node].mulval = tree[node].mulval;
            if(tree[2*node+1].mulval) tree[2*node+1].mulval  = (tree[2*node+1].mulval *tree[node].mulval)%MOD;
			else tree[2*node+1].mulval = tree[node].mulval;
			
			//tree[2*node].addval = (tree[2*node].addval * tree[node].mulval)%MOD;
			//tree[2*node+1].addval = (tree[2*node+1].addval * tree[node].mulval)%MOD;

		
            tree[2*node].sum = (tree[2*node].sum * tree[node].mulval)%MOD;
            tree[2*node+1].sum =(tree[2*node+1].sum * tree[node].mulval)%MOD;
            
            tree[node].mulval = 0;
		
	}
	
	
		
		

}



void build_tree(long int node,long int s,long int e)
{
	tree[node].mulval=0;
//tree[node].lazyset=0;
	
	if(s>e) return;

	if(s==e)
	{
		tree[node].sum = arr[s];
		return;
	}

	long int mid=(s+e);
	mid /= 2;

	build_tree(2*node,s,mid);
	build_tree(2*node+1,mid+1,e);

	tree[node].Sum(tree[2*node],tree[2*node+1]);
}





void update_mul(long int node,long int segs,long int sege,long int qs,long int qe,long int x)
{
	if(segs>sege||segs>qe||sege<qs)	{return;}
	
	if(tree[node].mulval)
		{
			pushdown(node,segs,sege);
		}
	if(segs>=qs && sege<=qe)
	{
		if(tree[node].mulval) tree[node].mulval = (tree[node].mulval * x)%MOD;
		else tree[node].mulval = x;
		//tree[node].addval = (tree[node].addval*x)%MOD;    /////change made now.
		tree[node].sum   = (x * tree[node].sum)%MOD;
		return;
	}
	long int mid= segs+sege; mid /= 2;
	

	update_mul(2*node,segs,mid,qs,qe,x);
    update_mul(2*node+1,mid+1,sege,qs,qe,x);
			
	tree[node].Sum(tree[2*node],tree[2*node+1]); 	
}




long long query(long int node,long int segs,long int sege,long int qs,long int qe)
{

	if(segs>sege || segs>qe || sege < qs) 
	{
		if(tree[node].mulval)
			{
				pushdown(node,segs,sege);
			}
		return 0;
	}

	if(tree[node].mulval)
		{
			pushdown(node,segs,sege);
		}

	if(segs>=qs && sege<=qe)
	{
		return (tree[node].sum)%MOD;
	}

	long long int mid= segs+sege; mid /= 2;
			
	return (query(2*node,segs,mid,qs,qe) + query(2*node+1,mid+1,sege,qs,qe))%MOD;
}



int main()
{
	int d; INT(d);
	
while(d--){
		int n_,q,k; INT(n_); INT(k);INT(q);
		long long n = n_*n_;
	
		memset(arr,k,sizeof(arr));
		CLR(tree);
		for(int i=0;i<n;i++){arr[i] = k;}//cout<<arr[i]<<" ";}
		build_tree(1,0,n-1);

		while(q--)
		{


			char comm; long long  x1,y1,x2,y2,z,l,r; 
			
			cin>>comm; 
		
			if(comm=='s')
			{
				//set x	
				LLD(x1);LLD(y1);
				x1 -= 1;y1 -= 1;
				long long index = (x1*n_)+y1;
				 LLD(z);		
				update_mul(1,0,n-1,index,index,z);	
			
			}
			else
			{
				LLD(x1);LLD(y1);
				 LLD(x2);LLD(y2);
				 x1 -= 1;y1 -= 1;x2 -= 1;y2 -= 1;	
				long long  ans = 0;
				for(int k=x1;k<=x2;k++)
				{
					l = (k*n_)+y1;
					r = (k*n_)+y2;
					ans = ans + query(1,0,n-1,l,r);
				}
				PLLD(ans);
						
			}
		
		}
}
return 0;
}
//100000000
