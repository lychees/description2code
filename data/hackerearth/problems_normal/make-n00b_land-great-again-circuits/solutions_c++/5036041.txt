#include<bits/stdc++.h>
using namespace std;

#define ff first
#define ss second
#define m_p make_pair
#define pb push_back
#define ppb pop_back
#define pf push_front
#define ppf pop_front
#define ll long long
#define l_b lower_bound
#define u_b upper_bound

inline void scanll(ll &x)
{
    register  int c = getchar();
    x = 0;
    int neg = 0;
    for(; ((c<48 || c>57) && c != '-'); c = getchar());
    if(c=='-')
    {
        neg=1;
        c=getchar();
    }
    for(; c>47 && c<58; c = getchar())
    {
        x = (x<<1) + (x<<3) + c - 48;
    }
    if(neg) x=-x;
}


struct Graph
{
	static const ll maxN=500100;
	vector<ll>edge[maxN];
	ll n,m;
	void setNodeEdge(ll _n,ll _m=-1)
	{
		n=_n;
		if(_m==-1) m=n-1;
		else m=_m;
		for(ll i=0;i<=n;i++) edge[i].clear();
	}
	//treeDFS method
		ll level[maxN];
		ll parent[maxN];
		ll subtreesz[maxN];
		ll root;
		ll time;
		ll starT[maxN],endT[maxN];
		void treeDFS(ll cn,ll curlev)
		{
			ll subtreeszcnt=0,spchildind=-1;
			level[cn]=curlev;
			 starT[cn]=++time;
			for(ll i=0;i<edge[cn].size();i++)
			{
				ll to=edge[cn][i];
				if(parent[cn]!=to) 
				{
					parent[to]=cn;
					treeDFS(to,curlev+1);
					subtreeszcnt+=subtreesz[to];
				}
			}
			subtreesz[cn]=subtreeszcnt+1;
			endT[cn]=time;
		}
		void treeDFS(ll _root)
		{
		    this->root=_root;
		    memset(parent,-1,sizeof(parent));
			time=0;
			treeDFS(root,0);
		}
};


ll n,m,u,thr[500100],q,f[500100],x[500100],d[500100],L[500100],R[500100];
vector<ll>bman[500100];

ll tree[3][500100],ans[500100];
vector<pair<ll,ll> > pp;

void up(ll tree[],ll x,ll v)
{
	for(ll i=x;i<=500005;i+=(i&-i)) tree[i]+=v;
}

ll read(ll tree[],ll x)
{
	ll sum=0;
	for(ll i=x;i>0;i-=(i&-i)) sum+=tree[i];
	return sum;
}

Graph G;

int  main()
{
	scanll(n);scanll(m);
	G.setNodeEdge(n);
	for(ll i=2;i<=n;i++)
	{
		scanll(u);
		G.edge[u].pb(i);
		G.edge[i].pb(u);
	}
	G.treeDFS(1);
	
	for(ll i=1;i<=n;i++)
	{
		scanll(u);
		bman[u].pb(i);
	}
	
	for(ll i=1;i<=m;i++) scanll(thr[i]);
	
	scanll(q);
	for(ll i=1;i<=q;i++)
	{
		scanll(f[i]);
		scanll(x[i]);
		scanll(d[i]);
	}
	
	for(ll i=1;i<=m;i++) L[i]=1,R[i]=q,ans[i]=q+1;
	f[q+1]=1;
	
	
	while(1)
	{
	
		bool update=0;
		memset(tree,0,sizeof(tree));
		pp.clear();
		for(ll i=1;i<=m;i++)
		{
			if(L[i]>R[i]) continue;
			ll mid=(L[i]+R[i])/2;
			pp.pb(make_pair(mid,i));
			update=1;
			//cout<<i<<" ## "<<mid<<endl;
		}
		
		
		sort(pp.begin(),pp.end());
		if(!update) break;
		
		//cout<<"came"<<endl;
		//getchar();
		int mp=0;
		for(ll i=1;i<=q;i++)
		{
			up(tree[0],G.starT[f[i]],d[i]);
			up(tree[0],G.endT[f[i]]+1,-d[i]);
			
			up(tree[1],G.starT[f[i]],x[i]-d[i]*G.level[f[i]]);
			up(tree[1],G.endT[f[i]]+1,-x[i]+d[i]*G.level[f[i]]);
			
			while(mp<pp.size() && pp[mp].ff<=i)
			{
				ll bmanid=pp[mp].ss;
				
				ll sum=0;
				
				for(ll j=0;j<bman[bmanid].size();j++)
				{
					ll fact=bman[bmanid][j];
					
					sum+=read(tree[0],G.starT[fact])*G.level[fact];
					sum+=read(tree[1],G.starT[fact]);
					
					if(sum>=thr[bmanid]) break;
				}
				//cout<<bmanid<<" <SUMMATION> "<<sum<<" "<<thr[bmanid]<<"  >>>>---- "<<i<<endl;
				if(sum>=thr[bmanid])  R[bmanid]=i-1,ans[bmanid]=min(ans[bmanid],i);
				//{
					//cout<<"enter the zone"<<endl;	
					
					 //cout<<"** "<<ans[i]<<endl;
				//}
				else L[bmanid]=i+1;
				mp++;
			}
		}
	}
	
	for(ll i=1;i<=m;i++)
	{
		//cout<<"???"<<ans[i]<<endl;
		if(ans[i]<=q) printf("%lld\n",ans[i]);
		else puts("rekt");
	}
}