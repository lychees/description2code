/*--------------------------
|  Author- Advitiya Brijesh |
|  PIE @ MNNIT Allahabad    |
|  advitiyabrijesh@gmail.com|
|                           |
---------------------------*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<list<ll> > vli;
typedef vector<int> vi;
typedef vector<pair<ll,ll> > vpll;
typedef vector<pair<int,int> > vpii;
typedef pair<int ,int> pii;
#define F first
#define S second
#define pb push_back
#define mp make_pair
#define rep(i,n) for(int i=0;i<n;++i)
#define REP(i,a,b) for(int i=a;i<=b;++i)
#define PER(i,b) for(int i=b;i>=0;--i)
#define sd(n) scanf("%d",&n)
#define sld(n) scanf("%ld",&n)
#define sll(n) scanf("%lld",&n)
#define ss(n) scanf("%s",n)
#define sc(n) scanf("%c",&n)
#define oll(n) printf("%lld\n",n);
#define mset(n,k) memset(n,k,sizeof(n))
#define MOD 1000000007
#define MAX 2000005
#define MAXN 100005
int tree[4*MAXN],n,q,val[MAXN];
void build(int node,int st,int en,int idx){
	if(st==en){
		tree[node]=1;
		return;
	}
	else{
	int mid=st+(en-st)/2;
	if(idx<=mid)
	build(2*node,st,mid,idx);
	else
	build(2*node+1,mid+1,en,idx);
	tree[node]=(tree[2*node]*val[en-mid]+tree[2*node+1])%3;}
}
int query(int node,int st,int en,int l,int r){
	if(r<st||en<l)
		return 0;
	if(st==l && en==r){
		return tree[node];
	}
	int mid=st+(en-st)/2;
	if(mid>=r)
		return query(2*node,st,mid,l,r);
	else if(l>mid)
		return query(2*node+1,mid+1,en,l,r);
	else
	return (query(2*node,st,mid,l,mid)*val[r-mid]+query(2*node+1,mid+1,en,mid+1,r))%3;
}
int main(){
	sd(n);
	val[0]=1;
	for(int i=1;i<=100000;++i){
		val[i]=(2*val[i-1])%3;
	}
	string s;
	cin>>s;
	rep(i,n){
		if(s[i]=='1')
			build(1,0,n-1,i);
	}
	sd(q);
	while(q--){
		int ty,l,r;
		sd(ty),sd(l);
		if(ty==0){
			sd(r);
			int ans=query(1,0,n-1,l,r);
			printf("%d\n",ans);
		}
		else{
			build(1,0,n-1,l);
		}
	}
return 0;}