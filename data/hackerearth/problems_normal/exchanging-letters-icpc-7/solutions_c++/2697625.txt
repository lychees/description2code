#include<bits/stdc++.h>
#define PB push_back
#define MP make_pair
#define F first
#define S second
#define RI(a) scanf("%d",&a);
#define SZ(a) (int)(a.size())
#define SET(a,b) memset(a,b,sizeof(a))
#define TR(a,t) for(typeof(a.begin()) t=a.begin();t!=a.end();t++)
#define REP(i,l,h) for(int i=(l); i<=(h);i++)
#define REPD(i,h,l) for(int i=(h);i>=(l);i--)
#define ALL(a) a.begin(),a.end()
#define DRT()  int t; cin>>t; while(t--)
#define PRSNT(a,e) (a.find(e) != a.end())
#define MINH priority_queue<int, vector<int>, greater<int> >
#define N 20000
typedef long long LL;
using namespace std;
/* This function calculates (a^b)%MOD */
long long pow(int a, int b, int MOD)
{
        long long x=1,y=a; 
        while(b > 0)
        {
                if(b%2 == 1)
                {
                        x=(x*y);
                        if(x>MOD) x%=MOD;
                }
                y = (y*y);
                if(y>MOD) y%=MOD; 
                b /= 2;
        }
        return x;
}

/*  Modular Multiplicative Inverse
 *      Using Euler's Theorem
 *          a^(phi(m)) = 1 (mod m)
 *              a^(-1) = a^(m-2) (mod m) */
long long InverseEuler(int n, int MOD)
{
        return pow(n,MOD-2,MOD);
}
long long C(int n, int r, int MOD)
{
        vector<long long> f(n + 1,1);
        for (int i=2; i<=n;i++)
                f[i]= (f[i-1]*i) % MOD;
        return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD;
}
int main()
{
        LL sum=0;
        int n,k,T,a;
        cin>>n>>k>>T;
        REP(i,0,k-1) {
                cin>>a;
                sum+=(a-1);
        }
        if((T-sum)%2==1||(T<sum)||(T>(sum+2*k))) cout<<0<<endl;
        else cout<<(C(k,(T-sum)/2,1000000007))<<endl;
        return 0;
}
