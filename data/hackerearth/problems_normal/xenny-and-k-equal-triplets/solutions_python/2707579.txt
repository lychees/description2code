"""
Xenny had N numbers and he loved equal triplets (An equal triplet is group of 3 numbers that are equal).
He defined a K-equal-triplet as a triplet in which all 3 integers were equal to K.
Given an integer K, he wanted to find out the probability of getting a K-equal triplet, from the N numbers.

Xenny is bad at understanding floating point numbers. Help him to find the probability in terms of a fraction, reduced to its lowest terms.

Input

First line contains a single integer - T, the total number of testcases.
T testcases follow.
Each testcase consists of 2 lines:
First line contains 2 space-separated integers - N and K, which represent the total number of integers Xenny had, and the value K whose K-equal-triplet was required.

Output

For each testcase, print the probability of finding a K-equal-triplet in terms of the lowest fraction.
For example, if the answer is 4/8, you must print 1/2, which is the lowest reduced fraction of 4/8.

"""
from fractions import Fraction

def numberOfCombination(numOfK):
    #Denom will always be 6
    if (numOfK == 3):
        return 1; #There is only one way
    if (numOfK > 3):
        return (numOfK*(numOfK-1)*(numOfK-2)/(6));
    else:
        return 0;

T = int(raw_input(''))
for i in range(T):
    NK = raw_input('');
    N = int(NK.split()[0])
    K = int(NK.split()[1])

    # collect the instances of K
    kInstance = 0;
    numbers = list();
    numbers = raw_input('')
    numbers = numbers.split();

    result = list(filter(lambda x: int(x) == K, numbers))
    #print(result)
    #print(type(result))
    kInstance = len(result)

    #print("Number of instances of k = {}".format(kInstance));
    numrtr = int(numberOfCombination(kInstance))
    if (numrtr == 0):
        print("0/1");
        continue;
    denomrtr = int(numberOfCombination(N));
    #print("Denomicator combinations : {}".format(denomrtr))
    f = Fraction(numrtr, denomrtr);
    print("{}/{}".format(f.numerator, f.denominator));

