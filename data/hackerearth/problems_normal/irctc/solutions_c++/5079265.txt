#include <bits/stdc++.h>

using namespace std;
#define INF 0x3f3f3f3f

typedef pair<int, pair<int, int> > iii;

int A, B, C, n, k;
vector<vector<pair<int, int> > > graph;
pair<int, int> pre[100100][2];
vector<int> trains;

int dijkstra()
{
	int dist[n][2];
	for(int i = 0; i < n; i++)
	{
		dist[i][0] = dist[i][1] =INF;
		pre[i][0] = pre[i][1] = make_pair(-1, -1);
	}
	dist[A][0] = 0;
	
	priority_queue<iii, vector<iii>, greater<iii> > pq;
	pq.push(iii(0, make_pair(A, 0)));
	
	while(!pq.empty())
	{
		int d = pq.top().first, u = pq.top().second.first, ok = pq.top().second.second;
		pq.pop();
		
		if(d > dist[u][ok])
			continue;
			
		for(int i = 0; i < (int)graph[u].size(); i++)
		{
			pair<int, int> v = graph[u][i];
			
			if(dist[u][ok] + v.second < dist[v.first][v.first == B || ok])
			{
				dist[v.first][v.first == B || ok] = dist[u][ok] + v.second;
				pq.push(iii(dist[v.first][v.first == B || ok], make_pair(v.first, v.first == B || ok)));
				pre[v.first][v.first == B || ok] = make_pair(u, ok);
			}
		}
	}
	return dist[C][1];
}

void path(int no, int ok)
{
	trains.push_back(no);
	if(pre[no][ok].first != -1)
		path(pre[no][ok].first, pre[no][ok].second);
}

int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
    	scanf("%d %d", &n, &k);
    	graph.assign(n, vector<pair<int, int> >());
    	
    	int u, v, w;
    	while(k--)
    	{
    		scanf("%d %d %d\n", &u, &v, &w);
    		u--, v--;
    		graph[u].push_back(make_pair(v, w));
    		graph[v].push_back(make_pair(u, w));
    	}
    	
    	scanf("%d %d %d\n", &A, &B, &C);
    	A--, B--, C--;
    	int ans = dijkstra();
    	if(ans == INF)
    		printf("No Train Found.\n");
    	else
    	{
    		printf("%d\n", ans);
    		trains.clear();
    		path(C, 1);
    		reverse(trains.begin(), trains.end());
    		for(int i = 0; i < trains.size(); i++)
    			printf("%d ", trains[i] + 1);
    		printf("\n");
    	}
    }
    return 0;
}
