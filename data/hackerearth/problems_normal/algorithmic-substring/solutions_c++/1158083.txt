#include <bits/stdc++.h>
using namespace std;

#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)
#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)
#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)
#define EACH(it,a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)
#define SZ(S) ((int) ((S).size()))

#define DEBUG(x) { cout << #x << " = " << x << endl; }
#define PR(a,n) { cout << #a << " = "; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }
#define PR0(a,n) { cout << #a << " = "; REP(_,n) cout << a[_] << ' '; cout << endl; }

const int MN = 100111;
struct Node {
    int cnt, left, right;
    long long sum;
} nodes[11000111];
int nNode, n, k, sx;
long long a[MN], x[MN], cx[MN];

int createNode() {
    ++nNode;
    nodes[nNode].cnt = nodes[nNode].sum = nodes[nNode].left = nodes[nNode].right = 0;
    return nNode;
}

void RR() {
    sx = 0;
    FOR(i,1,n) cx[i] = x[i];
    sort(cx+1, cx+n+1);
    sx = unique(cx+1, cx+n+1) - cx - 1;
    FOR(i,1,n) x[i] = lower_bound(cx+1, cx+sx+1, x[i]) - cx;

//    PR(cx, sx);
//    PR(x, n);
}

int insert(int l, int r, int u, int oldNode) {
    if (u < l || r < u) return oldNode;
    if (l == r) {
        int res = createNode();
        nodes[res].cnt = nodes[oldNode].cnt + 1;
        nodes[res].sum = nodes[oldNode].sum + cx[u];
        return res;
    }
    int mid = (l + r) >> 1;
    int res = createNode();
    nodes[res].left = insert(l, mid, u, nodes[oldNode].left);
    nodes[res].right = insert(mid+1, r, u, nodes[oldNode].right);
    nodes[res].cnt = nodes[ nodes[res].left ].cnt + nodes[ nodes[res].right ].cnt;
    nodes[res].sum = nodes[ nodes[res].left ].sum + nodes[ nodes[res].right ].sum;
    return res;
}

long long getK(int node_to, int node_from, int l, int r, int k) {
    if (l == r) return cx[l];
    
    int mid = (l + r) >> 1;
    int has = nodes[ nodes[node_to].left ].cnt - nodes[ nodes[node_from].left ].cnt;
    if (has >= k)
        return getK(nodes[node_to].left, nodes[node_from].left, l, mid, k);
    else
        return getK(nodes[node_to].right, nodes[node_from].right, mid+1, r, k-has);
}

pair<long long, long long> add(pair<long long, long long> a, pair<long long, long long> b) {
    return make_pair(a.first + b.first, a.second + b.second);
}

pair<long long, long long> getLower(int node_to, int node_from, int l, int r, long long val) {
    if (val < cx[l]) return make_pair(0, 0);
    if (cx[r] <= val) return make_pair( nodes[node_to].cnt - nodes[node_from].cnt, nodes[node_to].sum - nodes[node_from].sum);
    int mid = (l + r) >> 1;
    return add(getLower(nodes[node_to].left, nodes[node_from].left, l, mid, val),
            getLower(nodes[node_to].right, nodes[node_from].right, mid+1, r, val));
}

pair<long long, long long> getGreater(int node_to, int node_from, int l, int r, long long val) {
    if (val <= cx[l]) return make_pair( nodes[node_to].cnt - nodes[node_from].cnt, nodes[node_to].sum - nodes[node_from].sum);
    if (cx[r] < val) return make_pair(0, 0);
    int mid = (l + r) >> 1;
    return add(getGreater(nodes[node_to].left, nodes[node_from].left, l, mid, val),
            getGreater(nodes[node_to].right, nodes[node_from].right, mid+1, r, val));
}

int it[MN];

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL);
    cout << (fixed) << setprecision(6);
    int ntest; cin >> ntest;
    while (ntest--) {
        cin >> n >> k;
        long long need = 0;
        FOR(i,1,n) {
            cin >> a[i];
            if (i == 1) need = a[i];
            else need += k;
            x[i] = need - a[i];
        }
        RR();

        FOR(i,1,n) {
            it[i] = insert(1, sx, x[i], it[i-1]);
        }

        int q; cin >> q;
        while (q--) {
            int l, r; cin >> l >> r;
            int len = r - l + 1;
            int k = (len % 2) ? (len/2 + 1) : len/2;
            long long median = getK(it[r], it[l-1], 1, sx, k);

//            cout << "Query: " << l << ' ' << r << endl;
//            DEBUG(median);
            long long res = 0;

            pair<long long,long long> lower = getLower(it[r], it[l-1], 1, sx, median);
            pair<long long,long long> greater = getGreater(it[r], it[l-1], 1, sx, median);

            res += (median * lower.first) - lower.second;
            res += greater.second - (median * greater.first);

            cout << res << endl;
        }
    }
    return 0;
}

