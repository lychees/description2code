#include <bits/stdc++.h>
#define endl '\n'

using namespace std;

const int N = 1<<20;
const unsigned MOD = 176081;

	#define B1 (139)
	//#define B2 (137)
	/*struct rolling_hash {
		unsigned long long h1,h2;

		void initialize() {
			h1=0ll;
			h2=0ll;
		}

		void append(char a) {
			h1*=B1;h1+=a-'a'+1;
			h2*=B2;h2+=a-'a'+1;
		}

		bool operator <(const rolling_hash &a) const {
			if(h1<a.h1) return true;
			if(h1>a.h1) return false;
			return h2<a.h2;
		}

		bool operator ==(const rolling_hash &a) const {
			return (h1==a.h1 && h2==a.h2);
		}
	};*/
	struct rolling_hash {
		unsigned long long h1;//,h2;
		int length;
		void initialize() {
			h1=0ll;
			length=0;
			//h2=0ll;
		}

		void append(char a) {
			h1*=B1;h1+=a-'a'+1;
			//h2*=B2;h2+=a-'a'+1;
			++length;
		}

		bool operator <(const rolling_hash &a) const {
			if(length<a.length) return true;
			if(length>a.length) return false;
			//if(h1>a.h1) return false;
			//return h2<a.h2;
		}

		bool operator ==(const rolling_hash &a) const {
			return (h1==a.h1 && length==a.length);
		}
	};
	struct hash_x {
	 unsigned long long operator()(const rolling_hash &a) const {
	 	return a.h1;
	 }
	};
int n;
int sz[N];
char a[N];
int k;
long long curr,sum;
//unordered_map <rolling_hash, long long,hash_x> cnt[N];
//unordered_map <rolling_hash, long long,hash_x>::iterator it;
vector <long long> ans;
vector <int> cnt[MOD];
vector <rolling_hash> hash_map[MOD];
void clear_map() {
	int i;
	for(i=0;i<MOD;i++) hash_map[i].clear(),cnt[i].clear();
}

int get(rolling_hash &a) {
	return (a.h1)%MOD;
}
long long c[N];

int find_hash(rolling_hash &a) {
  int i,where=get(a);
  for(i=0;i<hash_map[where].size();i++) if(hash_map[where][i]==a) return cnt[where][i];
  return 0;
}
void insert_hash(rolling_hash &a) {
  int i,where=get(a);
  for(i=0;i<hash_map[where].size();i++) if(hash_map[where][i]==a) {
    cnt[where][i]++;
    return;
  }
  hash_map[where].push_back(a);
  cnt[where].push_back(1);
}

int main() {
	//ios_base::sync_with_stdio(false);
	//cin.tie(NULL);
	int i,j;
	rolling_hash h;
	
	//cin>>n;
	scanf("%d", &n);
	for(i=1;i<=n;i++) {
		//cin>>a[i];
		scanf("%s", a+1);
		sz[i]=strlen(a+1);
		k=max(k,sz[i]);
		h.initialize();
		//ph[i].push_back(h);
		for(j=1;j<=sz[i];j++) {
			h.append(a[j]);
			//ph[i].push_back(h);
			//++cnt[j][h];
			insert_hash(h);
		}
	}
	h.initialize();
	for(i=1;i<=n;i++) insert_hash(h);
	for(i=0;i<MOD;i++) {
		for(j=0;j<(int)(hash_map[i].size());j++) {
			c[hash_map[i][j].length]+=cnt[i][j]*1ll*(cnt[i][j]-1)/2;
		}
	}
	
	

	/*for(i=k;i>=0;i--) {
		curr=0;
		for(it=cnt[i].begin();it!=cnt[i].end();it++) {
			curr+=((*it).second*((*it).second-1))/2;
		}
		curr-=sum;
		sum+=curr;
		ans.push_back(curr);
	}*/
	//ans.push_back(n*(n-1)/2-sum);
	for(i=k;i>=0;i--) {
		c[i]-=sum;
		sum+=c[i];
		ans.push_back(c[i]);
	}
	reverse(ans.begin(),ans.end());
	for(i=0;i<(int)(ans.size());i++) {
		if(i>0) printf(" ");
		printf("%lld", ans[i]);
	}
	printf("\n");

	return 0;
}
