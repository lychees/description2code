#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cmath>
#include <vector>
#include <iomanip>
#include <utility>
#include <memory.h>
#include <set>
#include <map>

using namespace std;

#define pb push_back
#define mp make_pair
#define F first
#define S second

const int N = 20;
const int USED = (1 << 16) + 20;

int n;
bool can[N][USED];
long long f[N][USED];
long long ways[N][USED];

int getCount(int mask, int pos) {
    int res = 0;
    for (int i = pos + 1; i < n; i++) {
        if ((mask & (1 << i)) != 0) {
            ++res;
        }
    }
    return res;
}

int get_pos(vector<int> &v, int x) {
    for (int i = 0; i < (int)v.size(); i++) if (v[i] == x) return i;
}

void solveStupid() {
    vector<int> v;
    for (int i = 1; i <= n; i++) v.pb(i - 1);
    long long ans = 0LL;
    do {
        bool isOk = true;
        for (size_t i = 0; i < v.size(); i++) {
            if ((int)i == v[i]) {
                isOk = false;
                break;
            }
        }
        if (!isOk) {
            continue;
        }
        for (int i = 0; i < n; i++) {
            int my = get_pos(v, i);
            for (int j = i + 1; j < n; j++) {
                if (get_pos(v, j) < my) {
                    ++ans;
                }
            }
        }
    } while (next_permutation(v.begin(), v.end()));
    cout << ans << endl;
}

void solve() {
    scanf("%d", &n);
    memset(can, false, sizeof(can));
    int maxMask = (1 << n);
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= maxMask; j++) {
            f[i][j] = 0LL;
            ways[i][j] = 0LL;
            can[i][j] = false;
        }
    }
    can[0][0] = true;
    ways[0][0] = 1LL;
        for (int mask = 0; mask < maxMask; mask++) {
            for (int i = 0; i < n; i++) {
            if (!can[i][mask]) continue;
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    continue;
                }
                if ((mask & (1 << j)) != 0) continue;
                long long ff = 1LL * getCount(mask, j) * ways[i][mask] + f[i][mask];
                int mm = mask | (1 << j);
                f[i + 1][mask | (1 << j)] += ff;
                can[i + 1][mask | (1 << j)] = true;
                ways[i + 1][mask | (1 << j)] += ways[i][mask];
            }
        }
    }
    long long ans = 0LL;
    ans = f[n][maxMask - 1];
    cout << ans << endl;
}

int main() {
    int tc;
    scanf("%d", &tc);
    while (tc--) {
        solve();
    }
    return 0;
}