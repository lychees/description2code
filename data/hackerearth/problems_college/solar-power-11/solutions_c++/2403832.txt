#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<list>
#include<map>
#include<set>
#include<stack>
#include<vector>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include <limits.h>
#include <queue>
 
#define K 1010
#define M 1000000007
#define fo(i,n) for(int i=0;i<n;i++)
#define Fo(i,k,n) for(int i=k;i<n;i++)
#define F first
#define S second
#define sd(n) scanf("%d",&n);
#define sl(n) scanf("%lld",&n);
#define PB push_back
#define MP make_pair
 
 
using namespace std;
 
typedef long long ll;
typedef pair<int,int> PI;
typedef pair<double,double> PD;
typedef vector<int> VI;
typedef vector<VI> VII;
typedef vector<PI> VPI;


ll tree[K][K];
//int in[K][K];


void update(int x , int y , ll val){
    int y1;
    while (x <= K-1){
        y1 = y;
        while (y1 <= K-1){
            tree[x][y1] += val%M;
            y1 += (y1 & -y1); 
        }
        x += (x & -x); 
    }
}

ll read(int x,int y){ 
            if(!(x && y)) return 0;
           ll sum= 0;         
             while( x){
                  int y1 = y;
                 while(y1){
                     sum += tree[x][y1];
                     sum%=M;
                       y1 -= y1 & -y1;
                }
                x -= x & -x;
            }
          return sum;
}

int main()
{
    int d;
    sd(d);
    while(d--)
    {
    	int n,k,a;
    	sd(n); sd(k); sd(a);
    	fo(i,n+2)
    		fo(j,n+2)
    			tree[i][j]=0;
    		//	cout<<"y";
    	Fo(i,1,n+2)
    		Fo(j,1,n+2)
    			update(i,j,k);
    			
    	int x1,x2,y1,y2;
    	ll z;
    	while(a--)
    	{
    		char c;
    		cin>>c;
    		if(c=='m')
    		{
    			sd(x1); sd(y1); sd(x2); sd(y2);
    		
    			ll ans = read(x2,y2) - read(x2,y1-1) - read(x1-1,y2) + read(x1-1,y1-1);
    			ans %= M;
    			if(ans<0) ans+=M;
    			cout<<ans<<endl;
    		}
    		else
    		{
    			sd(x2); sd(y2); sl(z);
    			x1 = x2-1;
    			y1 = y2-1;
    			ll ans = read(x2,y2) - read(x2,y1) - read(x1,y2) + read(x1,y1);
    			ll ans1=ans;
    			ans*=z;
    			ans%=M;
    			update(x2,y2,ans-ans1);
    		}
    	}
    }
    
}
