#include<cmath>
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<cstring>
#include<complex>
using namespace std;

typedef long long LL;
typedef vector<int> VI;

#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)
#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)
#define eprintf(s...) fprintf(stderr, s)

template<class T> inline void amin(T &a, const T &b) { if (b<a) a=b; }
template<class T> inline void amax(T &a, const T &b) { if (a<b) a=b; }

typedef double Double;
const Double EPS = 1e-8; // 0 ~~ [-EPS, EPS]
// const LL EPS = 0;
const Double INF = 1e12;
const Double PI = acos((Double)-1);

typedef complex<Double> Point;
const Point I(0, 1);

// abs(P a) ::= sqrt(a.x^2 + a.y^2);
// norm(P a) ::= a.x^2 + a.y^2;
// Point polar(rho, theta=0)

int sign(Double x) {
    if (x < -EPS) return -1;
    if (EPS < x) return 1;
    return 0;
}

namespace std {
    bool operator<(const Point &x, const Point &y) {
	return real(x) != real(y)? real(x) < real(y): imag(x) < imag(y);
    }
}

Double cross(const Point &x, const Point &y) {
    return imag(conj(x)*y);
}
Double dot(const Point &x, const Point &y) {
    return real(conj(x)*y);
}
Point normal(const Point &a) { return a / abs(a); }

struct Line : public vector<Point> {
    Line(const Point &a, const Point &b) {
	push_back(a); push_back(b);
    }
    Point vector() const {
	return back() - front();
    }
};

typedef vector<Point> Polygon;
Double area2(const vector<Point> &g) {
    Double r = 0;
    for (int i=0; i<(int)g.size(); i++)
	r += cross(g[i], g[(i+1)%g.size()]);
    return abs(r);
}


int ccw(Point a, Point b, Point c) {
    b-=a; c-=a;
    if (cross(b, c) > EPS) return 1; // counter clockwise
    if (cross(b, c) < -EPS) return -1; // clockwise
    if (dot(b, c) < -EPS) return 2; // c--a--b on line
    if (norm(b) < norm(c)) return -2; // a--b--c on line
    return 0;
}
Polygon convex_hull(vector<Point> ps) {
    int n = ps.size(), k = 0;
    sort(ps.begin(), ps.end());
    vector<Point> ch(2*n);
    for (int i=0; i<n; ch[k++] = ps[i++]) // lower -hull
	while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper -hull
	while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
    ch.resize(k-1);
    return ch;
}

int N;
Polygon PS;

Double f(Double a) {
    Point turn = polar(1.0, a);
    Double l = INF, r = -INF, u = -INF, d = INF;
    REP (i, N) {
	Point p = PS[i] * turn;
	amin(l, p.real());
	amax(r, p.real());
	amin(d, p.imag());
	amax(u, p.imag());
    }
    return -max(r-l, u-d);
}

int main() {
    scanf("%d", &N);
    PS.resize(N);
    REP (i, N) {
	Double x, y;
	scanf("%lf%lf", &x, &y);
	PS[i] = Point(x, y);
    }

    // if (0) {
    // 	N = 1000;
    // 	PS.resize(N);
    // 	REP (i, N) {
    // 	    PS[i].real() = rand() % 1000;
    // 	    PS[i].imag() = rand() % 1000;
    // 	}
    // }
    
    // if (N == 2) {
    // 	Double ans = abs(PS[0] - PS[1]) / sqrt(2.0);
    // 	printf("%.4f\n", ans);	
    // 	return 0;
    // }
    
    
    PS = convex_hull(PS);

    N = PS.size();
    // Point o = PS[0];
    // REP (i, N) PS[i] -= o;
    Double ans = INF;

    const int MAGIC = 1000;
    const double GR = (sqrt(5) - 1.0) / 2.0; // GR == 0.618
    REP (t, MAGIC) {
	Double lo = PI / 2 * t / MAGIC;
	Double hi = PI / 2 * (t+1) / MAGIC;
	Double x = hi - GR * (hi - lo), y = lo + GR * (hi - lo);
	Double vx = f(x), vy = f(y);
	for (int i=0; i<60; i++) {
	    if (vx < vy) { lo = x; x = y; vx = vy; y = lo + GR * (hi - lo); vy = f(y); }
	    else { hi = y; y = x; vy = vx; x = hi - GR * (hi - lo); vx = f(x); }
	}

	Double tmp = -f((x+y)/2.0);
	amin(ans, tmp);
    }

    
    // REP (i, N) {
    // 	int j = i+1; if (j==N) j=0;
    // 	Point vec = PS[j] - PS[i];
    // 	vec = normal(vec);
    // 	vec.imag() *= -1.0;
	
    // 	Double le = 0, ri = 0, hi = 0;
    // 	REP (a, N) {
    // 	    Point g = PS[a] - PS[i];
    // 	    g *= vec;
    // 	    amax(ri, g.real());
    // 	    amin(le, g.real());
    // 	    amax(hi, g.imag());
    // 	}

    // 	amin(ans, max(hi, ri-le));
    // }

    printf("%.4f\n", ans);
    return 0;
}
