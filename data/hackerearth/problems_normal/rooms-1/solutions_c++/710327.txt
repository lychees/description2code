#include<iostream>
#include<algorithm>
#include<set>
#include<vector>
#include<queue>
using namespace std;

struct Cmq{
    bool operator ()(const pair<long long, long long> &a, const pair<long long, long long> &b){    
        return a.second > b.second;
    }
};
bool compare(const pair<long long, long long> &a, const pair<long long, long long> &b){    
        return a.first < b.first;
    }


priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,Cmq> cook;  

vector<pair<long long,long long>> arrival;


vector<pair<long long,long long>>::iterator itarrival;
long long a[100001],b[100001];
int main(){
	int T;
	cin >> T;
	while (T--){
		int  n;
        cin >> n;
        for (int i=0;i<n;i++) scanf("%lld",&a[i]);
        for (int i=0;i<n;i++) scanf("%lld",&b[i]);
       // long long t,l;
       arrival.clear();
       //cook.clear();
       while (!cook.empty()) cook.pop();
        long long w = 0,last = 0;
        for (int i=0; i<n;i++) {            
            arrival.push_back(make_pair(a[i],b[i]));  
        //    cout << a[i] << ".." << b[i] << endl;
        }
        sort(arrival.begin(),arrival.end(),compare);
        itarrival = arrival.begin();
        //w = (*itarrival).second;
        last = (*itarrival).first + (*itarrival).second;
       // cout << last << "??" << (*itarrival).first << ".." << (*itarrival).second << endl;
        int room = 1;
        cook.push(make_pair((*itarrival).first,(*itarrival).first+(*itarrival).second));
        //itarrival = arrival.begin();
        itarrival ++;
      //  for (int i=1;i<n;i++){
        	
     //   }
        long long mtmp,ar;
        while (itarrival != arrival.end()){    
            if (!cook.empty()){
               ar = cook.top().first;
               mtmp =  cook.top().second; 
          //     cout << ar << ", " << mtmp << endl;
               
           }
           if (mtmp <= (*itarrival).first){
               cook.push(make_pair((*itarrival).first,(*itarrival).first+(*itarrival).second));
               itarrival ++; 
               cook.pop();
           }
           else{
           	   room += 1;
           	   cook.push(make_pair((*itarrival).first,(*itarrival).first+(*itarrival).second));
               itarrival ++; 
           }
        }
        cout << room << endl;
	}
           /*while (itarrival != arrival.end() && (*itarrival).first<=cur){
               cook.push(make_pair((*itarrival).first,(*itarrival).second));
               itarrival ++; 
           }
           if (!cook.empty()){
               ar = cook.top().first;
               mtmp = cook.top().second;           
               cook.pop();
           }
           else{
               mtmp = (*itarrival).second;
               ar = (*itarrival).first;
               itarrival ++;
           }
           if (ar<=cur){
               w += cur-ar;
               w += mtmp;
               cur += mtmp; 
           }
           else{
               w += mtmp;
               cur += ar+mtmp;
           }
                    
        }   */
        
        
	//}
    return 0;
}