#include <algorithm>
#include <utility>
#include <map>
#include <vector>
#include <list>
#include <string>
#include <memory.h>
#include <queue>
#include <ctime>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>
#include <limits.h>
#include <cstdlib>
#include <stack>
#define sc(x) scanf("%d",&x);
#define pr(x) printf("%d \n",x);

using namespace std;
bool pr[1000001];
struct tree
{
    long long sum;
    int l,r;
}
segtree[500001];
void buildtree(int i,int l,int r,int s[])
{
    segtree[i].l=l;
    segtree[i].r=r;
    if(l==r)
    {
       /* if(pr[s[l]]) segtree[i].sum=s[l];
        else segtree[i].sum=0;*/
        segtree[i].sum=s[l];
    //    cout<<i<<" "<<segtree[i].sum<<endl;
        return;
    }
    buildtree(2*i,l,(l+r)/2,s);
    buildtree(2*i+1,1+(l+r)/2,r,s);
    if( pr[segtree[2*i].sum] && pr[segtree[2*i+1].sum] ) segtree[i].sum = max( segtree[2*i].sum , segtree[2*i+1].sum );
    else if( pr[segtree[2*i].sum] ) segtree[i].sum=segtree[2*i].sum;
    else if( pr[segtree[2*i+1].sum] ) segtree[i].sum=segtree[2*i+1].sum;
    else segtree[i].sum=0;

 //   cout<<i<<" "<<segtree[i].sum<<endl;
}
void updatetree(int i,int l,int r,int x,int y)
{
    if(l==x&&r==x)
    {
        if(pr[y]) segtree[i].sum=y;
        else segtree[i].sum=0;
        return;
    }
    else if(x<=(l+r)/2) updatetree(2*i,l,(l+r)/2,x,y);
    else updatetree(2*i+1,(l+r)/2+1,r,x,y);
    if(pr[segtree[2*i].sum]&&pr[segtree[2*i+1].sum]) segtree[i].sum = max( segtree[2*i].sum , segtree[2*i+1].sum );
    else if(pr[segtree[2*i].sum]) segtree[i].sum=segtree[2*i].sum;
    else if(pr[segtree[2*i+1].sum]) segtree[i].sum=segtree[2*i+1].sum;
    else segtree[i].sum=0;
}
tree query(int i,int l,int r,int c,int d)
{
    if(c==l&&d==r) return segtree[i];
    else if(d<=(l+r)/2) return query(2*i , l , (l+r)/2 , c , d);
    else if((l+r)/2<c) return query(2*i+1 , 1+(l+r)/2 , r , c , d);
    else
    {
        tree a=query(2*i, l , (l+r)/2 , c , (l+r)/2 );
        tree b=query(2*i+1 , 1+(l+r)/2 , r ,  1+(l+r)/2 , d );
        tree mer;
        if(pr[a.sum] && pr[b.sum]) mer.sum = max(a.sum , b.sum);
        else if(pr[a.sum]) mer.sum=a.sum;
        else if(pr[b.sum]) mer.sum=b.sum;
        else mer.sum=0;
        return mer;
    }
}

int main()
{
    memset(pr,1,1000001);
    pr[0]=pr[1]=false;
    for(int i=2;i<1000001;i++){
        if(pr[i]){
            for(int j=2;j*i<1000001;j++){
                pr[i*j]=false;
            }
        }
    }
    int n,m;
    sc(n);sc(m);
    int c[n+1];
    for(int i=1;i<n+1;i++) sc(c[i]);
    buildtree(1,1,n,c);
    //for(int i=1;i<=13;i++)  cout<<segtree[i].sum<<" ";
    //cout<<"end"<<endl;
    int a,b,q;
    while(m--){
        sc(q);sc(a);sc(b);
        if(q==0){
            updatetree(1,1,n,a,b);
        //for(int i=1;i<=13;i++) cout<<segtree[i].sum<<" ";
        //cout<<"end"<<endl;
        }
        else{
            tree q=query(1,1,n,a,b);
            if(pr[q.sum]) cout<<q.sum<<endl;
            else cout<<-1<<endl;
        }
    }
}
