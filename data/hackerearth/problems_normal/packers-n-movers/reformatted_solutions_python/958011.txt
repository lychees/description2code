# print 'Hello World!'
# weight = {}

# def recursive memory loss
def move(M, P, p):
    # print "inside..."
    sol = []
    if M == 1:
        return sum(p[0:P])

    for i in range(P+1):
        # print "looping..."
        if i == P:
            sol.append(sum(p[0:P]))
        weight = sum(p[0:i])
        # print "calling..."
        sol.append(max(weight, move(M-1, P - i, p[i:])))
        # print "Current Sol: ", sol

    # print "Solution : ", sol
    return min(sol)

# bottoms up


def budp(M, P, p):

    for x in range(1, P+1):
        wei[0][x] = sum(p[P-x:])
    wei[0:][0] = 0

    for x in range(1, M):
        for y in range(
                0, P+1):  # y is nos of packages consumed  #starting marker
            for k in range(P-y, P-1):  # close marker
                wei[x][y] = min(max(sum(p[P-y:k]), wei[x-1][P-1-k]), wei[x][y])
    # min(max()) dp[i][j]=min(max(dp[k][j-1],csum[i]-csum[k]),dp[i][j])

    # print wei[M-1][P-1]

    return wei[M-1][P-1]


def process(M, P, p):

    dp = [[99999 for y in range(P+1)] for x in range(M+1)]
    for x in range(M+1):
        dp[x][0] = 0

    # print dp[1][0]
    for x in range(1, P+1):
        dp[1][x] = p[-x]+dp[1][x-1]
    # print dp[1]

    for i in range(2, M+1):
        for j in range(1, P+1):
            for k in range(0, j+1):
                # print dp [i-1][j-k]
                dp[i][j] = min(max(sum(p[P-j:P-j+k]), dp[i-1][j-k]), dp[i][j])
    return dp[M][P]


M = int(raw_input())
P = int(raw_input())
p = [int(x) for x in raw_input().split()]


# print sum(p[0:0])
# print M, P, p
print process(M, P, p)


'''
# Read input from stdin and provide input before running code

name = raw_input('What is your name?\n')
print 'Hi, %s.' % name

#print 'Hello World!'

#weight= list()

def move(M, P, p, c):
	#print "inside..."
	if P in weight[M]:
		return weight[M][P]

	sol = []


	for i in range(c, P+1+c):
		#print "looping..."
		if i == P:
			sol.append(sum(p[c:P]))
		w = sum(p[c:i])
		#print "calling..."
		sol.append(max(w, move(M-1, P - i, p, c+i)))
		#print "Current Sol: ", sol

	#print "Solution : ", sol

	weight[M][P] = min(sol)
	return weight[M][P]

M = int(raw_input())
P = int(raw_input())
p = [int(x) for x in raw_input().split()]



#print sum(p[0:0])
#print M, P, p
#weight = {{},{}}
weight = {x:{} for x in range(1, M+1)}
weight[1] = {n:sum(p[0:n]) for n in range(P+1)}
print move(M, P, p, 0)

'''
