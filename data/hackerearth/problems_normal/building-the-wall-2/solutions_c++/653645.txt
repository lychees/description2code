#include <iostream>
#include <ctime>
#include <iomanip>
#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include <algorithm>
#include <array>
#include <cassert>

using namespace std;

constexpr unsigned mod = 1000000007;
enum orientation_t { HORIZONTAL, VERTICAL };
ostream& operator<<(ostream &out, orientation_t t)
{
    if (t == HORIZONTAL) return out << "HORIZONTAL";
    return out << "VERTICAL";
}

typedef array<int, 3> front_t;

struct brick_t
{
    brick_t(int in_row=numeric_limits<int>::max())
	: row(in_row), col(1), size(1), orientation(HORIZONTAL)
    {}
    brick_t(const front_t & front)
	: size(1), orientation(HORIZONTAL)
    {
	auto min_it = min_element(front.begin(), front.end());
	row = *min_it;
	col = min_it - front.begin() + 1;
    }

    void next(const front_t & front)
    {
	auto min_it = min_element(front.begin(), front.end());
	if (row > *min_it || min_it < front.begin() + (col-1))
	{
	    row = numeric_limits<int>::max();
	    return;
	}
	if (row > *min_it || min_it > front.begin() + (col-1))
	{
	    row = *min_it;
	    col = min_it - front.begin() + 1;
	    size = 1;
	    orientation = HORIZONTAL;
	    return;
	}
	if (size != 1)
	{
	    if (orientation == HORIZONTAL)
	    {
		if (*min_it == row && min_it == front.begin() + (col-1))
		{
		    orientation = VERTICAL;
		    return;
		}
	    }
	    orientation= HORIZONTAL;
	}
	++size;
	if (col - 1 + size <= 3)
	{
	    bool all_eq = true;
	    for (unsigned i=col ; i < col + size ; ++i)
	    {
		all_eq = all_eq && front[col-1] == front[i-1];
	    }
	    if (all_eq) return;
	}
	if (size <= 3)
	{
	    orientation = VERTICAL;
	    return;
	}
	row = numeric_limits<int>::max();
	return;
    }
    bool done() const { return row == numeric_limits<int>::max(); }
    front_t combine(const front_t & front) const
    {
	front_t ret = front;
	assert(front[col-1] == row);
	if (orientation == HORIZONTAL)
	{
	    for (unsigned i=1; i < size ; ++i) 
	    {
		assert(front[col-1] == front[col - 1 + i]);
	    }
	    for (unsigned i=0; i < size ; ++i) 
	    {
		++ret[col -1 + i];
	    }
	}
	else
	{
	    assert(size >= front[col-1]);
	    ret[col - 1] += size;
	}
	return ret;
    }

	
    int row; // 0..(count-1), or  numeric_limits<int>::max() if beyond the last
    unsigned char col;  // 1..3
    unsigned char size; // 1..3
    orientation_t orientation;
};


namespace std
{
    template<>
    class hash< front_t >
    {
    public:
	size_t operator()(const front_t & ar) const
	{
	    // size_t ret= 0;
	    // for (auto t: ar)
	    // {
	    // 	ret = ( ret ^ t ) * 0x01000193 * 131;
	    // }
	    return ar[0] ^ ((size_t)ar[1] << 20) ^ ((size_t)ar[2] << 40);
	}
    };
}


constexpr front_t add_level(const front_t f, int n)
{
    return front_t({f[0]+n, f[1]+n, f[2]+n});
}

constexpr unsigned find_level(const front_t f)
{
    return (f[0] <= f[1] && f[0] <= f[2] ? f[0] :
	    (f[1] <= f[0] && f[1] <= f[2] ? f[1] : f[2]));
}

constexpr front_t set_level(const front_t f, int n)
{
    return add_level(f, n-find_level(f));
}

vector<front_t> build_fronts()
{
    set<front_t> inserted;
    vector<front_t> queue(1, front_t{0,0,0});
    while (!queue.empty())
    {
	front_t front = queue.back();
	queue.pop_back();
	if (!inserted.insert(front).second) continue;
	
	for (brick_t brick(front); !brick.done(); brick.next(front))
	{
	    front_t next= set_level(brick.combine(front), 0);
	    queue.push_back(next);
	}
    }
    return vector<front_t>(inserted.begin(), inserted.end());
}


constexpr array<front_t, 27> fronts= {{
	{0,0,0}, {0,0,1}, {0,0,2}, {0,1,0}, {0,1,1}, {0,1,2}, {0,2,0}, 
	{0,2,1}, {0,2,2}, {1,0,0}, {1,0,1}, {1,0,2}, {1,1,0}, {1,2,0}, 
	{1,3,0}, {2,0,0}, {2,0,1}, {2,0,2}, {2,1,0}, {2,2,0}, {2,3,0}, 
	{3,0,0}, {3,0,1}, {3,0,2}, {3,1,0}, {3,2,0}, {3,3,0}
    }};

struct edge_t 
{
    unsigned char from_front; // 0..7
    unsigned char to_front;   // 0..7
    unsigned char up_level; // 0..3
    bool is_valid;  // When false, the edge becomes nonexistent.
};

array<array<edge_t, 5>, fronts.size()> get_transitions();
static const array<array<edge_t, 5>, fronts.size()> transitions = 
    get_transitions();

static auto assert_fronts_func = [&]() {
    auto built_fronts = build_fronts();
    bool ret = (built_fronts.size() == fronts.size() &&
		equal(fronts.begin(), fronts.end(), built_fronts.begin()));
    assert(ret);
    return ret;
};

static const bool assert_fronts_result = assert_fronts_func();


array<array<edge_t, 5>, fronts.size()> get_transitions()
{
    array<array<edge_t, 5>, fronts.size()> ret;
    for (unsigned i=0 ; i != ret.size(); ++i)
    {
	for (unsigned j=0 ; j != ret[i].size() ; ++j)
	{
	    ret[i][j].from_front = i;
	    ret[i][j].is_valid = false;
	}
	unsigned num_edges = 0;
	for (brick_t brick(fronts[i]); !brick.done(); brick.next(fronts[i]))
	{
	    front_t next_front= brick.combine(fronts[i]);
	    unsigned level= *min_element(next_front.begin(), next_front.end());
	    edge_t & edge = ret[i][num_edges];
	    edge.up_level = level;
	    
	    front_t next_as_level0 = set_level(next_front, 0);
	    auto it = find(fronts.begin(), fronts.end(), next_as_level0);
	    assert(it != fronts.end());
	    edge.to_front = it - fronts.begin();
	    edge.is_valid = true;
	    ++num_edges;
	}
    }
    return ret;
}

unsigned fast(int n)
{
    array<unsigned, fronts.size()> initial;
    fill(initial.begin(), initial.end(), 0);
    static vector<array<unsigned, fronts.size()> > counts;
    static int largest_n = 0;
    if (n == 0) return 0;
    if (n <= largest_n)
    {
	return counts[n][0];
    }
    counts.resize(n+4, initial);
    if (largest_n == 0) counts[0][0] = 1;
    for (int i=largest_n ; i < n ; ++i)
    {
	for (unsigned j=0 ; j != fronts.size(); ++j)
	{
	    if (!counts[i][j]) continue;
	    for (const auto & t : transitions[j])
	    {
		if (!t.is_valid) break;
		unsigned & c = counts[i+t.up_level][t.to_front];
		c= (c + counts[i][j]) %mod;
	    }
	}
    }

    largest_n= n;
    return counts[n][0];
}

unsigned count(unsigned n)
{
    clock_t a = clock();
    unsigned ret_fast = fast(n);
    clock_t b = clock();
    cout << "fast time =" << 1.0*(b-a)/CLOCKS_PER_SEC << " res=" << ret_fast
	 << endl;
    unsigned ret_slow = fast(n);
    clock_t c = clock();
    cout << "slow time =" << 1.0*(c-b)/CLOCKS_PER_SEC << " res=" << ret_slow
	 << endl;
    assert(ret_fast == ret_slow);
    return ret_slow;
}

int main()
{
    int lines;
    if (!(cin >> lines)) return 0;
    for (int i=0 ; i < lines ; ++i) 
    {
	unsigned n;
	if (!(cin >> n)) return 0;
	cout << fast(n) << "\n";
    }
    return 0;
}

