#include<bits/stdc++.h>
using namespace std;
#define ll long long int
#define MOD 1000000007
ll modexp(ll a, ll b)
{
		ll res = 1LL;
		while(b)
		{
				if(b&1) res=(res*a)%MOD;
				a=(a*a)%MOD;
				b/=2;
		}
		return res;
}
vector<ll> vt;
ll fact[1000006],ifact[1000006];
ll ncr(ll n, ll r)
{
		if(r > n) return 0;
		if(r == 1) return n;
		if(r == 0) return 1;
		ll ans = 1;
		ans = (ifact[n-r]*ifact[r])%MOD;
		ans = (ans*fact[n])%MOD;
		return ans;
}
int main()
{
		int n;
		int m;
		int i;
		int j;
		ll res =1;
		i=0;
		fact[i]=1;
		ifact[i] = modexp(fact[i],MOD-2);
		for(i=1;i<1000006;++i)
		{
				fact[i] = (fact[i-1]*i)%MOD;
				ifact[i] = modexp(fact[i],MOD-2);
		}
		int msum;
		cin>>n;
		ll cans = 1;
		msum = 0;
		for(i=0;i<n;++i)
		{
				cin>>m;
				int tmp;
				vt.clear();
				msum+=m;
				cans=1;
				for(j=0;j<m;++j)
				{
						cin>>tmp;
						vt.push_back(tmp);
				}
				sort(vt.begin(),vt.end());
				int pre;
				int fre;
				fre=0;
				pre=vt[0];
				fre=1;
				for(j=1;j<vt.size();++j)
				{
						if(vt[j] == pre) fre++;
						else
						{
								cans = (cans*fact[fre])%MOD;
								pre = vt[j];
								fre=1;
						}
				}
				cans = (cans*fact[fre])%MOD;
				res = (res*cans)%MOD;
				res = (res*ncr(msum,m))%MOD;
		}
		cout<<res<<endl;
		return 0;
}

