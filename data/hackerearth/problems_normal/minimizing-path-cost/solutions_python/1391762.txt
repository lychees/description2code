def floydwarshall(graph):
 
    # Initialize dist and pred:
    # copy graph into dist, but add infinite where there is
    # no edge, and 0 in the diagonal
    dist = {}
    pred = {}
    for u in graph:
        dist[u] = {}
        pred[u] = {}
        for v in graph:
            dist[u][v] = 1000
            pred[u][v] = -1
        dist[u][u] = 0
        for neighbor in graph[u]:
            dist[u][neighbor] = graph[u][neighbor]
            pred[u][neighbor] = u
 
    for t in graph:
        # given dist u to v, check if path u - t - v is shorter
        for u in graph:
            for v in graph:
                newdist = dist[u][t] + dist[t][v]
                if newdist < dist[u][v]:
                    dist[u][v] = newdist
                    pred[u][v] = pred[t][v] # route new path through t
 
    return dist, pred

 
N, M = map(int, raw_input().split())
graph = {}
nodes = raw_input().split()
for node in nodes:
	graph[node] = {}
for m in xrange(M):
	node1, node2, dist = raw_input().split()	
	graph[node1][node2] = graph[node2][node1] = int(dist)
#print graph
dists, preds = floydwarshall(graph)
#print dists
for q in xrange(int(raw_input())):
	node1, node2 = raw_input().split()
	print dists[node1][node2]