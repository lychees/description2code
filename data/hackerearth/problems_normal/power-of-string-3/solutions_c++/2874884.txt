#include<deque>
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;

typedef long long LL;
typedef vector<int> VI;

#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)
#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)
#define eprintf(s...) fprintf(stderr, s)

template<class T> inline void amin(T &a, const T &b) { if (b<a) a=b; }
template<class T> inline void amax(T &a, const T &b) { if (a<b) a=b; }

// MOD 2^64
typedef unsigned long long ULL;
struct RollingHash {
    static const ULL BASE = 2e9 + 11; // 3e9+19, 4e9+7 
    static const int MAX_LEN = 1000100;
    static const vector<ULL>powB;
    static const vector<ULL>buildB();
    deque<char> S;
    deque<ULL> H; // H[i] := hash(S[0 .. i])
    RollingHash(const string &str) {
	init(str);
    }
    void init(const string &str) {
	S.clear(); H.assign(1, 0ULL);
	for (int i=0; i<(int)str.size(); i++) {
	    S.push_back(str[i]);
	    H.push_back(H.back() * BASE + str[i]);
	}
    }
    ULL get(int l, int r) { // hash(S[l .. r-1])
	return H[r] - H[l] * powB[r-l];
    }
    void push(char c) {
	S.push_back(c);
	H.push_back(H.back() * BASE + c);
    }
    void pop() {
	S.pop_back();
	H.pop_back();
    }
};
const vector<ULL>RollingHash::buildB() {
    vector<ULL>h(MAX_LEN);
    h[0] = 1;
    for (int i=1; i<MAX_LEN; i++) h[i] = h[i-1]*BASE;
    return h;
}
const vector<ULL>RollingHash::powB = RollingHash::buildB();

int K, N;
char buf[1000011];
int main() {
    scanf("%d%d%s", &K, &N, buf);
    RollingHash R(buf);
    
    int lo = 0, hi = N+1;
    while (hi - lo > 1 ) {
	int m = (lo + hi) /2;

	vector<ULL> v;
	REP (i, N-m+1) v.push_back(R.get(i, i+m));
	sort(v.begin(), v.end());
	int cnt = 1, last = 0;
	int ma = 1;
	for (int i=1; i<(int)v.size(); i++) {
	    if (v[i] != v[last]) {
		last = i;
		cnt = 1;
	    } else {
		cnt++;
		amax(ma, cnt);
	    }
	}

	if (ma >= K) lo = m;
	else hi = m;
    }
    printf("%d\n", lo);
    return 0;
}
