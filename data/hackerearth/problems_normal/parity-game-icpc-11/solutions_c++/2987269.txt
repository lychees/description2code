#include<bits/stdc++.h>
using namespace std;

struct Edge
{
    int from, to, cap, flow, index;
    Edge(int from, int to, int cap, int flow, int index) :
        from(from), to(to), cap(cap), flow(flow), index(index) {}
};

struct PushRelabel
{
    int N;
    vector<vector<Edge> > G;
    vector<int> excess;
    vector<int> dist, active, count;
    queue<int> Q;

    PushRelabel(int N) : N(N), G(N), excess(N), dist(N), active(N), count(2*N) {}

    void AddEdge(int from, int to, int cap)
    {
        G[from].push_back(Edge(from, to, cap, 0, G[to].size()));
        if (from == to) G[from].back().index++;
        G[to].push_back(Edge(to, from, 0, 0, G[from].size() - 1));
    }

    void Enqueue(int v)
    {
        if (!active[v] && excess[v] > 0)
        {
            active[v] = true;
            Q.push(v);
        }
    }

    void Push(Edge &e)
    {
        int amt = int(min(excess[e.from], int(e.cap - e.flow)));
        if (dist[e.from] <= dist[e.to] || amt == 0) return;
        e.flow += amt;
        G[e.to][e.index].flow -= amt;
        excess[e.to] += amt;
        excess[e.from] -= amt;
        Enqueue(e.to);
    }

    void Gap(int k)
    {
        for (int v = 0; v < N; v++)
        {
            if (dist[v] < k) continue;
            count[dist[v]]--;
            dist[v] = max(dist[v], N+1);
            count[dist[v]]++;
            Enqueue(v);
        }
    }

    void Relabel(int v)
    {
        count[dist[v]]--;
        dist[v] = 2*N;
        for (int i = 0; i < G[v].size(); i++)
            if (G[v][i].cap - G[v][i].flow > 0)
                dist[v] = min(dist[v], dist[G[v][i].to] + 1);
        count[dist[v]]++;
        Enqueue(v);
    }

    void Discharge(int v)
    {
        for (int i = 0; excess[v] > 0 && i < G[v].size(); i++) Push(G[v][i]);
        if (excess[v] > 0)
        {
            if (count[dist[v]] == 1)
                Gap(dist[v]);
            else
                Relabel(v);
        }
    }

    int GetMaxFlow(int s, int t)
    {
        count[0] = N-1;
        count[N] = 1;
        dist[s] = N;
        active[s] = active[t] = true;
        for (int i = 0; i < G[s].size(); i++)
        {
            excess[s] += G[s][i].cap;
            Push(G[s][i]);
        }

        while (!Q.empty())
        {
            int v = Q.front();
            Q.pop();
            active[v] = false;
            Discharge(v);
        }

        int totflow = 0;
        for (int i = 0; i < G[s].size(); i++) totflow += G[s][i].flow;
        return totflow;
    }
    vector<vector<Edge> > build()
    {
        return G;
    }
};
int a[100011],b[100011];
int main()
{
	srand(time(NULL));
    int i,j,k,n,q,ans=1000000000;
    scanf("%d %d",&n,&q);
    for(i=0;i<q;i++)
        scanf("%d %d",&a[i],&b[i]);
	double start = clock(),ed;
    for(;;)
    {
        int p=rand()%(n+1);
        int y=rand()%(n+1);
        if(p==y)
        	continue;
        PushRelabel flow(n+1);
        for(j=0;j<q;j++)
        {
            flow.AddEdge(a[j]-1,b[j],1);
            flow.AddEdge(b[j],a[j]-1,1);
        }
        ans=min(ans,flow.GetMaxFlow(y,p));
        ed=clock();
		if((ed-start)/CLOCKS_PER_SEC >0.87)break;
    }
    cout<<ans<<endl;
    return 0;
}
