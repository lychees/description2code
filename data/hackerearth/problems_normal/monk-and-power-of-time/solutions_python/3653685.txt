# https://www.hackerearth.com/code-monk-stacks-queues/algorithm/monk-and-power-of-time/


n = input()

if n >= 1 and n <= 100:

    CO = map(int, raw_input().split())
    IO = map(int, raw_input().split())


    class Queue:
        def __init__(self, d):
            self._data = d

        def enqueue(self, i):
            self._data.append(i)


        def dequeue(self):
            f = self._data[0]
            del self._data[0]
            return f

        def show(self):
            return self._data


        def is_empty(self):
            return len(self._data) == 0

        def get_front(self):
            return self._data[0]


    is_ideal = False

    points = 0

    q = Queue(CO)
    q1 = Queue(IO)

    while not q.is_empty():

        if q1.get_front() == q.get_front():
            q.dequeue()
            q1.dequeue()
            points += 1
        else:
            f = q.dequeue()
            q.enqueue(f)
            points += 1

print points