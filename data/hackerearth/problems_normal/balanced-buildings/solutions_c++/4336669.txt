#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

#ifndef ONLINE_JUDGE
#define dbg(x) cerr << __LINE__ << " : " << #x << " = " << (x) << endl;
#else
#define dbg(x)
#endif

#define ff first
#define ss second
typedef pair<ll, int> pll;
typedef tree<
    pii,
    null_type,
    less<pii>,
    rb_tree_tag,
    tree_order_statistics_node_update>
ordered_set;

const int MAXN = 2525;
int n;
int S, M, P;
int arr[MAXN];
ll memo[MAXN], mincost[MAXN][MAXN];
ll dp(int id){
    ll &res = memo[id];
    if (res != -1) return res;
    if (id >= n-1) return 0;
    // ignore
    res = dp(id + 1);
    for (int i = id + 1; i < n; i++){
        ll cur = (ll) (i - id) * S;
        cur -= mincost[id][i];
        cur += dp(i + 1);
        if (cur > res) res = cur;
    }
    return res;
}

const int MAXVAL = int(1e6 + 10);
ll ft[MAXN];
int frq[MAXN];
void update(int x, int val){
    while (x < MAXN){
        ft[x] += val;
        frq[x]++;
        x |= (x + 1);
    }
}

pll query(int x){
    pll res = {0, 0};
    while (x >= 0){
        res.first += ft[x];
        res.second += frq[x];
        x &= (x + 1);
        x--;
    }
    return res;
}

int pos[MAXVAL];
int main(){
    std::ios_base::sync_with_stdio(false);
    scanf("%d%d%d%d", &n, &S, &M, &P);
    set<int> xs;
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
        xs.insert(arr[i]);
    }
    int p = 0;
    for (auto &it : xs){
        pos[it] = p;
        p++;
    }
    for (int i = 0; i < n; i++){
        ordered_set mset;
        mset.insert({arr[i], i});
        memset(ft, 0, sizeof ft);
        memset(frq, 0, sizeof frq);
        update(pos[arr[i]], arr[i]);
        for (int j = i + 1; j < n; j++){
            mincost[i][j] = LLONG_MAX;
            mset.insert({arr[j], j});
            update(pos[arr[j]], arr[j]);
            int sz = j - i + 1;
            int limit = (ll) sz * M / (M + P);
            for (int idx = max(0, limit - 1); idx <= min(sz - 1, limit + 1); idx++){
                int val = (*mset.find_by_order(idx)).first;
                pll sum = query(pos[val]);
                ll ldiff = (ll) sum.second * val - sum.first;
                ll rdiff = query(MAXN-1).first - sum.first - (ll) (j - i + 1 - sum.second) * val;
                ll cur = ldiff * P + rdiff * M;
                mincost[i][j] = min(mincost[i][j], cur);
            }
            //cerr << i << ' ' << j << ": " << mincost[i][j] << endl;
        }
    }

    memset(memo, -1, sizeof memo);
    ll res = dp(0);
    cout << res << "\n";

    return 0;
}
