#include <iostream>
using namespace std;




/*
function modularExponentiationIterative(x, n):
    result = 1
    while n > 0
        if power % 2 == 1
            result = (result * x) % m
        x = (x * x) % m
        n = n/2
    return result
*/


long long modPower(long long n, long long k, int M) {
	long long result = 1;
	n = n%M;
	
	while(k>0) {
		
		if(k%2==1) {
			result = (result * n) % M;	
		}
		
		n = (n * n) % M;
		k = k/2;
	}
	return result;
}

long long C(long long n, long long r, int M) {
    if(r > n / 2) r = n - r; // because C(n, r) == C(n, n - r)
    long long nr = 1;
    long long dr = 1;
    int i;

    for(i = 1; i <= r; i++) {
        nr = (nr * (n - r + i))%M;
        dr = (dr * i)%M;
    }
	
	long long ans = (nr * modPower(dr, M-2, M)) % M;
	
    return ans;
}

int main()
{
    int t, temp;
    
    cin>>t;
    
    while(t--) {
    	int k, m;
    	
    	cin>>k; //no children
    	cin>>m; //no tablets
    	
    	
    	for(int i=0;i<k;i++) {
    		cin>>temp;
    		m-=temp;
    	}
    	//cout<<k+m-1<<"C"<<k-1<<":::";
    	if(m<0) {
    		cout<<0<<endl;
    	} else {
    		cout<<C(k+m-1,k-1, 1000000007L)<<endl;
    		//cout<<res%1000000007L<<endl;
    	}
    	
    	
    }
    
}
