#include<bits/stdc++.h>
#define ll long long
using namespace std;

#define MP make_pair
#define PB push_back
#define SZ size

std::vector<int> adj[100005];
std::vector<pair<int,int> > node;

bool vis[100005];

int target, nodes;

bool dfs(int u, int beg, int end)
{
	if(vis[u])
		return 0;

	vis[u] = 1;

	if(end - beg == target)
		return 1;

	bool ret = 0;

	int i, limit = adj[u].SZ();

	for(i=0; i<limit; i++)
	{
		int v = adj[u][i];
		ret |= dfs(v,beg, max(end,node[v].second));
	}

	return ret;
}

int main()
{
	int i, j;

	int cases;

	scanf("%d", &cases);

	while(cases--)
	{
		scanf("%d %d", &nodes, &target);

		for(i=0; i<nodes; i++)
		{
			adj[i].clear();
		}
		node.clear();

		for(i=0; i<nodes; i++)
		{
			int x, y;
			scanf("%d %d", &x, &y);
			node.PB(MP(y,x));
		}
		
		sort(node.begin(), node.end());
		
		for(i=0; i<nodes; i++)
			swap(node[i].first,node[i].second);

		for(i=0; i<nodes; i++)
		{
			for(j=0; j<nodes; j++)
			{
				if(i == j)	continue;

				if(node[j].first >= node[i].first && node[j].first <= node[i].second)
				{
					adj[i].PB(j);
				}
			}
		}

		bool ans = 0;

		for(i=0; i<nodes; i++)
		{
			for(j=0; j<nodes; j++)	vis[j] = 0;
			ans |= dfs(i,node[i].first,node[i].second);
		}

		if(ans)
			cout<<"Yes";
		else
			cout<<"No";
		cout<<"\n";
	}

    return 0;
}