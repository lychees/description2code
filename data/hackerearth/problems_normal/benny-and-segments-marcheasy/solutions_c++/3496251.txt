#include <bits/stdc++.h>

// clang-format off
using namespace std;
typedef int i32;
#define int long long
#define all(a) (a).begin(), (a).end()
#define ms(a,v) memset(a, v, sizeof(a))
#define mp make_pair
#define pb push_back
#define prev franga_de_sunga
#define next tio_de_sueter
#define index bora_baea
#define left ahsiha19as
#define VAR(i, x) __typeof(x) i=(x)
#define R32 ({i32 x; scanf("%d", &x); x;})
#define RL ({long long x; scanf("%lld", &x); x;})
#define RC ({char x; scanf(" %c", &x); x;})
#define foreach(i, x) for(VAR(i, (x).begin()); i != (x).end(); ++(i))
#define RI RL
typedef pair<int, int> ii;
typedef long long ll;
// clang-format on

const int N = 1e6 + 10;
const int MN = 1e6 + 5;

int t[4 * N];
int lz[4 * N];

void push(int no, int l, int r) {
  if (lz[no]) {
    t[no] += lz[no];
    lz[2 * no] += lz[no];
    lz[2 * no + 1] += lz[no];
    lz[no] = 0;
  }
}

void update(int no, int l, int r, int i, int j, int val) {
  push(no, l, r);
  if (r < l || r < i || l > j)
    return;
  if (i <= l && r <= j) {
    lz[no] += val;
    push(no, l, r);
  } else {
    int mid = (l + r) / 2;
    update(2 * no, l, mid, i, j, val);
    update(2 * no + 1, mid + 1, r, i, j, val);
    t[no] = min(t[2 * no], t[2 * no + 1]);
  }
}

int query(int no, int l, int r, int i, int j) {
  push(no, l, r);
  if (i <= l && r <= j) {
    return t[no];
  } else {
    int mid = (l + r) / 2;
    if (j <= mid)
      return query(2 * no, l, mid, i, j);
    if (i > mid)
      return query(2 * no + 1, mid + 1, r, i, j);
    return min(query(2 * no, l, mid, i, j), query(2 * no + 1, mid + 1, r, i, j));
  }
}

bool cmp(ii a, ii b) { return a.second < b.second; }

void solve() {
  int n = RI;
  int L = RI;

  vector<ii> road;
  for (int i = 0; i < n; i++) {
    int x = RI;
    int y = RI;
    if (x != y && y - x <= L)
      road.push_back({x, y});
  }

  sort(all(road), cmp);

  priority_queue<ii, vector<ii>, greater<ii> > pq;
  bool ok = false;
  for (int i = 0; i < road.size(); i++) {
    int R = road[i].second;
    // insert
    update(1, 0, MN, road[i].first, R - 1, +1);
    pq.push(road[i]);

    // remove
    while (!pq.empty() && pq.top().first < R - L) {
      ii p = pq.top();
      pq.pop();
      update(1, 0, MN, p.first, p.second - 1, -1);
    }

    // test
    if (R - L >= 0) {
      int mn = query(1, 0, MN, R - L, R - 1);
      // printf("road (%lld, %lld) mn = %lld, testing %lld to %lld\n", road[i].first, R, mn, R - L, R - 1);
      ok |= mn > 0;
    }
  }

  while (!pq.empty()) {
    ii p = pq.top();
    pq.pop();
    update(1, 0, MN, p.first, p.second - 1, -1);
  }

  if (ok)
    puts("Yes");
  else
    puts("No");
}

i32 main() {
  int T = RI;
  for (int i = 1; i <= T; i++)
    solve();
}
