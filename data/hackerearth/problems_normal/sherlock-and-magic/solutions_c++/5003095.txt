#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<vector>
#include<bitset>
#include<map>
#include<queue>
#include<stack>
#include<set>
#include<cmath>
#include<algorithm>
#include<utility>
#include<climits>
#include<sstream>

using namespace std;

#define nl printf("\n")
#define space printf(" ")

#define mem(x,val) memset(x,val,sizeof(x))
#define rite(x) freopen(x,"w",stdout)
#define read(x) freopen(x,"r",stdin)

typedef long long ll;
typedef unsigned long long ull;

struct p {
    int x,y;
    char d;
    bool vanish;
    };

int main() {
//    read("in.txt");
//rite("out.txt");
    int tc;
    cin >> tc;

    p criminal[50];
    int reachable[50][50];
    int when[50][50];//when will the two people meet
    set<int> tgian;//meeting time
    set<int>::iterator it;
    int a,b;
    int n;
    int i,j;
    int left;
    bool xoa;
    while(tc--) {
        cin >> n;
        for(i = 0 ; i < n ; ++i) {
            cin >> criminal[i].x >> criminal[i].y >> criminal[i].d;
            criminal[i].vanish = false;
            }

        for(i = 0 ; i < n-1; ++i) {
            for(j = i+1; j < n; ++j) {

                if (criminal[i].d <= criminal[j].d) a = i, b = j;
                else a = j,b = i;

                if (criminal[a].d == criminal[b].d) {
                    if (criminal[a].x == criminal[b].x && criminal[a].y == criminal[b].y) reachable[i][j] = 1;
                    else reachable[i][j] = 0;
                    }
                else {
                    if (criminal[a].d == 'N' && criminal[b].d == 'S') {
                        if (criminal[a].x == criminal[b].x && criminal[a].y < criminal[b].y) reachable[i][j] = 1;
                        else reachable[i][j] = 0;
                        }
                    else if (criminal[a].d == 'E' && criminal[b].d == 'N') {
                        if(criminal[a].y > criminal[b].y && criminal[a].x < criminal[b].x && criminal[a].y - criminal[b].y == criminal[b].x - criminal[a].x) reachable[i][j] = 1;
                        else reachable[i][j] = 0;
                        }
                    else if (criminal[a].d == 'E' && criminal[b].d == 'W') {
                        if (criminal[a].y == criminal[b].y && criminal[a].x < criminal[b].x ) reachable[i][j] = 1;
                        else reachable[i][j] = 0;
                        }
                    else if (criminal[a].d == 'E' && criminal[b].d == 'S') {
                        if (criminal[b].y > criminal[a].y && criminal[b].x > criminal[a].x && criminal[b].y - criminal[a].y == criminal[b].x - criminal[a].x) reachable[i][j] = 1;
                        else reachable[i][j] = 0;
                        }
                    else if (criminal[a].d == 'N' && criminal[b].d == 'W') {
                        if (criminal[b].x > criminal[a].x && criminal[b].y > criminal[a].y && criminal[b].x - criminal[a].x == criminal[b].y - criminal[a].y) reachable[i][j] = 1;
                        else reachable[i][j] = 0;
                        }
                    else {
                        if (criminal[a].y > criminal[b].y && criminal[b].x > criminal[a].x && criminal[a].y - criminal[b].y == criminal[b].x - criminal[a].x) reachable[i][j] = 1;
                        else reachable[i][j] = 0;
                        }
                    }
                }
            }

        for( i = 0 ; i < n - 1; ++i) {
            for (j = i+1 ; j < n ; ++j) {
                if (reachable[i][j] == 1 && criminal[i].vanish == false && criminal[j].vanish == false) {
                    when[i][j] = abs(criminal[i].x - criminal[j].x) + abs(criminal[i].y - criminal[j].y);
                    tgian.insert(when[i][j]);
                    }
                else when[i][j] = INT_MAX;
                }
            }
        left = n;
        for(it = tgian.begin(); it != tgian.end(); ++it ) {
            for(i = 0; i < n - 1; ++i) {

                if (criminal[i].vanish == false ) {
                    xoa = false;
                    for(j = i + 1; j < n ; ++j) {
                        if(when[i][j] == *it && criminal[j].vanish == false) {
                            when[i][j] = INT_MAX;
                            xoa = true;
                            criminal[j].vanish = true;
                            left -= 1;
                            }
                        }
                    if (xoa) {
                        criminal[i].vanish = true;
                        left -= 1;
                        }
                    }
                }
            }
        cout << left << endl;
        }
    return 0;
    }
