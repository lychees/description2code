#include <bits/stdc++.h> 

using namespace std;
 
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define sz(x) (int)((x).size()) 
#define forn(i,n) for (int i = 0; (i) < (n); ++i)
#define fornr(i,n) for (int i = (n) - 1; (i) >= 0; --i)
#define forab(i,a,b) for (int i = (a); (i) < (b); ++i)
#define forba(i,a,b) for (int i = (b) - 1; (i) >= (a); --i)
#define forit(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)
#define all(c) (c).begin(),(c).end() 

#ifdef LOCAL
    #define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
    #define eprintf(...) static_cast<void>(0)   
#endif

#ifdef _WIN32
    #define I64 "%I64d"
#else
    #define I64 "%lld"
#endif

typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
typedef unsigned int uint;
typedef vector <int> vi;
typedef pair <int, int> pii;

#define FNAME ""

const int MAXN = 1e5 + 5, MAXK = 18;

int size[MAXN], used[MAXN], fst[MAXK][MAXN], last[MAXK][MAXN], sonOfRoot[MAXK][MAXN], treeSize[MAXN], pr[MAXN], nex[MAXN], tin[MAXN], tout[MAXN], up[MAXN][MAXK];
LL h[MAXK][MAXN];
pii adj[MAXN][MAXK];
vector <pii> g[MAXN];
map <pii, int> edge;
int curPath = 0, timer = 0;
vi eulerPath;
vector <pair <LL, int> > t[MAXN];
vector <LL> add[MAXN];
pii pathNum[MAXN];
vi ePath[MAXN];
pair <LL, int> tmp[MAXN];

void upBuild(int v, int p = -1)
{
    tin[v] = timer++;
    forab (i, 1, MAXK)
        up[v][i] = up[up[v][i - 1]][i - 1];
    for (auto np : g[v])
        if (np.fs != p)
        {
            up[np.fs][0] = v;
            upBuild(np.fs, v);
        }    
    tout[v] = timer++;
}

inline bool isAncestor(int v, int u)
{
    return tin[v] <= tin[u] && tout[v] >= tout[u];
}

inline int getSon(int v, int u)
{
    if (!isAncestor(v, u))
        return up[v][0];
    fornr (i, MAXK)
        if (!isAncestor(up[u][i], v))  
            u = up[u][i];
    return u;
}

void dfs(int v, int p = -1)
{
    size[v] = 1;
    for (auto np : g[v])
        if (p != np.fs && !used[np.fs])
        {
            dfs(np.fs, v);
            size[v] += size[np.fs];
        }
}

void euler(int root, int level, int v, LL curDist, int p, int son)
{
    eulerPath.pb(v);
    fst[level][v] = timer++;
    h[level][v] = curDist;
    sonOfRoot[level][v] = son;
    for (auto np : g[v])
    {
        if (p != np.fs && !used[np.fs])
        {
            if (son == -1)
                euler(root, level, np.fs, curDist + np.sc, v, np.fs);
            else
                euler(root, level, np.fs, curDist + np.sc, v, son);                
        }
        if (used[np.fs])
            adj[root][pathNum[np.fs].sc] = mp(v, np.fs); 
    }
    last[level][v] = timer;
}

void build(int v, int p, int level = 0) 
{
    dfs(v);
    int pred = -1;
    int curSize = size[v];
    while (1)
    {
        bool was = 0;
        for (auto np : g[v])
            if (!used[np.fs] && np.fs != pred && size[np.fs] * 2 >= curSize)
            {
                was = 1;
                pred = v;
                v = np.fs;
                break;    
            }
        if (!was)
            break;
    }   
    eulerPath.clear();
    timer = 0;
    euler(v, level, v, 0, -1, -1);
    if (level != 0)
        nex[v] = adj[v][level - 1].fs;
    fornr (i, level)
        if (adj[v][i].fs == -1)
        {
            adj[v][i].fs = adj[v][i + 1].fs;
            adj[v][i].sc = pr[adj[v][i + 1].sc];
        }
    adj[v][level] = mp(v, v);
    ePath[curPath] = eulerPath;
    used[v] = 1;
    pr[v] = p;
    treeSize[curPath] = 1;
    while (treeSize[curPath] < sz(eulerPath))
        treeSize[curPath] *= 2;
    t[curPath].resize(2 * treeSize[curPath]);
    add[curPath].resize(2 * treeSize[curPath]);
    forn (i, sz(eulerPath))
        t[curPath][treeSize[curPath] + i] = mp(h[level][eulerPath[i]], i);
    forba (i, 1, treeSize[curPath])
        t[curPath][i] = max(t[curPath][2 * i], t[curPath][2 * i + 1]);
    pathNum[v] = mp(curPath++, level);
    for (auto np : g[v])
        if (!used[np.fs])
            build(np.fs, v, level + 1);    
}

inline void push(int ind, int v, int ll, int rr)
{
    if (add[ind][v] == 0)
        return;
    if (ll != rr - 1)
        forn (j, 2)
            add[ind][2 * v + j] += add[ind][v];
    t[ind][v].fs += add[ind][v];
    add[ind][v] = 0;                
}

pair <LL, int> get(int ind, int v, int ll, int rr, int l, int r)
{
    push(ind, v, ll, rr);
    if (ll >= l && rr <= r)
        return t[ind][v];
    if (ll >= r || l >= rr)
        return mp(0, 0);
    int mm = (ll + rr) / 2;
    pair <LL, int> np = mp(0, 0);
    if (l < mm)
        np = max(np, get(ind, 2 * v, ll, mm, l, r));
    if (r > mm)
        np = max(np, get(ind, 2 * v + 1, mm, rr, l, r));
    return np;
}

void update(int ind, int v, int ll, int rr, int l, int r, int dlt)
{
    if (ll >= l && rr <= r)
    {
        add[ind][v] += dlt;
        push(ind, v, ll, rr);
        return;
    }
    push(ind, v, ll, rr);
    if (ll >= r || l >= rr)
        return;
    int mm = (ll + rr) / 2;
    push(ind, 2 * v, ll, mm);
    push(ind, 2 * v + 1, mm, rr);
    if (l < mm)
        update(ind, 2 * v, ll, mm, l, r, dlt);
    if (r > mm)
        update(ind, 2 * v + 1, mm, rr, l, r, dlt);
    t[ind][v] = max(t[ind][2 * v], t[ind][2 * v + 1]);
}

LL getLongestPath(int v)
{
    LL ans = 0;
    int path = pathNum[v].fs, level = pathNum[v].sc;
    auto np = get(path, 1, 0, treeSize[path], 0, last[level][v]);
    if (np.fs != 0)
    {
        int u = sonOfRoot[level][ePath[path][np.sc]];
        ans = max(ans, np.fs + max(get(path, 1, 0, treeSize[path], 0, fst[level][u]).fs, get(path, 1, 0, treeSize[path], last[level][u], last[level][v]).fs));
    }
    int ind = 0;
    LL maxx = 0;
    fornr (i, level)
    {
        int u = adj[v][i].sc;
        int pathU = pathNum[u].fs, levelU = pathNum[u].sc;
        int w = nex[adj[v][i + 1].sc];
        int x = getSon(v, u);
        LL partOfPath = get(pathU, 1, 0, treeSize[pathU], fst[levelU][v], fst[levelU][v] + 1).fs +
                       max(get(pathU, 1, 0, treeSize[pathU], 0, fst[levelU][w]).fs, get(pathU, 1, 0, treeSize[pathU], last[levelU][w], treeSize[pathU]).fs);
        ans = max(ans, partOfPath + max(get(path, 1, 0, treeSize[path], 0, fst[level][x]).fs, get(path, 1, 0, treeSize[path], last[level][x], treeSize[path]).fs));
        tmp[i] = mp(partOfPath, x);
        if (partOfPath > maxx)
        {
            maxx = partOfPath;
            ind = i;
        }
    }
    forn (i, level)
        if (ind != i && (tmp[i].sc != tmp[ind].sc))
            ans = max(ans, maxx + tmp[i].fs);
    return ans;
}

void update(int v, int u, int w)
{
    int x;
    if (pathNum[v].sc < pathNum[u].sc)
        x = v;
    else
        x = u;
    int k = pathNum[x].sc;
    fornr (i, k + 1)
    {
        int path = pathNum[x].fs;
        int level = pathNum[x].sc;
        assert(level == i);
        update(path, 1, 0, treeSize[path], max(fst[level][v], fst[level][u]), min(last[level][v], last[level][u]), w);
        x = pr[x];
    }
}

int main() 
{
#ifdef LOCAL    
    freopen(FNAME".in", "r", stdin);
    freopen(FNAME".out", "w", stdout); 
#endif    
    int n, q;
    scanf("%d%d", &n, &q);
    forn (i, n)
        forn (j, MAXK)
            adj[i][j] = mp(-1, -1);
    forn (i, n - 1)
    {
        int v, u, w;
        scanf("%d%d%d", &v, &u, &w);
        v--, u--;
        if (v > u)
            swap(v, u);
        edge[mp(v, u)] = w;
        g[v].pb(mp(u, w));
        g[u].pb(mp(v, w));
    }
    upBuild(0);
    timer = 0;
    build(0, 0);
    forn (qq, q)
    {
        int type;
        scanf("%d", &type);
        if (type == 1)
        {
            int v, u, w;
            scanf("%d%d%d", &v, &u, &w);
            v--, u--;
            if (v > u)
                swap(v, u);
            int dlt = w - edge[mp(v, u)];
            edge[mp(v, u)] += dlt;
            update(v, u, dlt);
        }
        else
        {
            int v;
            scanf("%d", &v);
            v--;
            printf(I64 "\n", getLongestPath(v));
        }
    }
    return 0;
}