#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<vector>
#include<bitset>
#include<map>
#include<queue>
#include<stack>
#include<set>
#include<cmath>
#include<algorithm>
#include<utility>
#include<climits>
#include<sstream>

using namespace std;

#define nl printf("\n")
#define space printf(" ")

#define mem(x,val) memset(x,val,sizeof(x))
#define rite(x) freopen(x,"w",stdout)
#define read(x) freopen(x,"r",stdin)

typedef long long ll;
typedef unsigned long long ull;


int main() {
//    read("in.txt");
//rite("out.txt");

    int n,k;
    cin >> n  >> k;
    cin.ignore();
    string input;
    cin >> input;
    int i,j;

    vector< queue<int> > unchosen;
    vector<set<int> > chosen;
    set<int>::iterator it;
    set<int> temp1;
    queue<int> temp2;
    chosen.assign(26,temp1);
    unchosen.assign(26,temp2);

    for(j = n-1 ; j >= 0 ; --j) {
        unchosen[input[j]-'a'].push(j);
        }

    bool chon,cu,moi;
    //chon tells us whether i has been chosen yet
    //cu == tells us whether there exists a smaller letter in chosen,moi == tells us whether there exists a smaller letter in unchosen
    int p1,p2;

    for(i = 0 ; i < n ; ++i) {

        moi = false, cu = false, chon = false;

        //subtask 3: find whether there exists an unchosen letter to the left that is smaller than input[i]
        for(j = 0 ; j < input[i] - 'a'; ++j) { //only checks at most 25 number
            if (unchosen[j].size() > 0 && unchosen[j].front() > i) {
                moi = true;
                p1 = unchosen[j].front();
                break;
                }
            }
        //subtask 2: find whether there lies a smaller ALREADY CHOSEN letter to the left  to swap with input[i]
        for(j = 0 ; j < input[i]-'a'; ++j) {
            if (chosen[j].size() > 0) {
                it = chosen[j].upper_bound(i);
                if (it != chosen[j].end()) {
                    cu = true;
                    p2 = *it;
                    break;
                    }
                }
            }
        //subtask 1: find whether i lies in chosen
        if (chosen[input[i]-'a'].size() > 0 ) {
            it = chosen[input[i]-'a'].lower_bound(i);
            if (it != chosen[j].end() && *it == i) chon = true;
            }

        if (chon) { //input[i] is in chosen
            chosen[input[i]-'a'].erase(i);//delete from chosen, after processing it,it's value has been minimised --> no longer care about it
            if (k > 0) {
                if (moi && cu) {
                    if (input[p1] < input[p2]) {//unchosen letter < chosen letter
                        unchosen[input[p1]-'a'].pop();//delete the index from unchosen
                        swap(input[p1],input[i]);//swap two letters
                        chosen[input[p1]-'a'].insert(p1);//letter at index p1 has now been chosen
                        k -= 1;
                        }
                    else {//if unchosen letter == chosen letter --> better to select chosen letter to save k
                        chosen[input[p2]-'a'].erase(p2);//erase letter from chosen--> since you are going to swap, location stored in chosen changes
                        swap(input[p2],input[i]);
                        chosen[input[p2]-'a'].insert(p2);//input[p2] now has a new letter stored in it, update chosen
                        }
                    }
                else if (moi) {
                    unchosen[input[p1]-'a'].pop();//delete the index from unchosen
                    swap(input[p1],input[i]);//swap two letters
                    chosen[input[p1]-'a'].insert(p1);//letter at index p1 has now been chosen
                    k -= 1;
                    }
                else if (cu) {
                    chosen[input[p2]-'a'].erase(p2);//erase letter from chosen--> since you are going to swap, location stored in chosen changes
                    swap(input[p2],input[i]);
                    chosen[input[p2]-'a'].insert(p2);//input[p2] now has a new letter stored in it, update chosen
                    }
                }
            else if (cu) { //k == 0
                chosen[input[p2]-'a'].erase(p2);//erase letter from chosen--> since you are going to swap, location stored in chosen changes
                swap(input[p2],input[i]);
                chosen[input[p2]-'a'].insert(p2);//input[p2] now has a new letter stored in it, update chosen
                }
            }
        else {
            if (k >= 2) {

                if (moi && cu) {
                    if (input[p1] < input[p2]) {//unchosen letter < chosen letter
                        unchosen[input[p1]-'a'].pop();//delete the index from unchosen
                        swap(input[p1],input[i]);//swap two letters
                        chosen[input[p1]-'a'].insert(p1);//letter at index p1 has now been chosen
                        k -= 2;
                        }
                    else {//if unchosen letter == chosen letter --> better to select chosen letter to save k
                        chosen[input[p2]-'a'].erase(p2);//erase letter from chosen--> since you are going to swap, location stored in chosen changes
                        swap(input[p2],input[i]);
                        chosen[input[p2]-'a'].insert(p2);//input[p2] now has a new letter stored in it, update chosen
                        k -= 1;//chosen now includes index i, but you don't need to push into chosen though, because you will finish processing it soon
                        }
                    }
                else if (moi) {
                    unchosen[input[p1]-'a'].pop();//delete the index from unchosen
                    swap(input[p1],input[i]);//swap two letters
                    chosen[input[p1]-'a'].insert(p1);//letter at index p1 has now been chosen
                    k -= 2;
                    }
                else if (cu) {
                    chosen[input[p2]-'a'].erase(p2);//erase letter from chosen--> since you are going to swap, location stored in chosen changes
                    swap(input[p2],input[i]);
                    chosen[input[p2]-'a'].insert(p2);//input[p2] now has a new letter stored in it, update chosen
                    k -= 1;
                    }
                }
            else if (k == 1 && cu) {
                chosen[input[p2]-'a'].erase(p2);//erase letter from chosen--> since you are going to swap, location stored in chosen changes
                swap(input[p2],input[i]);
                chosen[input[p2]-'a'].insert(p2);//input[p2] now has a new letter stored in it, update chosen
                k -= 1;
                }
            }

        }
    cout << input << endl;
    return 0;
    }
