#include <iostream>
using namespace std;
int t, n, m, k;
int keys[21];
int chests[101];
int gems[101];
int lock_memory[51][51];
int dp[(1<<21)];
int val[(1<<21)];

int countSetBits(int num)
{
	if (num == 0) return 0;
	int cnt = 0;
	do 
	{
		++cnt;
		num = (num & (num-1));
	}while(num);
	return cnt;
}

int GCD (int a, int b)
{
	if (b == 0) return a;
	else return GCD(b, a%b);
}

bool keyUnlocksChest(int key, int chest)
{
	// key will unlock chest if key and chest are not co-prime
	// i.e. there GCD is not 1
	if (lock_memory[key][chest] != -1) 
		return lock_memory[key][chest];
		
	if (GCD(key, chest) != 1) 
		return lock_memory[key][chest] = 1;
	return lock_memory[key][chest] = 0;
}

int calculate_val(int mask)
{
	if (val[mask]) return val[mask];
	bool vis[201];
	for(int i = 0; i < 201; ++i) vis[i] = false;
	
	int key;
	for (int i = 0; i < n; ++i)
	{
		if (mask & (1<<i)) 
		{
			key = keys[i];
			for (int j = 0; j < m; ++j)
			if (!vis[j] && keyUnlocksChest(key, chests[j]))
			{
				vis[j] = true;
				val[mask] += gems[j];
			}
		}
	}
	return val[mask];
}

int solve(int mask)
{
	int setBits = countSetBits(mask);
	if (setBits == k) 
	{
		// we have chosen k keys. No more gems.
		return dp[mask] = calculate_val(mask);	
	}
	if (dp[mask]) return dp[mask];
	
	for (int i = 0; i < n; ++i)
	{
		if (mask & (1<<i)) continue;
		//pick i
		dp[mask] = max(dp[mask], solve(mask|(1<<i)));	
	}
	return dp[mask];
}

int main()
{
	cin >> t;
	while (t--)
	{
		scanf("%d%d%d", &n, &m, &k);
		for (int i = 0; i < n; ++i)
			scanf("%d", &keys[i]);
		for (int i = 0; i < m; ++i)
			scanf("%d", &chests[i]);
		for (int i = 0; i < m; ++i)
			scanf("%d", &gems[i]);
		
		for (int i = 0; i < 1<<(n+1); ++i) 
		{
			dp[i] = val[i] = 0;
		}
		for (int i = 0; i < 51; ++i)
		for (int j = 0; j < 51; ++j)
			lock_memory[i][j] = -1;
			
		printf("%d\n",solve(0));
	}
    return 0;
}
