/* -----  PRIM ALGORITHM (Using STL) --------
 -->> We only include those vertex in priority queue which are:-
           (a) NOT included in MST
           (b) Adjacent vertex to already include vertex in MST

 1). We take "boolean array" which mark the vertices "already included in MST" as true (visited_MST[]) 
 2). We take "key array" which stores the minimum distance of paricular vertex from its all adjacent ,intially it is infinite
 
 Minimum weight = sumof ( key[] )
*/

#include<bits/stdc++.h>
using namespace std;

typedef long long lld;

#define MAX 100005
#define pii pair<lld,lld >
vector<pii > graph[MAX];
bool visited_MST[MAX];


struct comp 
{
    bool operator() (const pii &a, const pii &b) 
    {
        return a.second > b.second;
    }
};
 

void prim(lld n)
{
  priority_queue< pii, vector< pii >, comp > pq; 
  vector<lld > key(MAX,INT_MAX);

  lld starting=1,total=0;
   //cin>>starting;	
   //visited[starting]=true;
  pq.push(make_pair(starting,0));
  key[starting]=0;
 
while(!pq.empty())
{ 
  lld t;
  t=pq.top().first;
  //cout<<t<<" ";

  visited_MST[t]=true;
  pq.pop();

  for(lld i=0; i<graph[t].size() ; i++)
   {
       if( visited_MST[graph[t][i].first]==false and key[graph[t][i].first] > graph[t][i].second )
       {  pq.push(make_pair(graph[t][i].first,graph[t][i].second));
       	  key[graph[t][i].first]=graph[t][i].second;
       }      
   
   }

   
} 

for(lld i=1;i<=n;i++)
   	total+=key[i];
  

 cout<<total<<"\n";

}
int main()
{
	
  lld n;
  cin>>n;

  lld e;
  cin>>e;

  for(lld i=0;i<e;i++)
  {   lld a,b,w;
      cin>>a>>b>>w;

      graph[a].push_back(make_pair(b,w));
      graph[b].push_back(make_pair(a,w));
 
  }

   prim(n);



}