#include<bits/stdc++.h>

#define lli long long int
#define llu unsigned long long int
#define ld long double
#define all(v) v.begin(),v.end()
#define pb push_back
#define mp make_pair
#define F first
#define S second
#define si(n) scanf("%d",&n)
#define slli(n) scanf("%lld",&n);
#define ss(n) scanf("%s",n);

const long double EPS = 1e-10;
const lli MOD = 1000000007ll;
const lli mod1 = 1000000009ll;
const lli mod2 = 1100000009ll;
int INF = 2147483645;
lli INFINF = 9223372036854775807;
int debug = 0;

using namespace std;

void print(int a[],int s,int e){for(int i=s;i<=e;i++)cout<<a[i]<<" ";cout<<"\n";}
void print(vector<int> &v,int s,int e){for(int i=s;i<=e;i++)cout<<v[i]<<" ";cout<<"\n";}
void print(vector<int> &v){for(int x:v)cout<<x<<" ";cout<<"\n";}

lli bit_count(lli _x){lli _ret=0;while(_x){if(_x%2==1)_ret++;_x/=2;}return _ret;}
lli bit(lli _mask,lli _i){return (_mask&(1<<_i))==0?0:1;}
lli powermod(lli _a,lli _b,lli _m){lli _r=1;while(_b){if(_b%2==1)_r=(_r*_a)%_m;_b/=2;_a=(_a*_a)%_m;}return _r;}
lli add(lli a,lli b,lli m=MOD){lli x=a+b;while(x>=m)x-=m;return x;}
lli sub(lli a,lli b,lli m=MOD){lli x=a-b;while(x<0)x+=m;return x;}
lli mul(lli a,lli b,lli m=MOD){lli x=a*b;x%=m;return x;}

lli ans;

struct UnionFind
{
    vector<lli> parent,rank,cnt;
    int comp;
    void init(lli N){
        vector<lli>_v1(N,0),_v2(N),_v3(N,0);
        for(lli i=0;i<N;i++) _v2[i]=i;
        rank=_v1;parent=_v2;cnt=_v3;comp=N;
    }
    lli Find(lli u){
        if(parent[u]!=u) parent[u]=Find(parent[u]);
        return parent[u];
    }
    lli Union(lli u,lli v){
        lli pv=Find(v),pu=Find(u);
        lli ret = cnt[pu]*cnt[pv];
        if(rank[u]>rank[v]) parent[pv]=pu,cnt[pu]+=cnt[pv];
        else parent[pu]=pv,cnt[pv]+=cnt[pu];
        if(rank[u]==rank[v]) rank[pv]++;
        comp--;
        return ret;
    }
};

int n,q;
vector<pair<int,int> > G[100010];
vector<pair<int,pair<int,int> > > edges;
int lca[100010][25];
int rmq[100010][25];
int depth[100010];
int MAGIC = 160;

void dfs(int u,int p,int d,int pedge){
    lca[u][0] = p;
    rmq[u][0] = pedge;
    depth[u] = d;
    for(auto it : G[u]){
        int v = it.F;
        int c = it.S;
        if(v!=p)
            dfs(v,u,d+1,c);
    }
}

void LCApreprocess()
{
    for(int i=1;i<=n;i++)for(int j=1;j<20;j++)lca[i][j]=0,rmq[i][j]=INF;
    for(int j=1;j<20;j++)for(int i=1;i<=n;i++)lca[i][j]=lca[lca[i][j-1]][j-1],
        rmq[i][j] = min(rmq[i][j-1],rmq[lca[i][j-1]][j-1]);
}

int LCAquery(int u,int v)
{
    if(depth[u]<depth[v]) swap(u,v);
    int diff=depth[u]-depth[v];
    for(int i=0;i<20;i++) if( (diff>>i)&1 ) u=lca[u][i];
    if(u==v)return u;
    for(int j=19;j>=0;j--)if(lca[u][j]!=lca[v][j]) u=lca[u][j],v=lca[v][j];
    return lca[u][0];
}

int rmqQuery(int u,int v){
    if(depth[u]<depth[v]) swap(u,v);
    int diff=depth[u]-depth[v];
    int ret = INF;
    for(int i=0;i<20;i++) {
        if( (diff>>i)&1 ) {
            ret=min(ret,rmq[u][i]);
            u = lca[u][i];
        }
    }
    return ret;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    debug = 1;
#endif
    srand (time(NULL));

    si(n);
    for(int i=1;i<n;i++){
        int u,v,c;
        si(u);si(v);si(c);
        G[u].pb({v,c});
        G[v].pb({u,c});
        edges.pb({c,{u,v}});
    }
    dfs(1,0,0,INF);
    LCApreprocess();
    sort(all(edges));
    reverse(all(edges));
    si(q);
    while(q--){
        int k;
        si(k);
        vector<int> v;
        for(int i=0;i<k;i++){
            int x;
            si(x);
            v.pb(x);
        }
        if(k<=MAGIC){
            ans = 0;
            for(int i=0;i<v.size();i++){
                for(int j=i+1;j<v.size();j++){
                    int x = v[i];
                    int y = v[j];
                    int l = LCAquery(x,y);
                    if(x==l){
                        ans += rmqQuery(y,l);
                    }
                    else if(y==l){
                        ans += rmqQuery(x,l);
                    }
                    else{
                        ans += min(rmqQuery(x,l),rmqQuery(y,l));
                    }
                }
            }
        }
        else{
            UnionFind UF;
            UF.init(n+10);
            for(int x:v){
                UF.cnt[x] = 1;
            }
            ans = 0;
            for(pair<int,pair<int,int> > it : edges){
                int x = it.S.F;
                int y = it.S.S;
                int c = it.F;
                ans += UF.Union(x,y)*1ll*c;
            }
        }
        printf("%lld\n",ans);
    }


    return 0;
}

