#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<bool> vb;
typedef vector<vb> vvb;

vvi field;
vvb marked;

int dfs(int y, int x)
{
	int xsize, ysize, nnodes;
	int ny, nx;
	ysize = field.size();
	xsize = field[0].size();
	marked[y][x] = true;
	stack<ii> st;
	st.push(make_pair(y, x));
	nnodes = 0;
	while(!st.empty())
	{
		ii point = st.top();
		st.pop();
		nnodes++;
		for(int i=-1;i<=1;i++)
		{
			for(int j=-1;j<=1;j++)
			{
				ny = point.first+i;
				nx = point.second+j;
				if (nx >=0 && nx<xsize && ny>=0 && ny<ysize && marked[ny][nx]==false && field[ny][nx]==1)
				{
					st.push(make_pair(ny,nx));
					marked[ny][nx] = true;
				}
			}
		}
	}
	return nnodes;
}

int main()
{
    int T, N, M, ncomps, max_comp_size;
    cin >> T;
    while(T--)
    {
    	cin >> N >> M;
    	field.assign(N, vi());
    	marked.assign(N, vb());
    	for(int i=0;i<N;i++)
    	{
    		field[i].assign(M, 0);
    		marked[i].assign(M, false);
    		for(int j=0;j<M;j++)
    		{
    			cin >> field[i][j];
    		}
    	}
    	ncomps = 0;
    	max_comp_size = 0;
    	for(int i=0;i<N;i++)
    	{
    		for(int j=0;j<M;j++)
    		{
	    		if (!marked[i][j] && field[i][j]==1)
	    		{
	    			int comp_size = dfs(i, j);
	    			max_comp_size = max(comp_size, max_comp_size);
	    			ncomps++;
	    		}
    		}
    	}
    	cout << ncomps << " " << max_comp_size << endl;
    }
    return 0;
}
