#include <cstdio>
#include <vector>

using namespace std;

typedef long long ll;

const ll MOD = 1e9 + 7;

struct Matrix {
	vector<vector<int> > mat;
	int n_rows, n_cols;
	
	Matrix() {}
	
	Matrix(int n, int m, int val = 0) : n_rows(n), n_cols(m) {
		mat.assign(n, vector<int>(m, val));
	}
	
	Matrix(vector<vector<int> > val) : mat(val), n_rows(val.size()),
		n_cols(val[0].size()) {}
	
	static Matrix Identity(int n) {
		vector<vector<int> > ret(n, vector<int>(n, 0));
		for (int i = 0; i < n; i++) ret[i][i] = 1;
		return Matrix(ret);
	}
	
	Matrix operator *(const Matrix &other) const {
		int n = n_rows, m = other.n_cols;
		vector<vector<int> > ret(n, vector<int>(m, 0));
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				for (int k = 0; k < n_cols; k++)
					ret[i][j] = (ret[i][j] + mat[i][k] * 1LL * other.mat[k][j]) % MOD;
		return Matrix(ret);
	}
};

Matrix mpow(Matrix base, ll power) {
	Matrix ret = Matrix::Identity(base.n_cols);
	while (power > 0) {
		if (power & 1LL)
			ret = ret * base;
		base = base * base;
		power >>= 1;
	}
	return ret;
}

int main() {
    int t, a, b, c, d;
    ll n;
    
    scanf("%d", &t);
    
    while (t--) {
    	scanf("%lld %d %d %d %d", &n, &a, &b, &c, &d);
    	
    	Matrix mul(1 << 4, 1 << 4);
    	
    	for (int mask = 0; mask < (1 << 4); mask++) {
    		mul.mat[mask][mask] = 6;
    		for (int i = 0; i < 4; i++)
    			mul.mat[mask][mask ^ (1 << i)] = 1;
    	}
    	
    	Matrix base(1, 1 << 4);
    	
    	base.mat[0][0] = 1;
    	
    	Matrix ans = base * mpow(mul, n);
    	
    	int pos = 0;
    	if (a) pos |= (1 << 0);
    	if (b) pos |= (1 << 1);
    	if (c) pos |= (1 << 2);
    	if (d) pos |= (1 << 3);
    	
    	printf("%d\n", ans.mat[0][pos]);
    }
    
    return 0;
}
