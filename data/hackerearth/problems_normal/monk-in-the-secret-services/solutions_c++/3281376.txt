#include <bits/stdc++.h>
using namespace std;
#define MAX 10005
#define INF 1e9
#define pii pair<int,int >
#define psi pair<string,int>
#define pb(x) push_back(x) 
struct comp {
    bool operator() (const pii &a, const pii &b) {
        return a.second > b.second;
    }
};
 
vector< pii > G[MAX];
int D[MAX];
int D1[MAX];
int D2[MAX];
bool F[MAX];
 
int main() {
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int starting;
		int n,m;
		scanf("%d %d",&n,&m);
    		int i,j;
    		for(i=0;i<=n;i++)
    		G[i].clear();
    		for(i=0;i<m;i++)
    		{
    			int u,v,z;
    			scanf("%d %d %d",&u,&v,&z);
    			G[u].pb(pii(v,z));
    			G[v].pb(pii(u,z));
    		}
    		int s,a,h;
    		scanf("%d %d %d",&s,&a,&h);
    		starting=s;
    		
    		
 			int u,sz,v,w;
    // initialize distance vector
    		for(i=0; i<=n; i++) 
			{	
				D[i] = INF;
			
				D2[i]=INF;
				F[i]=false;
			}
			priority_queue< pii, vector< pii >, comp > Q;
    		D[starting] = 0;
    		Q.push(pii(starting, 0));
 			
    // dijkstra
    		while(!Q.empty()) {
        		u = Q.top().first;
        		Q.pop();
        		if(F[u]) continue;
        		sz = G[u].size();
        		for(i=0; i<sz; i++) {
            		v = G[u][i].first;
            		w = G[u][i].second;
            		if(!F[v] && D[u]+w < D[v]) {
                		D[v] = D[u] + w;
                		Q.push(pii(v, D[v]));
            		}
        		}
        		
        		F[u] = 1; // done with u
        	}
    		for(i=0;i<=n;i++)
    		{
    				D1[i]=INF;	F[i]=false;
    		}
    		
			while(!Q.empty())
			Q.pop();
			starting = a;
			D1[starting]=0;
			Q.push(pii(starting, 0));
 			
    // dijkstra
    		while(!Q.empty()) {
        		u = Q.top().first;
        		Q.pop();
        		if(F[u]) continue;
        		sz = G[u].size();
        		for(i=0; i<sz; i++) {
            		v = G[u][i].first;
            		w = G[u][i].second;
            		if(!F[v] && D1[u]+w < D1[v]) {
                		D1[v] = D1[u] + w;
                		Q.push(pii(v, D1[v]));
            		}
        		}
        		
        		F[u] = 1; // done with u
        	}
        	
    		for(i=0;i<=n;i++)
    		{
    				D2[i]=INF;	F[i]=false;
    		}
    		
			while(!Q.empty())
			Q.pop();
			starting = h;
			D2[starting]=0;
			Q.push(pii(starting, 0));
 			
    // dijkstra
    		while(!Q.empty()) {
        		u = Q.top().first;
        		Q.pop();
        		if(F[u]) continue;
        		sz = G[u].size();
        		for(i=0; i<sz; i++) {
            		v = G[u][i].first;
            		w = G[u][i].second;
            		if(!F[v] && D2[u]+w < D2[v]) {
                		D2[v] = D2[u] + w;
                		Q.push(pii(v, D2[v]));
            		}
        		}
        		
        		F[u] = 1; // done with u
        	}
        	long long maxi=-1;
        	for(i=1;i<=n;i++)
        	{
        		if(i==s||i==a||i==h)
        		continue;
        		long long x=D[i]+2*D1[i]+D2[i];
        		maxi=max(x,maxi);
        	}
 			printf("%lld\n",maxi);
 		}
    //for(i=1; i<=nodes; i++) printf("Node %d, min weight = %d\n", i, D[i]);
    return 0;
} 
