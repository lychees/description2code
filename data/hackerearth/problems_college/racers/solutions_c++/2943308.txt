#include <iostream>
#include <cstdio>
#include <vector>
#include <string.h>
using namespace std;
#define MAX 2001
#define SET(x) memset(x, -1, sizeof(x))
#define CLR(x) memset(x, 0, sizeof(x))
 
int N, M, K;
vector<int>edges[MAX];
bool visited[MAX];
int Left[MAX], Right[MAX];
long long int dist[MAX][MAX];
 
bool dfs(int u)
{
    if(visited[u]) return false;
    visited[u] = true;
    int len = edges[u].size(), v;
    for(int i = 0; i < len; ++i)
    {
        v = edges[u][i];
        if(Right[v] == -1)
        {
           Right[v] = u, Left[u] = v;
           return true;
        }
    }
    for(int i = 0; i < len; ++i)
    {
        v = edges[u][i];
        if(dfs(Right[v]))
        {
           Right[v] = u, Left[u] = v;
           return true;
        }
    }
    return false;    
 
}
 
int match()
{
    SET(Left);
    SET(Right);
    int i, ret = 0;
 
    bool done;
    do 
    {
        done = true;
        CLR(visited);
        for(int i = 1; i <= N; ++i)
        {
            if(Left[i] == -1 && dfs(i))
            {
               done = false;
            }
 
        }
    } while(!done);
 
    for(int i = 1; i <= N; ++i)
        ret += (Left[i]!= -1);
    return ret;
}
 
bool check(long long int val)
{
    for(int i = 1; i <= N; ++i)
    {
        for(int j = 1; j <= M; ++j)
        {
             if(dist[i][j] <= val)
             {
                  edges[i].push_back(j);
             }
        }
    }
    long long int num_match = match();
 
    for(int i = 1; i <= N; ++i)
    {
          edges[i].clear();
     }
 
    if(num_match >= K)
       return true;
    else
       return false;
}
 
 
int main() {
    cin >> N >> M >> K;
  //cout << N << M << K << endl;
    int a, b;
    pair<long long int, long long int> P[N + 1];
    pair<long long int, long long int> Q[M + 1];
 
    for(int i = 1; i <= N; ++i)
        cin >> P[i].first >> P[i].second;
 
    for(int i = 1; i <= M; ++i)
        cin >> Q[i].first >> Q[i].second;
 
 
    for(int i = 1; i <= N; ++i)
    {
         for(int j = 1; j <= M; ++j)
         {
              dist[i][j] = (P[i].first - Q[j].first) * 
                           (P[i].first - Q[j].first) +
                           (P[i].second - Q[j].second) *
                           (P[i].second - Q[j].second);
 
 
         }
    }
 
    long long int low = 0;
    long long int high = 10000000000000000;
    while(low < high)
    {
         long long int mid = (low + high)/2;
 
         if(check(mid))
         {
             high = mid;
         }
         else
         {
             low = mid + 1;
         }
    }
    cout << low << endl;
	return 0;
}
