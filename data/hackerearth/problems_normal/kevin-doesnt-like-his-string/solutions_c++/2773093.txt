

    #include <bits/stdc++.h>
    // iostream is too mainstream
    #include <cstdio>
    // bitch please
    #include <iostream>
    #include <algorithm>
    #include <cstdlib>
    #include <vector>
    #include <set>
    #include <map>
    #include <queue>
    #include <stack>
    #include <list>
    #include <cmath>
    #include <iomanip>
    #include <time.h>
    #define dibs reserve
    #define OVER9000 1234567890
    #define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)
    #define tisic 47
    #define soclose 1e-8
    #define chocolate win
    // so much chocolate
    #define patkan 9
    #define ff first
    #define ss second
    #define abs(x) ((x < 0)?-(x):x)
    #define uint unsigned int
    #define dbl long double
    #define pi 3.14159265358979323846
    using namespace std;
    // mylittledoge
    #ifdef DONLINE_JUDGE
    	// palindromic tree is better than splay tree!
    	#define lld I64d
    #endif
    int main() {
    	cin.sync_with_stdio(0);
    	cin.tie(0);
    	cout << fixed << setprecision(10);
    	int N,K;
    	char ch[200000];
    	scanf(" %d %d %s",&N,&K,ch);
    	string S =(string)ch;
    	vector<bool> hole(N,false);
    	multiset<char> X;
    	map<char,set<int> > right;
    	for(int i =0; i < N; i++) right[S[i]].insert(i);
    	for(int i =0; i < N; i++) {
    //		cout << i << " " << K << endl;
    		auto it =right.find(S[i]);
    		if(it != end(right)) {
    			(it->ss).erase(i);
    			if((it->ss).empty()) right.erase(it);}
    		char minch =(hole[i])?*begin(X):S[i];
    		if(!X.empty() && (K > 0 || hole[i])) minch =min(minch,*begin(X));
    		if(!right.empty() && K > 0 && (K > 1 || hole[i])) minch =min(minch,begin(right)->ff);
    		if(!hole[i] && S[i] == minch) continue;
    		if(!X.empty() && minch == *begin(X)) {
    			X.erase(begin(X));
    			if(!hole[i]) {
    				K--;
    				X.insert(S[i]);}
    			S[i] =minch;
    			continue;}
    		K--;
    		it =begin(right);
    		int x =*((it->ss).rbegin());
    		(it->ss).erase(--end(it->ss));
    		if((it->ss).empty()) right.erase(it);
    		if(!hole[i]) {
    			K--;
    			X.insert(S[i]);}
    		S[i] =minch;
    		hole[x] =true;}
    	printf("%s\n",S.c_str());
    	return 0;}
    // look at my code
    // my code is amazing

