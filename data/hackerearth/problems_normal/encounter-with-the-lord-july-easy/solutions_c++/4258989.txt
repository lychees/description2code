//its not how good you are...its how good you want to be
#include <iostream>
#include<bits/stdc++.h>
using namespace std;
#define ll   long long   int
#define inf 1000000000000
#define mod 1000000007
#define pb push_back
#define mp make_pair
#define all(v) v.begin(),v.end()
#define S second
#define F first
#define boost1 ios::sync_with_stdio(false);
#define boost2 cin.tie(0);
#define mem(a,val) memset(a,val,sizeof a)
#define ld  long double
#define endl "\n"

typedef vector<int> VI;
typedef vector<VI> VVI;
typedef int L;
typedef vector<L> VL;
typedef vector<VL> VVL;
typedef pair<int, int> PII;
typedef vector<PII> VPII;

const L INF = numeric_limits<L>::max() / 4;

struct MinCostMaxFlow {
  int N;
  VVL cap, flow, cost;
  VI found;
  VL dist, pi, width;
  VPII dad;

  MinCostMaxFlow(int N) :
    N(N), cap(N, VL(N)), flow(N, VL(N)), cost(N, VL(N)),
    found(N), dist(N), pi(N), width(N), dad(N) {}

  void AddEdge(int from, int to, L cap, L cost) {
    this->cap[from][to] = cap;
    this->cost[from][to] = cost;
  }

  void Relax(int s, int k, L cap, L cost, int dir) {
    L val = dist[s] + pi[s] - pi[k] + cost;
    if (cap && val < dist[k]) {
      dist[k] = val;
      dad[k] = make_pair(s, dir);
      width[k] = min(cap, width[s]);
    }
  }

  L Dijkstra(int s, int t) {
    fill(found.begin(), found.end(), false);
    fill(dist.begin(), dist.end(), INF);
    fill(width.begin(), width.end(), 0);
    dist[s] = 0;
    width[s] = INF;

    while (s != -1) {
      int best = -1;
      found[s] = true;
      for (int k = 0; k < N; k++) {
        if (found[k]) continue;
        Relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);
        Relax(s, k, flow[k][s], -cost[k][s], -1);
        if (best == -1 || dist[k] < dist[best]) best = k;
      }
      s = best;
    }

    for (int k = 0; k < N; k++)
      pi[k] = min(pi[k] + dist[k], INF);
    return width[t];
  }

  pair<L, L> GetMaxFlow(int s, int t) {
    L totflow = 0, totcost = 0;
    while (L amt = Dijkstra(s, t)) {
      totflow += amt;
      for (int x = t; x != s; x = dad[x].first) {
        if (dad[x].second == 1) {
          flow[dad[x].first][x] += amt;
          totcost += amt * cost[dad[x].first][x];
        } else {
          flow[x][dad[x].first] -= amt;
          totcost -= amt * cost[x][dad[x].first];
        }
      }
    }
    return make_pair(totflow, totcost);
  }
};

ll dist[205][205];
int main()
{
	boost1;boost2;
	ll i,j,n,m,k,t,x,y,z,ans,l;
	cin>>t;
	while(t--)
	{
		ans=inf;
		cin>>n>>m>>k;
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				dist[i][j]=inf;
				if(i==j)
				dist[i][j]=0;
			}
		}
		for(i=1;i<=m;i++)
		{
			cin>>x>>y>>z;
			dist[x][y]=min(dist[x][y],z);
			dist[y][x]=min(dist[y][x],z);
		}
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				if(i==j)
				continue;
				dist[i][j]=min(dist[i][j],10000LL);
				dist[j][i]=min(dist[j][i],10000LL);
			}
		}
		for(l=1;l<=n;l++)
		{
			for(i=1;i<=n;i++)
			{
				for(j=1;j<=n;j++)
				dist[i][j]=min(dist[i][l]+dist[l][j],dist[i][j]);
			}
		}
		MinCostMaxFlow network(2*k+2);
		for(i=1;i<=k;i++)
		network.AddEdge(0,i,1,0);
		for(i=k+1;i<=2*k;i++)
		network.AddEdge(i,2*k+1,1,0);
		for(i=1;i<=k;i++)
		{
			for(j=k+1;j<=2*k;j++)
			{
				network.AddEdge(i,j,1,dist[i][j+n-2*k]);
			}
		}
		pair<ll,ll> p=network.GetMaxFlow(0,2*k+1);
		if(p.F==k)
		ans=p.S;
		cout<<ans<<endl;
	}
	return 0;
}