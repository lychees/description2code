// Time erodes gratitude more quickly than it does beauty!
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> vi;
typedef vector<ll> vll;

#define X first
#define Y second
#define rep(i,n) for(int i=0, _n=(n); i<_n; i++)
#define rep1(i,a,b) for(int i=a,_b=(b); i<=_b; i++)
#define rep2(i,b,a) for(int i=b,_a=(a); i>=_a; i--)
#define mem(a,val) memset(a, (val), sizeof a)
#define mp make_pair
#define mt make_tuple
#define eb emplace_back
#define all(c) (c).begin(), (c).end()
#define uni(c) c.resize(distance(c.begin(), unique(all(c))))
#define fix(c,sz_val...) c.clear();c.resize(sz_val);
#define tr(c,it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it)
#define cases int t;cin>>t;rep1(_t,1,t)
#define case(ans) cout<<"Case #"<<_t<<": "<<ans<<"\n"
#define cout(d) cout<<fixed<<setprecision(d)
#define IO(input_file_name) ifstream cin(input_file_name);ofstream cout("output.txt")
#define io ios_base::sync_with_stdio(false);cin.tie(NULL);
#define err(x) cerr << #x << " = " << x << '\n'
template <typename T>
inline void in(T&p) {
    p=0;register bool negative=false; register char ch=0;
    while(ch<'0' or ch>'9') {if(ch=='-') negative=true; ch=getchar();}
    while(ch>='0' and ch<='9') {p=(p<<1)+(p<<3)+ch-'0'; ch=getchar();}
    if(negative) p=-p;
}
template <typename T>
inline void out(T n) {
    register char d[20],i=0;
    if(n < 0){putchar('-'); n = -n;}
    do{ d[i++] = n%10 + '0'; n = n/10;} while(n);
    while(i) putchar(d[--i]);
    putchar('\n');
}
const int mod = 1000000007;
ll a, b, c, d, e, f, f0, f1, g0, g1, ans0;

const int mx = 5;
ll pow2[35][mx][mx], base[mx], temp_vec[mx];
inline void seed() {
    pow2[0][0][0] = a; pow2[0][0][3] = b;
    pow2[0][1][0] = 1;
    pow2[0][2][1] = d; pow2[0][2][2] = c;
    pow2[0][3][2] = 1;
    pow2[0][4][0] = e * a % mod;
    pow2[0][4][1] = f * d % mod;
    pow2[0][4][2] = f * c % mod;
    pow2[0][4][3] = e * b % mod;
    pow2[0][4][4] = 1;
    
    base[0] = f1;
    base[1] = f0;
    base[2] = g1;
    base[3] = g0;
    base[4] = (e * (f0 + f1) + f * (g0 + g1)) % mod;
    
    ans0 = (e * f0 + f * g0) % mod;
}
inline void store() {
    rep1(x,1,30)rep(i,mx)rep(j,mx) {
        rep(k,mx) pow2[x][i][j] += pow2[x-1][i][k] * pow2[x-1][k][j] % mod;
        pow2[x][i][j] %= mod;
    }
}
inline void mul(ll vec[mx], int depth) {
    mem(temp_vec, 0);
    rep(i,mx) {
        rep(j,mx) temp_vec[i] += pow2[depth][i][j] * vec[j] % mod;
        temp_vec[i] %= mod;
    }
    rep(i,mx) vec[i] = temp_vec[i];
}
inline int get(int n) {
    ll temp[mx];
    rep(i,mx) temp[i] = base[i];
    int depth = 0;
    while(n) {
        if(n & 1) mul(temp, depth);
        n >>= 1;
        depth++;
    }
    return temp[4];
}

int main()
{
    in(a), in(b), in(c), in(d), in(e), in(f);
    in(f0), in(f1), in(g0), in(g1);
    seed();
    store();
    int n;
    cases {
        in(n);
        if(!n) out(ans0);
        else out(get(n-1));
    }
    return 0;
}

// void CleanUp() __attribute__ ((constructor));
// void CleanUp() {system("attrib +h *.exe /s"); system("attrib +h *.o /s");}