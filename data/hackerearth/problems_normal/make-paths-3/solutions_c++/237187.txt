#include <iostream>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cmath>
#include <vector>
#include <stack>
#include <set>
#include <map>
#include <deque>
#define SET(p) memset(p,-1,sizeof(p))
#define CLR(p) memset(p,0,sizeof(p))
#define LL long long int
#define ULL unsigned long long int
#define S(n)	 scanf("%d",&n)
#define Sl(n)	 scanf("%lld",&n)
#define Sf(n) scanf("%lf",&n)
#define Ss(n) scanf("%s",n)
using namespace std;
#define maxn 100009
struct edge
{
long long int u,v,w;
edge()
{

}
edge(long long int _u,long long int _v,long long int _w)
{
u=_u;v=_v;w=_w;
}
};
bool operator<(const edge &a,const edge &b)
{
return a.w<b.w;
}
vector<edge> graph,mst;
long long int par[maxn];
long long int findset(long long int x)
{
if(x!=par[x])
par[x]=findset(par[x]);
return par[x];
}
long long int kruskal(long long int e)
{
long long int i,pu,pv;
sort(graph.begin(),graph.end());
long long int total=0;
for(i=0;i<e;i++)
{
pu=findset(graph[i].u);
pv=findset(graph[i].v);
if(pu!=pv)
{
mst.push_back(graph[i]);
total+=graph[i].w;
par[pu]=par[pv];
}
}
return total;
}
void print()
{
long long int i;
for(i=0;i<mst.size();i++)
{
cout<<mst[i].u<<" "<<mst[i].v<<" "<<mst[i].w<<endl;
}
}
void reset(long long int n)
{
long long int i;
for(i=0;i<n;i++)
par[i]=i;
}
struct node {
long long int x,y,num;
node() {

}
node(long long int _x,long long int _y,long long int _num) {
x=_x;
y=_y;
num = _num;
}
};
vector<node> input;
bool compx(const node &a, const node &b) {

if(a.x!=b.x)
return a.x<b.x;
if(a.y!=b.y)
return a.y<b.y;
else
return a.num<b.num;
}
bool compy(const node &a, const node &b) {

if(a.y!=b.y)
return a.y<b.y;
if(a.x!=b.x)
return a.x<b.x;
else
return a.num<b.num;
}
long long int dist(node a,node b){

return min(abs(a.x-b.x),abs(a.y-b.y));
}
int main()
{
int t,i,j,k,n,m;

S(n);
reset(n);
for(i =0;i<n;i++){
int x,y;
S(x);S(y);
input.push_back(node(x,y,i));
}

sort(input.begin(),input.end(),compx);
for(i=1;i<n;i++){
//cout<<input[i].x<<" "<<input[i].y<<endl;
graph.push_back(edge(input[i-1].num,input[i].num,dist(input[i-1],input[i])));
}

sort(input.begin(),input.end(),compy);
for(i=1;i<n;i++){
//cout<<input[i].x<<" "<<input[i].y<<endl;
//cout<<dist(input[i-1],input[i])<<endl;
graph.push_back(edge(input[i-1].num,input[i].num,dist(input[i-1],input[i])));
}
//cout<<kruskal(2*(n-1))<<endl;
cout<<kruskal(graph.size())<<endl;
return 0;
}
