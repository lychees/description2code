#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
#define S(x) scanf("%d",&x)
#define P(x) printf("%d\n",x)

typedef vector<int> VI;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef long long LL;
#define gc getchar_unlocked
inline void fs(int &x) {
    register int c = gc();
    x = 0;
    int neg = 0;

    for(; ((c<48 || c>57) && c != '-'); c = gc());

    if(c=='-') {
    	neg = 1;
    	c = gc();
    }

    for(; c>47 && c<58 ; c = gc()) {
    	x = (x<<1) + (x<<3) + c - 48;
    }

    if(neg)
    	x = -x;
}
const int MAXN = 200010;
int a[MAXN], tree[4*MAXN], tree2[4*MAXN];

// --------------------------segTree-------------------------------------------------//
void initMaxTree(int node, int ss, int se) {
    if(ss > se) return ;

    if(ss == se) {
        tree[node] = a[ss];
        tree2[node] = a[ss];
        return;
    }

    int mid = (ss + se) >> 1, lc = (node << 1), rc = (node << 1) + 1;
    initMaxTree(lc, ss, mid);
    initMaxTree(rc, mid+1, se);

    tree[node] = tree[lc] > tree[rc] ? tree[lc] : tree[rc];
    tree2[node] = tree2[lc] < tree2[rc] ? tree2[lc] : tree2[rc];
}

void updateMAxTree(int node, int ss, int se, int qi, int val) {
    int mid = (ss + se) >> 1, lc = (node << 1), rc = (node << 1) + 1;

    if(ss > se || ss > qi || se < qi)
        return;

    if(ss == se && ss == qi) {
        tree[node] = val;
        tree2[node] = val;
        return;
    }

    updateMAxTree(lc, ss, mid, qi, val);  // update left child
    updateMAxTree(rc, mid+1, se, qi, val);  // update right child

    tree[node] = tree[lc] > tree[rc] ? tree[lc] : tree[rc];
    tree2[node] = tree2[lc] < tree2[rc] ? tree2[lc] : tree2[rc];
}

void query(int node, int ss, int se, int qs, int qe, int *minn, int *maxx) {
    if(ss > se || ss > qe || se < qs) {
        *minn = INT_MAX;
        *maxx = -1;
        return;
    }

    int mid = (ss + se) >> 1, lc = (node << 1), rc = (node << 1) + 1;

    if(ss >= qs && se <= qe) { // segment fully within
        *maxx = tree[node];
        *minn = tree2[node];
        return;
    }

    int lmn,lmx,rmn,rmx;
    query(lc, ss, mid, qs, qe, &lmn, &lmx);
    query(rc, mid+1, se, qs, qe, &rmn, &rmx);
    *minn = (lmn < rmn ? lmn : rmn);
    *maxx = (lmx > rmx ? lmx : rmx);
}
// ---------------------------------------------------------------------------------------//

int main()
{
    #ifndef ONLINE_JUDGE
        freopen("in.txt","r",stdin);
    #endif

    int n,q;
    fs(n); fs(q);

    rep(i,1,n+1) fs(a[i]);

    initMaxTree(1,1,n);

    rep(Q,1,q+1){
        char c;
        int x,y;
        scanf("\n%c",&c); fs(x); fs(y);
        if(c=='U') {
            updateMAxTree(1,1,n,x,y);
            a[x] = y;
        }
        else {
            int l=x,r=n,mid,mn,mx,gmn=a[x]-y,gmx=a[x]+y,tmx,tmn,f=0,pos,minn,maxx;
            while(1) {
                if(l>r) break;
                if(l==r) {
                    query(1,1,n,x,l,&mn,&mx);
                    if(mn>=gmn && mx<=gmx) f=1,pos=l,minn=mn,maxx=mx;
                    break;
                }
                if(l==r-1) {
                    query(1,1,n,x,l,&mn,&mx);
                    //tmx = findMax(1,1,n,x,r);
                    //tmn = findMin(1,1,n,x,r);
                    tmx = max(mx,a[r]);
                    tmn = min(mn,a[r]);
                    //printf("test:%d l=%d r=%d lmx=%d lmn=%d rmx=%d rmn=%d\n",Q,l,r,mx,mn,tmx,tmn);
                    if(tmn>=gmn && tmx<=gmx) f=1,pos=r,minn=tmn,maxx=tmx;
                    else if(mn>=gmn && mx<=gmx) f=1,pos=l,minn=mn,maxx=mx;
                    break;
                }

                mid = (l+r)>>1;
                query(1,1,n,x,mid,&mn,&mx);
                if(mn>=gmn && mx<=gmx) l = mid;
                else r = mid-1;
            }
            if(f) {
                //cout<<minn<<" "<<maxx<<"--";
                printf("%d %d\n",pos-x+1,max(abs(a[x]-minn),abs(a[x]-maxx)));
            }
            else printf("-1 -1\n");
        }
    }
    return 0;
}
