#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pii pair<int,int>
#define pil pair<int,long long>
#define pli pair<long long,int>
#define pll pair<long long,long long>
#define pb push_back
#define mk make_pair
#define sd(x) scanf("%d", &x)
#define pd(x) printf("%d\n",x)
#define pdl(x) printf("%lld\n",x)
#define sdl(x) scanf("%lld", &x)
#define eps 1e-12
using namespace std;
struct pree
{
	ll l,r,h;
};
inline bool compare(pree uu,pree vv)
{
	if(uu.l==vv.l)
	{
		return uu.r<vv.r;
	}
	return uu.l<vv.l;
}
struct Point
{
    ll x;
    ll y;
};
bool onSegment(Point p, Point q, Point r)
{
    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) && q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))
       return true;
 
    return false;
}
int orientation(Point p, Point q, Point r)
{
    ll val = (q.y - p.y) * (r.x - q.x) -
              (q.x - p.x) * (r.y - q.y);
 
    if (val == 0) return 0;
 
    return (val > 0)? 1: 2;
}
bool doIntersect(Point p1, Point q1, Point p2, Point q2)
{
    ll o1 = orientation(p1, q1, p2);
    ll o2 = orientation(p1, q1, q2);
    ll o3 = orientation(p2, q2, p1);
    ll o4 = orientation(p2, q2, q1);
    if (o1 != o2 && o3 != o4)
        return true;
    if (o1 == 0 && onSegment(p1, p2, q1)) return true;
    if (o2 == 0 && onSegment(p1, q2, q1)) return true;
    if (o3 == 0 && onSegment(p2, p1, q2)) return true;
    if (o4 == 0 && onSegment(p2, q1, q2)) return true;
 	return false;
}
int main()
{
	int t;
	sd(t);
	while(t--)
	{
		int n;
		sd(n);
		pree a[n];
		bool lvisible[n+2],rvisisible[n+2];
		int lfvisible[n+2],rfvisible[n+2];
		memset(lvisible,false,sizeof(lvisible));
		memset(rvisisible,false,sizeof(rvisisible));
		memset(lfvisible,0,sizeof(lfvisible));
		memset(rfvisible,0,sizeof(rfvisible));
		for(int i=0;i<n;i++)
		{
			sdl(a[i].l);
			sdl(a[i].r);
			sdl(a[i].h);
		}
		sort(a,a+n,compare);
		for(int i=1;i<n;i++)
		{
			int last_index=i-1;
			for(int j=i-2;j>=0;j--)
			{
				Point p1,p2,p3,p4;
				p1.x=a[j].r;
				p1.y=a[j].h;
				p2.x=a[i].l;
				p2.y=0;
				p3.x=a[last_index].r;
				p3.y=0;
				p4.x=a[last_index].r;
				p4.y=a[last_index].h;
				if(doIntersect(p1,p2,p3,p4))
				{
					ll x1=p2.x-p1.x;
					ll y1=p2.y-p1.y;
					ll z=__gcd(x1,y1);
					x1=x1/z;
					y1=y1/z;
					ll x2=p2.x-p4.x;
					ll y2=p2.y-p4.y;
					z=__gcd(x2,y2);
					x2=x2/z;
					y2=y2/z;
					if(pll(x2,y2)==pll(x1,y1))
					{
						last_index=j;
					}
				}
				else
				{
					last_index=j;
				}
			}
			if(last_index!=i-1)
			{
				lvisible[i]=true;
				lfvisible[last_index]=1;
			}
		}
		for(int i=0;i<n-1;i++)
		{
			int last_index=i+1;
			for(int j=i+2;j<n;j++)
			{
				Point p1,p2,p3,p4;
				p1.x=a[j].l;
				p1.y=a[j].h;
				p2.x=a[i].r;
				p2.y=0;
				p3.x=a[last_index].l;
				p3.y=0;
				p4.x=a[last_index].l;
				p4.y=a[last_index].h;
				if(doIntersect(p1,p2,p3,p4))
				{
					ll x1=p2.x-p1.x;
					ll y1=p2.y-p1.y;
					ll z=__gcd(x1,y1);
					x1=x1/z;
					y1=y1/z;
					ll x2=p2.x-p4.x;
					ll y2=p2.y-p4.y;
					z=__gcd(x2,y2);
					x2=x2/z;
					y2=y2/z;
					if(pll(x2,y2)==pll(x1,y1))
					{
						last_index=j;
					}
				}
				else
				{
					last_index=j;
				}
			}
			if(last_index!=i+1)
			{
				rvisisible[i]=true;
				rfvisible[last_index]=1;
			}
		}
		for(int i=0;i<n-1;i++)
		{
			if(lvisible[i+1]&&rvisisible[i])
			{
				continue;
			}
			if(rfvisible[i+1]==0&&lfvisible[i]==0)
			{
				lfvisible[i]=1;
			}
		}
		int fans=0;
		for(int i=0;i<n;i++)
		{
			fans+=lfvisible[i]+rfvisible[i];
		}
		fans++;
		fans++;
		cout<<fans<<"\n";
	}
}