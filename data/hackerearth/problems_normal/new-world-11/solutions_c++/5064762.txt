#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<vector>
#include<bitset>
#include<map>
#include<queue>
#include<stack>
#include<set>
#include<cmath>
#include<algorithm>
#include<utility>
#include<climits>
#include<sstream>

using namespace std;

#define nl printf("\n")
#define space printf(" ")

#define mem(x,val) memset(x,val,sizeof(x))
#define rite(x) freopen(x,"w",stdout)
#define read(x) freopen(x,"r",stdin)

typedef long long ll;
typedef unsigned long long ull;
int step[100005];
bool possible(int maxdis,int n, int k) {// you have to reach the last stone in k steps with the longest step having the dis of maxids
    int i, p1,diff;
    bool able = true;
    for(i = 0 ; i < n; ++i) {
        if (i == n - 1) break;
        p1 = lower_bound(step+i,step+n,step[i]+maxdis)- step;

        if (p1 == n || step[p1] > step[i] + maxdis) p1 -= 1;//found step is requires you to travel more than maxdistance permitted
        if (n-1-p1 < k-1 ) diff = k-n+p1, p1 = max(i,p1-diff);
//        while(n-1-p1 < k - 1 && p1 > i) p1 -= 1; //the max possible number of remaining steps you can take after this is less the test number of steps you need to take
//        cout << p1 << " ";
        if (p1 == i) {
            able = false;//impossible to reach the final stone with the given maxdis
            break;
            }

        k -= 1;
        if (k == 0 && p1 != n-1) {
            able = false;
            break;
            }
        i = p1 - 1;
        }
//    printf("\n");
    return able;
    }
int main() {
//    read("in.txt");
//    rite("out.txt");
    int tc;
    cin >> tc;
    int n,k;
    int i,j;
    int mindis,maxdis,mid,ans;

    while(tc--) {
        cin >> n >> k;
        for(i = 0 ; i < n ; ++i) cin >> step[i];
//        cout << possible(61,n,k) << endl;
        mindis = 1,maxdis = step[n-1] - step[0],mid;
        ans = maxdis;
        //binary search
        while(mindis <= maxdis) {
            mid = (mindis+maxdis)/2;
//            printf("(%d) ",mid);
            if ( possible(mid,n,k) == true) {
                ans = min(ans,mid);
                maxdis = mid - 1;
                }
            else {
                mindis = mid + 1;
                }
            }
        cout << ans << endl;
        }
    return 0;
    }
