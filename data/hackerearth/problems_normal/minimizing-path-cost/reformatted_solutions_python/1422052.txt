inp = raw_input()
n_nodes, n_paths = map(int, inp.split())

nodes = []
nodes_inp = raw_input()
nodes = map(str, nodes_inp.split())

# creating graph
graph = {node: [0]*n_nodes for node in nodes}

# initializing
for i in range(0, n_paths):

    path_inp = raw_input().split()
    node_from = str(path_inp[0])
    node_to = str(path_inp[1])
    node_cost = int(path_inp[2])

    graph[node_from][nodes.index(node_to)] = node_cost
    graph[node_to][nodes.index(node_from)] = node_cost

# print nodes
# print graph


def dijkstra(graph, start):
    # infinite initial values
    dist = {i: 999 for i in graph.keys()}
    queue = {i for i in graph.keys()}
    prev = {i: None for i in graph.keys()}

    dist[start] = 0
    prev[start] = None

    # queue.remove(start)
    # print queue

    current = start
    while len(queue) > 0:
        # print current

        queue.remove(current)

        for i in range(0, len(nodes)):
            if graph[current][i] != 0:
                alt = dist[current] + graph[current][i]
                if alt < dist[nodes[i]]:
                    dist[nodes[i]] = alt
                    prev[nodes[i]] = current

        min = 9999
        ele = 0
        for i in queue:
            if int(dist[i]) < int(min):
                # print i, dist[i]
                min = dist[i]
                ele = i
        current = ele

    # print dist
    # print prev
    return dist


t = int(raw_input())
inps = []
for i in range(0, t):
    inps.append(map(str, raw_input().split()))

shortest_paths = {}
for test_case in inps:
    # print test_case
    if shortest_paths.has_key(test_case[0]):
        print shortest_paths[test_case[0]][test_case[1]]
    else:
        d = dijkstra(graph, test_case[0])
        shortest_paths[test_case[0]] = d
        print shortest_paths[test_case[0]][test_case[1]]


# print shortest_paths
