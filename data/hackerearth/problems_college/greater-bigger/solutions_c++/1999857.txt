/*
Given a word w, rearrange the letters of w to construct another word s in such a way that s is lexicographic-ally greater than w. In case of multiple possible answers, find the lexicographic-ally smallest one.

Input Format

The first line of input contains t, the number of test cases. Each of the next t lines contains w.

Output Format

For each testcase, output a string lexicographically bigger than w in a separate line. In case of multiple possible answers, print the lexicographically smallest one, and if no answer exists, print no answer.

Constraints

1?t?105

1?|w|?100

w will contain only lower-case English letters and its length will not exceed 100.
Sample Input
(Plaintext Link)

5
ab
bb
hefg
dhck
dkhc

Sample Output
(Plaintext Link)

ba
no answer
hegf
dhkc
hcdk
*/
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<vector>
#include<list>
#include<map>
#include<algorithm>
#include<math.h>
#include<limits.h>
#include<stack>
#include<queue>
#include<set>
#define ll long long
using namespace std;
int main()
{
	int test;
	scanf("%d",&test);
	while(test--)
	{
		char str[110];
		scanf("%s",str);
		int i,j,l,p;
		char t;
		l=strlen(str);
		int flag=0;
		for(i=(l-1);i>=0;i--)
		{
			t='z';
			for(j=(i+1);j<l;j++)
			{
				if(str[j]>str[i] && str[j]<=t)
				{
					flag=1;  //Lexigographically bigger string possible
					t=str[j];
					p=j;
				}
			}
			if(flag)
			{
				str[p]=str[i];
				str[i]=t;
				sort(str+i+1,str+l);
				break;
			}
		}
		if(flag)
		{
			printf("%s\n",str);
		}
		else
		{
			printf("no answer\n");
		}
	}
	return 0;
}
