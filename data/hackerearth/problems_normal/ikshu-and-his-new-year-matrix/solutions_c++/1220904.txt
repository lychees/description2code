///ROHIT PATIYAL///

#include <iostream>
#include <cstdio>	//for printf and scanf (faster io)
#include <cmath> 	//for logl2() and pow etc math functions
#include <algorithm>	//for sort and other algorithms
#include <vector> 	//for vectors(resizable arrays)
					
using namespace std;

#define lli long long int
#define ull unsigned long long	//(0 - 18446744073709551615) ie (0 - 10x10^19) 	int - 0 to 4294967295 ie (0 - 10^9)

#define rep(i,b) for(i=0;i<b;i++)
#define repe(i,b) for(i=0;i<=b;i++)
#define repab(i,a,b) for(i=a;i<b;i++)
#define repabe(i,a,b) for(i=a;i<=b;i++)

#define printArray(a,size) for(lli i=0;i<size;i++){cout<<a[i]<<endl;};

vector<lli> Primes;


void seiveOfEras(lli uplimit){
	if(uplimit>=2){
		
		lli i;
		bool isPrime[uplimit];
		rep(i, uplimit){
			isPrime[i] = true;	
		}
		isPrime[0] = isPrime[1] = false;
		lli k = 0;
		for(int i=2; i<uplimit;i++){
			if(isPrime[i] == true){
				Primes.push_back(i);
				k++;
			
				//Marking the multiples	
				lli j=2;
				while((i*j)<=uplimit){
					isPrime[i*j] = false;
					j++;
				}

			}
		}
	}
}

lli binarySearchCeilIndex(vector<lli> array, lli size, lli n){
	lli index = size-1;
	lli i = 0;
	lli j = size;
	lli mid;
	while(i<=j){
		mid = (i+j)/2;
		if(array[mid] < n){
			i = mid +1;
		}else if(array[mid] == n){
			return mid;
		}else{
			j = mid -1;
		}
	}
	if(i<size)
		index = i;
	return index;
}
lli matrix[1001][1001];
lli marked[1001][1001];


//max stack size allowed is 10^8
int main(){
	//max stack size allowed is 10^6

	lli i, j, k, n, K, N;
	cin>>N>>K;
	
	lli largest = 0;
	rep(i,N){
		rep(j, N){
			cin>>matrix[i][j];
			marked[i][j] = -1;
			if(matrix[i][j]>largest){
				largest = matrix[i][j];
			}
		}
	}
	
	seiveOfEras(2*largest);
	lli numprimes = Primes.size();
	//printArray(Primes, numprimes);
	//lli upperprimeid = binarySearchCeilIndex(Primes, numprimes, 210);
	//cout<<"--------------"<<upperprimeid<<endl;
	bool opossible = false;
	lli osum = 999999999999;
	lli centeri= -1;
	lli centerj = -1;
	repabe(i,1, N-2){
		repabe(j,1, N-2){

			bool possible = true;
			lli sum = 0;
			//check neighbours and itself
			lli upperprimeid ;
			if(marked[i][j] == -1){
				upperprimeid = binarySearchCeilIndex(Primes, numprimes, matrix[i][j]);
				marked[i][j] = Primes[upperprimeid] - matrix[i][j];
			
			}
		//	cout<<marked[i][j]<<endl;
			if(marked[i][j]%K != 0){
					possible = false;
			}				
		

			if(marked[i-1][j-1] == -1){
				upperprimeid = binarySearchCeilIndex(Primes, numprimes, matrix[i-1][j-1]);
				marked[i-1][j-1] = Primes[upperprimeid] - matrix[i-1][j-1];
				//cout<<marked[i-1][j-1]<<endl;
			}
			if(marked[i-1][j-1]%K != 0){
				possible = false;
			}
			if(marked[i-1][j+1] == -1){
				upperprimeid = binarySearchCeilIndex(Primes, numprimes, matrix[i-1][j+1]);
				marked[i-1][j+1] = Primes[upperprimeid] - matrix[i-1][j+1];
				//	cout<<marked[i-1][j+1]<<endl;
			}
			if(marked[i-1][j+1]%K != 0){
				possible = false;
			}

			if(marked[i+1][j-1] == -1){
				upperprimeid = binarySearchCeilIndex(Primes, numprimes, matrix[i+1][j-1]);
				marked[i+1][j-1] = Primes[upperprimeid] - matrix[i+1][j-1];
				//	cout<<marked[i+1][j-1]<<endl;
			}
			if(marked[i+1][j-1]%K != 0){
				possible = false;
			}

			if(marked[i+1][j+1] == -1){
				upperprimeid = binarySearchCeilIndex(Primes, numprimes, matrix[i+1][j+1]);
				marked[i+1][j+1] = Primes[upperprimeid] - matrix[i+1][j+1];
			//		cout<<marked[i+1][j+1]<<endl;
			}
			// if(matrix[i][j] == 37)
			// 	cout<<possible<<endl;
			 if(marked[i+1][j+1]%K != 0){
				possible = false;
			}
			
			if(possible == true){
				opossible = true;
				sum = marked[i][j]/K + marked[i-1][j-1]/K + marked[i-1][j+1]/K + marked[i+1][j-1]/K + marked[i+1][j+1]/K; 	//				cout<<sum<<endl;
			//	cout<<"[ "<<i+1<<" , "<<j+1<<" ] ("<<matrix[i][j]<<") = "<<sum<<endl;
				if(sum < osum){
					osum = sum;
					centeri = i+1;
					centerj = j+1;
				}
			}
		}
	}
	if(opossible == true){
		cout<<"yes"<<endl<<osum<<endl<<centeri<<" "<<centerj<<endl;
	}
	else{
		cout<<"no"<<endl;
	}
	return 0;
} 
