"""
This is O(1) solution for each test case
If one can't figure that its a Tribonacci Series,
then he will use bruteforce over ((n-2)^2)/12 possibilities
which shall get him AC in one or two Test Files.

Note that I've used Dynamic-Programming Tag for O(1) solution and
Multiplicative-Inverse Tag for O(n^2) solution

This question is inspired from integer partition problem, where each partition can only be 1, 2 or 3
For each possible partition we find number of permutations and sum them up.
Initially I actually restricted each partition to be just 1 or 2, which when used brute force relvealed that its Fibonacci Series
So to make things tough, I introduced 3 also and hence Tribonacci series
"""

MOD = 1000000007
trib = []


def calc_trib():
    trib.append(0)
    trib.append(1)
    trib.append(2)
    trib.append(4)
    for i in xrange(4, 100010):
        temp = (trib[i-1] + trib[i-2] + trib[i-3]) % MOD
        trib.append(temp)


def roy_and_mario():
    calc_trib()  # we figured that it is nothing but a tribonacci series, so we precalculate
    for t in xrange(input()):
        n = input()
        print trib[n]


roy_and_mario()
