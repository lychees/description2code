#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#define MAXN 100005

using namespace std;

struct cvor
{
    int prefiks;
    int sufiks;
    int najbolji;
    int indeks_pocetka,indeks_kraja;
};

vector<cvor> tree(4*MAXN);
vector<long long> unos(MAXN);
int n,q;

void spoji(cvor *roditelj,cvor *lijevo,cvor *desno)
{
    bool nastavlja = false;
    if(unos[lijevo->indeks_kraja] < unos[desno->indeks_pocetka]) nastavlja = true;

    roditelj->najbolji = max(lijevo->najbolji,desno->najbolji);
    if(nastavlja) roditelj->najbolji = max(roditelj->najbolji,lijevo->sufiks+desno->prefiks);

    roditelj->prefiks = lijevo->prefiks;
    if(lijevo->prefiks == (lijevo->indeks_kraja - lijevo->indeks_pocetka + 1) and nastavlja)
        roditelj->prefiks = max(roditelj->prefiks, lijevo->prefiks + desno->prefiks);

    roditelj->sufiks = desno->sufiks;
    if(desno->sufiks == (desno->indeks_kraja - desno->indeks_pocetka + 1) and nastavlja)
        roditelj->sufiks = max(roditelj->sufiks, lijevo->sufiks + desno->sufiks);

    roditelj->indeks_pocetka = lijevo->indeks_pocetka;
    roditelj->indeks_kraja = desno->indeks_kraja;
}

void build(int node,int a,int b)
{
    int mid = (a+b)/2;
    if(a==b)//ako je leaf
    {
        tree[node].prefiks = tree[node].sufiks = tree[node].najbolji = 1;
        tree[node].indeks_pocetka = tree[node].indeks_kraja = a;
        return ;
    }
    build(node*2,a,mid);
    build(node*2+1,mid+1,b);

    spoji(&tree[node],&tree[node*2],&tree[node*2+1]);
}

void update(int node,int a,int b,int pozicija,int value)
{
    int mid = (a+b)/2;

    if(a==b)
    {
        unos[a]+=value; //isto je unos[b]+=value;
        return ;
    }
    if(pozicija>mid)
        update(node*2+1,mid+1,b,pozicija,value);
    else
        update(node*2,a,mid,pozicija,value);

    spoji(&tree[node],&tree[node*2],&tree[node*2+1]);
}

cvor query(int node,int a,int b,int l,int r)
{
    int mid = (a+b)/2;
    bool prvi = false, drugi = false;
    cvor lijevo,desno,res;
    if(a>=l and b<=r) return tree[node];
    if(l<=mid)//ako ima potrebe da ide lijevo
    {
        lijevo = query(node*2,a,mid,l,r);
        prvi = true;
    }
    if(r>=mid+1)//ako ima potrebe da ide desno
    {
        desno = query(node*2+1,mid+1,b,l,r);
        drugi = true;
    }

    if(prvi and drugi)
    {
        spoji(&res,&lijevo,&desno);
        return res;
    }
    if(prvi) return lijevo;
    if(drugi) return desno;
}

int main()
{
    int t; cin >> t;
    while(t--)
    {
        cin >> n >> q;
        for(int i=0;i<n;i++)
            scanf("%lld",&unos[i]);
        build(1,0,n-1); //cvor i interval za koji je jedan cvor zaduzen
        for(int i=0;i<q;i++)
        {
            int t,a,b;
            scanf("%d%d%d",&t,&a,&b);
            if(t==1)//update
                update(1,0,n-1,a-1,b);
            else
                printf("%lld\n",query(1,0,n-1,a-1,b-1).najbolji);
        }
    }
    return 0;
}
