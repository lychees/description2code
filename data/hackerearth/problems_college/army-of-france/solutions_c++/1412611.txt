#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>
#include <climits>
#include <ctime>
#include <cassert>
#include <cctype>
#include <algorithm>
#include <numeric>
#include <map>
#include <set>
#include <queue>
#include <string>
#include <vector>
#include <bitset>

#define X first
#define Y second
#define pb push_back
#define bit(x) (1 << (x))
#define bnum(x) (__builtin_popcount(x))
#define sqr(x) ((x) * (x))
#define sz(x) ((int)(x.size()))
#define PQ priority_queue

#if _WIN32 || __WIN32__
#define LLD "%I64d"
#else
#define LLD "%lld"
#endif

using namespace std;
typedef long long LL;
typedef pair<int, int> pii;
typedef vector<int> vi;
template <class T> inline void chkmin(T &a, T b) {
	if (b < a) a = b;
}
template <class T> inline void chkmax(T &a, T b) {
	if (a < b) a = b;
}

#define MX 1005

int T, N, M;
vi con[MX];
int sz[MX];
int q[MX], dst[MX], ba[MX];
bool used[MX], vis[MX];
 
void BFS() {
	int i;
	for (i = 0; i < N; i++) dst[i] = -1;
	int st = 0, en = 0;
	for (i = 0; i < N; i++) if (!used[i]) {
		q[en++] = i;
		dst[i] = 0;
	}
	
	while (st < en) {
		int u = q[st++];
		for (i = 0; i < sz[u]; i++) {
			int v = ba[con[u][i]];
			if (v > -1 && dst[v] == -1)
				q[en++] = v, dst[v] = dst[u] + 1;
		}
	}
}

bool DFS(int u) {
	int i, uu, v;
	vis[u] = 1;
	for (i = 0; i < sz[u]; i++) {
		v = con[u][i];
		uu = ba[v];
		if (uu == -1 || !vis[uu] && dst[uu] == dst[u] + 1 && DFS(uu)) {
			ba[v] = u;
			used[u] = 1;
			return 1;
		}
	}
	return 0;
}

int Hopcroft_Karp() {
	int ans = 0, i;
	for (i = 0; i < M; i++) ba[i] = -1;
	for (i = 0; i < N; i++) used[i] = 0;
	
	while (1) {
		BFS();
		for (i = 0; i < N; i++) vis[i] = 0;
		int rlt = 0;
		for (i = 0; i < N; i++)
			if (!used[i] && DFS(i)) rlt++;
		if (!rlt) return ans;
		ans += rlt;
	}
}

int main() {
	#ifndef ONLINE_JUDGE
	freopen("in.txt", "r", stdin);
	freopen("out.txt", "w", stdout);
	#endif
	
	int i, j, tp;
	for (scanf("%d", &T); T--; ) {
		scanf("%d%d", &N, &M);
		for (i = 0; i < N; i++)
			con[i].clear();
		
		for (i = 0; i < N; i++) {
			scanf("%d", sz + i);
			for (j = 0; j < sz[i]; j++) {
				scanf("%d", &tp);
				con[i].pb(tp - 1);
			}
		}
		cout << Hopcroft_Karp() << endl;
	}
	return 0;
}
