/*dp[i][j]=number of ways that sum of elements (upto i th index ,not necessary to consider all elements upto i th index is equal to j (j<K)*/
#include<iostream>
using namespace std;
#define p 1000000007
long long A[104];//A[i]>=1
long long dp[104][100004]={0};
long long modexp(long long a,long long b,long long m)
{
    long long ans=1;
    while (b)
    {
        if (b%2==1)
            ans=ans*a%m;
        a=a*a%m;
        b/=2;
    }
    return ans;
}
int main()
{
    long long N,K,sum=0,ans,temp=0,i,j;//K>=1
    cin>>N>>K;
    for (i=0;i<N;++i)
    {
        cin>>A[i];
        sum+=A[i];
    }
    if (sum<2*K)
    {
        cout<<0;
        return 0;
    }
    if (A[0]<K)
      dp[0][A[0]]=1;
    for (i=1;i<N;++i)
        for (j=1;j<K;++j)
    {
        if (j>A[i])
            dp[i][j]=(dp[i-1][j]+dp[i-1][j-A[i]])%p;
        else if (j==A[i])
            dp[i][j]=(dp[i-1][j]+1)%p;
        else
            dp[i][j]=dp[i-1][j];
    }
    for (i=0;i<K;++i)
        temp=(temp+dp[N-1][i])%p;
        temp=2*temp%p;
    ans=(modexp(2,N,p)-2-temp)%p;
    if (ans<0)
        ans+=p;
    cout<<ans;
    return 0;
}
