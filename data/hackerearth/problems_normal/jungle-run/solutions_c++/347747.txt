#include <cstdio>
#include <iostream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
#include <set>
#include <map>
#include <queue>
#include <deque>
#include <stack>
#include <list>
#include <bitset>
#include <utility>
#include <ctime>
#include <cassert>
#include <climits>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
typedef pair<int,int> pii;
typedef vector<pii > vii;
typedef vector<pair<int, pair<int, int> > > viii;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
typedef vector<vii> vvii;

#define pb push_back
#define mp make_pair
#define X first
#define Y second
#define MEM(a,b) memset(a,(b),sizeof(a))
#define pr(a) cout<<#a<<" = "<<(a)<<endl
#define cin(n) int (n); scanf("%d", &(n))
#define cin2(n,m) int (n),(m); scanf("%d%d",&(n),&(m))
#define sz(a) int((a).size())
#define all(a) a.begin(),a.end()
#define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++)
#define rep(x,n)   for(int (x)=0;(x)<(n);(x)++)
#define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define prc(a) tr(a, it) cout<<*(it)<<" "; cout<<endl
#define pra(a,n) for(int i=0; i<(n); i++) printf("%d ",((a)[i])); printf("\n")
#define prdd(a,r,c) for(int i=0;i<(r);i++) { for(int j = 0;j<(c);j++) cout<<a[i][j]<<" "; cout<<endl; } cout<<endl; 
#define present(c,x) ((c).find(x) != (c).end()) 
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) scanf("%d",&((a)[i])) 
#define vin(a,n) vector<int> (a); (a).resize((n)); for(int i=0; i<(n); i++) scanf("%d",&((a)[i])) 
#define md 1000000007

int n;
int g[50][50];

int main()
{   
    
    int xs,ys,xe,ye;
    scanf("%d",&n);
    char tmp[n];
    rep(i,n)
    {
        
        rep(j,n)
        {
            cin>>tmp[j];
            if(tmp[j] == 'T')
                g[i][j] = -1;
            else
                g[i][j] = INT_MAX;
            if(tmp[j] == 'S')
                xs = i,ys =  j;
            if(tmp[j] == 'E')
                xe = i,ye = j;

        }
    }
    g[xs][ys] = 0; 
    queue<pii> q;
    q.push(mp(xs,ys));
    while(sz(q) > 0)
    {
        int cx = q.front().first,cy = q.front().second;
        q.pop();
        if(cx != 0 and g[cx-1][cy] == INT_MAX)
        {
            q.push(mp(cx-1,cy));
            g[cx-1][cy] = 1 + g[cx][cy];
        }
        if(cx != n-1 and g[cx+1][cy] == INT_MAX)
        {
            q.push(mp(cx+1,cy));
            g[cx+1][cy] = 1 + g[cx][cy];
        }
        if(cy != 0 and g[cx][cy-1] == INT_MAX)
        {
            q.push(mp(cx,cy-1));
            g[cx][cy-1] = 1 + g[cx][cy];
        }
        if(cy != n-1 and g[cx][cy+1] == INT_MAX)
        {
            q.push(mp(cx,cy+1));
            g[cx][cy+1] = 1 + g[cx][cy];
        }

    }

    printf("%d\n",g[xe][ye]);
    
    return 0;
}


