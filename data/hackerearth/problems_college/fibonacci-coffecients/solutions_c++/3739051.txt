//Created By Mayur Agarwal :)

#include <iostream>
#include <stdio.h>
#include <cmath>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <algorithm>
#include <map>
#include <iterator>
#include <functional>
#include <stack>
#include <queue>

#define ll long long
#define ind(a) scanf("%d",&a)
#define in(a) scanf("%lld",&a)
#define inc(a) scanf("%c",&a)
#define ins(a) scanf("%s",a)
#define pr(a) printf("%lld\n",a)
#define prc(a) printf("%c",a)
#define prs(a) printf("%s\n",a)
#define fori(I,N) for(ll I=0;I<N;I++)
#define forin(i,n) for(ll I=1;I<=N;I++)
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define ALL(X) (X).begin(), (X).end()
#define pi   acos(-1.0)
#define SIZE 200100

using namespace std;
typedef pair<ll, ll>pll;
ll fib[SIZE];
ll mod;
ll ar[SIZE], temp[SIZE], bit1[SIZE], bit2[SIZE], temp1[SIZE];
int n, m;

inline void update1(int idx, ll val)
{
	if (idx <= 0)
		return;
	while (idx <= n)
	{
		bit1[idx] = (bit1[idx] + val + mod) % mod;
		idx += (idx & -idx);
	}
}
inline void update2(int idx, ll val)
{
	if (idx <= 0)
		return;
	while (idx <= n)
	{
		bit2[idx] = (bit2[idx] + val + mod) % mod;
		idx += (idx & -idx);
	}
}


inline ll query1(int idx)
{
	ll res = 0;
	if (idx <= 0)
		return res;
	while (idx > 0)
	{
		res = (res + bit1[idx] + mod) % mod;
		idx -= (idx & -idx);
	}
	return res;
}


inline ll query2(int idx)
{
	ll res = 0;
	if (idx <= 0)
		return res;
	while (idx > 0)
	{
		res = (res + bit2[idx] + mod) % mod;
		idx -= (idx & -idx);
	}
	return res;
}

int main()
{
	//ios_base::sync_with_stdio(0); cin.tie(0);
	ind(n);
	ind(m);
	in(mod);
	fib[1] = fib[2] = 1;
	for (int i = 3; i <= n + 1; i++)
	{
		fib[i] = (fib[i - 1] + fib[i - 2]) % mod;
	}
	for (int i = 1; i <= n; i++)
	{
		in(ar[i]);
	}
	for (int i = 1; i <= n; i++)
	{
		temp[i] = (ar[i] * fib[i]) % mod;
		temp1[i] = (ar[i] * fib[i + 1]) % mod;
		//cout << "%%" << temp[i] << endl;
		update1(i, temp[i]);
		update2(i, temp1[i]);
	}
	for (int i = 0; i < m; i++)
	{
		int type, l, r;
		ind(type);
		ind(l);
		ind(r);
		ll ans = 0, ans1 = 0;
		if (type == 2)
		{
			ans = (((query1(r) - query1(l - 1) + mod) * fib[l]) % mod);
			//cout << "^^" << ans << endl;
			ans1 = (((query2(r) - query2(l - 1) + mod) * fib[l - 1]) % mod);
			//cout << "$$" << ans1 << endl;
			//cout << "%%" << query2(r) << endl;

			if (!(l & 1))
			{
				ans = (ans1 - ans + mod) % mod;
			}
			else
			{
				ans = (ans - ans1 + mod) % mod;
			}
			cout << ans << endl;
		}
		else
		{
			temp[l] = (((r * fib[l]) % mod - temp[l] + mod)) % mod;
			temp1[l] = (((r * fib[l + 1]) % mod - temp1[l] + mod)) % mod;
			update1(l, temp[l]);
			update2(l, temp1[l]);
			temp[l] = ((r * fib[l]) % mod);
			temp1[l] = ((r * fib[l + 1]) % mod);
		}
	}
	return 0;
}