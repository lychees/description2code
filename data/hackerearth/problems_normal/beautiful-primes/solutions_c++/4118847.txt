/* NumeriX
   "Hard Work Beats Talent
   When Talent Doesn't Work Hard"
*/
#include <bits/stdc++.h>
#define ll long long int
#define sii(x) scanf("%d",&x)
#define pii(x) printf("%d\n",x)
#define sll(x) scanf("%lld",&x)
#define pll(x) printf("%lld\n",x)
#define present_set_map(container, element) (container.find(element) != container.end()) 
#define present_vec(container, element) (find(all(container),element) != container.end()) 
#define mp make_pair
#define all(x) x.begin(),x.end()
#define all_rev(x) x.rbegin(),x.rend()
#define pb push_back
#define fr first
#define se second
using namespace std;

ll arr1[1000005];
ll arr2[1000005];

ll modPow(ll a,ll b,ll mod)
{
    ll ans=1;
    while(b>0)
    {
        if(b&1)
            ans=(ans*a)%mod;
        a=(a*a)%mod;
        b=b>>1;
    }
    return ans;
}
 
ll gcd(ll a,ll b)
{
    if(b==0)
        return a;
    else
        return gcd(b,a%b);
}

ll modInverse(ll n,ll p)
{
    return modPow(n,p-2,p);
}
int main()
{
    ll tc,x,num,i,mod=1e9+7;
    sll(tc);
    while(tc--)
    {
        ll lcm=1,sum_t=1,ans,terms,t1;
        sll(x);
        for(i=0;i<x;i++)
            sll(arr1[i]);
        for(i=0;i<x;i++)
            sll(arr2[i]);
        num=1;
        for(i=0;i<x;i++)
        {
            terms = (arr1[i] * (modPow(arr1[i],arr2[i],mod) - 1)) % mod;
    		terms = (terms * modPow(arr1[i]-1,mod-2,mod)) % mod;
    		sum_t = (sum_t*terms)%mod;
    	}
    	if(sum_t<0) sum_t+=mod;
    	printf("%lld\n",sum_t);
    }
}