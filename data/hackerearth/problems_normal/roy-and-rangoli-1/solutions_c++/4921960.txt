//DARK LORD
#include<bits/stdc++.h>
#define ll long long
#define _ ios::sync_with_stdio(false);cin.tie(0);
#define max(a,b)                 (a>=b?a:b)
#define min(a,b)                 (a<b?a:b)
#define max3(a,b,c)               max(a,max(b,c))
#define min3(a,b,c)               min(a,min(b,c))
#define f0(i,a,b) for(int i=a;i<b;i++)
#define f1(i,a,b) for(int i=a;i<=b;i++)
#define fr(i,b,a) for(int i=b;i>=a;i--)
#define F first
#define S second
#define pb push_back
#define mp make_pair
#define mod 1000000007
#define T() int t;cin>>t;while(t--)
inline ll modexp(ll a,ll b){ll x=1;while(b>0){if(b&1){x*=a;if(x>=mod)x%=mod;};b>>=1;a*=a;if(a>=mod)a%=mod;}return x;}
inline ll digSum(ll n){ll s=0;n=abs(n);while(n){s+=(n%10);n/=10;}return s;}
using namespace std;
/*  Graph Part
static const int N  = 100001;
static bool visited[N];
vector<int> adj[N];
*/
#define mx 2000001
vector<bool> isprime(mx,true);
vector<ll> cnt(mx);
int main()
{
   _
   ll ans = 0;
    isprime[0]=false;
    isprime[1]=false;
    ll i,j,primelen;
    for(i=4;i<mx;i+=2)
    	isprime[i] = false;
    for(i=3;i<=sqrt(mx);i+=2)
    if(isprime[i])
    for(j=i*i;j<=mx;j+=2*i)
    {
        isprime[j]=false;
    }  
    cnt[2] = 1;
    for(i=3;i<=mx;i+=1){
    if(isprime[i])
    cnt[i] = cnt[i-1] + 1;
	else cnt[i] = cnt[i-1];}
	int n;
	cin>>n;
	f0(i,0,n){
		if(i == 0){
			ans = ans + cnt[n-1];
		}
		else{
			ans = ans + (cnt[n-1+i] - cnt[i - 1]);
		}
	}
	ans = ans%mod;
	cout<<ans;
}

