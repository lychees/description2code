#include<bits/stdc++.h>
#define MOD 1000000007
using namespace std;
#include<cstdio>
#include<map>
using namespace std;
int Prime[1100000];
int pos[10100010];
long long int ans[5100009]={};
#define prime(i) ((Prime[i>>5])&(1<<(i&(31))))
#define assign(j) (Prime[j>>5]|=(1<<(j&(31))))
#define LIMIT 5100000
#define SLIMIT 2500
int i,j,m,n,t,x,k,l,h;
void sieve()
{
pos[0]=0;
assign(1);
pos[1]=2;
pos[2]=3;
ans[2]=ans[3]=ans[5]=1;
for(k=2,l=3,i=5; i<=SLIMIT; k++,i=3*k-(k&1)-1)
if(prime(k)==0)
{
pos[l++]=i;
ans[i]=1;
for(j=i*i,h=((j+2)/3); j<=LIMIT; h+=(k&1)?(h&1?((k<<2)-3):((k<<1)-1)):(h&1?((k<<1)-1):((k<<2)-1)),j=3*h-(h&1)-1)
assign(h);
}
i=3*k-(k&1)-1;
for(; i<=LIMIT; k++,i=3*k-(k&1)-1)
if(prime(k)==0)
{
    pos[l++] = i;
    ans[i]=1;
}
}
int main()
{
    sieve();
    int test;
    scanf("%d",&test);
    while(test--)
    {
        int n,m;
        scanf("%d%d",&n,&m);
        map<int,int>memo;
        int p=n;
        while(p!=0)
        {
            memo[p]=1;
            p/=2;
        }
        int q=m;
        int ansa=0;
        while(q!=0)
        {
            if(ans[q]==1)
                ansa-=q;
            else
                ansa+=q;
            if(memo[q]==1)
                break;
            q/=2;
        }
        p=n;
        while(p!=q)
        {
            if(ans[p]==1)
                ansa-=p;
            else
                ansa+=p;
            p/=2;
        }
        printf("%d\n",ansa);
    }
    return 0;
}
