#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cctype>
#include<cstdlib>
#include<algorithm>
#include<bitset>
#include<cstdio>
#include<cstring>
#include<string>
#include<cctype>
#include<cstdlib>
#include<algorithm>
#include<bitset>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<map>
#include<set>
#include<stack>
#include<cmath>
#include<sstream>
#include<fstream>
#include<iomanip>
#include<ctime>
#include<complex>
#include<functional>
#include<climits>
#include<cassert>
#include<iterator>
using namespace std;



#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if (y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if (x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) { }
	ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

struct Matrix {
	typedef mint Num;
	static const int MaxN = 9;
	int hei, wid;
	Num v[MaxN][MaxN];
	Matrix() {}
	Matrix(int n, int m) : hei(n), wid(m) { mset(v, 0); }
	inline int height() const { return hei; }
	inline int width() const { return wid; }
	inline Num& at(int i, int j) { return v[i][j]; }
	inline const Num& at(int i, int j) const { return v[i][j]; }
	static Matrix identity(int n) {
		Matrix A(n, n);
		rep(i, n) A.at(i, i) = 1;
		return A;
	}
	inline static Matrix identity(const Matrix& A) { return identity(A.height()); }
	Matrix& operator*=(const Matrix& B) {
		int n = height(), m = B.width(), p = B.height();
		assert(p == width());
		const unsigned(*b)[MaxN] = reinterpret_cast<const unsigned(*)[MaxN]>(B.v);
		Num w[MaxN][MaxN];
		unsigned long long pp = (1ULL << 32) % mint::Mod;
		rep(i, n) {
			const unsigned *ai = reinterpret_cast<const unsigned*>(v[i]);
			rep(j, m) {
				unsigned x0 = 0; unsigned long long x1 = 0;
				rep(k, p) {
					unsigned long long y = (unsigned long long)ai[k] * b[k][j];
					unsigned long long t = x0 + y;
					x1 += t >> 32;
					x0 = t & 0xffffffff;
				}
				w[i][j].x = (x0 + x1 % mint::Mod * pp) % mint::Mod;
			}
		}
		memcpy(v, w, sizeof(v));
		return *this;
	}
};

long long int a;
long long int b;
long long int e;
long long int c;
long long int d;
long long int f;
long long int F[3];
long long int G[3];


Matrix mat(5,5);

Matrix PM[42];


vector<long long int> V;


long long int ar[10];


#define MOD 1000000007

Matrix MT;
Matrix tmp;

mint anss[1000002];
vector<pair<int, int> > query;

int main(){
	V.assign(5, 0);
	cin >> a >> b >> c >> d >> e >> f >> F[0] >> F[1] >> G[0] >> G[1];
	mat.at(0,0) = a;
	mat.at(0,3) = b;
	mat.at(1,0) = 1;
	mat.at(2,1) = d;
	mat.at(2,2) = c;
	mat.at(3,2) = 1;
	mat.at(4,0) = e;
	mat.at(4,2) = f;
	mat.at(4,4) = 1;
	PM[0] = mat;
	for (int i = 1; i<40; i++){
		(PM[i] = PM[i-1])*=PM[i-1];
	}
	ar[0] = F[1];
	ar[1] = F[0];
	ar[2] = G[1];
	ar[3] = G[0];
	ar[4] = F[0] * e + G[0] * f;
	ar[4] %= MOD;
	int q;
	cin >> q;
	for (int i = 0; i < q; i++){
		int n;
		scanf("%d", &n);
		query.push_back(make_pair(n, i));
	}
	sort(query.begin(), query.end());
	int pr = 1;
	MT = mat;
	for (int i = 0; i < q; i++){
		if (query[i].first == 0){
			anss[query[i].second] = ar[4];
			continue;
		}
		int want = query[i].first - pr;
		want--;
		if(want>=0){tmp = mat;
		int ii = 0;
		while (want>0){
			if ((want & 1)){
				tmp *= PM[ii];
			}
			ii++;
			want >>= 1;
		}
		MT *= tmp;
		}
		mint ans = 0;
		for (int i = 0; i < 5; i++){
			ans += (mint)(ar[i])*MT.at(4, i);
		}
		anss[query[i].second] = ans;
		pr = query[i].first;
	}
	for (int i = 0; i < q; i++){
		printf("%d\n", anss[i].get());
	}
	return 0;
}