#include <bits/stdc++.h>

#define x first
#define y second
#define MAXN 1010

using namespace std;

typedef long long ll;
typedef pair < int, int > ii;

int N;
ii points[MAXN];

ll getArea() {
    ll Area=0LL;
    for (int i=0; i<N; i++) {
        ll x1 = (ll)points[i].x;
        ll y1 = (ll)points[i].y;
        ll x2 = (ll)points[(i+1)%N].x;
        ll y2 = (ll)points[(i+1)%N].y;

        ll add = x1*y2 - x2*y1;
        Area += add;
    }
    Area = Area/2LL;
    if (Area < 0) Area = -Area;

    return Area;
}

int gcd(int x, int y) {
    if (x < y)  return gcd(y, x);
    if (y == 0) return x;
    return gcd(y, x%y);
}

ll border() {
    ll retVal = 0;
    for (int i=0; i<N; i++) {
        int x1 = points[i].x;
        int y1 = points[i].y;
        int x2 = points[(i+1)%N].x;
        int y2 = points[(i+1)%N].y;

        int temp = gcd(abs(x1-x2), abs(y1-y2));
        retVal += (ll)temp;
    }
    retVal = retVal/2LL;
    return retVal;
}

int main()
{
    cin >> N;

    for (int i=0; i<N; i++)
        cin >> points[i].x >> points[i].y;

    ll ans = getArea() - border() + 1;

    cout << ans << endl;

    return 0;
}

/**#include <bits/stdc++.h>

#define l 2*pos
#define r 2*pos+1
#define mid (i+j)/2

#define offset 100005
#define MAXN 300010   /// change this

using namespace std;

int T, M;
bool lazy[4*MAXN];
int seg_tree[4*MAXN];
int dWage, minWage, peopleLeft;

int target, start, stop;

void propagate(int pos, int i, int j) {
    if (lazy[pos] == true) {
        seg_tree[pos] = 0;
        if (i != j) {
            lazy[l] = true;
            lazy[r] = true;
        }
        lazy[pos] = false;
    }
}

void add(int pos, int i, int j) {
    propagate(pos, i, j);

    if (i == j) {
        seg_tree[pos] ++;
        return;
    }

    if (target <= mid) add(l, i, mid);
    else               add(r, mid+1, j);
    seg_tree[pos] = seg_tree[l]+seg_tree[r];
}

int query(int pos, int i, int j) {
    propagate(pos, i, j);

    if (j < start || stop < i || j < i)
        return 0;

    if (start <= i && j <= stop)
        return seg_tree[pos];

    return (query(l, i, mid) + query(r, mid+1, j));
}

void zero(int pos, int i, int j) {
    propagate(pos, i, j);

    if (j < start || stop < i || j < i) return;

    if (start <= i && j <= stop) {
        lazy[pos] = true;
        propagate(pos, i, j);
        return;
    }

    zero(l, i, mid);
    zero(r, mid+1, j);

    seg_tree[pos] = seg_tree[l] + seg_tree[r];
}

int Kth(int pos, int i, int j, int _K) {
    if (i == j && _K == 1)
        return i;

    if (i == j)
        return -1;

    if (seg_tree[r] >= _K)
        return Kth(r, mid+1, j, _K);
    else
        return Kth(l, i, mid, _K-seg_tree[r]);
}

void Solve() {
    scanf("%d %d", &M, &minWage);

    int K;
    char cmd[2];

    for (int i=0; i<M; i++) {
        scanf("%s %d", &cmd, &K);

        if (cmd[0] == 'I') {
            if (K < minWage) continue;
            K = K - dWage + offset;
            target = K;
            add(1, 0, MAXN-1);
        } else if (cmd[0] == 'A') {
            dWage += K;
        } else if (cmd[0] == 'S') {
            dWage -= K;
            start = 0; stop = minWage+offset-dWage-1;
            peopleLeft += query(1, 0, MAXN-1);
            zero(1, 0, MAXN-1);
        } else {
            if (seg_tree[1] < K) printf("-1\n");
            else printf("%d\n", Kth(1, 0, MAXN-1, K)-offset+dWage);
        }
    }
    printf("%d\n", peopleLeft);
}

int main()
{
    scanf("%d", &T);

    while (T --) {
        memset(seg_tree, 0, sizeof seg_tree);
        memset(lazy, false, sizeof lazy);
        peopleLeft = 0;
        dWage = 0;
        Solve();
    }

    return 0;
}**/
