/*#include <bits/stdc++.h>

using namespace std;

int search(int a[], int beg, int end, int item)    // Function to Search Element  
{
if(beg==end)                                     // if Single Element is in the List 
{
if(item==a[beg])
return beg;
else
;
}

else
{
int mid = (beg + end)/2;
if(item == a[mid])
return mid;

else if(item < a[mid])
search(a,beg,mid-1,item);                 // Function Calls Itself (Recursion)  

else
search(a,mid+1,end,item);                 // Function Calls Itself (Recursion)  
}

}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int i,n,a[100001],b[100001],c[10001];
		for(i = 0; i < 10001;i++)
		{
			c[i] = 0;
		}
		scanf("%d", &n);
		for(i = 0; i < n;i++)
		{
			scanf("%d", &a[i]);
			b[i]= a[i];
		}
		sort(a,a+n);
		int max = 0;
		int temp;
		int fact= 0;
		for(i = 0; i < n; i++)
		{
			temp = search(a,0,n-1,b[i]);
			if(c[a[i]] == 0)
			{
				c[a[i]] = c[a[i]] + 1;
				fact = abs(temp-i);
				
			}
			else if(c[a[i]] != 0)
			{
				
				fact = abs(temp-i) + c[a[i]];
				c[a[i]] = c[a[i]] + 1;
			}
		
			if(fact > max)
			{
				max = fact;
			}
		}
		printf("%d\n", max);
	}
	return 0;
}*/
//Above solution is just giving 40/100 and does not work for all cases.

#include <bits/stdc++.h>

struct btnode  //details of node in binary tree
{
    int val;
	struct btnode *lptr;
	struct btnode *rptr;
	int pos;  //final position
	int ipos; //initial position
};

int temp1 = 0;

void btinsert(struct btnode **bt,int a)  //node insertion
{
	if(*bt == NULL)
	{
		*bt = (struct btnode *)malloc(sizeof(struct btnode));
		(*bt)->lptr = NULL;
		(*bt)->rptr = NULL;
		(*bt)->val = a;
		(*bt)->ipos = temp1++;  //initial position
		return;
	}
	else
	{
		if(a < (*bt)->val)
			btinsert(&((*bt)->lptr),a);
		else
			btinsert(&((*bt)->rptr),a);
	}
}

int temp = 0,diff = 0,z = 0;

void assignPos(struct btnode *bt)  //assigning position to nodes after sorting
{
	if(bt != NULL)  //in-order traversal
	{
		assignPos(bt->lptr);
		bt->pos = temp++;
		z = abs(bt->ipos - bt->pos);  //finding difference between initial position and final position
		if(z > diff)
			diff = z;  //diff holds largest difference which is the final answer.
		assignPos(bt->rptr);
	}
}

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		struct btnode *bt = NULL;
		diff = 0;
		z = 0;
		temp = 0;
		temp1 = 0;
		int n;
		scanf("%d",&n);
		int i = 0;
		int x;
		while(i<n)
		{
			scanf("%d",&x);
			btinsert(&bt,x);
			i++;
		}
		assignPos(bt);
		printf("%d\n",diff);
	}
	return 0;
}