#include <iostream>
#include <stdio.h>
#include <limits.h>
#include <vector>
#include <queue>
using namespace std;

typedef pair<int, int> ii;
typedef vector<int> vi;
typedef vector<bool> vb;
typedef vector<ii> vii;

class UnionFind
{
private:
    vi rank, size_set, p;
    int num_sets;
public:
    UnionFind(int N) { num_sets = N; rank.assign(N, 0); size_set.assign(N,1);
        p.assign(N, 0); for (int i = 0; i < N; ++i) { p[i] = i; } };
    int find_set(int i) { return (i==p[i]) ? i : p[i]=find_set(p[i]);};
    void union_set(int i, int j) {
        int y = find_set(i), x = find_set(j);
        if(y==x) return;
        num_sets--;
        if(rank[x] > rank[y]) { p[y]=x; size_set[x] += size_set[y];
        } else { p[x]=y; size_set[y]+=size_set[x]; 
                if (rank[x]==rank[y]) rank[y]++; 
        }
    };
    bool same_set(int i, int j) { return find_set(i)==find_set(j); };
    int get_set_size(int i) {  return size_set[find_set(i)]; };
    int get_num_sets() { return num_sets; };
};

vector<vii> adjlist;
vi distto;
vi edgeto;
vi ufedgeto;
vb marked;

void bfs(int s, UnionFind& ufk, UnionFind& uf)
{
	marked[s] = true;
	distto[s] = 0;
	edgeto[s] = s;
	queue<int> qe;
	qe.push(s);
	int k = 0;
	int nufm = 0;
	while(!qe.empty())
	{
		int u = qe.front();
		qe.pop();
		for (int i = 0; i < adjlist[u].size(); ++i)
		{
			int v = adjlist[u][i].first;
			if (marked[v]==false)
			{
				distto[v] = distto[u] + 1;
				edgeto[v] = u;
				marked[v] = true;
				if (u!=k && v!=k)
				{
					//cout << " addk "  << u << " " <<  v << endl;
					ufk.union_set(u, v);
				}
				if (adjlist[u].size() == 2) 
				{
					//cout << " added "  << u << " " <<  v << endl;
					uf.union_set(u, v);
					nufm++;
				}
				qe.push(v);
			}
		}
	}
	//cout << " nufm : " << nufm << endl;

}

// Oliver and the Game
int main()
{
	int N, Q, A, B, X, Y, opt;
	scanf("%d", &N);
	adjlist.assign(N, vii());
	distto.assign(N, INT_MAX);
	marked.assign(N, false);
	edgeto.assign(N, -1);
	ufedgeto.assign(N, -1);
	for (int i = 0; i < N-1; ++i)
	{
		scanf("%d %d", &A, &B);
		A--; B--;
		adjlist[A].push_back(make_pair(B, 1));
		adjlist[B].push_back(make_pair(A, 1));
	}
	//cout << "read " << N <<  endl;
	int k = 0;
	int node, distX, distY, distNode;
	int nops0 = 0;
	int nops1 = 0;
	int nmg0 = 0;
	int nmg1 = 0;
	int nhk = adjlist[k].size();
	UnionFind ufk(N);
	UnionFind uf(N);
	//cout << " init uf" << endl;
	bfs(k, ufk, uf);
	int nsets = uf.get_num_sets();
	vi min_dist(N, INT_MAX);
	vi ind_min_dist(N, -1);
	//cout << "nsets " << nsets << endl;
	for (int i = 0; i < N; ++i)
	{
		int root = uf.find_set(i);
		if( distto[i] < min_dist[root])
		{
			min_dist[root] = distto[i];
			ind_min_dist[root] = i;
		}	
	}
	
	//cout << " ok uf" << endl;
	// get queries]
	scanf("%d", &Q);
	//cout << " Q " <<  Q << endl;
	bool ans;
	for (int i = 0; i < Q; ++i)
	{
		scanf("%d %d %d", &opt, &X, &Y);
		X--; Y--;
		//cout << X << " " << Y << endl;
		// according to the option //(distto[Y] >=  distto[X])
		if ( X==Y)
			ans = true;
		else if ( X==k && Y==k)
			ans = true;
		else if (ufk.same_set(Y, X))
		{
			if (opt == 0)  // Y -> X -> K
			{
				nops0++;
				//if (k == X) {
				//	ans = true;
				//} else 
				if ( distto[Y] < distto[X] ) { // NO
					ans = false;
				} else if ( uf.same_set(X, Y) ) {
					ans = true;
					nmg0++;
				} else {
					//cout << "opt 0" << endl;
					node = Y;
					distX = distto[X];
					distNode = distto[Y];
					while(node!=X && distNode >= distX)//
					{
						/*
						int u = node;
						int v;
						for (int i = 0; i < adjlist[u].size(); ++i)
						{
							v = adjlist[u][i].first;
							if (distto[v] < distto[u])
								break;
						}
						node = v;
						*/
						int root = uf.find_set(node);
						if ( uf.get_set_size(root) > 1 && ind_min_dist[root]!=node) {
							if (uf.same_set(node, X))
							{
								node = X;
								break;
							} else {
								distNode = min_dist[root];
								node = ind_min_dist[root];
							}

						} else {
							distNode--;
							node = edgeto[node];
						}
					}
					if (node == X)
						ans = true;
					else
						ans = false;
				}
			} else { // K -> Y -> X
				if ( distto[X] < distto[Y] ) { // NO
					ans = false;
				} else if ( uf.same_set(X, Y) ) {
					ans = true;
					nmg1++;
				} else {
					nops1++;
					//cout << "opt 1" << endl;
					node = X;
					distY = distto[Y];
					distNode = distto[X];
					while(node!=Y && distNode >= distY) //
					{
						/*
						int u = node;
						int v;
						for (int i = 0; i < adjlist[u].size(); ++i)
						{
							v = adjlist[u][i].first;
							if (distto[v] < distto[u])
								break;
						}
						node = v;
						*/
						int root = uf.find_set(node);
						if ( uf.get_set_size(root) > 1 && ind_min_dist[root]!=node) {
							if (uf.same_set(node, Y))
							{
								node = Y;
								break;
							} else {
								distNode = min_dist[root];
								node = ind_min_dist[root];
							}

						} else {
							distNode--;
							node = edgeto[node];
						}
					}
					if (node == Y)
						ans = true;
					else
						ans = false;
				}
			}
		} else {
			if (X == k && opt==0)
				ans = true;
			else if (Y == k && opt==1)
				ans = true;
			else
				ans = false;
		}
		
		if(ans)
			printf("YES\n");
		else
			printf("NO\n");
		
	}
	//printf("nops0 : %d, nops1:  %d\n", nops0, nops1);
	//printf("nmg0 : %d, nmg1:  %d\n", nmg0, nmg1);

}