#include <bits/stdc++.h>

using namespace std;

const int N = 1234567;

vector <int> g[N];
int kw, w[N];
int pos[N];
int to[N];
int pv[N];

void dfs(int v) {
  w[++kw] = v;
  pos[v] = kw;
  for (int j = 0; j < (int) g[v].size(); j++) {
    int u = g[v][j];
    if (u != pv[v]) {
      pv[u] = v;
      dfs(u);
    }
  }
  to[v] = kw;
}

const int LOG = 20;

int pr[N][LOG];

inline bool anc(int x, int y) {
  return (pos[x] <= pos[y] && to[y] <= to[x]);
}

inline int lca(int x, int y) {
  if (anc(x, y)) {
    return x;
  }
  for (int j = LOG - 1; j >= 0; j--) {
    if (!anc(pr[x][j], y)) {
      x = pr[x][j];
    }
  }
  return pr[x][0];
}

int fenw[N];
int n;

void modify(int x, int v) {
  while (x <= n) {
    fenw[x] += v;
    x = (x | (x - 1)) + 1;
  }
}

int find_sum(int x) {
  int v = 0;
  while (x > 0) {
    v += fenw[x];
    x &= x - 1;
  }
  return v;
}

int main() {
  int tt;
  scanf("%d %d", &n, &tt);
  for (int i = 0; i < n; i++) {
    g[i].clear();
  }
  for (int i = 0; i < n - 1; i++) {
    int x, y;
    scanf("%d %d", &x, &y);
    x--; y--;
    g[x].push_back(y);
    g[y].push_back(x);
  }
  kw = 0;
  pv[0] = 0;
  dfs(0);
  for (int i = 0; i < n; i++) {
    pr[i][0] = pv[i];
  }
  for (int j = 1; j < LOG; j++) {
    for (int i = 0; i < n; i++) {
      pr[i][j] = pr[pr[i][j - 1]][j - 1];
    }
  }
  for (int i = 1; i <= n; i++) {
    fenw[i] = 0;
  }
  while (tt--) {
    int op;
    scanf("%d", &op);
    if (op == 1) {
      int x, y;
      scanf("%d %d", &x, &y);
      x--; y--;
      int z = lca(x, y);
      modify(pos[x], 1);
      modify(pos[y], 1);
      modify(pos[z], -1);
      if (z != 0) {
        modify(pos[pv[z]], -1);
      }
    } else {
      int x;
      scanf("%d", &x);
      x--;
      printf("%d\n", find_sum(to[x]) - find_sum(pos[x] - 1));
    }
  }
  return 0;
}
