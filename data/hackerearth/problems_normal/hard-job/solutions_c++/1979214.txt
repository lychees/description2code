#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <list>
#include <vector>
#include <string>
#include <cstring>
#include <cmath>
#include <ctime>
#include <cassert>
#include <bitset>
 
using namespace std;
 
#define forn(i, n) for(int i = 0; i < (int)(n); i++)
#define forn1(i, n) for(int i = 1; i <= (int)(n); i++)
#define all(a) (a).begin(), (a).end()
#define sz(a) (int)((a).size())
#define mp make_pair
#define pb push_back
#define X first
#define Y second
#define x first
#define y second
#define y1 __y1
#define sqr(x) ((x) * (x))
 
typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;
 
const int INF = (int)(1e9);
const li INF64 = (li)(INF) * (li)(INF);
const ld eps = 3e-8;
const ld pi = ld(3.1415926535897932384626433832795);
 
inline bool in(int i, int j, int n, int m)
{
    return i >= 1 && i <= n && j >= 1 && j <= m;
}
 
inline int myrand()
{
    return (rand() ^ (rand() << 15));
}
 
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};
 
const int N = 2e6 + 777;

int a[N], reva[N];
int n, m;
int pos[N], pos2[N];

inline bool read()
{
	if(scanf("%d %d", &n, &m) != 2)
		return false;

	forn1(i, n)
	{
		int x;
		assert(scanf("%d", &x) == 1);
		//assert(scanf("%d", &a[i + 1000000]) == 1);
		a[i + 1000000] = 1;
		reva[i + 1000000] = 1;
		pos[x] = i + 1000000;
		pos2[x] = n + 1000000 - (i) + 1;
	}

    return true;
}

/*
int t[4 * N];

void build(int idx, int l, int r)
{
	if(l == r)
	{
		t[idx] = a[l];
		return;
	}

	int mid = (l + r) / 2;

	build(2 * idx + 1, l, mid);
	build(2 * idx + 2, mid + 1, r);

	t[idx] = t[2 * idx + 1] + t[2 * idx + 2];
	return;
}

void upd(int idx, int l, int r, int pos, int val)
{
	if(l == r)
	{
		t[idx] += val;
		return;
	}

	int mid = (l + r) / 2;

	if(pos <= mid)
		upd(2 * idx + 1, l, mid, pos, val);

	if(pos > mid)
		upd(2 * idx + 2, mid + 1, r, pos, val);

	t[idx] = t[2 * idx + 1] + t[2 * idx + 2];
	return;
}

int get(int idx, int l, int r, int L, int R)
{
	if(l == L && r == R)
		return t[idx];

	int mid = (l + r) / 2;

	int res = 0;

	if(L <= mid)
		res += get(2 * idx + 1, l, mid, L, min(R, mid));

	if(R > mid)
		res += get(2 * idx + 2, mid + 1, r, max(mid + 1, L), R);

	return res;
}
*/

int tt[N], tt2[N];

inline void inc(int i, int add)
{
	for ( ; i < N; i = (i | (i + 1)))
	{
		//cerr << "add == " << add << endl;
		tt[i] += add;
	}
	return;
}

inline int sum(int i)
{
	int res = 0;
	for ( ; i >= 0; i = (i & (i + 1)) - 1)
		res += tt[i];
	return res;
}

void build()
{
	forn(i, N)
	{
		if(a[i] > 0)
		{
			//cerr << "A[i] == " << a[i] << endl;
			inc(i, a[i]);
			//assert(false);
			//cerr << "INCED" << endl;
		}
	}

	return;
}

inline void inc2(int i, int add)
{
	for ( ; i < N; i = (i | (i + 1)))
	{
		//cerr << "add == " << add << endl;
		tt2[i] += add;
	}
	return;
}

inline int sum2(int i)
{
	int res = 0;
	for ( ; i >= 0; i = (i & (i + 1)) - 1)
		res += tt2[i];
	return res;
}

void build2()
{
	forn(i, N)
	{
		if(reva[i] > 0)
		{
			//cerr << "A[i] == " << a[i] << endl;
			inc2(i, reva[i]);
			//assert(false);
			//cerr << "INCED" << endl;
		}
	}

	return;
}

inline void solve()
{
	li ans = 0;

	build();
	build2();

	//build(0, 0, N - 1);

	//cerr << "build" << endl;

	//assert(scanf("%d", &m) == 1);
	int LF = 1 + 1000000;
	int RG = LF + n - 1;
	//forn(i, N)
		//if(tt[i] > 0)
			//assert(false);
	int LL = LF, RR = RG;

	forn(kk, m)
	{
		int x;
		char y;
		assert(scanf("%d %c", &x, &y) == 2);
		//cerr << x << " == " << y << " == " << endl;

		int pos = ::pos[x];
		int pos2 = ::pos2[x];
		//cerr << "pos == " << pos << ' ' << pos2 << endl;
		//int res1 = get(0, 0, N - 1, 0, pos - 1);
		int res2 = sum2(pos2 - 1);
		int F = sum(pos - 1);
		int res1 = F;
		//cerr << "FEnwick sum == " << F << endl;
		//cerr << "res == " << res1 << ' ' << res2 << endl;
		ans += min(res1, res2);

		if(y == 'l')
		{
			a[pos] = 0;
			reva[pos2] = 0;
			//upd(0, 0, N - 1, pos, -1);
			inc(pos, -1);
			inc2(pos2, -1);
			LF--;
			RR++;
			::pos2[x] = RR;
			reva[RR] = 1;
			a[LF] = 1;
			::pos[x] = LF;
			//upd(0, 0, N - 1, LF, +1);
			inc(LF, +1);
			inc2(RR, +1);
		}
		else
		{
			a[pos] = 0;
			reva[pos2] = 0;
			//upd(0, 0, N - 1, pos, -1);
			inc(pos, -1);
			inc2(pos2, -1);
			RG++;
			a[RG] = 1;
			::pos[x] = RG;
			LL--;
			reva[LL] = 1;
			::pos2[x] = LL;
			//upd(0, 0, N - 1, RG, +1);
			inc(RG, +1);
			inc2(LL, +1);
		}
	}

	cout << ans << endl;
    return;
}

int main() {
#ifdef _DEBUG
    assert(freopen("input.txt", "rt", stdin));
    assert(freopen("output.txt", "wt", stdout));
#endif

    cout << setprecision(10) << fixed;
    cerr << setprecision(10) << fixed;

    srand(int(time(NULL)));

    assert(read());
    solve();

#ifdef _DEBUG
    cerr << "TIME == " << clock() << " ms" << endl;
#endif
    return 0;
}