#include<iostream>
#include<queue>
// i'm never gonna give 

// algorithm - bfs with memorisation
 
using namespace std;
 
 
int main()
{
    int t,start,target,mul,div,add,sub,steps,temp,ans,n;
	cin>>t;
	while(t--)
	{
		
        int bfs[1000009]={0};   		// could also be done if array is set -1 , then we just have to change some thing below to adjust
		queue <int> que;				// and satisfy cases  , already done in hacker earth second last submitted,      
		cin>>start>>target;
		cin>>mul>>div>>add>>sub;        
		que.push(start);
		bfs[start]=1;
		ans=0;
		
		while(!que.empty()){
			
			//cout<<que.front()<<endl;
				
			n=que.front();
			que.pop();
				
			if(n==target){
				ans=bfs[n];
				break;
			}	
			
			temp=n*mul;
			if(temp>=2 && temp<=1000000 && !bfs[temp]){
					bfs[temp]=bfs[n]+1;
					que.push(temp);					
			}
				
			temp=n/div;
			if(temp>=2 && temp<=1000000 && !bfs[temp]){
					bfs[temp]=bfs[n]+1;
					que.push(temp);					
			}
				
			temp=n+add;
		    if(temp>=2 && temp<=1000000 && !bfs[temp]){
					bfs[temp]=bfs[n]+1;
					que.push(temp);					
			}
				
			temp=n-sub;
			if(temp>=2 && temp<=1000000 && !bfs[temp]){
					bfs[temp]=bfs[n]+1;
					que.push(temp);					
			}
			
		}
		cout<<ans-1<<endl;
	}
	return 0;
}