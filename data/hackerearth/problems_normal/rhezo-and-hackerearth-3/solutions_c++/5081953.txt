#include <bits/stdc++.h>

using namespace std;

#define maxN 100000

int n,m;
vector<pair<int,int> > edge;
vector<int> g[maxN+5];
int visit[maxN+5];
int disc[maxN+5];
int low[maxN+5];
int parent[maxN+5];
map<pair<int,int>,int> bridge;

void dfs(int u,int timer)
{
	visit[u]=1;
	disc[u]=low[u]=timer+1;
	int i,v;
	for(i=0;i<(int)g[u].size();i++)
	{
		v=g[u][i];
		if(visit[v]==0)
		{
			parent[v]=u;
			dfs(v,timer+1);
			low[u]=min(low[u],low[v]);
			if(low[v]>disc[u])
			{
				bridge[make_pair(min(u,v),max(u,v))]=1;
				//printf("%d %d\n",u,v);
			}			
		}
		else
		{
			if(v!=parent[u])
				low[u]=min(low[u],disc[v]);
		}
	}
}

int main()
{
	int i,u,v,q;
    scanf("%d%d",&n,&m);
    while(m--)
   	{
   		scanf("%d%d",&u,&v);
   		g[u].push_back(v);
   		g[v].push_back(u);
   		if(u>v)
   			swap(u,v);
   		edge.push_back(make_pair(u,v));
   	}
   	for(i=1;i<=n;i++)
   	{
   		parent[i]=-1;
   		visit[i]=0;
   	}
   	for(i=1;i<=n;i++)
   		if(visit[i]==0)
   			dfs(i,0);
   	scanf("%d",&q);
   	while(q--)
   	{
   		scanf("%d",&i);
   		u=edge[i-1].first;
   		v=edge[i-1].second;
   		if(u>v)
   			swap(u,v);
   		if(bridge[make_pair(u,v)]==1)
   			printf("Unhappy\n");
   		else
   			printf("Happy\n");
   	}
    return 0;
}
