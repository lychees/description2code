/*	I will not win immediately,
 *	but I will win definitely...
 */
#include<bits/stdc++.h>
#define opt		ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
//====================================================================================
#define li		long int
#define lli		long long int
//====================================================================================
#define sd(n)		scanf("%d",&n)
#define sld(n)		scanf("%ld",&n)
#define slld(n)		scanf("%lld",&n)
#define pd(n)		printf("%d\n",n)
#define pld(n)		printf("%ld\n",n)
#define plld(n)		printf("%lld\n",n)
#define pn		printf("\n")
//====================================================================================
#define rep(i,a,b)	for(i=a;i<b;i++)
#define repr(i,a,b)	for(i=a;i>b;i--)
#define repi(i,v)	for(i=v.begin();i!=v.end();i++)
#define elif		else if
#define clr(a,b)    memset(a,b,sizeof(a))
//====================================================================================
#define vi		vector<int>
#define vli		vector<li>
#define vlli		vector<lli>
//====================================================================================
#define pb		push_back
#define pob		pop_back
#define all(v)		v.begin(),v.end()
#define itr		iterator
#define sz		size()
#define lb		lower_bound
#define ub		upper_bound
#define mp		make_pair
#define pii		pair<int,int>
#define pll		pair<li,li>
#define vpi		vector<pii >
#define vpl		vector<pll >
#define F		first
#define S		second
//====================================================================================
#define mod		1000000007
#define MX1		100005
#define MX2		1000005
//====================================================================================
using namespace std;
//====================================================================================
li power(li a, li b){
		li ans=1L;
		while(b){
				if(b&1)
						ans=(ans*a)%mod;
                a=(a*a)%mod;
                b>>=1;
		}
		return ans;
}
//====================================================================================
li mmi(li n){
		return power(n,mod-2);
}
//====================================================================================
li gcd(li a, li b){
        if(a%b==0)
                return b;
        else
                return gcd(b,a%b);
}
//====================================================================================
void fs(int &x){
        bool neg=false;
        register int c;
        x=0;
        c=getchar();
        if(c=='-'){
                neg = true;
                c=getchar();
        }
        for(;(c>47 && c<58);c=getchar())
                x = (x<<1)+(x<<3)+c-48;
        if(neg)
                x *=-1;
}
//====================================================================================
/*-----------------MAIN CODE BEGINS NOW!-----------------*/

int risk[1001];
int arr[1001];
int sizea[1001];

void init(){
        int i;
        rep(i,0,1001){
                arr[i]=i;
                sizea[i]=1;
        }
}

int root(int i){
        while(arr[i]!=i){
                arr[i]=arr[arr[i]];
                i=arr[i];
        }
        return i;
}

void unionof(int a, int b){
        int root_a=root(a);
        int root_b=root(b);
        if(sizea[root_b]>sizea[root_a])
                swap(root_a,root_b);
        arr[root_b]=root_a;
        sizea[root_a]+=sizea[root_b];
}

int main(){
        init();
        int i,n;
        sd(n);
        rep(i,1,n+1)
                sd(risk[i]);
        int k;
        li ans=1L;
        sd(k);
        while(k--){
                int x,y;
                sd(x),sd(y);
                unionof(x,y);
        }
        set<int> ms;
        vi v;
        v.pb(-1);
        rep(i,1,n+1)
                ms.insert(root(arr[i])),v.pb(root(arr[i]));
        set<int>::itr it;
        repi(it,ms){
                int minx=INT_MAX, cnt=0;
                rep(i,1,n+1){
                        if(v[i]==*it && risk[i]<minx){
                                minx=risk[i];
                                cnt=1;
                        }
                        elif(v[i]==*it && risk[i]==minx)
                                cnt++;
                }
                ans=(ans*cnt)%mod;
        }
        pld(ans);
		return 0;
}
