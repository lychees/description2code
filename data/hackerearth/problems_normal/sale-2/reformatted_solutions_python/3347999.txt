def findParent(edge, parents):
    while parents.has_key(edge):
        edge = parents[edge]
    return edge


def checkCycles(edges):  # union find algorithm to find edges
    parents = {}
    for edge in edges:
        parenta = findParent(edge[0], parents)
        parentb = findParent(edge[1], parents)
        if parenta == parentb:
            # print "cycle found"
            return True
        else:
            parents[edge[0]] = edge[1]
    # print "Cycles not found"
    return False


def solve(N, M):
    edges = []
    degree = {}
    result = True
    for pair in range(0, M):
        a, b = map(int, raw_input().split())
        if not result:
            continue
        edges.append([a, b])
        if not degree.has_key(a):
            degree[a] = 0
        if not degree.has_key(b):
            degree[b] = 0
        degree[a] = degree[a]+1
        degree[b] = degree[b]+1
        if degree[a] > 2 or degree[b] > 2:
            result = False

    if not result:
        return False

    # DFS check for cycles
    hasCycles = checkCycles(edges)
    if hasCycles:
        return False
    else:
        return True


T = input()
for t in range(0, T):
    N, M = map(int, raw_input().split())
    answer = solve(N, M)
    if answer:
        print "YES"
    else:
        print "NO"
