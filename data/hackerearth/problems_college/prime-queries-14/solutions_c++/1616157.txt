/*
Author - Shubham Shukla (shuklas664)
*/
#include <bits/stdc++.h>
#include <iostream>
#include<iomanip>
#include<stdio.h>
#include<math.h>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<string>
#include<string.h>
#include<cstdio>
#include<vector>
#include<utility>
#include<map>

//datatypes
typedef long long       ll;

//macros
#define inf         0x7fffffff
#define MOD         1000000007
#define scl(t)      scanf("%ld",&t)
#define scll(t)     scanf("%lld",&t)
#define sc(t)       scanf("%d",&t)
#define scf(t)      scanf("%f",&t)
#define max(a,b)    (a>=b?a:b)
#define min(a,b)    (a<b?a:b)
#define gc          getchar_unlocked
#define mp          make_pair
#define pb          push_back
#define F           first
#define S           second
#define lc          printf("\n")

//print array and matrix
#define printAr(a,n)    {for(int i=0;i<n;i++){cout<<a[i]<<" ";}lc;}
#define printMat(a,n,m) {for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<" ";}lc;}lc}
#define N 100001
#define MAX (400001) // Why? :D
#define inf 0x7fffffff

using namespace std;




void scanint(int &x)
{
    register int c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}
/*
void scanint(int &x)
{
    register int c = gc();
    x = 0;
    int neg = 0;
    for(;((c<48 || c>57) && c != '-');c = gc());
    if(c=='-') {neg=1;c=gc();}
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
    if(neg) x=-x;
}

*/


int arr[N];
int tree[MAX];
int p[1000009]={0};

int w=0;

void sieve()
{   int j;

    for ( int i = 2; i <=1000001; i++)
    		{
        		if (p[i] == 0)
        		{
                    j = i;

                    //if(i==2)
                       // cout<<"This is for "<<prime[0]<<"\n";
            		p[j]=i;

                    //cout<<"i j pj pprev\n";
                   // cout<<i<<" "<<j<<" "<<p[i]<<" "<<p[prev]<<endl;
            		while (j <= 1000001)
            		{
                		p[j]=i;
                		j = j + i;
            		}
        		}

   			}

}

/**
* Build and init tree
*/
void build_tree(int node, int a, int b) {
    if(a > b) return; // Out of range
    if(a == b) { // Leaf node
        if(p[arr[a]]==arr[a])
                tree[node] = arr[a];
        else tree[node] = -1;
        //cout<<node<<"-->"<<tree[node]<<endl;
    return;
    }
    build_tree(node*2, a, (a+b)/2); // Init left child
    build_tree(node*2+1, 1+(a+b)/2, b); // Init right child
    tree[node] = max(tree[node*2], tree[node*2+1]); // Init root value
}

/**
* Increment elements within range [i, j] with value value
*/
void update_tree(int node, int a, int b, int i, int value) {
if(a > b || b<i || a>i) // Current segment is not within range [i, j]
    return;
if(a == b) { // Leaf node
    if(p[value]==value)
                tree[node] = value;
        else tree[node] = -1;
return;
}

update_tree(node*2, a, (a+b)/2, i,  value); // Updating left child
update_tree(1+node*2, 1+(a+b)/2, b, i,  value); // Updating right child

tree[node] = max(tree[node*2], tree[node*2+1]); // Updating root with max value
}

/**
* Query tree to get max element value within range [i, j]
*/
int query_tree(int node, int a, int b, int i, int j) {
if(a > b || a > j || b < i) return -inf; // Out of range

if(a >= i && b <= j) // Current segment is totally within range [i, j]
{
    //cout<<node<<" has "<<tree[node];lc;
    return tree[node];
}

int q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child
int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); // Query right child

int res = max(q1, q2); // Return final result
return res;
}

int main()
{

    int n,m,i,q,l,r,ans;
    sieve();

    scanint(n);
    scanint(m);



    for(i=0;i<n;i++)
        scanint(arr[i]);
    build_tree(1, 0, n-1);
    for(i=0;i<m;i++)
    {
       scanint(q); scanint(l); scanint(r);
       
        if(q==1)
        {
            ans = query_tree(1, 0, n-1, l-1, r-1);
            printf("%d\n",ans);
        }
        else
        {
            update_tree(1, 0, n-1, l-1, r);
            //cout<<"7 now has "<<tree[7]<<endl;
        }
    }


}
