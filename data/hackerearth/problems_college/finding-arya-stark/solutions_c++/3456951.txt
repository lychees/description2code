#include<stdio.h>
#include<iostream>
#include<list>
using namespace std;
int v,x,y;
int ar[100005],stT[100005],enT[100005];
class Graph
{
	int tN,tim=0;
	list<int> *adj_List;
	void _DFS(int curr, bool visited[], int par);
	
	public:
		Graph(int tN);
		void addEdge(int a, int b);
		void DFS();
};

Graph::Graph(int tN)
{
	this->tN=tN;
	adj_List=new list<int>[tN+1];
}

void Graph::addEdge(int a, int b)
{
	adj_List[a].push_back(b);
	adj_List[b].push_back(a);
}

void Graph::DFS()
{
	bool visited[tN+1];
	for(int i=0;i<tN+1;i++)
		visited[i]=false;
		
	_DFS(1,visited, 0);
}

void Graph::_DFS(int node, bool visited[], int dis)
{
	visited[node]=true;
	ar[node]=dis;
	tim=tim+1;
	stT[node]=tim;
	ar[node]=dis;
	//System.out.print(node+" ");
		
	list<int>::iterator i;
    for(i=adj_List[node].begin();i!=adj_List[node].end();i++)
       	if(!visited[*i])
        {
        	_DFS(*i, visited, dis+1);
        }   	
    tim=tim+1;
    enT[node]=tim;
}
	
int main()
{
		int N,a,b,q,par,cnt,flag;
		scanf("%d",&N);
		Graph g (N);
		for(int i=0;i<N-1;i++)
		{
			scanf("%d %d",&a,&b);
			g.addEdge(a,b);
		}
		g.DFS();
		cin>>q;
		while(q--)
		{
			scanf("%d %d %d",&v,&x,&y);
			if(v==0)
			{
				if((stT[x]<stT[y]) && (enT[x]>enT[y]))
					cout<<"YES "<<(ar[y]-ar[x]+1)<<endl;
				else cout<<"NO\n";
			}
			else
			{
				if((stT[x]>stT[y]) && (enT[x]<enT[y]))
					cout<<"YES "<<(ar[x]-ar[y]+1)<<endl;
				else cout<<"NO\n";
			}
			/*cnt=1;
			flag=0;
			if(v==0)
				par=y;
			else par=x;
			//cout<<par<<endl;
			while(par!=1)
			{
				par=ar[par];
				cnt++;
				if(v==0)
				{	if(par==x)
					{
						flag=1;
						break;
					}
						
				}
				else if(par==y)
					{
						flag=1;
						break;
					}
			}
			if(flag==0) printf("NO\n");
			else printf("YES %d\n",cnt);*/
		}
	return 0;
}