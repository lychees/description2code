#include <iostream>
using namespace std;
typedef long long ll;

const int MAXP = 100;
const int MAXNUM = 25;
int T;
ll N, M;
int K;
int mod[MAXNUM], sz;
int fac[MAXP][MAXNUM]; //fac[n][m] = n! mod m
int inv[MAXP][MAXNUM];

int power(ll a, ll b, int MOD)
{
	if (b == 0)
		return 1;
	if (b == 1)
		return a % MOD;
	if (b % 2 == 0)
		return power(a*a % MOD, b/2, MOD) % MOD;
	return a*power(a*a % MOD, (b-1)/2, MOD) % MOD;
}

void process()
{
	sz = 0;
	for (int i = 2, k = K; i <= 97; i++) //compute prime factors of K
		if (k % i == 0)
		{
			mod[sz++] = i;
			k /= i;
		}
			
	for (int i = 0; i < sz; i++)
	{
		fac[0][i] = inv[0][i] = 1;
		for (int j = 1; j < mod[i]; j++)
		{
			fac[j][i] = fac[j-1][i]*j % mod[i];
			inv[j][i] = power(fac[j][i], mod[i] - 2, mod[i]);
		}
	}
}

int C(int n, int r, int idx)
{
	if (n < r)
		return 0;
	return fac[n][idx]*(inv[r][idx]*inv[n-r][idx] % mod[idx]) % mod[idx];
}

int combination(int idx)
{
	int p = mod[idx], ret = 1;
	ll n = N - 1, m = M - 1;
	while (n != 0 || m != 0)
	{
		ret = ret*C(n % p, m % p, idx) % p;
		n /= p, m /= p;
	}
	return ret;
}

ll CRT()
{
	ll ans = 0;
	for (int i = 0; i < sz; i++)
	{
		ll m = K/mod[i];
		ll invm = power(m, mod[i] - 2, mod[i]);
		ll c = m*invm;
		int r = combination(i);
		ans = (ans + r*c % K) % K;
	}
	return ans;
}

int main()
{
    ios::sync_with_stdio(0);
    
    cin >> T;
    for (int t = 0; t < T; t++)
    {
    	cin >> N >> M >> K;
    	if (N < M)
    	{
    		cout << "0\n";
    		continue;
    	}
    	
    	process();
    	cout << CRT() << "\n";
    }
    
    return 0;
}
