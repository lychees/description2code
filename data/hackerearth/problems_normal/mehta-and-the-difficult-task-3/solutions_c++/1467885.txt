#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
// adapted from my own matrix exponentiation code (from koder kombat prelims)
#define int long long
const int mod=1e9+7; 
#define MATRIX vector<vector<int> >
MATRIX mult (MATRIX r, MATRIX rr)
{
    vector <int> l; MATRIX ans; for (int g=0;g<r.size(); g++) ans.push_back(l); 
    for (int g=0;g<r.size(); g++)
    {
        for (int y=0;y<rr[0].size(); y++)
        {int catcher=0; 
            for (int z=0;z<r[0].size(); z++)
            {
               catcher+=r[g][z]*rr[z][y]; catcher%=mod; 
            }
            ans[g].push_back(catcher); 
        }
    }return ans; 
}
MATRIX expo (int b, MATRIX orig)
{
    if (b==1) return orig;
    if (b&1)
    {MATRIX r=expo(b/2, orig); MATRIX rr=mult(r, orig); 
        return mult(r,rr); 
    }
    else
    {MATRIX r=expo(b/2, orig); 
        return mult(r,r);
    }
}
main() {
    int a; cin >> a;
    MATRIX init; vector <int> store; 
    store.push_back(1); for (int g=0; g<15; g++) store.push_back(0); 
    init.push_back(store); 
    MATRIX multiplier; 
    for (int g=0; g<16; g++)
    {
    	vector <int> k; 
    	for (int y=0; y<16; y++)
    	{
    		k.push_back(0); 
		}multiplier.push_back(k); 
	}
	for (int g=0; g<16; g++)
	{
		for (int y=0; y<16; y++)
		{
			if (g==y)
			{
				multiplier[g][y]=6; 
			}
			else
			{
				int r=(g^y); 
				if (r==1 || r==2 || r==4 || r==8) multiplier[g][y]=1; 
			}
		}
	}
	for (int g=0; g<a; g++)
	{
		int b, c, d, e, f; cin >> b >> c >> d >> e >> f;
		MATRIX as=mult(init, expo(b, multiplier)); 
		int find=c+2*d+4*e+8*f; 
		cout << as[0][find] << '\n'; 
	}
    return 0;
}
