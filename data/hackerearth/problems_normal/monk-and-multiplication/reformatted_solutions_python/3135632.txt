import heapq


def _heappush_max(heap, item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)


def _heappop_max(heap):
    """Maxheap version of a heappop."""
    lastelt = heap.pop()  # raises appropriate IndexError if heap is empty
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        heapq._siftup_max(heap, 0)
        return returnitem
    return lastelt


class MonkAndMultiplication():
    def runTheTest(self):
        arrSize = int(raw_input())
        self.Arr = [int(i) for i in raw_input().split(" ")]
        self.solve()

    def solve(self):
        q = []
        heapq._heapify_max(q)
        for i in xrange(len(self.Arr)):
            _heappush_max(q, self.Arr[i])
            if i < 2:
                print -1
                continue
            x = _heappop_max(q)
            y = _heappop_max(q)
            z = _heappop_max(q)
            print x*y*z
            _heappush_max(q, x)
            _heappush_max(q, y)
            _heappush_max(q, z)

    def myTest(self):
        self.Arr = [1, 2, 3, 4, 5]
        self.solve()


MaM = MonkAndMultiplication()
MaM.runTheTest()
