// Bismillah-ir-rahman-ir-rahim
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <cstring>
#define de(x) cerr << #x << "=" << x << endl
using namespace std;

const int maxn = 100009;
vector<int> G[maxn];
int visited[maxn];

int main() {
    int t; cin>>t;
    int caseNo=1;
    while(t--) {
        int n, a, b; cin>>n;
        for(int i=0; i<maxn; i++)
            G[i].clear();
        memset(visited, 0 , maxn*sizeof(visited[0]));
        int possibleMaxn=0;
        for(int i=0; i<n; i++) {
            cin>>a>>b;
            G[a].push_back(b);
            G[b].push_back(a);
            possibleMaxn = max(a, max(b, possibleMaxn));
        }

        // bfs
        queue<int> q;
        set<int> A, B;
        long long maxAns=0;
        for(int i=1; i<=possibleMaxn; i++) {
            if( visited[i] == 0  and G[i].size() > 0) {

                if(A.empty() and B.empty()) {
                    A.insert(i);
                    q.push(i);
                    // visited[i]=1;
                    /*for(int j=0; j<(int) G[i].size(); j++) {
                        // if(G[i][j]==i) continue;
                        B.insert(G[i][j]);
                        q.push(G[i][j]);
                    }*/
                    while(!q.empty()) {
                        int top = q.front(); q.pop();
                        if(visited[top] == 1) continue;
                        visited[top] = 1;
                        if(A.find(top) != A.end()) {
                            // push all it's neighbours to B
                            for(int j=0; j<(int) G[top].size(); j++) {
                                // if(G[top][j]==top) continue;
                                B.insert(G[top][j]);
                                q.push(G[top][j]);
                            }

                        } else {
                            for(int j=0; j<(int) G[top].size(); j++) {
                                // if(j==top) continue;
                                A.insert(G[top][j]);
                                q.push(G[top][j]);
                            }

                        }

                    }
                }
                maxAns += max(A.size(), B.size());
                A.clear(); B.clear();
            }
        }
        cout<< "Case "<< caseNo <<": " <<maxAns<<endl;
        caseNo++;
    }

    return 0;
}

