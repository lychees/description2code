#include<bits/stdc++.h>
using namespace std;
class Segment
{
	public:
		int node;
		int *a;
		char temp;
		int *tree;
		int *lazy;
		void build(int node,int st, int end);
		void updateRange(int node,int st, int end, int l, int r);
		int query(int node,int st,int end,int l,int r);
		Segment(int n);
		void buildA(int n);
		
};
Segment::Segment(int n)
{
	a=new int [n];
	tree=new int [4*n];
	lazy=new int [4*n];
	for(int i=0;i<4*n;i++)
	{
		lazy[i]=0;
	}
}
void Segment::buildA(int n)
{
	for(int i=1;i<n;i++)
	{
		cin>>temp;
		if(temp=='<')
		a[i]=1;
		else
		a[i]=0;
	}
}
void Segment::build(int node ,int st,int end)
{
	if(st==end)
	{
		tree[node]=a[st];
	}
	else
	{
		int mid=(st+end)/2;
		build(2*node,st,mid);
		build(2*node+1,mid+1,end);
		tree[node]=tree[2*node]+tree[2*node+1];
	}
}
void Segment:: updateRange(int node,int st, int end, int l, int r)
{
	if(lazy[node]!=0)
	{
		tree[node]=(end-st+1)-tree[node];
		if(st!=end)
		{
			lazy[node*2]++;
			lazy[node*2+1]++;
			if(lazy[node*2]%2!=0)
			lazy[node*2]=1;
			else
			lazy[node*2]=0;
			if(lazy[node*2+1]%2!=0)
			lazy[node*2+1]=1;
			else
			lazy[node*2+1]=0;
			
		}
		lazy[node]=0;
	}
	if(st>end || st>r || end<l)
	{
		return;
	}
	if(st>=l && end<=r)
	{
		tree[node]=(end-st+1)-tree[node];
		
		if(st!=end)
		{
			lazy[node*2]++;
			lazy[node*2+1]++;
			if(lazy[node*2]%2!=0)
			lazy[node*2]=1;
			else
			lazy[node*2]=0;
			if(lazy[node*2+1]%2!=0)
			lazy[node*2+1]=1;
			else
			lazy[node*2+1]=0;
		}
		return;
	}
	int mid=(st+end)/2;
	updateRange(node*2,st,mid,l,r);
	updateRange(node*2+1,mid+1,end,l,r);
	tree[node]=tree[node*2]+tree[node*2+1];
}
int Segment::query(int node,int st,int end,int l,int r)
{

		if(lazy[node]!=0)
		{
			tree[node]=(end-st+1)-tree[node];
			if(st!=end)
			{
				lazy[node*2]++;
				lazy[node*2+1]++;
				if(lazy[node*2]%2!=0)
				lazy[node*2]=1;
				else
				lazy[node*2]=0;
				if(lazy[node*2+1]%2!=0)
				lazy[node*2+1]=1;
				else
				lazy[node*2+1]=0;
				
			}
			lazy[node]=0;
		}
		if(st>end || st>r || end<l)
		return 0;
		if(st>=l && end<=r)
		{
			return tree[node];
		}
		int mid=(st+end)/2;
		int p1=query(node*2,st,mid,l,r);
		int p2=query(node*2+1,mid+1,end,l,r);
		return (p1+p2);
	
}
int main()
{
	int  n,m,ans;
	cin>>n>>m;
	int qn,l,r;
	Segment seg(n);
	seg.buildA(n);
	seg.build(1,1,n-1);
	while(m--)
	{
		cin>>qn>>l>>r;
		if(qn==1)
		{
			seg.updateRange(1,1,n-1,l,r-1);
		}
		else
		{
			if(l<r)
			ans=seg.query(1,1,n-1,l,r-1);
			else
			{
				ans=l-r-seg.query(1,1,n-1,r,l-1);
				
			}
			cout<<ans<<endl;
		}
	}
	return 0;
}