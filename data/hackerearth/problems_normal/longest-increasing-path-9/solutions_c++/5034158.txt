//
//  main.cpp
//  LongestIncreasingpathHE
//
//  Created by Shashank Shekhar on 02/09/16.
//  Copyright Â© 2016 Shashank Shekhar. All rights reserved.
//

#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <unordered_map>
#include <map>
#include <set>
#include <queue>
#include <cstring>
#include <sstream>
#include <iterator>
#include <stack>
#define minInt INT_MIN
#define maxInt INT_MAX
#define umaxInt UINT_MAX
#define llminInt LLONG_MIN
#define llmaxInt LLONG_MAX
#define MOD 1000000007
#define mp(a, b) make_pair(a, b)
#define F first
#define S second
#define pb(a) push_back(a)
#define sze(a) (int)(a.size())
#define fr(i,a,N) for (int i =a;i<N;i++)
#define fre(i,a,N) for (int i =a;i<=N;i++)
#define frr(i,a,N) for (int i = a;i>=N;--i)
#define lli long long int
#define ulli  unsigned long long int
#define ui unsigned int
#define pii pair<int,int>
#define vi vector<int>
#define vpii vector<pair<int,int>>
#define vpsi vector<pair<string,int>>
#define print_array(a,n) for(i=0;i<=n;i++) cout<<a[i]<<" ";
using namespace std;

int N,M;
bool check(int x,int y ) {
    if (x>=N || x<0) return false;
    if (y>=M || y<0) return false;
    return true;
}
int ar[102][102];
int dp[102][102];
int recurse(int x,int y) {
    if (dp[x][y] != 0) return dp[x][y];
    int r=1,c=1;
    if (check(x+1,y) && ar[x+1][y] > ar[x][y])
        r+=recurse(x+1,y);
    if (check(x,y+1) && ar[x][y+1] > ar[x][y])
        c+=recurse(x,y+1);
    return dp[x][y] = max (r,c);
}
int main(int argc, const char * argv[]) {
    // insert code here...
    int t;
    cin >>t;
    while (t--) {
        cin >>N>>M;
        memset(dp,0,sizeof dp);
        fr(i,0,N)
        fr(j,0,M)
        cin >>ar[i][j];
        cout << recurse(0,0) << "\n";
    }
    
    return 0;
}
