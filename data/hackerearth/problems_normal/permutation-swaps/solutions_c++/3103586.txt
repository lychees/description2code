/*
A tale is only good as its final turn of events, the plot twist.
Failures must be seen as mere amusements!
They are trials, which hone your skills. I lived believing that
And in return, I swore I would accomplish a deed so great that it would obliterate all of my failuresÂ¦
- Jiraya
*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
#include <climits>
#include <iomanip>
#include <cassert>
#include <cmath>
using namespace std;

#define trace(x) {cerr << #x << "=" << x <<endl;}
#define trace2(x, y) {cerr << #x << "=" << x << " " << #y << "=" << y <<endl;}
#define trackarr(x, n) {cerr << #x << ":" << endl; for (int q = 0; q < n; q++) {cerr << x[q] << " ";} cerr << endl;}
#define track(x) {cerr << #x << ":" << endl; for (int q = 0; q < x.size(); q++) {cerr << x[q] << " ";} cerr << endl;}
#define trackvv(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) { cerr << "i:" << i << endl; for (int j = 0; j < x[i].size(); j++){cerr << x[i][j] << " ";} cerr << endl;} cerr << endl;}
#define trackcr(x) {cerr << #x << ":" << endl; for (auto i = x.begin(); i != x.end(); i++) {cerr << *i << " ";} cerr << endl;}

const int MAX = 100005;
const int MOD = 1000000007;
const int INF = 1000000000;

class Disjoint_Set {
	private:
		vector<unsigned> P;
		vector<unsigned> rank;
	public:
		Disjoint_Set(int n)
		{
			P.resize(n);
			rank.resize(n);
			for (int i = 0; i < n; i++)
				P[i] = i;
		}
		void merge(unsigned node_x, unsigned node_y)
		{
			unsigned rep_x = find(node_x);
			unsigned rep_y = find(node_y);
			if (rank[rep_x] > rank[rep_y])
				P[rep_y] = rep_x;
			else {
			        P[rep_x] = rep_y;
				if (rank[rep_x] == rank[rep_y])
					rank[rep_y]++;
			}
		}
		unsigned int find(unsigned node)
		{
			unsigned tmp = node;
			while (node != P[node]) {
				node = P[tmp];
				tmp = node;
			}
			return node;
		}
};

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        map<int,int> positionP;
        vector<int> P(n), Q(n);
        for (int i = 0; i < n; i++) {
            cin >> P[i];
            positionP[P[i]] = i;
        }
        for (int i = 0; i < n; i++){
            cin >> Q[i];
        }
        Disjoint_Set D(n);
        while (m--){
            int x, y;
            cin >> x >> y;
            x--, y--;
            D.merge(x, y);
        }
        bool isPossible = true;
        for (int i = 0; i < n; i++) {
            isPossible &= (D.find(positionP[Q[i]]) == D.find(i));
        }
        if (isPossible) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
    }
}
