#include <bits/stdc++.h>
#include <stdlib.h>
using namespace std;
const long long mod=1e9+7;
 
#define llu long long unsigned
#define lld long long
#define ld long
#define sc(a) scanf("%lld",&a)
#define sc2(a,b) scanf("%lld%lld",&a,&b)
#define sc3(a,b,c) scanf("%lld%lld%lld",&a,&b,&c)
#define scf(a) scanf("%lf",&a)
#define scf2(a,b) scanf("%lf%lf",&a,&b)
#define scf3(a,b,c) scanf("%lf%lf%lf",&a,&b,&c)
#define prL(a) printf("%lld\n",a)
#define prS(a) printf("%lld ",a)
#define prfL(a) printf("%lf\n",a)
#define prfS(a) printf("%lf ",a)
#define popcount __builtin_popcountll
#define swap(a,b,t) t=a;a=b;b=t
typedef pair<lld,lld> PA;
 
#define lim 20003
#define lim2 3003
 // lld A[lim],D[lim],B[lim];
 // char C[lim2][lim2];
 //string A,B;
// char S[lim];
// map<lld,lld> M;
// map<lld,lld>::iterator it;
// map<string,lld> M,Mn;
// string S[lim];

// multiset<lld> S;
//std::vector<lld> A[400];
// set<lld> S;
// string S;
// lld A[10003][12];
// vector<lld> V[lim],ANS;

// lld A[53][53],C[53][53],dp[53][53];

lld A[5][lim],M[5][4*lim],Lazy[5][4*lim];

void buildT(lld M[],lld A[],lld Lazy[],lld l,lld r,lld ind){
    if(l==r){
        M[ind]=A[l];
        Lazy[ind]=0;
        return ;
    }
    Lazy[ind]=0;
    lld mid=l+(r-l)/2;
    buildT(M,A,Lazy,l,mid,2*ind+1);
    buildT(M,A,Lazy,mid+1,r,2*ind+2);
    M[ind]=M[2*ind+1]+M[2*ind+2];
}

void updateN(lld M[],lld A[],lld Lazy[],lld l,lld r,lld ind,lld x){
    Lazy[ind]+=x;
    M[ind]=M[ind]+x*(r-l+1);
}

void shift(lld M[],lld A[],lld Lazy[],lld l,lld r,lld ind){
    lld mid=l+(r-l)/2;
    updateN(M,A,Lazy,l,mid,2*ind+1,Lazy[ind]);
    updateN(M,A,Lazy,mid+1,r,2*ind+2,Lazy[ind]);
    Lazy[ind]=0;
}

void increase(lld M[],lld A[],lld Lazy[],lld st,lld end,lld l,lld r,lld ind,lld x){
    if(end<l||st>r) return ;
    if(l>=st&&r<=end){
        updateN(M,A,Lazy,l,r,ind,x);
        return ;
    }
    shift(M,A,Lazy,l,r,ind);
    lld mid =l+(r-l)/2;
    increase(M,A,Lazy,st,end,l,mid,2*ind+1,x);
    increase(M,A,Lazy,st,end,mid+1,r,2*ind+2,x);
    M[ind]=M[2*ind+1]+M[2*ind+2];
}

lld query(lld M[],lld A[],lld Lazy[],lld st,lld end,lld l,lld r,lld ind){
    if(end<l||st>r) return 0;
    if(l>=st&&r<=end){
        return M[ind];
    }
    shift(M,A,Lazy,l,r,ind);
    lld mid=l+(r-l)/2;
    return query(M,A,Lazy,st,end,l,mid,2*ind+1)+query(M,A,Lazy,st,end,mid+1,r,2*ind+2);
}

int main(){
    lld T,i,j,k,l,r,s,a,b,c,d,w,x,y,v,z,m,n,t,p,q,curr,sum,ans,pos,val,countA,secondMin;
    sc2(n,m);
    lld N[5],R[5];
    R[0]=16;R[1]=9;R[2]=26;R[3]=26;R[4]=1;
    for(i=0;i<n;i++){
    	sc(A[i%5][i/5]);
    	N[i%5]=i/5;
    }
//    sc(m);
    for(i=0;i<=4;i++) buildT(M[i],A[i],Lazy[i],0,N[i],0);

    while(m--){
        sc3(z,l,r);
        l--;r--;
        if(z==1){
        	i=0;
        	sum=0;
        	for(j=l;(j<=r&&i<=4);j++){
        		a=j/5;
        		b=a+(r-j)/5;
        		sum+=query(M[j%5],A[j%5],Lazy[j%5],a,b,0,N[j%5],0);
        		i++;
        	}
        	printf("%lld/%lld\n",sum,r-l+1 );
        }
        else{
        	i=0;
        	for(j=l;(j<=r&&i<=4);j++){
        		a=j/5;
        		b=a+(r-j)/5;
        		increase(M[j%5],A[j%5],Lazy[j%5],a,b,0,N[j%5],0,R[i]);
        		i++;
        	}
        }
        // t=query(0,x-1,0,n-1,0);
        // prL(t);
        // increase(0,x-1,0,n-1,0,t+y);
    }
    return 0;
}