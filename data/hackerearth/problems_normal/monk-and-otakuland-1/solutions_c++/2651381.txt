#include<bits/stdc++.h>
using namespace::std;
#define ll long long int
const int N = 1000000;
ll tree[N];
ll arr[N];
ll lazy[N];

void build(ll node,ll start,ll end)
{
	if(start==end)
	{
		tree[node]=arr[start];
		lazy[node]=0;
		return ;
	}	
	ll mid = (start+end)/2;
	build(node*2,start,mid);
	build(node*2+1,mid+1,end);
	tree[node]=tree[node*2]+tree[node*2+1];
}

void update(ll node,ll start,ll end,ll l,ll r)
{
	if(lazy[node])
	{
		if(lazy[node]&1)
		tree[node]=(end-start+1)-tree[node];
		lazy[2*node]+=lazy[node];
		lazy[2*node+1]+=lazy[node];
		lazy[node]=0;
	}	

	if(start>r || end<l)
	return ;
	
	if(start>=l && end<=r)
	{
		tree[node]=(end-start+1)-tree[node];
		lazy[2*node]++;
		lazy[2*node+1]++;
		return;
	}	

	ll mid = (start+end)/2;
	update(node*2,start,mid,l,r);
	update(2*node+1,mid+1,end,l,r);

	tree[node]=tree[node*2]+tree[node*2+1];
}

ll query(ll node,ll start,ll end,ll l,ll r)
{
	if(lazy[node])
	{
		if(lazy[node]%2!=0)
		tree[node]=(end-start+1)-tree[node];
		lazy[2*node]+=lazy[node];
		lazy[2*node+1]+=lazy[node];
		lazy[node]=0;
	}

	if(start>r || end<l)
	return 0;
	
	if(start>=l && end<=r)
	return tree[node];
	
	ll mid = (start+end)/2;
	return query(2*node,start,mid,l,r)+query(2*node+1,mid+1,end,l,r);
}

int main()
{
	ll i,j,k,q,t,l,r,n,type;
	string s;
	cin>>n>>q;

	cin>>s;
	for(i=1;i<n;i++)
	{
		if(s[i-1]=='>')
		arr[i]=1;
		else
		arr[i]=0;
	}

	build(1,1,n-1);
	//cout<<tree[1]<<endl;

	while(q--)
	{
		scanf("%ld %ld %ld",&type,&l,&r);
		if(type==1)
		{
			r--;
			update(1,1,n-1,l,r);
		}
		else
		{
			if(l<r)
			{
				r--;
				printf("%lld\n",((r-l+1)-query(1,1,n-1,l,r)));
				
			}	
			else if(l>r)
			{
				l--;
				printf("%lld\n",query(1,1,n-1,r,l));	
			}
			else 
			printf("0\n");
		}
	}	
}