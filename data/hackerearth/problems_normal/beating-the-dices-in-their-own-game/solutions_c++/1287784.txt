#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll oo = (ll)1e15;
const int MAXN = 101;
typedef vector<ll> VI;
typedef vector<VI> VVI;

#define pb push_back

int n, a, b, m[MAXN], q, ask;
vector<pair<int, int> > v[MAXN];
vector<int> Lmate, Rmate;

ll labs(ll a) {
	if (a < 0) return -a;
	return a;
}

ll MinCostMatching(const VVI &cost, vector<int> &Lmate, vector<int> &Rmate) {
	int n = int(cost.size());

  	// construct dual feasible solution
  	VI u(n);
  	VI v(n);
  	for (int i = 0; i < n; i++) {
    	u[i] = cost[i][0];
    	for (int j = 1; j < n; j++) u[i] = min(u[i], cost[i][j]);
  	}
  	for (int j = 0; j < n; j++) {
	    v[j] = cost[0][j] - u[0];
	    for (int i = 1; i < n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
  	}
  
  	// construct primal solution satisfying complementary slackness
  	Lmate = vector<int>(n, -1);
  	Rmate = vector<int>(n, -1);
  	int mated = 0;
  	for (int i = 0; i < n; i++) {
	    for (int j = 0; j < n; j++) {
	      if (Rmate[j] != -1) continue;
	      if (labs(cost[i][j] - u[i] - v[j]) == 0) {
			Lmate[i] = j;
			Rmate[j] = i;
			mated++;
			break;
    	  }
	    }
  	}
  
  	VI dist(n);
  	vector<int> dad(n);
  	vector<int> seen(n);
  
  	// repeat until primal solution is feasible
  	while (mated < n) {
    	// find an unmatched left node
    	int s = 0;
    	while (Lmate[s] != -1) s++;
    
    	// initialize Dijkstra
    	fill(dad.begin(), dad.end(), -1);
    	fill(seen.begin(), seen.end(), 0);
    	for (int k = 0; k < n; k++) 
      		dist[k] = cost[s][k] - u[s] - v[k];
    
    	int j = 0;
    	while (true) {
      		// find closest
      		j = -1;
      		for (int k = 0; k < n; k++) {
				if (seen[k]) continue;
				if (j == -1 || dist[k] < dist[j]) j = k;
      		}
      		seen[j] = 1;
      		// termination condition
      		if (Rmate[j] == -1) break;
      		// relax neighbors
      		const int i = Rmate[j];
      		for (int k = 0; k < n; k++) {
				if (seen[k]) continue;
				const ll new_dist = dist[j] + cost[i][k] - u[i] - v[k];
				if (dist[k] > new_dist) {
	  				dist[k] = new_dist;
	  				dad[k] = j;
				}
      		}
    	}
    	// update dual variables
    	for (int k = 0; k < n; k++) {
      		if (k == j || !seen[k]) continue;
      		const int i = Rmate[k];
      		v[k] += dist[k] - dist[j];
      		u[i] -= dist[k] - dist[j];
    	}
    	u[s] += dist[j];
    	// augment along path
    	while (dad[j] >= 0) {
      		const int d = dad[j];
      		Rmate[j] = Rmate[d];
      		Lmate[Rmate[j]] = j;
      		j = d;
    	}
    	Rmate[j] = s;
    	Lmate[s] = j;
    	mated++;
  	}
  
  	ll value = 0;
  	for (int i = 0; i < n; i++)
    	value += cost[i][Lmate[i]];
  
  	return value;
}


int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
    	scanf("%d", &m[i]);
    	for (int j = 0; j < m[i]; j++) {
    		scanf("%d%d", &a, &b);
    		v[i].pb(make_pair(a, b));
    	}
    }
    scanf("%d", &q);
    while (q--) {
    	map<int, vector<int> > mp;
    	for (int i = 0; i < n; i++) {
    		scanf("%d", &ask);
    		mp[ask].push_back(i);
    	}
    	VVI cost;
    	cost.resize(n);
    	for (int i = 0; i < n; i++) {
			cost[i].resize(n);
    		for (int j = 0; j < n; j++) cost[i][j] = oo;
    		for (int j = 0; j < m[i]; j++) {
    			if (mp.find(v[i][j].first) != mp.end()) {
					vector<int> res = mp[v[i][j].first];
					for (int k = 0; k < res.size(); k++)
    					cost[i][res[k]] = v[i][j].second;
				}
    		}
    	}
    	ll ans = MinCostMatching(cost, Lmate, Rmate);
    	if (ans >= oo) ans = -1;
    	printf("%lld\n", ans);
    }
    return 0;
}
