#include<algorithm>
#include<string>
#include<string.h>
#include<stdio.h>
#include<map>
#define max(a,b) ((a)>(b)?(a):(b))
#define fr(i,n) for(i=0;i<(n);i++)
using namespace std;
char q[300005],a[300005],b[300005];
string s,t1,t2,tmp;
int a1[300005],a2[300005],n1,n2;
map<string,int> mp;

void computeLPSArray(char *pat, int M, int *lps);
//KMP implementation from GFG
//Suffix array & LCP implementation from http://apps.topcoder.com/forums/?module=RevisionHistory&messageID=1171511

void KMPSearcha(char *pat, char *txt)
{
    int M = strlen(pat);
    int N = strlen(txt);
    // create lps[] that will hold the longest prefix suffix values for pattern
    int *lps = (int *)malloc(sizeof(int)*M);
    int j  = 0;  // index for pat[]
    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);
    int i = 0;  // index for txt[]
    while(i < N)
    {
      if(pat[j] == txt[i])
      {
        j++;
        i++;
      }
      if (j == M)
      {
        //a1[n1++]=i-j;
        a1[i-j]=1;
        //printf("Found pattern at index %d \n", i-j);
        j = lps[j-1];
      }
      // mismatch after j matches
      else if(pat[j] != txt[i])
      {
        // Do not match lps[0..lps[j-1]] characters,
        // they will match anyway
        if(j != 0)
         j = lps[j-1];
        else
         i = i+1;
      }
    }
    free(lps); // to avoid memory leak
}
void KMPSearchb(char *pat, char *txt)
{
    int M = strlen(pat);
    int N = strlen(txt);
    // create lps[] that will hold the longest prefix suffix values for pattern
    int *lps = (int *)malloc(sizeof(int)*M);
    int j  = 0;  // index for pat[]
    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);
    int i = 0;  // index for txt[]
    while(i < N)
    {
        if(i > 0)
        a2[i] = a2[i-1];
      if(pat[j] == txt[i])
      {
        j++;
        i++;
      }
      if (j == M)
      {
        //a1[n1++]=i-j;
        a2[i-1]++;
        //printf("Found pattern at index %d \n", i-j);
        j = lps[j-1];
      }
      // mismatch after j matches
      else if(pat[j] != txt[i])
      {
        // Do not match lps[0..lps[j-1]] characters,
        // they will match anyway
        if(j != 0)
         j = lps[j-1];
        else
         i = i+1;
      }
    }
    free(lps); // to avoid memory leak
}
void computeLPSArray(char *pat, int M, int *lps)
{
    int len = 0;  // lenght of the previous longest prefix suffix
    int i;

    lps[0] = 0; // lps[0] is always 0
    i = 1;

    // the loop calculates lps[i] for i = 1 to M-1
    while(i < M)
    {
       if(pat[i] == pat[len])
       {
         len++;
         lps[i] = len;
         i++;
       }
       else // (pat[i] != pat[len])
       {
         if( len != 0 )
         {
           // This is tricky. Consider the example AAACAAAA and i = 7.
           len = lps[len-1];

           // Also, note that we do not increment i here
         }
         else // if (len == 0)
         {
           lps[i] = 0;
           i++;
         }
       }
    }
}


// Begins Suffix Arrays implementation
// O(n log n) - Manber and Myers algorithm
// Refer to "Suffix arrays: A new method for on-line string searches",
// by Udi Manber and Gene Myers

//Usage:
// Fill str with the characters of the string.
// Call SuffixSort(n), where n is the length of the string stored in str.
// That's it!

//Output:
// pos = The suffix array. Contains the n suffixes of str sorted in lexicographical order.
//       Each suffix is represented as a single integer (the position of str where it starts).
// rk = The inverse of the suffix array. rk[i] = the index of the suffix str[i..n)
//        in the pos array. (In other words, pos[i] = k <==> rk[k] = i)
//        With this array, you can compare two suffixes in O(1): Suffix str[i..n) is smaller
//        than str[j..n) if and only if rk[i] < rk[j]
#define N 300005
int str[N]; //input
int rk[N], pos[N]; //output
int cnt[N], nx[N]; //internal
bool bh[N], b2h[N];

// Compares two suffixes according to their first characters
bool smaller_first_char(int a, int b){
  return str[a] < str[b];
}

void suffixSort(int n){
  //sort suffixes according to their first characters
  for (int i=0; i<n; ++i){
    pos[i] = i;
  }
  sort(pos, pos + n, smaller_first_char);
  //{pos contains the list of suffixes sorted by their first character}

  for (int i=0; i<n; ++i){
    bh[i] = i == 0 || str[pos[i]] != str[pos[i-1]];
    b2h[i] = false;
  }

  for (int h = 1; h < n; h <<= 1){
    //{bh[i] == false if the first h characters of pos[i-1] == the first h characters of pos[i]}
    int buckets = 0;
    for (int i=0, j; i < n; i = j){
      j = i + 1;
      while (j < n && !bh[j]) j++;
      nx[i] = j;
      buckets++;
    }
    if (buckets == n) break; // We are done! Lucky bastards!
    //{suffixes are separted in buckets containing strings starting with the same h characters}

    for (int i = 0; i < n; i = nx[i]){
      cnt[i] = 0;
      for (int j = i; j < nx[i]; ++j){
        rk[pos[j]] = i;
      }
    }

    cnt[rk[n - h]]++;
    b2h[rk[n - h]] = true;
    for (int i = 0; i < n; i = nx[i]){
      for (int j = i; j < nx[i]; ++j){
        int s = pos[j] - h;
        if (s >= 0){
          int head = rk[s];
          rk[s] = head + cnt[head]++;
          b2h[rk[s]] = true;
        }
      }
      for (int j = i; j < nx[i]; ++j){
        int s = pos[j] - h;
        if (s >= 0 && b2h[rk[s]]){
          for (int k = rk[s]+1; !bh[k] && b2h[k]; k++) b2h[k] = false;
        }
      }
    }
    for (int i=0; i<n; ++i){
      pos[rk[i]] = i;
      bh[i] |= b2h[i];
    }
  }
  for (int i=0; i<n; ++i){
    rk[pos[i]] = i;
  }
}
// End of suffix array algorithm


// Begin of the O(n) longest common prefix algorithm
// Refer to "Linear-Time Longest-Common-Prefix Computation in Suffix
// Arrays and Its Applications" by Toru Kasai, Gunho Lee, Hiroki
// Arimura, Setsuo Arikawa, and Kunsoo Park.
int height[N];
// height[i] = length of the longest common prefix of suffix pos[i] and suffix pos[i-1]
// height[0] = 0
void getHeight(int n){
  for (int i=0; i<n; ++i) rk[pos[i]] = i;
  height[0] = 0;
  for (int i=0, h=0; i<n; ++i){
    if (rk[i] > 0){
      int j = pos[rk[i]-1];
      while (i + h < n && j + h < n && str[i+h] == str[j+h]) h++;
      height[rk[i]] = h;
      if (h > 0) h--;
    }
  }
}
// End of longest common prefixes algorithm


int main()
{
    int n,i,j,k,t,f=-1,j1,cnt;
    while(scanf("%s",q)!=EOF)
    {
        scanf("%s%s",a,b);
        n=strlen(q);
        int l1=strlen(a);
        int l2=strlen(b);
        fr(i,n)
        {a1[i]=0; a2[i]=0;}
        long long int cnt=0;
        f=-1;
        n1=n2=0;
        mp.clear();
        KMPSearcha(a,q);
        KMPSearchb(b,q);

        fr(i,n)
        str[i] = q[i];

        suffixSort(n);
        getHeight(n);


        fr(i,n)
        {
            if(a1[pos[i]] == 1)
            {
                int e = pos[i] + max(height[i],max(l1-1,l2-1));
                int val = 0;
                if(e==0)
                val=a2[n-1];
                else
                {
                    if(e>0&&e<n)
                    val=a2[n-1]-a2[e-1];
                }
                long long int tcaste = val;
                cnt += tcaste;
            }
        }

        /*i=j=0;

        while(i<n1 && j<n2)
        {
            if(a1[i]+t1.length()<=a2[j])
            {
                for(j1=j;j1<n2;j1++)
                {
                tmp=s.substr(a1[i],a2[j1]-a1[i]);
                    if(mp.find(tmp)==mp.end())
                    {
                        cnt++;
                        mp[tmp]=1;
                    }
                }
               // cnt+=n2-j;
                i++;
            }
            else
                j++;
        }*/
        printf("%lld\n",cnt);

    }

}
