#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp> 

using namespace std;
using namespace __gnu_pbds;

#define INF 1000000007

typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vector<int> > vvi;
typedef pair<int,int> ii;
typedef vector<pair<int,int> > vii;
typedef vector<vector<pair<int,int> > > vvii;

#define all(x) (x).begin(), (x).end()
#define nall(x) (x).rbegin(), (x).rend()
#define sz(a) int((a).size()) 
#define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define pb push_back 
#define F first
#define S second
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define NFOR(i,a,b) for(int i=(a);i>=(b);--i)
#define TCASE int __T;cin>>__T;FOR(Tc,1,__T)
inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;}
inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);}
#define mid ((l+r)>>1)
int n,m,mod;

vi a,f;
vii t;

void upd(int no,int l,int r,int pos, int val)
{
    if(l==r)
    {
        t[no].F=(val*1LL*f[l])%mod;
        t[no].S=(val*1LL*f[l+1])%mod;
        return;
    }
    if(pos<=mid)
        upd(2*no,l,mid,pos,val);
    else
        upd(2*no+1,mid+1,r,pos,val);

    t[no].F=add(t[2*no].F,t[2*no+1].F,mod);
    t[no].S=add(t[2*no].S,t[2*no+1].S,mod);

}
ii qry(int no,int l,int r, int u, int v)
{
    if(r<u or l>v)return make_pair(0,0);
    if(l>=u and r<=v)return t[no];
    
    ii x = qry(2*no,l,mid,u,v);ii y=qry(2*no+1,mid+1,r,u,v);
    ii ans;
    ans.F=add(x.F,y.F,mod);
    ans.S=add(x.S,y.S,mod);
    return ans;
}
inline int fib(int n)
{
    if(n<0)
    {
        n=-n;
        if(n&1)
            return f[n];
        else return add(mod-f[n],0,mod);
    }
    return f[n];
}
int main()
{
    boost;
    cin>>n>>m>>mod;
    a.resize(n+1);
    f.resize(n+10);
    t.resize(4*n+10);
    FOR(i,0,n-1)cin>>a[i];
    f[1]=1;
    FOR(i,2,n+9)f[i]=add(f[i-1],f[i-2],mod);
    FOR(i,0,n-1)upd(1,1,n,i+1,a[i]);
    
    FOR(i,0,m-1){
        int x,y,z;
        cin>>x>>y>>z;
        if(x==1)
        {
            upd(1,1,n,y,z);
            continue;
        }
        
        ii ans =qry(1,1,n,y,z);
        // cout<<ans.F<<" "<<ans.S<<"\n";
        cout<<(ans.F*1LL*fib(-y)+ans.S*1LL*fib(-y+1))%mod<<"\n";
    }
    
    return 0;
}
