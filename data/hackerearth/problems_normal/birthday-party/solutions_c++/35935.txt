#include <algorithm>
#include <assert.h>
#include <stdio.h>
#include <iostream>
#include <string>
#include <string.h>

using namespace std;

int dp[1010];
int a[1010];
int done[1010][1010];
int n;

int f(int sum, int pos){
	if(sum >= 1001) return 0;
	dp[sum] = 1;
	if(pos >= n) return 0;
	
	if(done[sum][pos] != -1) return 0;
	done[sum][pos] = 0;

	f(sum + a[pos], pos+1);
	f(sum, pos+1);
	return 0;
}

bool possible(int sum, int pos){
	if(sum < 0) return 0;
	if(sum == 0) return 1;
	if(pos >= n) return 0;
	if(done[sum][pos] != -1) return done[sum][pos];
	
	int x = possible(sum - a[pos], pos+1);
	int y = possible(sum, pos+1);
	
	return done[sum][pos] = (x || y);
	
	
}
int main(){
	int t; cin >> t;
	while(t--){
		memset(dp, 0, sizeof dp);
		memset(done, -1, sizeof done);
		int p;
		cin >> p >> n;
		for(int i = 0; i < n; i++){
			cin >> a[i];
		}
		//int ans = 0;
		f(0, 0);
	
		int z[1010];

		for(int i = 0; i < p; i++) {
			cin >> z[i];
			assert(z[i] <= 1000);
		}
		sort(z, z+p);
		long long ans = 0;
		for(int i = 0; i < p; i++){
			int cnt = 0;
			for(int j = i; j < p; j++) {
				cnt += (z[i] == z[j]);
				
			}
			while(i < p-1 && z[i] == z[i+1]) i++;
			
				assert(cnt <= 1000);
				if(cnt == 0) continue;
				if(dp[cnt]) ans++;
			//	if(possible(cnt, 0)) ans++;
			
		}
		cout << ans << endl;
	}
	return 0;
}