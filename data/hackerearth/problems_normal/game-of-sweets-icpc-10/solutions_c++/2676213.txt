
// karanaggarwal
//#include <bits/stdc++.h>
#include <cstring>
#include <queue>
#include <stack>
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>
#include <complex>
using namespace std;
#define TRACE
#ifdef TRACE
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1){
    cerr << name << " : " << arg1 << std::endl;
}
template <typename Arg1, typename... Args>
void __f(const char* names, Arg1&& arg1, Args&&... args){
    const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...);
}
#else
#define trace(...)
#endif

#define si(x) scanf("%d",&x)
#define F first
#define S second
#define PB push_back
#define MP make_pair


typedef long long LL;
typedef pair<int,int> PII;
typedef vector<int> VI;
typedef vector<PII> VPII;
const double PI = 4*atan(1);
typedef complex<double> base;
vector<base> omega;
int FFT_N;
void init_fft(int n)
{
    FFT_N = n;
    omega.resize(n);
    double angle = 2 * PI / n;
    for(int i = 0; i < n; i++)
        omega[i] = base( cos(i * angle), sin(i * angle));
}
void fft (vector<base> & a)
{
    int n = (int) a.size();
    if (n == 1) 
        return;
    int half = n >> 1;
    vector<base> even (half), odd (half);
    for (int i=0, j=0; i<n; i+=2, ++j)
    {
        even[j] = a[i];
        odd[j] = a[i+1];
    }
    fft (even), fft (odd);
    for (int i=0, fact = FFT_N/n; i < half; ++i)
    {
        base twiddle = odd[i] * omega[i * fact] ;
        a[i] = even[i] + twiddle;
        a[i+half] = even[i] - twiddle;
    }
}

void multiply (const vector<long long> & a, const vector<long long> & b, vector<long long> & res)
{
    vector<base> fa (a.begin(), a.end()), fb (b.begin(), b.end());
    int n = 1;
    while (n < 2*max (a.size(), b.size())) 
        n <<= 1;
    fa.resize (n), fb.resize (n);
    init_fft(n);
    fft (fa), fft (fb);
    for (size_t i=0; i<n; ++i)
        fa[i] = conj( fa[i] * fb[i]);
    fft (fa);
    res.resize (n);
    for (size_t i=0; i<n; ++i)
        res[i] = (long long) (fa[i].real() / n + 0.5);
}

const int off = 100000;

int main()
{
    int n; si(n);
    vector<LL> a(off+1);
    vector<LL> b(off+1);
    int ans = 0;
    for(int i = 0; i<n; i++)
    {
        int x; si(x);
        if(a[x]) ans = 1;
        a[x] = 1; 
        b[off-x]=1;
    }
    vector<LL> c;
    multiply(a,b,c);

    for(int i = off+1; i<c.size() and i<=2*off; i++)
    {
        //if(c[i])trace(i-off, c[i]);
        if(c[i]) ans++;
    }
    cout<<ans<<endl;
    return 0;
}
