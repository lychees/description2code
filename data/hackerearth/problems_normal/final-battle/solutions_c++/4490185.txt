#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
using namespace std;

typedef long long ll;
const ll MOD = (ll)1e9 + 7;
ll add(ll x, ll y)
{
	x += y;
	if (x >= MOD) return x - MOD;
	return x;
}
ll sub(ll x, ll y)
{
	x -= y;
	if (x < 0) return x + MOD;
	return x;
}
ll mult(ll x, ll y)
{
	return (x * y) % MOD;
}
ll bin_pow(ll x, ll p)
{
	if (p == 0) return 1;
	if (p == 2 || (p & 1)) return mult(x, bin_pow(x, p - 1));
	return bin_pow(bin_pow(x, p / 2), 2);
}
ll rev(ll x)
{
	return bin_pow(x, MOD - 2);
}

const int N = 80;
const int M = N * N;

struct Edge
{
	int v, u;
	int w;
	
	Edge() : v(), u(), w() {}
	
	void scan()
	{
		scanf("%d%d%d", &v, &u, &w);
		v--;u--;
	}
	
	bool operator < (const Edge &e) const
	{
		return w < e.w;
	}
};

Edge ed[M];
int col[N], oldCol[N];
vector<int> a[N];
int b[N];
ll g[N][N];

void clearG(int k)
{
	for (int i = 0; i < k; i++)
		for (int j = 0; j < k; j++)
			g[i][j] = 0;
	return;
}
void addEdge(int v, int u)
{
	g[v][u] = sub(g[v][u], 1);
	g[u][v] = sub(g[u][v], 1);
	g[v][v] = add(g[v][v], 1);
	g[u][u] = add(g[u][u], 1);
	return;
}

void printG(int n)
{
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
			printf("%lld ", g[i][j]);
		printf("\n");
	}
	printf("\n");
}

ll getDeterminant(int n)
{
//	printG(n);
	ll res = 1;
	for (int i = 0; i < n; i++)
	{
//		printG(n);
		int v = -1;
		for (int j = i; j < n; j++)
		{
			if (g[j][i] != 0)
			{
				v = j;
				break;
			}
		}
		if (v == -1) return 0;
		if (v != i) res = sub(0, res);
		swap(g[i], g[v]);
		ll x = g[i][i];
		res = mult(res, x);
		x = rev(x);
		for (int j = i; j < n; j++)
			g[i][j] = mult(g[i][j], x);
		for (int k = i + 1; k < n; k++)
		{
			x = g[k][i];
			for (int j = i; j < n; j++)
				g[k][j] = sub(g[k][j], mult(g[i][j], x));
		}
	}
	return res;
}

void unite(int v, int u, int n)
{
	int cv = col[v], cu = col[u];
	if (cv == cu) return;
	for (int i = 0; i < n; i++)
		if (col[i] == cu)
			col[i] = cv;
	return;
}

int main()
{
	
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i++)
	{
		int v, u;
		scanf("%d%d", &v, &u);
	}
	for (int i = 0; i < m; i++)
		ed[i].scan();
	sort(ed, ed + m);
	for (int i = 0; i < n; i++)
		col[i] = i;
	int l = 0;
	ll ans = 1;
	while(l < m)
	{
		for (int i = 0; i < n; i++)
			oldCol[i] = col[i];
		int r = l;
		while(r < m && ed[r].w == ed[l].w) r++;
		for (int i = l; i < r; i++)
			unite(ed[i].v, ed[i].u, n);
		for (int i = 0; i < n; i++)
			a[i].clear();
		for (int i = 0; i < n; i++)
			a[col[i]].push_back(oldCol[i]);
		for (int c = 0; c < n; c++)
		{
			sort(a[c].begin(), a[c].end());
			a[c].resize(unique(a[c].begin(), a[c].end()) - a[c].begin());
			int k = (int)a[c].size();
			if (k <= 1) continue;
			for (int i = 0; i < k; i++)
				b[a[c][i]] = i;
			clearG(k);
			for (int i = l; i < r; i++)
			{
				int v = ed[i].v, u = ed[i].u;
				if (col[v] != c) continue;
				v = b[oldCol[v]], u = b[oldCol[u]];
				if (v == u) continue;
				addEdge(v, u);
			}
			ans = mult(ans, getDeterminant(k - 1));
		}
		l = r;
	}
	for (int i = 0; i < n; i++)
		if (col[i] != col[0])
			ans = 0;
	printf("%lld\n", ans);
	
    return 0;
}
