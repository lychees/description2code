#include <bits/stdc++.h>
using namespace std;

#define gx getchar
#define pb push_back
#define mp make_pair
#define ff first 
#define ss second
#define i64 long long
#define mod 1000000007
#define DBG(vari) cerr<<#vari<<" ==> "<<(vari)<<endl
#define inf 2000000000

typedef pair<i64,i64> pll;
typedef pair<int,int> PII;
void scan(int &x)
{
    register int c = gx();
    x = 0;
    for(;(c<48 || c>57);c = gx());
    for(;c>47 && c<58;c = gx())
    {
        x = (x<<1) + (x<<3) + c - 48;
    }
}
int t,n,m,q,f[100005];
vector<pair<int,int> >fact[100002];

i64 expmod(i64 a,int b,int m){
	i64 ans=1;
	while(b>0){
		if(b&1)
		ans=(ans*a)%m;
		a=(a*a)%m;
		b>>=2;
	}
	return ans;
}

void factor(){
	int num,lim,ans;
	fact[1].pb(mp(1,1));
	for(int i=2;i<100002;i++){
		num=i,lim=sqrt(i);
		for(int j=2;j<=lim;j++){
			if(num%j==0){
				ans=0;
				while(num%j==0){
					ans++;num/=j;
				}
				fact[i].pb(mp(j,ans));
			}
		}
		if(num!=1)
		fact[i].pb(mp(num,1));
	}
}

void solve(){
	f[0]=1;
	long long int power[100005]={0},val;int a,b;
	vector<int>present;
	for(int i=1;i<=n;i++){
		if(i<n/2+1){
			a=i,b=n-i+1;
			for(int j=0;j<(int)fact[b].size();j++){
				if(power[fact[b][j].ff]==0)
				present.pb(fact[b][j].ff);
				
				power[fact[b][j].ff]+=fact[b][j].ss*b;
			}
			for(int j=0;j<(int)fact[a].size();j++){
				power[fact[a][j].ff]-=fact[a][j].ss*b;
			}
			val=1LL;
			for(int j=0;j<(int)present.size();j++){
				val*=(val*expmod(present[j],power[present[j]],m))%m;
			}
			f[i]=val;
		}
		else
		f[i]=f[n-i];
	}
}

int main()
{
	//freopen("aain.txt","r",stdin);
	//freopen("aaout.txt","w",stdout);
	ios_base::sync_with_stdio(false);
	i64 n,t,dig;
	cin>>t;
	while(t--){
		cin>>n;
		bool flag=0;
		dig=0;
		while(n>0){
			if(n%10==4 ||n%10==7)
			dig++;
			n/=10;
			
		}
		
		if(dig==4 || dig==7)
		cout<<"YES"<<endl; 
		else
		cout<<"NO"<<endl;
	}
	return 0;
}

