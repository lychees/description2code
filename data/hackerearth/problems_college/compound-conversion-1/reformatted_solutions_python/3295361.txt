'''
https://www.hackerearth.com/nit-calicut-codeburst-50/algorithm/compound-conversion-1/
'''

T = int(input())
negative_infinity = float("-inf")
postive_infinity = float("inf")
for tc in xrange(T):
    first = raw_input().strip()
    second = raw_input().strip()
    if len(first) != len(second):
        print(-1)
    else:
        non_matching_tuple_list = [
            (first[i], second[i]) for i in xrange(
                len(first)) if first[i] != second[i]]
        # count the number of 1s in the first list, it should be < num(0)
        # +num(?)
        num1, num0, numQ_1, numQ_0 = 0, 0, 0, 0
        for tup in non_matching_tuple_list:
            if tup[0] == '1':
                num1 += 1
            elif tup[0] == '0':
                num0 += 1
            else:
                if tup[1] == '1':
                    numQ_1 += 1
                else:
                    numQ_0 += 1

        if num1 > num0 + numQ_1:
            print('Case {}: {}'.format(tc+1, -1))
        else:
            score = 0
            that_can_be_toggled = num0 + numQ_1 + numQ_0
            if num1 >= num0:
                score = num0 + (num1 - num0)*2
                that_can_be_toggled -= num1
                score += that_can_be_toggled
            else:
                score = num1
                that_can_be_toggled -= num1
                score += that_can_be_toggled

            print('Case {}: {}'.format(tc+1, score))
