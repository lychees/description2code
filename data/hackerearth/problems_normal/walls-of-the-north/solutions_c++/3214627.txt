#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 1000000007
#define f first
#define s second
#define si(x)   scanf("%d",&x)
#define sl(x)   scanf("%I64d",&x)
#define CLR(x)  memset(x,0,sizeof(x))
#define RESET(x,a) memset(x,a,sizeof(x))
#define pi pair<int,int>
#define pb push_back
#define mp make_pair
#define debug(x) cerr<<">value ("<<#x<<") : "<<x<<endl;

const int sz=100005;
int DEF[]= {10000000,-1,0}; //min,max,sum

struct seg
{
    int val;
}A[3*sz];

inline int join(int i,int j,int type)
{
    if(type==0) return min(i,j);
    if(type==1) return max(i,j);
    return i+j;
}

void built_tree(int l,int r,int node,int type)
{
    if(l==r)
    {
        A[node].val=DEF[type];
        return;
    }
    int mid=(l+r)>>1;
    built_tree( l, mid, node<<1, type );
    built_tree( mid+1, r, (node<<1)+1, type );
    A[node].val = join( A[ node<<1 ].val , A[(node<<1)+1].val, type );
}

void update_tree(int l,int r,int st,int node, int val,int type)
{
    if(l>st||r<st)
        return;
    if(l>=st&&r<=st)
    {
        A[node].val=join(A[node].val,val, type);
        return;
    }
    int mid=(l+r)>>1;
    if(mid>=st)
        update_tree(l,mid,st,node<<1,val, type);
    else
        update_tree(mid+1,r,st,(node<<1)+1,val, type);
    A[node].val = join( A[ node<<1 ].val , A[(node<<1)+1].val, type );
}

int query(int l,int r,int st,int en,int node,int type)
{
    if(l>en||r<st)
        return DEF[type];
    if(l>=st&&r<=en)
    {
        return A[node].val;
    }
    int mid=(l+r)>>1;
    return join( query(l,mid,st,en,node<<1, type),query(mid+1,r,st,en,(node<<1)+1, type), type );
}

seg B[3*sz];

void mbuilt_tree(int l,int r,int node,int type)
{
    if(l==r)
    {
        B[node].val=DEF[type];
        return;
    }
    int mid=(l+r)>>1;
    mbuilt_tree( l, mid, node<<1, type );
    mbuilt_tree( mid+1, r, (node<<1)+1, type );
    B[node].val = join( B[ node<<1 ].val , B[(node<<1)+1].val, type );
}

void mupdate_tree(int l,int r,int st,int node, int val,int type)
{
    if(l>st||r<st)
        return;
    if(l>=st&&r<=st)
    {
        B[node].val=join(B[node].val,val, type);
        return;
    }
    int mid=(l+r)>>1;
    if(mid>=st)
        mupdate_tree(l,mid,st,node<<1,val, type);
    else
        mupdate_tree(mid+1,r,st,(node<<1)+1,val, type);
    B[node].val = join( B[ node<<1 ].val , B[(node<<1)+1].val, type );
}

int mquery(int l,int r,int st,int en,int node,int type)
{
    if(l>en||r<st)
        return DEF[type];
    if(l>=st&&r<=en)
    {
        return B[node].val;
    }
    int mid=(l+r)>>1;
    return join( mquery(l,mid,st,en,node<<1, type),mquery(mid+1,r,st,en,(node<<1)+1, type), type );
}

int a[100005];
int b[100005];
int dp[2][100005];
//int mx[2];
map<int,int> com;
map<int,int>::iterator it;

int main()
{
//    ios_base::sync_with_stdio(false);
//    cin.tie(NULL);
    int t,n,m,i,j;
    si(t);
    while(t--)
    {
        si(n);
        if(n>=11000)
        {
            for(i=0;i<n;i++)
            {
                si(a[i]);
            }
            for(i=1;i<n;i++)
            {
                b[i-1]=-1;
                if(a[i]>a[i-1])
                    b[i-1]=1;
                else if(a[i]>a[i-1])
                    b[i-1]=0;
            }
            int sign=b[0];
            int cnt=1;
            for(i=1;i<n-1;i++)
            {
                if(sign*b[i]==-1)
                {
                    sign=b[i];
                    cnt++;
                }
                else if(b[i]==0)
                {
                    sign=-sign;
                    cnt++;
                }
            }
            printf("%d\n",cnt+1);
            continue;
        }
        com.clear();
        for(i=0;i<n;i++)
        {
            si(a[i]);
            com[a[i]];
        }
        i=0;
        for(it=com.begin();it!=com.end();it++,i++)
        {
            (*it).s=i;
        }
        built_tree(0,n-1,1,1);
        mbuilt_tree(0,n-1,1,1);
        dp[0][0]=1;
        dp[1][0]=1;
        update_tree(0,n-1,com[a[0]],1,dp[0][0],1);
        mupdate_tree(0,n-1,com[a[0]],1,dp[1][0],1);
        for(i=1;i<n;i++)
        {
            int tmp=query(0,n-1,com[a[i]],n-1,1,1);
            dp[1][i]=tmp+1;
            tmp=mquery(0,n-1,0,com[a[i]],1,1);
            dp[0][i]=tmp+1;
            update_tree(0,n-1,com[a[i]],1,dp[0][i],1);
            mupdate_tree(0,n-1,com[a[i]],1,dp[1][i],1);
        }
        printf("%d\n",max(dp[0][n-1],dp[1][n-1]));
    }
    return 0;
}

