#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cmath>
#include<string>
#include<cstdlib>
#include<map>
#include<list>
#include<bits/stdc++.h>
using namespace std;

//	GC

#define in(a) scanf("%d",&a)
#define inn(a,b) scanf("%d%d",&a,&b)
#define inll(a) scanf("%lld",&a)
#define ins(a) scanf("%s",a)
#define out(a) printf("%d\n",a)
#define fo(i,n) for(i=0;i<n;i++)
#define foo(i,n) for(i=1;i<=n;i++)
#define pb push_back
#define ff first
#define ss second 
#define outll(a) printf("%lld\n",a)
#define vec vector<int>
#define mod 1000000007
#define sortt(a) sort(a.begin(),a.end()) 
#define sz size()
#define mem(a,b) memset(a,(b),sizeof(a))
#define mp make_pair 
#define r0 return 0
#define ll long long 
#define pa pair<int,int >
#define vecp vector<pa>

int st1[2000100],st2[2000100],a[200010];
int lazy1[2000100]={0},lazy2[2000100]={0};
char s[200010];

void build(int idx,int ss,int se)
{
	if(ss==se)
	{
		st1[idx]=a[ss];
		st2[idx]=!a[ss];
		return ;
	}
	
	int m=(ss+se)/2;
	
	build(2*idx,ss,m);
	build(2*idx+1,m+1,se);
	
	st1[idx]=st1[2*idx]+st1[2*idx+1];
	st2[idx]=st2[2*idx]+st2[2*idx+1];
}

int query1(int idx,int ss,int se,int q1,int q2)
{
	if(ss>q2 || se<q1)
		return 0;
	
	
	if(lazy1[idx]!=0)
	{
		if(ss==se)	{	if(st1[idx]==1)  st1[idx]=0;
						else 			   st1[idx]=1;
					}	
		
		else
		{
			if(st1[idx]==0)	st1[idx]=se-ss+1;
			else				st1[idx]=(se-ss+1)-st1[idx];
			
			lazy1[2*idx]=(lazy1[2*idx]==1)  ?  0  :  1;			//mark these nodes	   // 1 1 2
			lazy1[2*idx+1]=(lazy1[2*idx+1]==1) ? 0 : 1;
		}
		
		lazy1[idx]=0;
	}
	
	if(ss>=q1 && se<=q2)
		return st1[idx];
	
	int  m=(ss+se)/2;
		
	return query1(2*idx,ss,m,q1,q2)+query1(2*idx+1,m+1,se,q1,q2);
}

	
void update1(int idx,int ss,int se,int q1,int q2)	
{
	if(lazy1[idx]!=0)  //  marked node
	{
		
		if(ss==se)	{	if(st1[idx]==1)  st1[idx]=0;
						else 			   st1[idx]=1;
					}	
		
		else
		{
			if(st1[idx]==0)	st1[idx]=se-ss+1;// 0 0 1
			else				st1[idx]=(se-ss+1)-st1[idx];	   // 0 1 3
			
			lazy1[2*idx]=(lazy1[2*idx]==1)  ?  0  :  1;			//mark these nodes	   // 1 1 2
			lazy1[2*idx+1]=(lazy1[2*idx+1]==1) ? 0 : 1;
		}
		
		lazy1[idx]=0;
	}
	
	if(q1>q2 || ss>q2 || se<q1) //Segment is out of range
		return ;
	
	if(ss>=q1 && se<=q2)  //Segment is fully within range
	{
		if(ss==se)	{	if(st1[idx]==1)  st1[idx]=0;
						else 			   st1[idx]=1;
					}	
		
		else
		{
			if(st1[idx]==0)	st1[idx]=se-ss+1;
			else				st1[idx]=(se-ss+1)-st1[idx];
			
			lazy1[2*idx]=(lazy1[2*idx]==1)  ?  0  :  1;			//mark these nodes	   // 1 1 2
			lazy1[2*idx+1]=(lazy1[2*idx+1]==1) ? 0 : 1;
		}
		return ;
	}
	
	int m=(ss+se)/2;
	
	update1(2*idx,ss,m,q1,q2);
	update1(2*idx+1,m+1,se,q1,q2);
	
	st1[idx]=st1[2*idx]+st1[2*idx+1];
}


int query2(int idx,int ss,int se,int q1,int q2)
{
	if(ss>q2 || se<q1)
		return 0;
	
	
	if(lazy2[idx]!=0)
	{
		if(ss==se)	{	if(st2[idx]==1)  st2[idx]=0;
						else 			   st2[idx]=1;
					}	
		
		else
		{
			if(st2[idx]==0)	st2[idx]=se-ss+1;
			else				st2[idx]=(se-ss+1)-st2[idx];
			
			lazy2[2*idx]=(lazy2[2*idx]==1)  ?  0  :  1;			//mark these nodes	   // 1 1 2
			lazy2[2*idx+1]=(lazy2[2*idx+1]==1) ? 0 : 1;
		}
		
		lazy2[idx]=0;
	}
	
	if(ss>=q1 && se<=q2)
		return st2[idx];
	
	int  m=(ss+se)/2;
		
	return query2(2*idx,ss,m,q1,q2)+query2(2*idx+1,m+1,se,q1,q2);
}

	
void update2(int idx,int ss,int se,int q1,int q2)	
{
	if(lazy2[idx]!=0)  //  marked node
	{
		
		if(ss==se)	{	if(st2[idx]==1)  st2[idx]=0;
						else 			   st2[idx]=1;
					}	
		
		else
		{
			if(st2[idx]==0)	st2[idx]=se-ss+1;// 0 0 1
			else				st2[idx]=(se-ss+1)-st2[idx];	   // 0 1 3
			
			lazy2[2*idx]=(lazy2[2*idx]==1)  ?  0  :  1;			//mark these nodes	   // 1 1 2
			lazy2[2*idx+1]=(lazy2[2*idx+1]==1) ? 0 : 1;
		}
		
		lazy2[idx]=0;
	}
	
	if(q1>q2 || ss>q2 || se<q1) //Segment is out of range
		return ;
	
	if(ss>=q1 && se<=q2)  //Segment is fully within range
	{
		if(ss==se)	{	if(st2[idx]==1)  st2[idx]=0;
						else 			   st2[idx]=1;
					}	
		
		else
		{
			if(st2[idx]==0)	st2[idx]=se-ss+1;
			else				st2[idx]=(se-ss+1)-st2[idx];
			
			lazy2[2*idx]=(lazy2[2*idx]==1)  ?  0  :  1;			//mark these nodes	   // 1 1 2
			lazy2[2*idx+1]=(lazy2[2*idx+1]==1) ? 0 : 1;
		}
		return ;
	}
	
	int m=(ss+se)/2;
	
	update2(2*idx,ss,m,q1,q2);
	update2(2*idx+1,m+1,se,q1,q2);
	
	st2[idx]=st2[2*idx]+st2[2*idx+1];
}


int main()
{
	int n,q,i,x,y;
	
	inn(n,q);
	
	ins(s);
	
	fo(i,n-1)
		if(s[i]=='<')	a[i]=0;
		else			a[i]=1;
		
	build(1,0,n-2);
	
//	foo(i,9)	cout<<st1[i]<<"  ";		cout<<endl;
//	foo(i,9)	cout<<st2[i]<<"  ";		cout<<endl;	
	
	while(q--)
	{
		in(x);
		
		if(x==1)
		{
			inn(x,y);		
			
			if(x>y)		update2(1,0,n-2,y-1,x-2),update1(1,0,n-2,y-1,x-2);
			else		update2(1,0,n-2,x-1,y-2),update1(1,0,n-2,x-1,y-2);
		}
		else
		{
			inn(x,y);
			if(x>y)		out(query1(1,0,n-2,y-1,x-2));
			else		out(query2(1,0,n-2,x-1,y-2));
		}
	}
	
	r0;
}