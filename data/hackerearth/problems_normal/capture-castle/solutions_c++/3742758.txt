/*input
2
2 6
5 6 1 3 10 2
2 2 8 7 2 3
1 3 76
5 3
5 4 10
2 3 6
5 5 8
3 9 1
5 8 3
5 2 25
*/
#include <bits/stdc++.h>
#include<stdio.h>
using namespace std;
#define pi pair<long long,long long>
#define pii pair<pi,long long>
#define F(i,a,b) for(ll i = (ll)(a); i <= (ll)(b); i++)
#define RF(i,a,b) for(ll i = (ll)(a); i >= (ll)(b); i--)
#define PI 3.14159265
#define ll long long
#define ff first
#define ss second
#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define INF 1000000009
#define mod 1000000007
ll dp[1005][1005],arr[1005][1005];
int main() 
{
	std::ios::sync_with_stdio(false);
	ll t,m,n;
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		F(i,1,n)
		{
			F(j,1,m)
			{
				cin>>arr[i][j];
				dp[i][j] = INF;
			}
		}
		ll x,y,tm;
		cin>>x>>y>>tm;
		priority_queue < pii , vector<pii> > pq;
		pq.push(mp(mp(1,1),arr[1][1]));
		dp[1][1] = arr[1][1];
		while(!pq.empty())
		{
			pii p = pq.top();
			pq.pop();
			ll i,j,d;
			i = p.ff.ff;
			j = p.ff.ss;
			d = p.ss;
			if(i-1>=1 && dp[i-1][j]>d+arr[i-1][j])
			{
				dp[i-1][j]=d+arr[i-1][j];
				pq.push(mp(mp(i-1,j),dp[i-1][j]));	
			}
			if(i+1<=n && dp[i+1][j]>d+arr[i+1][j])
			{
				dp[i+1][j]=d+arr[i+1][j];
				pq.push(mp(mp(i+1,j),dp[i+1][j]));	
			}
			if(j-1>=1 && dp[i][j-1]>d+arr[i][j-1])
			{
				dp[i][j-1]=d+arr[i][j-1];
				pq.push(mp(mp(i,j-1),dp[i][j-1]));	
			}
			if(j+1<=m && dp[i][j+1]>d+arr[i][j+1])
			{
				dp[i][j+1]=d+arr[i][j+1];
				pq.push(mp(mp(i,j+1),dp[i][j+1]));	
			}
		}
		ll ans = dp[x][y];
		if(-ans+tm>=0)
		{
			cout<<"YES"<<endl;
			cout<<-ans+tm<<endl;
		}
		else
		{
			cout<<"NO"<<endl;
		}
	}
	return 0;
}