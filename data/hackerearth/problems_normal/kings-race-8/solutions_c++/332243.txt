// directives 
	#include <stdio.h>
	#include <vector>
	#include <map>
	#include <set>
	#include <deque>
	#include <queue>
	#include <algorithm>
	#include <iostream>
	#include <cmath>
	#include <cstring>
	#include <typeinfo>
	#include <sstream>
// 
using namespace std;
// macros 
	#define FOR(i,a,b)      for(int i(a);i<b;++i)
	#define REP(i,n)        FOR(i,0,n)
	#define FORD(i,a,b)      for(int i(a-1);i>=b;--i)
	#define CL(a,x)         memset(a,x,sizeof(a))
	#define FL(a,x)			fill_n(a,sizeof(a)/sizeof(a[0]),x)
	#define asort(a,n)		sort(a,a+n)
	#define vsort(v,n)		sort(v.begin(), v.begin()+n)
	#define sz(x)			x.size()
	#define all(x)			x.begin(), x.end()
	#define SSTR( x )		dynamic_cast< std::ostringstream & >( ( std::ostringstream() << std::dec << x ) ).str()
// 

typedef long long LL;
typedef vector<int> vi;
typedef pair<int,int> pi;
int rint() { int x; if(scanf("%d",&x)!=1) return -1; return x; }
string rstring() { static char buf[100000]; if(scanf("%s",buf)!=1) return ""; return buf; }

vi H(1000000), Q(1000000);
vector<pi> C(1000000);
int lim;

int solve(int n, int k) {

	FORD(i,lim,0) {
		vector<pi>::iterator it = lower_bound(C.begin(), C.begin()+n, pi(H[Q[i]],0));
//		cout << ":" << it->first << "," << it->second << endl;
		if (it != C.begin() + n) {
			int minval = it->second;
			for (it = it+1; it!=C.begin()+n; it++) minval = min(minval, it->second);
			return minval;
		}
	}
	return 0;
}

void pre (int k) {
	lim = 0;
	REP(i,k) if (lim == 0 || H[i] > H[Q[lim-1]]) Q[lim++] = i;
}

int main()
{
	int t = rint();
	while (t--) {
		int n = rint(), k = rint();
		REP(i,n) C[i].first = rint(), C[i].second = i;
		REP(i,k) H[i] = rint();
		sort(C.begin(), C.begin() + n);
		pre(k);
//		sort(H.begin(), H.begin() + k);
		cout << solve(n,k) << endl;
	}
	return 0;
}
