/*

    fastest way to find nCr mod ( squarefree number )

    for very large n and r

*/

#include <iostream>
#include <vector>
using namespace std;

typedef long long ll;
typedef vector<ll> vll;
typedef vector<vll> vvll;

ll nCr(ll n, ll r, ll MOD)
{
    vvll C ( 2, vll(r+1,0) );
 
    for (ll i=0; i<=n; i++)
    {
        for (ll k=0; k<=r && k<=i; k++)
            if (k==0 || k==i)
                C[i%2][k] = 1;
            else
                C[i%2][k] = ( C[ !(i%2) ][ k-1 ] + C[ !(i%2) ][ k ] )%MOD;
    }
    return C[n%2][r];
}

ll Lucas(ll n, ll m, ll p)
{
    if (n==0 && m==0) return 1;
    ll ni = n % p;
    ll mi = m % p;
    if (mi>ni) return 0;
    return ( Lucas(n/p, m/p, p) * nCr(ni, mi, p) ) % p ;
}

ll mul_inv(ll a, ll b)
{
	ll b0 = b, t, q;
	ll x0 = 0, x1 = 1;
	if (b == 1) return 1ll;
	while (a > 1) {
		q = a / b;
		t = b, b = a % b, a = t;
		t = x0, x0 = x1 - q * x0, x1 = t;
	}
	if (x1 < 0) x1 += b0;
	return x1;
}
 
ll chinese_remainder(vll &n, vll &a)
{
    int i,len=n.size();
	ll p, prod = 1, sum = 0;
 
	for (i = 0; i < len; i++) prod *= n[i];
 
	for (i = 0; i < len; i++) {
		p = prod / n[i];
		sum = ( sum + a[i] * mul_inv(p, n[i]) * p ) % prod;
	}
 
	return sum ;
}

int main()
{    
    ios_base::sync_with_stdio(0);
    
    ll t,N,R,M,i;
    vll p,a;
    
    for( cin>>t; t--; )
    {
        p.clear();  a.clear();
        
        cin >> N >> R >> M ;
        
        while(M%2==0) { p.push_back(2); M/=2; }
        
        for( i=3; i*i<=M; i+=2 )
        while(M%i==0) { p.push_back(i); M/=i; }
        
        if( M>2 ) p.push_back(M);
        
        for(i=0;i<p.size();i++)
            a.push_back( Lucas(N-1,R-1,p[i]) );
        
        cout << chinese_remainder(p,a) << endl ;
    }
    
    return 0;
}