#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <utility>
#include <cstdlib>
#include <memory>
#include <queue>
#include <cassert>
#include <cmath>
#include <ctime>
#include <complex>
#include <bitset>

using namespace std;

#define pb push_back
#define fst first
#define snd second
#define mp make_pair 
#define sz(C) ((int) (C).size())
#define forn(i, n) for (int i = 0; i < (int) n; ++i)
#define ford(i, n) for (int i = ((int) n) - 1; i >= 0; --i)
#define y1 gftxdtrtfhyjfctrxujkvbhyjice
#define y0 ehfoiuvhefroerferjhfjkehfjke
#define left sdhfsjkshdjkfsdfgkqqweqweh
#define right yytrwtretywretwreytwreytwr
#define next jskdfksdhfjkdsjksdjkgf
#define prev koeuigrihjdkjdfj
#define hash kjfdkljkdhgjdkfhgurehg
#define all(C) begin(C), end(C)

typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair <int,int> pii;
typedef pair <ll, ll> pll;
typedef vector <ll> vll;
typedef vector <int> vi;
typedef vector <vector <int> > vvi;
typedef vector <pii> vii;
typedef long double ld;
typedef complex<double> cd;
typedef vector<cd> vcd;

#define FILE_NAME ""

const ld EPS = 1e-9;
const int MAXN = 1e5 + 10;
const int LOG = 21;

vi g[MAXN];
int sz[MAXN];
int n, q;
ll sq_sz[MAXN];
int par[MAXN][LOG+3];
int tin[MAXN];
int tout[MAXN];
int timer;
int depth[MAXN];
ll sum_sq[MAXN];

void dfs1(int v, int p) {
  tin[v] = timer++;

  par[v][0] = p;
  for (int i = 1; i <= LOG; ++i) {
    par[v][i] = par[par[v][i - 1]][i - 1];
  }

  sz[v] = 1;
  for (int to : g[v]) {
    if  (to != p) {
      depth[to] = depth[v] + 1;
      dfs1(to, v);
      sz[v] += sz[to];
    }
  }

  tout[v] = timer++;
}

bool upper(int v, int u) {
  return tin[v] <= tin[u] && tout[u] <= tout[v];
}

int lca(int v, int u) {
  if  (upper(v, u)) {
    return v;
  }
  if  (upper(u, v)) {
    return u;
  }

  for (int l = LOG; l >= 0; --l) {
    if  (!upper(par[v][l], u)) {
      v = par[v][l];
    }
  }

  return par[v][0];
}

int go_up(int v, int d) {
  for (int l = LOG; l >= 0; --l) {
    if  ((1 << l) <= d) {
      v = par[v][l];
      d -= 1 << l;
    }
  }
  assert(d == 0);
  return v;
}

ll C2(int k) {
  return k * 1ll * (k - 1) / 2;
}

void dfs2(int v, int p, ll up) {
  sq_sz[v] = up;

  sum_sq[v] = 0;
  for (int to : g[v]) {
    if  (to != p) {
      dfs2(to, v, up + C2(sz[v] - sz[to]));
      sum_sq[v] += C2(sz[to]);
    }                            
  }
}

int main() {
#ifdef LOCAL
  freopen(FILE_NAME ".in", "r", stdin);
//  freopen(FILE_NAME ".out", "w", stdout);
#endif

  scanf("%d", &n);
  forn(i, n - 1) {
    int a, b;
    scanf("%d%d", &a, &b);
    --a;
    --b;
    g[a].pb(b);
    g[b].pb(a);
  }

  timer = 0;
  depth[0] = 0;
  dfs1(0, 0);

  dfs2(0, 0, 0);

  scanf("%d", &q);
  while (q--) {
    int a, b;
    scanf("%d%d", &a, &b);
    --a;
    --b;

    int c = lca(a, b);
    if  (depth[a] > depth[b]) {
      swap(a, b);
    } 

    ll ans = 0;
    if  (c != a) {
      int pa = go_up(a, depth[a] - depth[c] - 1);
      int pb = go_up(b, depth[b] - depth[c] - 1);

      ans = sq_sz[a] - sq_sz[pa];
      ans += sq_sz[b] - sq_sz[pb];
      ans += C2(sz[a]);
      ans += C2(sz[b]);

      ans += C2(sz[0] - sz[pa] - sz[pb]);
    } else if  (a != b) {
      int pb = go_up(b, depth[b] - depth[a] - 1);
      
      ans = sq_sz[b] - sq_sz[pb];
      ans += C2(sz[b]);

      ans += C2(sz[0] - sz[pb]);
    } else {
      ans = C2(n);
    }

    cout << C2(n) - ans << '\n';
  }

  return 0;
}
