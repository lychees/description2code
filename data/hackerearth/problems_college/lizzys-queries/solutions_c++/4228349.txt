#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <list>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
#include <climits>
#include <iomanip>
#include <cassert>
using namespace std;

#define trace(x) cerr << #x << "=" << x <<endl;
#define track(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) {cerr << x[i] << " ";} cerr << endl;}
#define trackvv(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) { cerr << "i:" << i << endl; for (int j = 0; j < x[i].size(); j++){cerr << x[i][j] << " ";} cerr << endl;} cerr << endl;}
#define trackcr(x) {cerr << #x << ":" << endl; for (auto i = x.begin(); i != x.end(); i++) {cerr << *i << " ";} cerr << endl;}

#define MAX 1000005
#define INF 1000000005LL

long long power(long long n, long long m, long long MOD)
{
    if (m == 0) return 1;
    long long x = power(n, m / 2, MOD);
    if (!(m & 1)) return (x * x) % MOD;
    else return (((x * x) % MOD) * n) % MOD;
}

//const long long B = 100000007;
const long long B = 100000007;
const long long M = 1000000009;
const long long invB = power(B-1, M-2, M); //inverse of B-1

long long pB[MAX];
void pInit() {
    pB[0] = 1;
    for (int i = 1; i < MAX; i++) {
        pB[i] = (pB[i-1] * B) % M;
    }
}

struct node {
    long long val;
    bool flag;
    long long lazy;
    node() {
        flag = false;
        val = lazy = 0;
    }
} st[4*MAX];

long long update(int n, int l, int r, int ql, int qr, int c) {
    if (st[n].flag) {
        st[n].val = (((st[n].lazy * (pB[r-l+1]+M-1) % M) % M) * invB) % M;
        if (l != r) {
            st[2*n+1].flag = true;
            st[2*n+1].lazy = st[n].lazy;
            st[2*n+2].flag = true;
            st[2*n+2].lazy = st[n].lazy;
        }
        st[n].flag = false;
        st[n].lazy = 0;
    }

    if (qr < l or ql > r) {
        return st[n].val;
    } else if (l >= ql and r <= qr) {
        st[n].val = (((c * (pB[r-l+1]+M-1) % M) % M) * invB) % M;
        if (l != r) {
            st[2*n+1].flag = true;
            st[2*n+1].lazy = c;
            st[2*n+2].flag = true;
            st[2*n+2].lazy = c;
        }
        return st[n].val;
    } else {
        int mid = (l + r)/2;
        long long leftHash = update(2*n+1, l, mid, ql, qr, c);
        long long rightHash = update(2*n+2, mid+1, r, ql, qr, c);
        st[n].val = ((leftHash * pB[r - mid]) % M + rightHash) % M;
        return st[n].val;
    }
}

long long getHash(int n, int l, int r, int ql, int qr) {
    if (st[n].flag) {
        st[n].val = (((st[n].lazy * (pB[r-l+1]+M-1) % M) % M) * invB) % M;
        if (l != r) {
            st[2*n+1].flag = true;
            st[2*n+1].lazy = st[n].lazy;
            st[2*n+2].flag = true;
            st[2*n+2].lazy = st[n].lazy;
        }
        st[n].flag = false;
        st[n].lazy = 0;
    }
    if (qr < l or ql > r) {
        return 0;
    } else if (l >= ql &&  r <= qr) {
        return (st[n].val * pB[qr - r]) % M;
    } else {
        int mid = (l + r)/2;
        long long leftHash = getHash(2*n+1, l, mid, ql, qr);
        long long rightHash = getHash(2*n+2, mid+1, r, ql, qr);
        long long h = (leftHash + rightHash) % M;
        return h;
    }
}
struct node2 {
    long long val;
    bool flag;
    long long lazy;
    node2() {
        flag = false;
        val = lazy = 0;
    }
} st1[4*MAX];
long long update1(int n, int l, int r, int ql, int qr, int c) {
    if (st1[n].flag) {
        st1[n].val = (((st1[n].lazy * (pB[r-l+1]+M-1) % M) % M) * invB) % M;
        if (l != r) {
            st1[2*n+1].flag = true;
            st1[2*n+1].lazy = st1[n].lazy;
            st1[2*n+2].flag = true;
            st1[2*n+2].lazy = st1[n].lazy;
        }
        st1[n].flag = false;
        st1[n].lazy = 0;
    }

    if (qr < l or ql > r) {
        return st1[n].val;
    } else if (l >= ql and r <= qr) {
        st1[n].val = (((c * (pB[r-l+1]+M-1) % M) % M) * invB) % M;
        if (l != r) {
            st1[2*n+1].flag = true;
            st1[2*n+1].lazy = c;
            st1[2*n+2].flag = true;
            st1[2*n+2].lazy = c;
        }
        return st1[n].val;
    } else {
        int mid = (l + r)/2;
        long long leftHash = update1(2*n+1, l, mid, ql, qr, c);
        long long rightHash = update1(2*n+2, mid+1, r, ql, qr, c);
        st1[n].val = ((leftHash * pB[r - mid]) % M + rightHash) % M;
        return st1[n].val;
    }
}

long long getHash1(int n, int l, int r, int ql, int qr) {
    if (st1[n].flag) {
        st1[n].val = (((st1[n].lazy * (pB[r-l+1]+M-1) % M) % M) * invB) % M;
        if (l != r) {
            st1[2*n+1].flag = true;
            st1[2*n+1].lazy = st1[n].lazy;
            st1[2*n+2].flag = true;
            st1[2*n+2].lazy = st1[n].lazy;
        }
        st1[n].flag = false;
        st1[n].lazy = 0;
    }
    if (qr < l or ql > r) {
        return 0;
    } else if (l >= ql &&  r <= qr) {
        return (st1[n].val * pB[qr - r]) % M;
    } else {
        int mid = (l + r)/2;
        long long leftHash = getHash1(2*n+1, l, mid, ql, qr);
        long long rightHash = getHash1(2*n+2, mid+1, r, ql, qr);
        long long h = (leftHash + rightHash) % M;
        return h;
    }
}
int main(){
    pInit();
    int n, m, k;
    scanf("%d %d", &n,&k);
    char s[MAX],s1[MAX];
    scanf("%s", s);
    int j=0;
    for(int i=n-1;i>=0;i--)
    {
    	s1[j]=s[i];
    	j++;
    }
    s1[j]='\0';
    for (int i = 0; i < n; i++) {
        update(0, 0, n-1, i, i, s[i] - 'a');
    }
    for (int i = 0; i < n; i++) {
        update1(0, 0, n-1, i, i, s1[i] - 'a');
    }
    for (int i = 0; i < k; i++) {
        int choice;
        scanf("%d", &choice);
        if (choice == 0){
            int l, r;
            string stt;
            scanf("%d",&l);
            l--;
            r=l;
            cin>>stt;
            update(0, 0, n-1, l, r, stt[0]-'a');
            update1(0, 0, n-1, n-l-1 , n-l-1 , stt[0]-'a');
        } else if (choice == 1) {
            int l, r, c;
            scanf("%d %d", &l, &r);
            l--, r--;
            
                long long h1 = getHash(0, 0, n-1, l, r);
                long long h2 = getHash1(0, 0, n-1, n-r-1 , n-l-1);
                if (h1 == h2) {
                    printf("Yes\n");
                } else {
                    printf("No\n");
                }
            }
        }
    }
