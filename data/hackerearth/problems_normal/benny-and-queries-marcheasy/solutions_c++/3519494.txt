#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define m_p make_pair
//#define F first
//#define S second
#define For(i,a,b) for(int i=a;i<b;i++)
#define Fore(i,a,b) for(int i=a;i<=b;i++)
#define rFore(i,a,b) for(int i=a;i>=b;i--)
#define tr(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)
#define all(a) a.begin(),a.end()
#define mem(a,b) memset(a,b,sizeof(a))
typedef long long int lli;
typedef pair<int,int> pii;
typedef pair<int,pii> pi3;
typedef pair<lli,lli> plli;
typedef vector<int> vi;
typedef vector<pii> vpii;
void sc(int& a){scanf("%d",&a);}
void sc(lli& a){scanf("%lld",&a);}
void sc(int& a,int& b){sc(a);sc(b);}
void sc(lli& a,lli& b){sc(a);sc(b);}
void sc(int& a,int& b,int& c){sc(a,b);sc(c);}
void sc(lli& a,lli& b,lli& c){sc(a,b);sc(c);}
void prl(int a){printf("%d\n",a);}
void prl(lli a){printf("%lld\n",a);}
void prl(){printf("\n");}
void prs(int a){printf("%d ",a);}
void prs(lli a){printf("%lld ",a);}
void prl(lli a, lli b){cout<<a<<" "<<b<<" "<<endl;}
void prl(lli a, lli b, lli c){cout<<a<<" "<<b<<" "<<c<<" "<<endl;}
void prl(lli a, lli b, lli c, lli d){cout<<a<<" "<<b<<" "<<c<<" "<<d<<endl;}
void prl(lli a, lli b, lli c, lli d, lli e){cout<<a<<" "<<b<<" "<<c<<" "<<d<<" "<<e<<endl;}
void prl(lli a, lli b, lli c, lli d, lli e, lli f){cout<<a<<" "<<b<<" "<<c<<" "<<d<<" "<<e<<" "<<f<<endl;}
int mod=1000000007;
lli modpow(lli a, lli b, lli mod){lli res=1;while(b>0){if(b&1)res=(res*a)%mod;a=(a*a)%mod;b=b/2;}return res%mod;}
#define inf LLONG_MAX
#define N 10000000
int a[N],global=0;
typedef struct node{
    int F,S;
    vi f;
}node;
node tr[N];

void insert(int x, int index)
{
	int k=0;
	rFore(i,19,0){
		int bit=(x>>i)&1;
		if(bit==0){
			if(tr[k].F==-1){
				tr[k].F=++global;
				k=global;
			}
			else k=tr[k].F;
		}
		else{
			if(tr[k].S==-1){
				tr[k].S=++global;
				k=global;
			}
			else k=tr[k].S;
		}
        tr[k].f.pb(index);
	}
}

int func(int x, int l, int r)
{
    int y=0,k=0;
    rFore(i,19,0){
        int bit=(x>>i)&1;
        if(bit==0){
            if(tr[k].S==-1){
                k=tr[k].F;
            }
            else{
                int next=tr[k].S;
                auto it=lower_bound(all(tr[next].f),l);
                //auto it=tr[next].f.lower_bound(l);
                if(it!=tr[next].f.end() and *it<=r){
                    y+=(1<<i);
                    k=next;
                }
                else  k=tr[k].F;
            }
        }
        else{
            if(tr[k].F!=-1){
                int next=tr[k].F;
                auto it=lower_bound(all(tr[next].f),l);
                //auto it=tr[next].f.lower_bound(l);
                if(it!=tr[next].f.end() and *it<=r){
                    y+=(1<<i);
                    k=next;
                }
                else  k=tr[k].S;
			}
			else k=tr[k].S;
        }
    }
    return y;
}

int main()
{
    int n,q,l,r,x;
    sc(n,q);
    Fore(i,0,N-5) tr[i].F=tr[i].S=-1;
    Fore(i,1,n){
        sc(a[i]); insert(a[i],i);
    }
    while(q--){
        sc(l,r,x);
        prl(func(x,l,r));
    }
}
