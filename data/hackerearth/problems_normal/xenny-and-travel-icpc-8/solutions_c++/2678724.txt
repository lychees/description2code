     #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    typedef vector<ll>vll;
    typedef pair<ll,ll> pll;
    #define xx first
    #define yy second
    #define max(a, b, c) ((a > b? (a > c? a : c) : (b > c? b : c)))
    #define rep(n) for(i=0;i<n;i++)
    #define pb push_back
    #define mp make_pair
    #define clr(a) memset(a, 0, sizeof a)
    #define reset(a) memset(a, -1, sizeof a)
    #define Clr(a) fill(a.begin(),a.end(),0)
    #define Reset(a) fill(a.begin(),a.end(),-1)  
     #define tr(container, it) \
      for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)  
    void read(ll &n)
    {   scanf("%lld",&n);
    }
      void debug(vector<ll> v)
    {
        for(int i=0;i<v.size();i++)
            cout<<v[i]<<" ";
        cout<<"\n";
        // call debug({i,j,k})
    }
    vector< vector<pll> >graph,graph2,graph11,graph12;
    #define SIZE 1300
     struct node
    {
        ll n;
        ll cost;
        node(){}
        node(ll n,ll cost) {this->n = n;this->cost = cost;}
        bool operator < (const node &nd) const {
            if(cost!=nd.cost)
            return cost > nd.cost;
    }
    };
    bool visited[SIZE];
    ll weight[4][SIZE];
    ll cur;
    void dijkstra(ll st)
    {
        priority_queue<node>q;
        clr(visited);
 //       reset(weight);
        weight[cur][st]=0;
        //visited[st]=true;
        q.push(node(st,0));
        node x,z;
        pll y;
        //cout<<q.size();
        while(!q.empty())
        {
            x=q.top();
            q.pop();
            if(visited[x.n])
                continue;
            else visited[x.n]=true;
            //dist[st][x.n]=x.cost;
            //cout<<x.n<<endl;
            for(int i=0;i<graph[x.n].size();i++)
            {
                y=graph[x.n][i];
                if(weight[cur][y.yy]==-1||weight[cur][y.yy]>x.cost+y.xx)
                {
                    weight[cur][y.yy]=x.cost+y.xx;
                    q.push(node(y.yy,weight[cur][y.yy]));
                }
            }
        }
    }
    int main()
    {
        ll t,z,i,j,k,n,m,p,q,r,s,ans;
       // scanf("%lld",&t);
       t=1;
        for(z=1;z<=t;z++)
        {
            scanf("%lld",&n);
            graph.clear();
            graph11.clear();
            graph12.clear();
            graph2.clear();
            graph.resize(n);
            graph2.resize(n);
            graph11.resize(n);
            graph12.resize(n);
            memset(weight,-1,sizeof weight);
            for(i=0;i<n;i++)
            {
            	for(j=0;j<n;j++)
            	{
            		scanf("%lld",&p);
            		graph[i].push_back(mp(p,j));
            		graph11[j].push_back(mp(p,i));
            	}
            }
            for(i=0;i<n;i++)
            {
            	for(j=0;j<n;j++)
            	{
            		scanf("%lld",&p);
            		graph2[i].push_back(mp(p,j));
            		graph12[j].push_back(mp(p,i));
            	}
            }
            ll u,v;
            scanf("%lld%lld",&u,&v);
            u--;v--;
            cur=0;
            dijkstra(u);
            swap(graph,graph11);
            cur=1;
            dijkstra(v);
            swap(graph,graph2);
            cur=2;
            dijkstra(u);
            swap(graph,graph12);
            cur=3;
            dijkstra(v);
            ll mn=1e10;
            for(i=0;i<n;i++)
            {
            	if(i==u||i==v)continue;
            	mn=min(mn,weight[0][i]+weight[3][i]);
            	mn=min(mn,weight[1][i]+weight[2][i]);
            }
            /*for(i=0;i<n;i++)
            	debug({weight[0][i],weight[1][i],weight[2][i],weight[3][i]});*/
            printf("%lld\n",mn);
        }
        return 0;
    }