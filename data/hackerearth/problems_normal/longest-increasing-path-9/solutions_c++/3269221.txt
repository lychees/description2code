#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<vector>
using namespace std;
class Solution{
	public:
		void Print(vector <vector <int> > &matrix){
			int n=matrix.size();
			int m=matrix[0].size();
			for(int i=0;i<n;i++){
				for(int j=0;j<m;j++){
					cout<<matrix[i][j]<<" ";
				}
				cout<<endl;
			}
			return;
		}
		bool valid(int x,int y,int n,int m){
			if(x>=0 and y>=0 and x<n and y<m)return true;
			return false;
		}
		int dfs(int x,int y,vector <vector <int> > &matrix,vector <vector <int> > &dp){
			if(dp[x][y]==0){//if (x,y) is not visited yet
				int dx[]={1,0};
				int dy[]={0,1};
				int n=matrix.size();
				int m=matrix[0].size();
				for(int i=0;i<4;i++){
					int nx=x+dx[i];
					int ny=y+dy[i];
					if(valid(nx,ny,n,m)==true){
						if(matrix[nx][ny]>matrix[x][y]){
							dp[x][y]=max(dp[x][y],dfs(nx,ny,matrix,dp));
						}
					}
				}
				dp[x][y]=dp[x][y]+1;//include current cell in path
			}
			return dp[x][y];
		}
		int longestIncreasingPath(vector <vector <int> > &matrix){
			int n=matrix.size();
			int m=matrix[0].size();
			if(n==1 and m==1)return 1;//matrix with only 1 cell
			int result=0;
			vector <vector <int> > dp(n,vector <int> (m,0));
			//for(int i=0;i<n;i++){
			//	for(int j=0;j<m;j++){
					result=max(result,dfs(0,0,matrix,dp));
			//	}
		//	}
		//	Print(dp);
			return result;
		}
};
int main(void){
	int tests;
	cin>>tests;
	while(tests--){
	int n,m;
	cin>>n>>m;
	vector <vector <int> > matrix(n,vector <int> (m));
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cin>>matrix[i][j];
		}
	}
	Solution s;
	cout<<s.longestIncreasingPath(matrix)<<endl;
	}
	return 0;
}
