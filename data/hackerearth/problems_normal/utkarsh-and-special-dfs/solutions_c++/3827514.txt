#include <bits/stdc++.h>
#define mp make_pair
#define pb push_back

using namespace std;

typedef long long ll;
typedef pair<int,int> pii;
typedef long double ld;
typedef map<ll,ll>::iterator mapit;
typedef set<int>::iterator setit;

const int maxn = 1e5 + 4;
const int maxlog = 20;
const ll mod = 1e9 + 7;
const int sq = 720;
ll a[maxn];
int n ;
vector<int> adj[maxn];
ll val[maxn];
int st[maxn] , change[maxn] , fn[maxn];
int t = 0;
ll seg[4 * maxn] , lazy[4 * maxn];
void dfs(int v , int p){
    st[v] = t;
    change[t] = v;
    t ++ ;
    for(auto u : adj[v]){
        if(u == p)
            continue;
        val[u] = (val[v] * a[v]) % mod;
        dfs(u , v);
    }
    fn[v] = t;
}
void build(int ind , int l , int r){
    lazy[ind] = 1;
    if(r - l < 2){
        seg[ind] = val[change[l]];
        return ;
    }
    int mid = (l + r) / 2;
    build(2 * ind , l , mid);
    build(2 * ind + 1 , mid , r);
    seg[ind] = (seg[2 * ind] + seg[2 * ind + 1]) % mod;
}
ll powmod(ll a , ll b){
    if(b == 0)
        return 1;
    ll res = powmod(a , b / 2);
    res = (res * res) % mod;
    if(b & 1)
        res = (res * a) % mod;
    return res;
}

void upd(int ind , int l , int r , ll val){
    lazy[ind] = (lazy[ind] * val) % mod;
    seg[ind] = (seg[ind] * val) % mod;
}
void shift(int ind , int l , int r){
    int mid = (l + r) / 2;
    upd(2 * ind , l , mid , lazy[ind]);
    upd(2 * ind + 1 , mid , r , lazy[ind]);
    lazy[ind] = 1;
}
void update(int ind , int l , int r , int x , int y , ll val){
    if(x >= r || l >= y)
        return ;
	if(x <= l && r <= y){
		upd(ind , l , r , val);
		return ;
	}
	shift(ind , l , r);
	int mid = (l + r) / 2;
	update(2 * ind , l , mid , x , y , val);
	update(2 * ind + 1 , mid , r , x , y , val);
	seg[ind] = (seg[2 * ind] + seg[2 * ind + 1]) % mod;
}
ll get(int ind , int l , int r , int x , int y){
    if(x >= r || l >= y)
        return 0;
	if(x <= l && r <= y)
		return seg[ind];
	shift(ind , l , r);
	int mid = (l + r) / 2;
	return (get(2 * ind , l , mid , x , y) + get(2 * ind + 1 , mid , r , x , y)) % mod;
	seg[ind] = (seg[2 * ind] + seg[2 * ind + 1]) % mod;
}
int main()
{
	ios_base::sync_with_stdio(false) , cin.tie(0) , cout.tie(0); cout.precision(20);
	int q;
	cin >> n >> q;
	for(int i = 0 ; i < n - 1 ; i ++ ){
        int u , v;
        cin >> u >> v;
        adj[u].pb(v);
        adj[v].pb(u);
	}
	for(int i = 1 ; i <= n ; i ++ )
        cin >> a[i];
    val[1] = 1;
	dfs(1 , 0);
	build(1 , 0 , n);
	while(q -- ){
        int type;
        cin >> type;
        if(type == 1){
            int v , x;
            cin >> v >> x;
            if(st[v] + 1 == fn[v])
                continue;
            ll r = powmod(a[v] , mod - 2);
            r = (r * x) % mod;
            a[v] = x;
            update(1 , 0 , n , st[v] + 1 , fn[v] , r);
        }
        else{
            int v;
            cin >> v;
            ll res = get(1 , 0 , n , st[v] , fn[v]);
            cout << res << endl;
        }
	}
	return 0;
}



