#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int M = 305;
const int INF = 1e9;

int n, m, f[2*M], a[M], h[2*M], res[2*M][2*M], N;
vector<int> adj[2*M];
bool visited[2*M];
int f2[2*M];
queue<int> frontier;

bool level(int source, int sink) {
        for (int i=0;i<=N;i++) h[i] = INF;
        h[source] = 0;
        frontier.push(source);
        while (frontier.size()>0) {
                int x = frontier.front();
                frontier.pop();
                for (int i: adj[x]) if (res[x][i] && h[i]==INF) {
                        h[i] = h[x]+1;
                        frontier.push(i);
                }
        }
        return (h[sink]!=INF);
}

int dfs(int x, int source, int sink) {
        if (x==sink) return 1;
        visited[x] = 1;
        int num = 0;
        for (int i: adj[x]) {
            if (!visited[i] && h[i]==h[x]+1 && res[x][i] && dfs(i,source, sink)) {
                res[x][i]-=1;
                res[i][x]+=1;
                num+=1;
                if (x!=source) return num;
            }
        }
        return num;
}

int maxflow(int source, int sink) {
        int flow = 0;
        N = sink;
        while (true) {
                if (!level(source, sink)) break;
                for (int i=0;i<=N;i++) visited[i] = 0;
                flow+=dfs(source, source, sink);
        }
        return flow;
}

bool check(int x) {
	memset(res, 0, sizeof(res));
	memset(h, 0, sizeof(h));
	while (!frontier.empty())
		frontier.pop();
	
	for (int i = 0; i < 2*M; ++i)
		adj[i].clear();

	for (int i = 0; i < n; ++i) {
		adj[0].push_back(i+1);
		adj[i+1].push_back(0);
		res[0][i+1] = 1;
	}

	for (int i = 1; i <= n; ++i)
		for (int j = n+1; j <= 2*n; ++j) {
			if (f[i-1 + a[j-n-1]] > x)
				continue;
			adj[i].push_back(j);
			adj[j].push_back(i);
			res[i][j] = 1;
		}

	for (int j = n+1; j <= 2*n; ++j) {
		adj[j].push_back(2*n+1);
		adj[2*n+1].push_back(j);
		res[j][2*n+1] = 1;
	}

	if (maxflow(0, 2*n+1) == n)
		return true;
	else
		return false;
}

int main() {
	cin >> n >> m;
	for (int i = 0; i < n; ++i)
		cin >> a[i];
	for (int i = 0; i < n+m-1; ++i) {
		cin >> f[i];
		f2[i] = f[i];
	}

	sort(f2, f2+n+m-1);
	int lo = 0, hi = n+m-2;

	while (lo != hi) {
		int mid = (lo + hi)/2;
		if (check(f2[mid]))
			hi = mid;
		else
			lo = mid+1;
	}

	cout << f2[lo] << endl;
}