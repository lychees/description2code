#include <bits/stdc++.h>
using namespace std;
#define mod 1000000007
#define test int t;scanf("%d", &t);while(t--)
#define pb push_back
#define all(x) x.begin(),x.end() 
#define mp make_pair
#define ll long long int 
#define vi vector<int>
#define vii vector<pair<int,int> >
#define pii pair<int,int>
#define vl vector<ll>
#define vll vector<pair<ll,ll> >
#define pll pair<ll,ll>
#define ub upper_bound
#define lb lower_bound

#define sc(x) scanf("%d",&x)
#define sc2(x,y) scanf("%d%d",&x,&y)    
#define sc3(x,y,z) scanf("%d%d%d",&x,&y,&z)
#define sc4(w,x,y,z) scanf("%d%d%d%d",&w,&x,&y,&z)

#define scll(x) scanf("%lld",&x)
#define scll2(x,y) scanf("%lld%lld",&x,&y)
#define scll3(x,y,z) scanf("%lld%lld%lld",&x,&y,&z)
#define scll4(w,x,y,z) scanf("%lld%lld%lld%lld",&w,&x,&y,&z)

#define scs(s) scanf("%s", s);

#define pr(x) printf("%d\n",x)
#define pr2(x,y) printf("%d %d\n",x,y)
#define pr3(x,y,z) printf("%d %d %d\n",x,y,z)

#define prll(x) printf("%lld\n",x)
#define prll2(x,y) printf("%lld %lld\n",x,y)
#define prll3(x,y,z) printf("%lld %lld %lld\n",x,y,z)

#define prs(s) printf("%s\n", s);

#define prn() printf("\n");

#define prvec(v) for(int i=0;i<v.size();i++) cout << v[i] << " "

#define debug(s) cout << "check : " << s << endl

#define MaxVal 100000

int tree[MaxVal+5]={0};
int invtree[MaxVal+5]={0};

ll read(int tree[MaxVal+5], int idx){
    int sum = 0;
    while (idx > 0){
        sum += tree[idx];
        idx -= (idx & -idx);
    }
    return sum;
}

void update(int tree[MaxVal+5], int idx ,int val){
    while (idx <= MaxVal){
        tree[idx] += val;
        idx += (idx & -idx);
    }
}

int readSingle(int idx){
    int sum = tree[idx]; // sum will be decreased
    if (idx > 0){ // special case
        int z = idx - (idx & -idx); // make z first
        idx--; // idx is no important any more, so instead y, you can use idx
        while (idx != z){ // at some iteration idx (y) will become z
            sum -= tree[idx]; 
            // substruct tree frequency which is between y and "the same path"
            idx -= (idx & -idx);
        }
    }
    return sum;
}

void scale(int c){
    for (int i = 1 ; i <= MaxVal ; i++)
        tree[i] = tree[i] / c;
}

// if in tree exists more than one index with a same
// cumulative frequency, this procedure will return 
// the greatest one
int findG(int cumFre, int bitMask){
    int idx = 0;

    while ((bitMask != 0) && (idx < MaxVal)){
        int tIdx = idx + bitMask;
        if (cumFre >= tree[tIdx]){ 
            // if current cumulative frequency is equal to cumFre, 
            // we are still looking for higher index (if exists)
            idx = tIdx;
            cumFre -= tree[tIdx];
        }
        bitMask >>= 1;
    }
    if (cumFre != 0)
        return -1;
    else
        return idx;
}

typedef struct array1
{
    int ind, l, r;
}array1;
int a[MaxVal+5];
vector<array1> vec;
bool comp(array1 a1, array1 a2)
{
    if(a1.r>a2.r)return 0;
    return 1;
}
int main()
{
    int n, m, d;
    sc3(n,m,d);
    for(int i=1;i<=n;i++)sc(a[i]);
    for(int i=0;i<m;i++)
    {
        array1 tem = {i,0,0};
        sc2(tem.l, tem.r);
        vec.pb(tem);
    }
    sort(all(vec),comp);
    //for(int i=0;i<vec.size();i++)pr(vec[i].r);
    ll ans[MaxVal+5]={0};
    for(int i=1;i<=d;i++)
    {
        for(int j=0;j<=MaxVal;j++)
        {
            tree[j]=0;
            invtree[j]=0;
        }
        int cov[MaxVal+5]={0};
        int last = 0;
        for(int j=0;j<m;j++)
        {
            array1 tem = vec[j];
            for(int k=last+1;k<=tem.r;k++)
            {
            	if(a[k]+i<=MaxVal)
            	{
                if(cov[a[k]+i]!=0)
                {
                    update(tree,k,1);
                    update(invtree,cov[a[k]+i],1);
                }
            	}
                if(a[k]-i>=0)
                {
                if(cov[a[k]-i]!=0)
                {
                    update(tree,k,1);
                    update(invtree,cov[a[k]-i],1);
                }
                }
                cov[a[k]]=k;
            }
            last = tem.r;
            ans[tem.ind]+=read(tree,tem.r)-read(invtree,tem.l-1);
        }
    }
    for(int i=0;i<m;i++)
    {
        ll tem =(vec[i].r-vec[i].l+1);
        ans[vec[i].ind]+=tem;
    }
    for(int i=0;i<m;i++)prll(ans[i]);
    // add for d=0
    return 0;
}
