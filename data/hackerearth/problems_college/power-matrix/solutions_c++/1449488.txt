#include<bits/stdtr1c++.h>

#define gcd __gcd
#define bitcount __builtin_popcountll
#define msb __builtin_clzll
#define getcx getchar
#define rep(i,j,n) for(i=j;i<n;i++)
#define tr(it,c) for(auto it=(c).begin();it!=(c).end();it++)
#define pb push_back
#define mp make_pair
#define hell 1000000007LL
#define uset unordered_set
#define umap unordered_map
#define MAX 100000

using namespace std;

typedef long long ll;

template <class T> T& get(T &n){
    static int p;
    static bool f;
    f=false;
    n = 0;
    do{
        p=getcx();
    }while( !isdigit(p) && p!='-');
    if(p=='-'){
        f=true;
        p=getcx();
    }
    while ( isdigit(p) ){
        n = (n << 3) + (n << 1) + (p - '0');
        p = getcx();
    }
    n = (f ? -n : n);
    return n;
}

template <class T> T fastexp(T a,T b,T mod){
	static T res;
	if(a==0)
        return 1LL;
	res=1;
	while(b){
		if(b&1)
			res= (res * a)%mod;
		a= (a*a)%mod;
		b>>=1;
	}
	return res;
}
template< class T >
class Matrix
{
    public:
        int m,n;
        T *data;

        Matrix( int m, int n );
        Matrix( const Matrix< T > &matrix );

        const Matrix< T > &operator=( const Matrix< T > &A );
        const Matrix< T > operator*( const Matrix< T > &A );
        const Matrix< T > operator^( int P );

        ~Matrix();
};

template< class T >
Matrix< T >::Matrix( int m, int n )
{
    this->m = m;
    this->n = n;
    data = new T[m*n];
}

template< class T >
Matrix< T >::Matrix( const Matrix< T > &A )
{
    this->m = A.m;
    this->n = A.n;
    data = new T[m*n];
    for( int i = 0; i < m * n; i++ )
        data[i] = A.data[i];
}

template< class T >
Matrix< T >::~Matrix()
{
    delete [] data;
}

template< class T >
const Matrix< T > &Matrix< T >::operator=( const Matrix< T > &A )
{
    if( &A != this )
    {
        delete [] data;
        m = A.m;
        n = A.n;
        data = new T[m*n];
        for( int i = 0; i < m * n; i++ )
            data[i] = A.data[i];
    }
    return *this;
}

template< class T >
const Matrix< T > Matrix< T >::operator*( const Matrix< T > &A )
{
    Matrix C( m, A.n );
    for( int i = 0; i < m; ++i )
        for( int j = 0; j < A.n; ++j )
        {
            C.data[i*C.n+j]=0;
            for( int k = 0; k < n; ++k )
                C.data[i*C.n+j] = (C.data[i*C.n+j] + (data[i*n+k]*A.data[k*A.n+j])%hell)%hell;
        }
    return C;
}

template< class T >
const Matrix< T > Matrix< T >::operator^( int P )
{
    if( P == 1 ) return (*this);
    if( P & 1 ) return (*this) * ((*this) ^ (P-1));
    Matrix B = (*this) ^ (P/2);
    return B*B;
}

int main()
{
    ll T,M,N,i,j;
    get(T);
    while(T--)
    {
        get(M);
        get(N);
        Matrix<ll> A(M,M);
        rep(i,0,M)
            rep(j,0,M)
                get(A.data[i*M+j]);
        A = A^N;
        rep(i,0,M)
        {
            rep(j,0,M)
                printf("%lld ",A.data[i*M+j]%hell);
            printf("\n");
        }
    }
}
