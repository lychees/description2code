#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mset(m,v) memset(m,v,sizeof(m))
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define pi 3.1415926535897932384
#define mod 1000000007
#define d 100000

const int MAXM = 1e3+5 ;
ll fact[MAXM],ifact[MAXM];

// ll modpow(ll x,ll y)
// {
//     x%=mod;
//     ll res=1;
//     while(y)
//     {
//         if(y&1)
//             res=(res*x)%mod;
//         y>>=1;
//         x=(x*x)%mod;
//     }
//     return res;
// }


// ll reverse(int x){
// 	return modpow(x,mod-2);
// }

// void suck(){
// 	fact[0]=1;
// 	for(int i=1;i<MAXM;i++){
// 		fact[i]=i*fact[i-1];
// 		if(fact[i]>=mod)	fact[i]%=mod;
// 	}

// 	ifact[0]=1;
// 	for(int i=1;i<MAXM;i++){
// 		ifact[i]=reverse(i)*ifact[i-1];
// 		if(ifact[i]>=mod)	ifact[i]%=mod;
// 	}
// }

// ll nCr(int n,int r){
// 	ll x=fact[n];
// 	ll y=ifact[r];
// 	ll z=ifact[n-r];
// 	return (x*(y*z)%mod)%mod;
// }

void factorial()
{
    fact[0]=1;
    for(int i=1;i<MAXM;i++)
        fact[i]=(fact[i-1]*i)%mod;
}

ll modpow(ll x,ll y)
{
    x%=mod;
    ll res=1;
    while(y)
    {
        if(y&1)
            res=(res*x)%mod;
        y>>=1;
        x=(x*x)%mod;
    }
    return res;
}

ll inverse(ll n)
{
    return modpow(n,mod-2);
}

ll nCr(ll n,ll r)
{
    return ((fact[n])*(((inverse(fact[r]))*(inverse(fact[n-r])))%mod))%mod;
}


ll solve(int n,int p){
	ll sum=0;
	for(int i=0;i<=p;i++){
		sum=sum+nCr(n,i);
		if(sum>=mod)	sum%=mod;
	}
	return sum;
}

int main()
{
	factorial();
	int t,p,n,i,j,k;
	cin>>t;
	while(t--){
		cin>>n>>p;
		cout<<solve(n,p)<<endl;
	}	
    return 0;
}   