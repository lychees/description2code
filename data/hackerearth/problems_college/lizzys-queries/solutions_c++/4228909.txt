#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> ii;
typedef pair<ll,ll> pll;

//#define TRACE
#ifdef TRACE
template<class T, class U>
ostream& operator<<(ostream& out, const pair<T,U>& a){out<<"["<<a.first<<" "<<a.second<<"]";return out;}
template<class T>
ostream& operator<<(ostream& out, const vector<T>& a){out<<"[ ";for(auto &it:a)out<<it<<" ";out<<"]";return out;}
template<class T>
ostream& operator<<(ostream& out, const set<T>& a){out<<"[ ";for(auto &it:a)out<<it<<" ";out<<"]";return out;}
template<class T,class U>
ostream& operator<<(ostream& out, const map<T,U>& a){for(auto &it:a)out<<it.first<<" -> "<<it.second<<" | ";return out;}
#define pra(a,n) cerr<<#a<<" : ";for(int i=0;i<n;++i)cerr<<a[i]<<" ";cerr<<endl;
#define pr(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1){
  cerr << name << " : " << arg1 << endl;
}
template <typename Arg1, typename... Args>
void __f(const char* names, Arg1&& arg1, Args&&... args){
  const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...);
} 
#else
#define pr(...)
#define pra(a,n)
#endif
#define fill(a,x) memset(a,x,sizeof(a)) 
#define all(x) (x).begin(), (x).end()
#define sz(a) int((a).size()) 
#define pb push_back 
#define F first
#define S second
#define FOR(i,a,b) for(int i = a; i<=b; ++i)
#define NFOR(i,a,b) for(int i = a; i>=b; --i)
#define NOFLUSH ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);

const ll INF = 1e18;
const int mod = 1e9+7;
const int N = 1e5+10; 
const double eps = 1e-9;
const int p1 = 31;
const int p2 = 37;

ll expo(ll a,ll b,ll c = mod){
    if(!b)return 1;
    ll temp = expo(a,b/2,c);
    temp = (temp*temp)%c;
    if(b&1)temp = (temp*a)%c;
    return temp; 
}
struct FEN{
  vector<ll> T;
  int n;
  FEN(){n=0;T.clear();}
  FEN(int sz){n=sz;T.clear();T.resize(sz+1);}
  void clear(int sz){n=sz;T.clear();T.resize(sz+1);}
  void update(int i, ll val){
    while(i<=n){
      T[i]+=val;
      if(T[i] >= mod)T[i] -=mod;
      i+=i&-i;
    }
  }
  ll query(int i){
    ll ans=0;
    while(i>0){
      ans+=T[i];
      if(ans >= mod) ans-=mod;
      i-=i&-i;
    }
    return ans;
  }
}b1(N),b2(N),b3(N),b4(N);
ll P1[N],P2[N];
int main(){
  
  clock_t tm = clock();
  NOFLUSH;
  int __t = 1;
  //cin >> __t;
  FOR(_t,1,__t){
      int n,q;
      cin >> n >> q;
      string s;
      cin >> s;
      P1[0]=P2[0]=1;
      FOR(i,1,n-1){
      	P1[i] = (P1[i-1]*p1)%mod;
      	P2[i] = (P2[i-1]*p2)%mod;
      }
      FOR(i,0,n-1){
      	b1.update(i+1,((s[i]-'a')*(P1[i]))%mod);
      	b2.update(i+1,((s[i]-'a')*(P2[i]))%mod);
      }
      NFOR(i,n-1,0){
      	b3.update(n-i,((s[i]-'a')*(P1[n-i-1]))%mod);
      	b4.update(n-i,((s[i]-'a')*(P2[n-i-1]))%mod);
      }
      FOR(i,0,n-1){
      	pr(b1.query(i+1));
      }
      while(q--){
      	int bole;
      	cin >> bole;
      	if(bole){
      		int l,r;
      		cin >> l >> r;
      		pll __1;
      		__1.F = (b1.query(r)- b1.query(l-1)+ mod)%mod;
      		__1.F = (__1.F*expo(p1,1LL*(l-1)*(mod-2)))%mod;
      		__1.S = (b2.query(r) -b2.query(l-1) + mod)%mod;
      		__1.S = (__1.S*expo(p2,1LL*(l-1)*(mod-2)))%mod;
      		r = n - r + 1;
      		l = n - l + 1;swap(l,r);
      		pll __2;
      		__2.F = (b3.query(r)- b3.query(l-1)+ mod)%mod;
      		pr(__2.F);
      		__2.F = (__2.F*expo(p1,1LL*(l-1)*(mod-2)))%mod;
      		__2.S = (b4.query(r) -b4.query(l-1) + mod)%mod;
      		__2.S = (__2.S*expo(p2,1LL*(l-1)*(mod-2)))%mod;
      		pr(l,r);
      		pr(__1);pr(__2);
      		if(__1 == __2){
      			cout << "Yes\n";
      		}
      		else{
      			cout << "No\n";
      		}
      	}
      	else{
      		int i;char x;
      		cin >> i >> x;
      		i--;
      		b1.update(i+1,mod - ((s[i]-'a')*P1[i])%mod);
      		b1.update(i+1,((x-'a')*P1[i])%mod);
      		b2.update(i+1,mod - ((s[i]-'a')*P2[i])%mod);
      		b2.update(i+1,((x-'a')*P2[i])%mod);
      		b3.update(n-i,mod - ((s[i]-'a')*P1[n-i-1])%mod);
      		b3.update(n-i,((x-'a')*P1[n-i-1])%mod);
      		b4.update(n-i,mod - ((s[i]-'a')*P2[n-i-1])%mod);
      		b4.update(n-i,((x-'a')*P2[n-i-1])%mod);	
      		s[i] = x;
      		pr(b3.query(2));
      	}
      }

  }
  tm = clock()-tm ;
  cerr << (float)(tm)/CLOCKS_PER_SEC << "\n";
  return 0;
}