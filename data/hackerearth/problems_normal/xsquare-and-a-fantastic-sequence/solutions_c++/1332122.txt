#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define type(x) __typeof((x).begin())
#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); it++)

#ifdef KAZAR
    #define eprintf(...) fprintf(stderr,__VA_ARGS__)
#else
    #define eprintf(...) 0
#endif

using namespace std;

template<class T> inline void umax(T &a,T b){if(a<b) a = b ; }
template<class T> inline void umin(T &a,T b){if(a>b) a = b ; }
template<class T> inline T abs(T a){return a>0 ? a : -a;}

typedef long long ll;
typedef pair<int, int> ii;

const int inf = 1e9 + 143;
const ll longinf = 1e18 + 143;

inline int read(){int x;scanf(" %d",&x);return x;}

const int N = 101001;

int have[N][26];
int order[N][26];
char ans[N];
char s[N], t[N];
int p[N];

int get(int x){
    if(x == p[x])
        return x;
    return p[x] = get(p[x]);
}

void merge(int a,int b){
    a = get(a);
    b = get(b);
    if(a != b)
        p[a] = b;
}

void solve(){
    int n = read();
    int m = read();
    scanf(" %s", s + 1);
    scanf(" %s", t + 1);
    for(int i = 1; i <= n; i++)
        p[i] = i;
    for(int i = 0; i < m; i++){
        int a = read();
        int b = read();
        merge(a, b);
    }
    for(int i = 1; i <= n; i++){
        for(int c = 0; c < 26; c++)
            have[i][c] = order[i][c] = 0;
    }
    for(int i = 1; i <= n; i++){
        have[get(i)][s[i] - 'a']++;
        order[get(i)][t[i] - 'a']++;
        ans[i] = 0;
    }
    int res = 0;
    for(int c = 0; c < 26; c++){
        for(int i = 1; i <= n; i++){
            if(ans[i] != 0)
                continue;
            int p = get(i);
            if(t[i] == c + 'a' && have[p][c] > 0){
                ans[i] = c + 'a';
                have[p][c]--;
                order[p][c]--;
                res++;
            }
        }
        for(int i = 1; i <= n; i++){
            if(ans[i] != 0)
                continue;
            int p = get(i);
            if(have[p][c] > 0 && order[p][t[i] - 'a'] > have[p][t[i] - 'a']){
                ans[i] = c + 'a';
                order[p][t[i] - 'a']--;
                have[p][c]--;
            }
        }
    }
    ans[n + 1] = 0;
    printf("%d\n%s\n", res, ans + 1);
}

int main(){

#ifdef KAZAR
    freopen("f.input","r",stdin);
    freopen("f.output","w",stdout);
    freopen("error","w",stderr);
#endif

    int tc = read();

    while(tc--){
        solve();
    }

    return 0;
}
