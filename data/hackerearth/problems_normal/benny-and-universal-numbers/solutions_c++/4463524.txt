#include <iostream>
#include <stdio.h>
#include <cmath>
#include <algorithm>
#include <vector>
#include <utility>
#include <memory.h>
 
using namespace std;
 
const int N = 100500;
const int lcm = 360360;
const int mod = (int)1e9 + 7;
 
int n;
int sum[N];
int rems[N];
int answer[N];
bool good[111];
int f[2][20][lcm + 10];
bool mem[2][20][lcm + 10];
vector< pair<long long, int> > have[20];
 
void add(int &x, int y) {
    x += y;
    if (x >= mod) x -= mod;
    while (x < 0) {
        x += mod;
    }
    while (x >= mod) x -= mod;
}
 
int solve(int len, int flag, int prefix, int rem) {
    if (prefix == len) {
        return flag;
    }
    if (mem[flag][prefix][rem]) {
        return f[flag][prefix][rem];
    }
    int ans = 0;
    mem[flag][prefix][rem] = true;
    for (int newC = 0; newC < 10; newC++) {
        if (prefix == 0 && newC == 0) {
            continue;//3603509
        }
        int newCarry = rem * 10 + newC;
        newCarry %= (prefix + 1);
        if (newCarry != rems[prefix + 1]) {
            continue;
        }
        int newRem = rem * 10 + newC;
        newRem = newRem % lcm;
        int lstC = -1;
        int newFlag = flag;
        if (prefix != 0) {
            lstC = rem % 10;
            if (good[lstC * 10 + newC]) {
                newFlag = 1;
            }
        }
        add(ans, solve(len, newFlag, prefix + 1, newRem));
    }
    f[flag][prefix][rem] = ans;
    return ans;
}
 
bool isPrime(int x) {
    if (x == 1) return false;
    for (int i = 2; i < x; i++) {
        if (x % i == 0) return false;
    }
    return true;
}
 
void precalc() {
    good[0] = good[1] = false;
    for (int i = 2; i <= 99; i++) {
        if (isPrime(i)) {
            good[i] = true;
        }
        else {
            good[i] = false;
        }
    }
}
 
void clearDP(int len) {
    for (int i = 0; i <= len; i++) {
        memset(f[0][i], 0, sizeof(f[0][i]));
        memset(mem[0][i], false, sizeof(mem[0][i]));
        memset(f[1][i], 0, sizeof(f[1][i]));
        memset(mem[1][i], false, sizeof(mem[1][i]));
    }
}
 
int getLen(long long x) {
    int ret = 0;
    while (x > 0LL) {
        ++ret;
        x /= 10LL;
    }
    return ret;
}
 
int szd = 0;
int digits[20];
 
int process(long long value) {
    szd = 0;
    while (value > 0LL) {
        digits[++szd] = (int)(value % 10LL);
        value /= 10LL;
    }
    reverse(digits + 1, digits + 1 + szd);
    int ret = 0;
    int flag = 0;
    int rem = 0;
    bool fail = false;
    for (int prefix = 0; prefix < szd; prefix++) {
        for (int newC = 0; newC < digits[prefix + 1]; newC++) {
            if (newC == 0 && prefix == 0) continue;
            int newFlag = flag;
            int newRem = rem * 10 + newC;
            newRem %= lcm;
            if (prefix > 0) {
                if (good[digits[prefix] * 10 + newC]) {
                    newFlag = 1;
                }
            }
            if (newRem % (prefix + 1) != rems[prefix + 1]) {
                continue;
            }
            add(ret, solve(szd, newFlag, prefix + 1, newRem));
        }
        rem = rem * 10 + digits[prefix + 1];
        rem = rem % lcm;
        if (rem % (prefix + 1) != rems[prefix + 1]) {
            fail = true;
            break;
        }
        if (prefix>0&&good[digits[prefix-1] * 10 + digits[prefix]])
            flag = 1;
    }
    if (!fail) add(ret, flag);
    return ret;
}
 
int main() {
    for (int i = 1; i <= 15; i++) {
        scanf("%d", &rems[i]);
    }
    precalc();
    scanf("%d", &n);
    int le, ri;
    for (int i = 1; i <= n; i++) {
        long long a, b;
        cin >> a >> b;
        int la = getLen(a - 1);
        int lb = getLen(b);
        answer[i] = 0;
        have[la].push_back(make_pair(a - 1, -i));
        have[lb].push_back(make_pair(b, i));
    }
    sum[0] = 0;
    for (int i = 1; i <= 15; i++) {
        clearDP(i);
        solve(i, 0, 0, 0);
        sum[i] = f[0][0][0];
        add(sum[i], sum[i - 1]);
        int allAdd = sum[i - 1];
        for (int j = 0; j < (int)have[i].size(); j++) {
            int id = have[i][j].second;
            int sign = 1;
            if (id < 0) {
                sign = -1;
                id = -id;
            }
            int willGet = process(have[i][j].first);
            add(willGet, allAdd);
            willGet *= sign;
            add(answer[id], willGet);
        }
    }
    for (int i = 1; i <= n; i++) {
        printf("%d\n", answer[i]);
    }
    return 0;
}