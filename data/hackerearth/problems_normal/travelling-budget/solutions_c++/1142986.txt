#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<climits>

using namespace std;

#define maxn 510
#define fr first
#define se second
#define inf INT_MAX
vector<pair<int,pair<int,int> > > v1[maxn];
int dis[maxn][1090];
int vis[maxn][1090];



void dijkstra()
{
	priority_queue<  pair<int,pair<int,int> > , vector<pair<int,pair<int,int> > > , greater<pair<int,pair<int,int> > > > q1;
	pair<int,pair<int,int> > p1,p2;
	
	for(int i=0;i<maxn;i++)
	for(int j=0;j<1090;j++){
	dis[i][j]=inf;vis[i][j]=0;}
	
		dis[1][0]=0;
		p1.fr = 0;
		p1.se.fr = 0;//j
		p1.se.se = 1; 
		q1.push(p1);

	while(!q1.empty())
	{
		p2 = q1.top();
		q1.pop();
		int curr = p2.se.se;
		int cost = p2.se.fr;
		int t = p2.fr;
		if(vis[curr][cost])
		continue;
		vis[curr][cost]=1;
	//	if(t<dis[curr][cost])
	//	{
		for(int i=0;i<v1[curr].size();i++)
		{
			int node = v1[curr][i].fr;
			int bud = v1[curr][i].se.fr;
			int length = v1[curr][i].se.se;
			if(bud+cost<=1000 && dis[node][bud+cost]>t+length)
			{
				dis[node][bud+cost] = t + length;
				p1.fr = dis[node][bud+cost];
				p1.se.se = node;
				p1.se.fr = bud+cost;
				q1.push(p1);
			}			
		}			
	//	}
	}		
}
int main()
{
	int tc;
	scanf("%d",&tc);
	while(tc--)
	{
		int n,m,b,src,dest,cost,length;
		scanf("%d%d%d",&n,&m,&b);
		pair<int,pair<int,int> > p1;
		for(int i=0;i<maxn;i++)
		v1[i].clear();
		for(int i=0;i<m;i++)
		{	
			scanf("%d%d%d%d",&src,&dest,&cost,&length);
			p1.fr = dest;
			p1.se.fr = cost;
			p1.se.se = length;
			v1[src].push_back(p1);
		//	p1.fr=src;
		//	v1[dest].push_back(p1);
		}
		dijkstra();
		int q;
	//	cout<<inf<<endl;
		scanf("%d",&q);
		while(q--)
		{	
			scanf("%d%d",&dest,&cost);
			int ans = inf;
			for(int i=0;i<=cost;i++)
			{
				ans = min(ans,dis[dest][i]);				
			}	
			if(ans>=inf)
			printf("-1\n");
			else
			printf("%d\n",ans);
		}
	}
	return 0;
}