#include<bits/stdc++.h>
using namespace std;
int n,q;
long long arr[200000];
struct node
{
	long long left;
	long long right;
	int left_count;
	int right_count;
	int mid_count;
	int size;
	int max;
	int a;
};
node tree[500000];
node make_tree(int,int,int);
node query(int,int,int,int,int);
node update(int,int,int,int,int);
int main()
{
int test;int o,l,r;
scanf("%d",&test);int t;
int i;
for(t=0;t<test;t++)
{
scanf("%d %d",&n,&q);
for(i=0;i<n;i++)
{
scanf("%lld",&arr[i]);
}
make_tree(0,n-1,0);
for(i=0;i<q;i++)
{
scanf("%d %d %d",&o,&l,&r);
if (o==0)
{
	printf("%d\n",query(0,n-1,l-1,r-1,0).max);
}
else
{
	update(0,n-1,l-1,r,0);
}




}//q
	

}//test
	

	return 0;
}//main

node make_tree(int s,int e,int index)
{
	int mid;node temp,left,right;
	if (s==e)
	{
	temp.left=arr[s];
	temp.right=arr[s];
	temp.left_count=1;
	temp.right_count=1;
	temp.mid_count=1;
	temp.size=1;
	temp.max=1;
	temp.a=1;
	tree[index]=temp;
	return tree[index];
	}
	else
	{
	mid=(s+e)/2;
	left=make_tree(s,mid,2*index+1);
	right=make_tree(mid+1,e,2*index+2);
	temp.a=1;
	temp.left=left.left;
	temp.size=left.size+right.size;
	temp.right=right.right;
	if (left.right<right.left)
	{
	temp.mid_count=left.right_count+right.left_count;
	if (left.left_count==left.size)
	{
	temp.left_count=left.left_count+right.left_count;
	}
	else
	temp.left_count=left.left_count;
	if (right.right_count==right.size)
	{
	temp.right_count=right.right_count+left.right_count;
	}
	else
	temp.right_count=right.right_count;
	}
	else
	{
	temp.right_count=right.right_count;
	temp.left_count=left.left_count;
	temp.mid_count=max(right.mid_count,left.mid_count);
	}
	temp.max=max(temp.right_count,temp.left_count);
	temp.max=max(temp.max,temp.mid_count);
	temp.max=max(left.max,temp.max);
	temp.max=max(right.max,temp.max);
	tree[index]=temp;
	return temp;
	}//else

}//make_tree

node query(int s,int e,int l,int r,int index)
{
	node temp,left,right;int mid;
	if (l<=s && e<=r)
	{
	return tree[index];
	}
	else if (e<l || r<s)
	{
	temp.a=0;
	return temp;
	}
	else
	{
	mid=(s+e)/2;
	left=query(s,mid,l,r,2*index+1);
	right=query(mid+1,e,l,r,2*index+2);
	if (left.a==0)
	return right;
	else if (right.a==0)
	return left;
	else
	{
	temp.a=1;
	temp.left=left.left;
	temp.size=left.size+right.size;
	temp.right=right.right;
	if (left.right<right.left)
	{
	temp.mid_count=left.right_count+right.left_count;
	if (left.left_count==left.size)
	{
	temp.left_count=left.left_count+right.left_count;
	}
	else
	temp.left_count=left.left_count;
	if (right.right_count==right.size)
	{
	temp.right_count=right.right_count+left.right_count;
	}
	else
	temp.right_count=right.right_count;
	}
	else
	{
	temp.right_count=right.right_count;
	temp.left_count=left.left_count;
	temp.mid_count=max(right.mid_count,left.mid_count);
	}
	temp.max=max(temp.right_count,temp.left_count);
	temp.max=max(temp.max,temp.mid_count);
	temp.max=max(left.max,temp.max);
	temp.max=max(right.max,temp.max);
	return temp;
	}

	}//else

}//query

node update(int s,int e,int l,int val, int index)
{
	node left,right,temp;int mid;
	if (s==l && e==l)
	{
	arr[s]=arr[s]+val;
	tree[index].left=arr[s];
	tree[index].right=arr[s];
	return tree[index];
	}
	else if (e<l || s>l)
	{
	return tree[index];
	}
	else
	{
	mid=(s+e)/2;
	left=update(s,mid,l,val,2*index+1);
	right=update(mid+1,e,l,val,2*index+2);
	temp.a=1;
	temp.left=left.left;
	temp.size=left.size+right.size;
	temp.right=right.right;
	if (left.right<right.left)
	{
	temp.mid_count=left.right_count+right.left_count;
	if (left.left_count==left.size)
	{
	temp.left_count=left.left_count+right.left_count;
	}
	else
	temp.left_count=left.left_count;
	if (right.right_count==right.size)
	{
	temp.right_count=right.right_count+left.right_count;
	}
	else
	temp.right_count=right.right_count;
	}
	else
	{
	temp.right_count=right.right_count;
	temp.left_count=left.left_count;
	temp.mid_count=max(right.mid_count,left.mid_count);
	}
	temp.max=max(temp.right_count,temp.left_count);
	temp.max=max(temp.max,temp.mid_count);
	temp.max=max(left.max,temp.max);
	temp.max=max(right.max,temp.max);
	tree[index]=temp;
	return temp;
	}

}//update