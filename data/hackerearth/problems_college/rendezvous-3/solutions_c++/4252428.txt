//Archit Rai
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define sz(a) (int)(a.size())
#define all(c) (c).begin(),(c).end()
#define F first
#define S second
#define si(n) scanf("%d",&n)
#define sll(n) scanf("%lld",&n)
#define REP(i,a,b) for(int i=a;i<b;i++)
#define MOD 1000000007
#define endl '\n'
#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)
#define N 100010
typedef long long int ll;
ll powmod(ll a,ll b)
{
    if(b==0)return 1;
    ll x=powmod(a,b/2);
    ll y=(x*x)%MOD;
    if(b%2)
	return (a*y)%MOD;
    return y%MOD;
}
//Template ends here
vector<pair<ll,pair<int,int> > > graph;
int parent[N],rnk[N];
ll ans=0;
int find(int x)
{
    if(parent[x]!=x)
	parent[x]=find(parent[x]);
    return parent[x];
}
void union_set(int x,int y)
{
    int xroot=find(x);
    int yroot=find(y);
    //Attach smaller rnk tree under higher rnk tree
    if(rnk[xroot]>rnk[yroot])
	parent[yroot]=xroot;
    else if(rnk[yroot]>rnk[xroot])
	parent[xroot]=yroot;
    else
    {
	parent[xroot]=yroot;
	rnk[xroot]++;
    }
}
void kruskal()
{
    sort(all(graph));
    for(int i=0;i<sz(graph);i++)
    {
	int x=find(graph[i].S.F);
	int y=find(graph[i].S.S);
	if(x!=y)
	{
	    ans+=graph[i].F;
	    union_set(x,y);
	}
    }
}
int main()
{
    int n;
    si(n);
    REP(i,0,n)
    {
	parent[i]=i;
	rnk[i]=0;
    }
    int m;
    si(m);
    REP(i,0,m)
    {
	int a,b;
	ll c;
	si(a);
	si(b);
	sll(c);
	a--;
	b--;
	graph.pb(mp(c,mp(a,b)));
    }
    kruskal();
    printf("%lld\n",ans);
    return 0;
}
