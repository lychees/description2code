/*   ARSHEYA RAJ   */

#include <iostream>
#include <bits/c++io.h>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <deque>
#include <string.h>
#include <algorithm>
#include <iomanip>
#include <exception>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <iterator>
#include <climits>
 
#define ll long long int
#define MAX(a,b) (a>b)?a:b
#define MIN(a,b) (a>b)?b:a
#define FOR(i,n) for(int i=1;i<=n;i++)
#define FOR_X(i,x,n) for(i=x;i<n;i++)
#define BACK(i,n) for(i=n;i>0;i--)
#define BACK_X(i,n,x) for(i=n;i>=x;i--)
#define fill(a,v) memset(a,v,sizeof(a))
#define pb push_back
#define pp pair<int,int>
#define mod 1000000007
#define MAX_N 100000

template< class T > T sq(T &x) { return x * x; }
template< class T > T abs(T &n) { return (n < 0 ? -n : n); }
template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); }
template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); }
template< class T > bool inside(T &a, T &b, T &c) { return a<=b && b<=c; }
template< class T > void setmax(T &a, T b) { if(a < b) a = b; }
template< class T > void setmin(T &a, T b) { if(b < a) a = b; }

const double EPS = 1e-9;
const int INF = 0x3f3f3f3f;

using namespace std;

ll n,m,u,v,x;
vector<ll> graph[MAX_N],revgraph[MAX_N];
vector<ll> p[MAX_N];
stack<ll> s;
ll visited[MAX_N]={0},cost[MAX_N]={0};

void toposort(ll x){
	visited[x]=1;
	ll i;
	for(i=0;i<(ll)graph[x].size();i++){
		if(visited[graph[x][i]]==0)
			toposort(graph[x][i]);
	}
	s.push(x);
}

void scc(ll x,ll src){
	ll i;
	visited[x]=1;
	p[src].pb(x);
	for(i=0;i<(ll)revgraph[x].size();i++){
		if(visited[revgraph[x][i]]==0)
			scc(revgraph[x][i],src);
	}
}

int main(){
	ll i,t,ans=0,finalans=0;
	scanf("%lld",&t);
	while(t--){
		for(i=0;i<n;i++){
			graph[i].clear();
			revgraph[i].clear();
			p[i].clear();
		}
		scanf("%lld %lld",&n,&m);
		for(i=0;i<n;i++)
			cost[i]=0;
		for(i=0;i<n;i++){
			scanf("%lld",&cost[i]);
		}
		for(i=0;i<m;i++){
			scanf("%lld %lld",&u,&v);
			graph[u].pb(v);
			revgraph[v].pb(u);
		}
		for(i=0;i<n;i++)
			visited[i]=0;
		for(i=0;i<n;i++){	
			if(visited[i]==0){
				toposort(i);
			}
		}
		for(i=0;i<n;i++)
			visited[i]=0;
		while(!s.empty()){
			x=s.top();
			s.pop();
			if(visited[x]==0){
				scc(x,x);
				for(i=0;i<(ll)p[x].size();i++){
					ans=ans+cost[p[x][i]];
				}
				//printf("ans=%lld finalans=%lld\n",ans,finalans);
				finalans=MAX(finalans,ans);
				ans=0;
			}
		}
		printf("%lld\n",finalans);
		ans=0;
		finalans=0;
	}
return 0;
}