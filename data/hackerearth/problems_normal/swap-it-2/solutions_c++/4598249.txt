/*
Bob loves sorting very much. He is always thinking of new ways to sort an array.His friend Ram gives him a challenging task.He gives Bob an array and an integer K .The challenge is to produce the lexicographical minimal array after at most K-swaps.Only consecutive pairs of elements can be swapped.Help Bob in returning the lexicographical minimal array possible after at most K-swaps.

Input:
The first line contains an integer T i.e. the number of Test cases. T test cases follow. Each test case has 2 lines. The first line contains N(number of elements in array) and K(number of swaps).The second line contains n integers of the array.

Output:
Print the lexicographical minimal array.

Constraints:

1<=T<=10
1<=N,K<=1000
1<=A[i]<=1000000
*/

#include <iostream>
#include <string>
#include <cstring>
using namespace std;


bool smaller(long num1, long num2) {
	string s1, s2;
	s1 = to_string(num1);
	s2 = to_string(num2);
	if (strcmp(s1.c_str(), s2.c_str()) <= 0) {  // smaller  
		return true;
	}
	return false;
}

long findmin(long list[], long begin, long end) {

	long minIndex = begin;

	for (long k = begin ; k <= end; k++) {
		if (list[k] < list[minIndex]) {
			minIndex = k;
		}
	}
	return minIndex;
}
void swapme(long list[], long i, long j) {

	long tmp = 0;
	tmp = list[i];
	list[i] = list[j];
	list[j] = tmp;
}

int main()
{
    long T, N, K, tmp;
    long index;
    cin >> T;

    while(T--) {

    	cin >> N >> K;
    	long list[N];

    	for (long n = 0; n < N; n++) {
    		cin >> list[n];
    	}
    	for (long n = 0; n < N; n++) {
    		if (K == 0) {
    			break;
    		}
    		index = findmin(list, n, min(n + K, N - 1));

    		for (long i = index; i > n ; i--) {
    			 swapme(list, i, i - 1);
    			 K--;
    		}
    	}
    	for (long n = 0; n < N; n++) {
    		cout << list[n] << " ";
    	}
    	cout << endl;

    }
    return 0;
}
