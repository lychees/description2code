#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define X first
#define Y second
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define FILL(a,x) memset(a,x,sizeof(a))
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	mp make_pair
#define	pb push_back

inline int max(int a,int b){return a<b?b:a;}
inline int min(int a,int b){return a>b?b:a;}
inline ll max(ll a,ll b){return a<b?b:a;}
inline ll min(ll a,ll b){return a>b?b:a;}
const int mod = 1e9+7;
const int N = 1e6+10;
const ll INF = 1e18;


int arr[N],p[N];
int cmp1(int x,int y){
  return arr[x]>arr[y];
}
int s[N],e[N];
int par_uf[N],rank_uf[N];
class set{
public:

        void init(int n){
          for(int i = 0; i <= n; i++){
            par_uf[i] = i;
            rank_uf[i] = 1;
            s[i]=-1;e[i]=-1;
          }
        }
        int find(int x){
          if(par_uf[x] == x)return x;
          else return par_uf[x] = find(par_uf[x]);
        }
        void unite(int x, int y){
          x=find(x); y=find(y);
          if(x == y) return;
          int l=min(s[x],s[y]),r=max(e[x],e[y]);
          if(rank_uf[x] < rank_uf[y]){ par_uf[x] = y;rank_uf[y] += rank_uf[x]; s[y]=l;e[y]=r;}
          else{
            par_uf[y]=x;
            rank_uf[x] += rank_uf[y];
            s[x]=l;e[x]=r;
          }

        }
        bool same(int x, int y){
          return find(x) == find(y);
        }

} s1;
int f[N];
int main(){
  int n,cmp=0,ms=0;
  scanf("%d",&n);
  REP(i,n){
    scanf("%d",&arr[i+1]);
    p[i]=i+1;
    ms=max(arr[i+1],ms);
  }
  s1.init(n+3);
  sort(p,p+n,cmp1);
  int h=0,mx=-1,mi=mod,z=0;
  REP(i,n){
    if(arr[i+1]==ms){
      z++;
    }else if(z>0){
      //printf("g%d\n",z);
      f[1]++;f[z+1]--;z=0;

    }
  }
  if(z>0){
    //printf("g%d\n",z);
    f[1]++;f[z+1]--;
  }
  while(h<n){
    int x=arr[p[h]],t=h;
    while(arr[p[h]]==x&&h<n){
      int pv=p[h]-1,nx=p[h]+1;
      s[s1.find(p[h])]=e[s1.find(p[h])]=p[h];
      if(s[s1.find(pv)]!=-1){
        s1.unite(p[h],pv);
      }
      if(s[s1.find(nx)]!=-1){
        s1.unite(p[h],nx);
      }
    //  printf("hh%d %d %d\n",arr[p[h]],s[s1.find(p[h])],e[s1.find(p[h])]);
      h++;
    }
    if(mi<=mx){
      if(s1.same(mi,mx)){
        int d=e[s1.find(mi)]-s[s1.find(mi)]+1;
      //  printf("%d %d\n",mx,mi);
        f[mx-mi+1]++; f[d+1]--;
      }
    }
    while(t<h){
      mx=max(mx,p[t]);
      mi=min(mi,p[t]);
      t++;
  //    printf("%d %d\n",mx,mi);
    }
  }
  int ans=0;
  REPP(i,1,n+1){
    ans+=f[i];
    if(ans>0) printf("1"); else printf("0");
  }
  printf("\n");
  return 0;
}
