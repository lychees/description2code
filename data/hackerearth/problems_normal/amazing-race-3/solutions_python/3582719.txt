def possible(time):
	match = [-1 for i in xrange(m)]
	vis = [0 for i in xrange(n)]
	ret, tim = 0, 42
	def dfs(u):
		vis[u] = tim
		for t, i in G[u]:
			if t <= time:
				if match[i] == -1 or (vis[match[i]] != tim and dfs(match[i])):
					match[i] = u
					return True
			else:
				break
		return False
	for i in xrange(n):
		if dfs(i):
			ret += 1
			tim += 1
	return ret

n, m, k = map(int, raw_input().split())
start, end = [], []
for _ in xrange(n):
	start.append(map(int, raw_input().split()))
for _ in xrange(m):
	end.append(map(int, raw_input().split()))
speed = map(int, raw_input().split())

G = []
for i, x in enumerate(start):
	G.append([])
	for j, y in enumerate(end):
		d = (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2
		s = speed[i] ** 2
		t = d / s + (1 if d % s else 0)
		G[-1].append((t, j))
		G[-1].sort()

lo, hi = 0, 10 ** 20
while lo < hi:
	mi = (lo + hi) / 2
	if possible(mi) >= k:
		hi = mi
	else:
		lo = mi + 1
print lo