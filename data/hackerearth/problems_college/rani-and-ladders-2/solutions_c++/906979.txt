//
//  main.cpp
//  Rani and Ladders
//
//  Created by Pritam Khan on 26/10/14.
//  Copyright (c) 2014 Pritam Khan. All rights reserved.
//
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;

struct queueEntry
{
    int v;
    int dist;
};
int getMinDiceThrows(int move[], int N)
{
    bool *visited = new bool[N];
    for (int i = 0; i < N; i++)
        visited[i] = false;
    queue<queueEntry> q;
    visited[0] = true;
    queueEntry s = {0, 0};
    q.push(s);
    queueEntry qe;
    while (!q.empty())
    {
        qe = q.front();
        int v = qe.v;
        if (v == N-1)
            break;
        q.pop();
        for (int j=v+2; j<=(v+12) && j<N; ++j)
        {
            if (!visited[j])
            {
                queueEntry a;
                a.dist = (qe.dist + 1);
                visited[j] = true;
                if (move[j] != -1)
                    a.v = move[j];
                else
                    a.v = j;
                q.push(a);
            }
        }
    }
    return qe.dist;
}
bool comp(pair<int, int>a,pair<int, int>b)
{
    return a.second<b.second;
}
int turn(int src,int dest)
{
    int diff=dest-src;
    if (diff%12==0)
        return diff/12;
    return (diff/12)+1;

}
int main()
{
        int t;
        scanf("%d",&t);
        while (t--) {
            int n,l,flag=0,start=1;
           scanf("%d %d",&n,&l);
            int moves[n];
            vector<pair<int, int > > lad;
            map<int,int>mm;
            while(l--)
           {
           int b,u;
        scanf("%d %d",&b,&u);
               lad.push_back(make_pair(b, u));
               mm[b]=u;
               if (b==1)
                   flag=1;
           }
            if(flag==1)
            {
            while(mm.find(start)!=mm.end())
            {
                start=mm[start];
            }
            }
            //cout<<"start is "<<start<<endl;
            
            if(flag==1)
            {
                int move[n-start+1];
                for (int i=0;i<(n-start+1);i++)
                {
                    move[i]=-1;
                }
                for (int i=0;i<lad.size();i++)
                {
                    if (lad[i].first>start)
                    {
                        move[lad[i].first-start]=lad[i].second-start;
                    }
                }
//                for (int i=0;i<(n-start+1);i++)
//                {
//                    cout<<move[i]<<endl;
//                }
            cout <<getMinDiceThrows(move, n-start+1)<<endl;
            }
            else
            {
                for (int i = 0; i<n; i++)
                    moves[i] = -1;
                for (int i=0;i<lad.size();i++)
                {
                    moves[lad[i].first-1]=lad[i].second-1;
                }
                cout<<getMinDiceThrows(moves, n)<<endl;
            }
            
        }
    return 0;
}

