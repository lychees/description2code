    //sourav verma   ABV IIITM

#include <bits/stdc++.h>

#define ll long long int
#define loop(i,a,b) for(int i=(int)a;i<(int)b;++i)
#define rloop(i,a,b) for(int i=(int)a;i>=(int)b;--i)
#define loopl(i,a,b) for(ll i=(ll)a;i<(ll)b;++i)
#define rloopl(i,a,b) for(ll i=(ll)a;i>=(ll)b;--i)
#define pb push_back
#define eb emplace_back
#define ab(a) (a<0)?(-1*a):a
#define pc putchar_unlocked
#define gc getchar_unlocked
#define mset(a,b,c) loop(i,0,b) a[i]=c
#define F first
#define S second
#define mp make_pair
#define clr(x) x.clear()
#define MOD 1000000007
#define MAX 1e9
#define MIN -1e9
#define itoc(c) ((char)(((int)'0')+c))
#define vi vector<int>
#define vvi vector<vi>
#define pll pair<ll,ll>
#define pii pair<int,int>
#define all(p) p.begin(),p.end()
#define max(x,y) (x>y)?x:y
#define min(x,y) (x<y)?x:y
#define mid(s,e) (s+(e-s)/2)
#define mini INT_MIN
#define sv() int t; rdi(t); while(t--)
using namespace std;
ll gcd(ll a, ll b) {if (a == 0 || b == 0) return max(a,b); if (b % a == 0) return a; return gcd(b%a, a);}
ll hcf(ll a, ll b) {if(b>a) return (hcf(b, a)); if(a%b==0) return b; return (hcf(b, a%b));} 
ll modpow(ll a,ll b) {ll res=1;a%=MOD;for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}
inline void rdi(int &n) { n=0; char c=gc(); while(c<'0' or c>'9') c=gc(); while(c>='0' and c<='9') { n=(n<<3)+(n<<1)+c-'0'; c=gc(); }}
inline void rdl(ll &n) { n=0; char c=gc(); while(c<'0' or c>'9') c=gc(); while(c>='0' and c<='9') { n=(n<<3)+(n<<1)+c-'0'; c=gc(); }}
inline void print(int a) { char s[20]; int i=0; do { s[i++]=a%10+'0'; a/=10; } while(a); i--; while(i>=0) pc(s[i--]); pc('\n'); }
inline void prlong(ll a) { char s[20]; int i=0; do { s[i++]=a%10+'0'; a/=10; } while(a); i--; while(i>=0) pc(s[i--]); pc('\n'); }

ll fibonacci(int n){
    ll fib[2][2]= {{1,1},{1,0}},ret[2][2]= {{1,0},{0,1}},tmp[2][2]= {{0,0},{0,0}};
    int i,j,k;
    while(n){
        if(n&1){
            memset(tmp,0,sizeof tmp);
            for(i=0; i<2; i++) for(j=0; j<2; j++) for(k=0; k<2; k++)
                        tmp[i][j]=(tmp[i][j]+(ret[i][k]*fib[k][j])%MOD)%MOD;
            for(i=0; i<2; i++) for(j=0; j<2; j++) ret[i][j]=tmp[i][j];
        }
        memset(tmp,0,sizeof tmp);
        for(i=0; i<2; i++) for(j=0; j<2; j++) for(k=0; k<2; k++)
                    tmp[i][j]=(tmp[i][j]+(fib[i][k]*fib[k][j])%MOD)%MOD;
        for(i=0; i<2; i++) for(j=0; j<2; j++) fib[i][j]=tmp[i][j];
        n/=2;
    }
    return (ret[0][1]);
}

ll non_fib(int n){
	int a=1, b=2, c=3,ans;
    while(n>0){
        a=b; b=c; c=a+b;
        n-=(c-b-1);
    }
    n+=(c-b-1);
    ans=b+n;
    return ans;
}

int main() {
	sv(){
		int n; rdi(n);
		ll a=non_fib(n),b=fibonacci(n); b%=MOD;
		ll ans=modpow(a,b);
		ans%=MOD;
		prlong(ans);
	}
	// your code goes here
	return 0;
}