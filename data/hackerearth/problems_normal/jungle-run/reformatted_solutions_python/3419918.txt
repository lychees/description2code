t = input()
a = [0 for i in range(t)]
for _ in xrange(t):
    l = raw_input().split()
    a[_] = l
dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down,upward,right,left(i,j)
mark = [[0 for j in xrange(t+1)] for i in xrange(t+1)]
parent = [[0 for j in xrange(t+1)] for i in xrange(t+1)]


def valid(y, x):
    return y >= 0 and x >= 0 and y < t and x < t


def bfs(start):
    q = []
    q.append(start)
    Found = False
    l = 0
    m = 0
    while q and not Found:
        top = q.pop(0)
        # print top
        if a[top[0]][top[1]] == "E":
            l, m = top[0], top[1]
            # print "l,m",(l,m)
            Found = True

        for k in dif:
            if (valid(top[1] +
                      k[1], top[0] +
                k[0])) and (a[top[0] +
                              k[0]][top[1] +
                                    k[1]] == "P" or a[top[0] +
                                                      k[0]][top[1] +
                                                            k[1]] == "E") and mark[top[0] +
                                                                                   k[0]][top[1] +
                                                                                         k[1]] == False:
                mark[top[0]+k[0]][top[1]+k[1]] = True
                parent[top[0]+k[0]][top[1]+k[1]] = parent[top[0]][top[1]]+1
                q.append((top[0]+k[0], top[1]+k[1]))

    return l, m


for i in xrange(t+1):
    for j in xrange(t+1):
        if a[i][j] == "S":
            tI = bfs((i, j))
            break
    break
# print parent
# print tI
print parent[tI[0]][tI[1]]
