//
//  main.cpp
//  CaptureCastleHE
//
//  Created by Shashank Shekhar on 21/07/16.
//  Copyright Â© 2016 Shashank Shekhar. All rights reserved.
//

#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <unordered_map>
#include <map>
#include <set>
#include <queue>
#include <cstring>
#define minInt INT_MIN
#define maxInt INT_MAX
#define umaxInt UINT_MAX
#define llminInt LLONG_MIN
#define llmaxInt LLONG_MAX
#define MOD 1000000007
#define mp(a, b) make_pair(a, b)
#define pb(a) push_back(a)
#define fr(i,a,N) for (int i =a;i<N;i++)
#define fre(i,a,N) for (int i =a;i<=N;i++)
#define lli long long int
#define ui unsigned int
#define vi vector<int>
#define vpii vector<pair<int,int>>
using namespace std;


int adj[1001][1001];
int dp[1002][1002];
int N,M,CX,CY;
int arx[] = {0,0,-1,1};
int ary[] = {-1,1,0,0};
bool check(int i,int j,int x,int y) {
    if (i<1 || i>M  || j<1 || j>N) return 0;
//    cout << dp[x][y] << " " << adj[i][j] << " " << dp[i][j];
    if (dp[x][y] + adj[i][j] >= dp[i][j]) return 0;
//    cout << "returning tre \n";
    return true;
}
void bfs (int i,int j) {
    queue <pair<int,int>> q;
    q.push(mp(i,j));
    dp[i][j]= adj[i][j];
    while (!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        fr(k,0,4) {
            if (check(x+arx[k],y+ary[k],x,y)) {
                q.push(mp(x+arx[k],y+ary[k]));
                int val = dp[x][y] + adj[x+arx[k]][y+ary[k]];
                dp[x+arx[k]][y+ary[k]] = min(val, dp[x+arx[k]][y+ary[k]]);
            }
        }
    }
}

int main(int argc, const char * argv[]) {
    // insert code here..
    int t,e;
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >>t;
    for (;t>0;--t ) {
        memset (adj,0,sizeof adj);
//        memset (dp,10000000,sizeof dp);
        fre(i,1,1001)
        fre(j,1,1001)
        dp[i][j] = maxInt;
        cin >>M>>N;
        fre(i,1,M)
        fre(j,1,N)
        cin >> adj[i][j];
        cin >>CX>>CY>>e;
        bfs(1,1);
        if (dp[CX][CY] < e) {
            cout << "YES\n" << (e- dp[CX][CY]) << "\n";
        } else cout << "NO\n";
    }
    return 0;
}