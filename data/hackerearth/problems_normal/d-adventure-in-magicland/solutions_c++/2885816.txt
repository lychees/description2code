#include <algorithm>
#include <cassert>
#include <cstring>
#include <iostream>
#include <complex>

using namespace std;

#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define REP(i, n) FOR(i, 0, n)
#define TRACE(x) cout << #x << " = " << x << endl
#define _ << " _ " <<

typedef long long llint;

const int MAX = 100100;

namespace FFT {
  const int MAX = 1 << 18;
 
  typedef llint value;
  typedef complex<double> comp;
 
  int N;
  comp omega[MAX];
  comp a1[MAX], a2[MAX];
  comp z1[MAX], z2[MAX];
 
  void fft(comp *a, comp *z, int m = N) {
    if (m == 1) {
      z[0] = a[0];
    } else {
      int s = N/m;
      m /= 2;
 
      fft(a, z, m);
      fft(a+s, z+m, m);
 
      REP(i, m) {
        comp c = omega[s*i] * z[m+i];
        z[m+i] = z[i] - c;
        z[i] += c;
      }
    }
  }
 
  void mult(value *a, value *b, value *c, int len) {
    if (len < 64) {
      REP(i, 2*len) c[i] = 0;
      REP(i, len) REP(j, len) c[i+j] += a[i] * b[j];
      return;
    }

    N = 2*len;
    while (N & (N-1)) ++N;
    assert(N <= MAX);
 
    REP(i, N) a1[i] = 0;
    REP(i, N) a2[i] = 0;
    REP(i, len) a1[i] = a[i];
    REP(i, len) a2[i] = b[i];
 
    REP(i, N) omega[i] = polar(1.0, 2*M_PI/N*i);
    fft(a1, z1, N);
    fft(a2, z2, N);
 
    REP(i, N) omega[i] = comp(1, 0) / omega[i];
    REP(i, N) a1[i] = z1[i] * z2[i] / comp(N, 0);
    fft(a1, z1, N);
 
    REP(i, 2*len) c[i] = round(z1[i].real());
  }
}


vector<llint> ans, tmp, tmps, tmp2;
vector<llint> v[MAX];

vector<int> E[MAX];
bool bio[MAX];
int sz[MAX], bal[MAX];
vector<int> who;

void sqr(vector<llint>& a) {
  static llint A[MAX], B[MAX];
  int n = a.size();
  tmp.resize(2 * n);
  //  tmp2.resize(2 * n);
  FFT::mult(&a[0], &a[0], &tmp[0], n);
  //  REP(i, n) A[i] = a[i] / 256, B[i] = a[i] % 256;
  //  FFT::mult(B, &a[0], &tmp[0], n);
  //  FFT::mult(A, &a[0], &tmp2[0], n);
  //  REP(i, 2*n) tmp[i] += tmp2[i] * 256;
}

void dodaj(vector<llint>& a, vector<llint>& b, int k) {
  if (a.size() < b.size()) a.resize(b.size(), 0);
  REP(i, (int)b.size()) a[i] += b[i] * k;
}

void dfs(int x, int dad) {
  sz[x] = 1;
  bal[x] = 0;
  who.push_back(x);
  for (int y: E[x]) {
    if (y == dad) continue;
    if (bio[y]) continue;

    dfs(y, x);
    sz[x] += sz[y];
    bal[x] = max(bal[x], sz[y]);
  }
}

void dfs2(int x, int dad, vector<llint>& v, int dep) {
  if (dep >= (int)v.size()) v.resize(dep+1, 0);
  v[dep]++;
  for (int y: E[x])
    if (y != dad && !bio[y]) dfs2(y, x, v, dep + 1);
}

void solve(int x) {
  who.clear();
  dfs(x, -1);

  int r = x;
  for (int y: who) {
    bal[y] = max(bal[y], (int)who.size() - sz[y]);
    if (bal[y] < bal[r]) r = y;
  }

  x = r;
  bio[x] = true;
  //  TRACE(x);

  tmps.clear();
  for (int y: E[x]) {
    if (bio[y]) continue;
    
    v[y].clear();
    dfs2(y, x, v[y], 1);
    dodaj(tmps, v[y], +1);
    sqr(v[y]);
    dodaj(ans, tmp, -1);
  }
    
  dodaj(ans, tmps, +2);
  sqr(tmps);
  dodaj(ans, tmp, +1);

  for (int y: E[x])
    if (!bio[y]) solve(y);
}

const int mod = 1e9 + 7;

inline int add(int a, int b) {
  return a+b >= mod ? a+b-mod : a+b;
}

inline int mul(int a, int b) {
  return llint(a)*b % mod;
}

int powmod(int a, int b) {
  if (b == 0) return 1;
  if (b&1) return mul(a, powmod(a, b-1));
  return powmod(mul(a, a), b/2);
}

int main(void) {
  int n, k;
  scanf("%d %d", &n, &k);
  REP(i, n-1) {
    int a, b;
    scanf("%d %d", &a, &b); --a, --b;
    E[a].push_back(b);
    E[b].push_back(a);
  }

  solve(0);
  int total = 0;
  REP(i, (int)ans.size()) {
    total = add(total, mul(powmod(i, k), (ans[i]/2)%mod));
  }
  printf("%d\n", total);
  return 0;
}
