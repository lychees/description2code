/*
note:-
Consider a continuous streak of k 1's that end at position i.
 To form this, the value at position i-k must be 0.
 Note than any other sequence which ends at 1 at position i-k, will either form a continuous streak at position < i or have to form at a position > i.
*/

#include<bits/stdc++.h>
#include<algorithm>
using namespace std;
#define fr(i,a,b) for(int i=a;i<b;i++)
#define frn(i,a,b) for(int i=a;i>b;i--)
#define si(x) scanf("%d",&x)
#define sll(x)  scanf("%lld",&x)
#define pln printf("\n")
#define pi(x) printf("%d",x)
#define pll(x) printf("%lld",x)
#define mp make_pair
#define pb push_back
#define x first
#define y second
typedef long long ll;
ll MOD=1000000007;
ll pw(ll a,ll b){
  ll r=1;
  while(b>0){
     if(b&1){
       r=(r*a)%MOD;
        }
     b=b>>1;
     a=(a*a)%MOD;
  }
return r;
}
int vis[1010][1010]={{}};
ll dp[1010][1010]={{}};
   int n,k;
   //filling from right to left
ll fun(int boxes,int zeroonright){
    if(vis[boxes][zeroonright])return dp[boxes][zeroonright];
    vis[boxes][zeroonright]=1;
    if(boxes==0)return dp[boxes][zeroonright]=1;
    ll t1=0,t2=0;
    if(zeroonright+1<k){//k-1 consecutive 1's
        t1=fun(boxes-1,zeroonright+1);//marking 1
    }
      t2=fun(boxes-1,0);//marking 0

     return dp[boxes][zeroonright]=t1+t2;
}



int main(){

    si(n),si(k);
   ll g,num=0,den=pow(2,n);

     num=den-fun(n,0);
    g=__gcd(num,den);

    printf("%lld/%lld\n",num/g,den/g);


return 0;
}
/*
sol 2=>
dp[0][0]=1;
for (int i=0;i<n;i++)
{
 for (int j=0;j<k;j++)
 {
  dp[i+1][0]+=dp[i][j];
  dp[i+1][j+1]+=dp[i][j];
 }
}
ans=0;
for (int j=0;j<k;j++)
 ans+=dp[n][j];


*/


