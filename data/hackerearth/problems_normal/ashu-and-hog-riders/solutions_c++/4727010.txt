/*
#########################################
#        Syed Omar Ali                  #
#        Aligarh Muslim University      #
#        III Year                       #
#########################################
*/
#include<bits/stdc++.h>

using namespace std;
typedef long long int ll;
typedef unsigned long long int ull;

#define rep(n) for(ll i=0; i<(n); i++)
#define wl(n) while(n--)
#define mem(x,val) memset((x),(val),sizeof(x));
#define vl vector<ll>
#define vb vector<bool>
#define vvl vector<vl >
#define vvb vector<vb >
#define all(x) (x.begin(),x.end())
#define sz(x) ((ll)x.size())
#define pb push_back
#define em(x) (!x.empty())
#define MAX INT_MAX*INT_MAX
#define MIN INT_MIN*INT_MIN
#define MOD 1000000007
#define pr pair<ll,ll>
#define mp make_pair
#define F first
#define S second
#define sl(x) scanf("%lld",&x)
#define si(x) scanf("%d",&x)
#define t() ll tst,test=1; sl(tst); while(tst--)

template<class T1> void deb(T1 e1) {
    cout << e1 << endl;
}

template<class T1,class T2> void deb(T1 e1, T2 e2) {
    cout << e1 << " " << e2 << endl;
}
vvb mat;
vvb visited;
ll counter = 0;
void BFS(ll starti,ll startj,ll N);
vector<pair<ll,ll> > getAdjacents(ll i,ll j,ll R,ll C);
int main(){
    ll N;
    sl(N);
    counter =0;
    mat.clear();
    ll no;
    for(ll i=0;i<N;i++){
        vb row;
        vb row1;
        for(ll j=0;j<N;j++){
            sl(no);
            if(no)
                row.pb(true);
            else
                row.pb(false);
            row1.pb(false);
        }
        mat.pb(row);
        visited.pb(row1);
    }
    ll maxm = -1;
    for(ll i=0;i<N;i++){
        for(ll j=0;j<N;j++){
            if(!visited[i][j] && mat[i][j]){
                counter = 0;
                BFS(i,j,N);
                //cout << counter << endl;
                if(maxm<counter)
                    maxm  = counter;
            }
        }
    }
    cout << maxm << endl;
    //BFS(0,0,N);
    return 0;
}
void BFS(ll starti,ll startj,ll N){
    visited[starti][startj] = true;
    queue<pair<ll,ll> > q;
    q.push(make_pair(starti,startj));
    while(!q.empty()){
        pair<ll,ll> p = q.front();
        q.pop();
        starti = p.first;
        startj = p.second;
        //cout << mat[starti][startj];

        counter++;
        vector<pair<ll,ll> > adj = getAdjacents(starti,startj,N,N);
        for(ll i=0;i<adj.size();i++){
            if(mat[adj[i].first][adj[i].second] && !visited[adj[i].first][adj[i].second]){
                visited[adj[i].first][adj[i].second] = true;
                //cout << adj[i].first << "," << adj[i].second << " ";
                q.push(make_pair(adj[i].first,adj[i].second));
                //cout << "h";
            }

        }
        //cout << q.size();
    }
}
vector<pair<ll,ll> > getAdjacents(ll i,ll j,ll R,ll C){
    vector<pair<ll,ll> > v;
    if(j+1<C)
        v.push_back(make_pair(i,j+1));
    if(j-1>=0)
         v.push_back(make_pair(i,j-1));
    if(i+1<R)
        v.push_back(make_pair(i+1,j));
    if(i-1>=0)
        v.push_back(make_pair(i-1,j));
    return v;
}
