#ifndef SUFFIXARRAY_H_INCLUDED
#define SUFFIXARRAY_H_INCLUDED

#include <algorithm>
#include <vector>

class suffix_array
{
public:
    std::vector<int> suftab[2];
    std::vector<int> order;
    std::vector<int> sufarr;
    std::vector<int> bucket_count, bucket_size;
    std::vector<int> lcp; // lcp(sa[i], sa[i+1]) == sa.lcp[i]
    template<class T>
    void build_sa(T S[], int N)
    {
        suftab[0].resize(N);
        suftab[1].resize(N);
        order.resize(N);
        sufarr.resize(N);
        bucket_count.resize(N+1);
        bucket_size.resize(N+1);
        for(int i=0; i<N; i++)
            order[i]=S[i];
        std::sort(order.begin(), order.end());
        for(int i=0; i<N; i++)
            suftab[0][i]=std::lower_bound(order.begin(), order.end(), S[i])-order.begin();
        int lg=0;
        while((1<<lg)<N)
            lg++;
        int row=0;
        for(int hlen=1; hlen<(1<<lg); hlen*=2, row^=1)
        {
            bucket_count.assign(N+1, 0);
            int pos=0;
            for(int i=0; i+hlen<N; i++)
                bucket_count[suftab[row][i+hlen]+1]++;
            for(int i=N-hlen; i<N; i++)
                order[pos++]=i;
            bucket_count[0]=pos;
            std::partial_sum(bucket_count.begin(), bucket_count.end(), bucket_size.begin());
            for(int i=0; i+hlen<N; i++)
                order[bucket_size[suftab[row][i+hlen]]++]=i;
            bucket_count[0]=0;
            for(int i=0; i<hlen; i++)
                bucket_count[suftab[row][i]+1]++;
            std::partial_sum(bucket_count.begin(), bucket_count.end(), bucket_size.begin());
            for(int i=0; i<N; i++)
                sufarr[bucket_size[suftab[row][order[i]]]++]=order[i];
            int prev_a=-1, prev_b=-1, prev_c=-1;
            for(int i=0; i<N; i++)
            {
                const int x=sufarr[i];
                const int now_a=suftab[row][x];
                const int now_b=(x+hlen<N?suftab[row][x+hlen]:-1);
                prev_c+=now_a!=prev_a || now_b!=prev_b;
                suftab[row^1][x]=prev_c;
                prev_a=now_a;
                prev_b=now_b;
            }
        }
        if(row==1)
            suftab[0].swap(suftab[1]);
    }
    template<class T>
    void build(T S[], int N)
    {
        build_sa(S, N);
        lcp.resize(sufarr.size());
        for(int i=0, len=0; i<N; i++)
        {
            if(get_rank(i)==N-1)
                len=0;
            else
            {
                int j=sufarr[get_rank(i)+1];
                int maxl=N-std::max(i, j);
                while(len<maxl && S[i+len]==S[j+len])
                    len++;
                lcp[get_rank(i)]=len;
                if(len>0)
                    len--;
            }
        }
    }
    inline int get_rank(const int& idx) const
    {
        return suftab[0][idx];
    }
    int operator[] (const int& idx) const
    {
        return sufarr[idx];
    }
};

#endif // SUFFIXARRAY_H_INCLUDED

#include <bits/stdc++.h>

using namespace std;

int N, M;
int A[200001];
char S[200001];
suffix_array sa;
int parent[200001];
int sz1[200001];
int sz2[200001];
vector<int> ev[200002];
vector<pair<int, int>> ev2[200002];
long long tot;

int find(int u)
{
    if(parent[u]!=u)
        parent[u]=find(parent[u]);
    return parent[u];
}

void merge(int u, int v)
{
    u=find(u), v=find(v);
    if(u==v)
        return;
    tot-=1LL*sz1[u]*sz2[u];
    tot-=1LL*sz1[v]*sz2[v];
    sz1[v]+=sz1[u];
    sz2[v]+=sz2[u];
    parent[u]=v;
    tot+=1LL*sz1[v]*sz2[v];
}

int main()
{
    scanf("%d", &N);
    int L=0;
    for(int i=0; i<N; i++)
    {
        scanf("%s", S+L);
        int n=strlen(S+L);
        while(n>0)
        {
            A[L++]=n;
            n--;
        }
    }
    scanf("%d", &M);
    int L1=L;
    for(int i=0; i<M; i++)
    {
        scanf("%s", S+L);
        int n=strlen(S+L);
        while(n>0)
        {
            A[L++]=n;
            n--;
        }
    }
    sa.build(S, L);
    for(int i=0; i<L; i++)
    {
        parent[i]=i;
        sz1[i]=0;
        sz2[i]=0;
        if(i<L-1)
            ev[sa.lcp[i]-1].push_back(i);
        ev2[A[sa[i]]-1].push_back({i, sa[i]<L1});
    }
    long long ans=0;
    for(int i=L-1; i>=0; i--)
    {
        for(auto& it: ev[i])
            merge(it, it+1);
        for(auto& it: ev2[i])
        {
            int u=find(it.first);
            tot-=1LL*sz1[u]*sz2[u];
            if(it.second==0)
                sz1[u]++;
            else
                sz2[u]++;
            tot+=1LL*sz1[u]*sz2[u];
        }
        ans+=tot;
    }
    printf("%lld\n", ans);
    return 0;
}
