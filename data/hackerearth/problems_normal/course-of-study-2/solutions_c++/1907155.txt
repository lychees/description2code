#include <iostream>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <cstring>
#include <fstream>
#include <limits.h>
#define mod 1000000007
using namespace std;

struct node {

};

long long factorial[1000005],B[1000005],C[1000005];
vector <long long> v[1000005];

void preCompute(){
	long long fact = 1;
	factorial[0] = 1;
	for(long long i = 1; i < 100005; i++){
		factorial[i] = ((factorial[i-1]%mod)*(i%mod))%mod;
	}
}

long long modmulinverse(long long a)
{
	long long x = 0,y = 1,u = 1,v = 0;
	long long e = mod,f = a;
	long long c,d,q,r;
	while(f != 1){
		q = e/f;
		r = e%f;
		c = x-q*u;
		d = y-q*v;
		x = u;
		y = v;
		u = c;
		v = d;
		e = f;
		f = r;
	}
	u = (u+mod)%mod;
	return u;
}

long long combination(long long n, long long r){
	long long a = modmulinverse(factorial[n-r]);
	long long b = modmulinverse(factorial[r]);
	return ((((factorial[n]%mod)*(a%mod))%mod)*(b%mod))%mod;
}

int main()
{
	long long i,j,k,l,m,n,x,y,z,a,b,c,d,t,tot = 0;
	string str;
	struct node s;
	preCompute();
	cin>>n;
	for(i = 0; i < n; i++){
		cin>>k;
		tot += k;
		for(j = 0; j < k; j++){
			cin>>x;
			v[i].push_back(x);
		}
		sort(v[i].begin(), v[i].end());
	}
	long long sol = 1;
	for(i = 0; i < n; i++){
		vector <long long> dup;
		dup.clear();
		long long ans = combination(tot,v[i].size());
		long long cnt = 1;
		l = v[i][0];
		for(j = 1; j < v[i].size(); j++){
			if(v[i][j] == l){
				cnt++;
			}
			else {
				l = v[i][j];
				dup.push_back(cnt);
				cnt = 1;
			}
		}
		dup.push_back(cnt);
		for(j = 0; j < dup.size(); j++){
			ans = ((ans%mod)*(factorial[dup[j]]%mod))%mod;
		}
		tot -= v[i].size();
		sol = ((sol%mod)*(ans%mod))%mod;
	}
	cout<<sol<<endl;
	return 0;
}