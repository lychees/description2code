/*
Ashutosh Singla <ashu1461@gmail.com>
Algorithm: Dijkstra
#tags:
date: Tue Sep 10 01:02:48 IST 2013
*/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<algorithm>

using namespace std;
typedef vector<int> vi; 
typedef pair<int,int> ii;
typedef long long LL;
#define FL(a) memset(a, 0, sizeof a);
#define fill(a,v,N) memset(a, v, sizeof(a[0])*N)
#define sz(a) int((a).size()) 
#define pb push_back 
#define si(n) scanf("%d",&n)
#define sin(n) scanf("%d\n",&n) // for scanning strings ..
#define sill(n) scanf("%lld",&n)
#define pi(n) printf("%d\n",n);
#define pill(n) printf("%lld\n",n);
#define pis(n) printf("%d ",n);

#define all(c) (c).begin(),(c).end() 
#define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++)) 
#define present(c,x) ((c).find(x) != (c).end())  // map and set find .. 
#define cpresent(c,x) (find(all(c),x) != (c).end())  // stl find ..
#define FREP(b) for(int i=0;i<b;i++)
#define FREPr(b) for(int i=b-1;i>=0;i--)
#define REP(a,b,c) for(int a=b;a<c;a++)
#define REPr(a,b,c) for(int a=b;a>b;a--)
#define mp(a,b) make_pair(a,b);
typedef pair<int, int> mypair;
#define MAX_S 10000000
/*
struct data{
};
bool operator < (const data &a1, const data &a2){
}
*/
struct edge{
    int to, weight;
    edge(){}
    edge(int t,int w) :to(t),weight(w){}
    bool operator < (const edge &that) const{
        return weight > that.weight;
    }
};

//const int MAXNODES = 10002;
int g[300][300];
int d[608];
int n; //  no of edges
int Dijkstra(int s,int t)
{
    // The perfect Dijkstra algorithm .. !!
    FREP(n+1){
        d[i] = MAX_S;
        // p[i] = -1;
    }

    d[s] = 0;
    priority_queue <edge> q;
    q.push(edge(s,0));
    while(q.size()){
        int node = q.top().to;
        int dist = q.top().weight;
        q.pop();
        //printf("here for node ... %d %d\n", node, t);
        if (dist > d[node]) continue;
        if (node == t) break;
        for (int i = 0; i<n+1;++i){
            if(g[node][i] == 0){
                continue;
            }
            int to = i;
            int w_extra = g[node][i];
            //printf("children are ... %d %d %d \n", to, w_extra , d[to]);
            if (dist + w_extra < d[to]){
                d[to] = dist + w_extra;
                q.push(edge(to,d[to]));
            }
        }
    }
//    printf("n is ... %d\n",n);
//    FREP(n){
    //    pi(d[i]);
  //  }
    return d[t];
}
int main()
{
    int test, q, a, b, c;
    si(test);
    while(test--){
        si(n); si(q);
        FL(g);
        FREP(q){
            si(a);si(b);si(c);
            REP(j,a,b+1){
                if(g[j][b] == 0)
                    g[j][b] = c;
                else
                    g[j][b] = min(g[j][b], c);
            }
        }
        /*FREP(n+1){
            REP(j,0,n+1){
                pis(g[i][j]);
            }
            pi(-1);
        }*/
  //      printf("n is ...%d\n",n);
        int ans = Dijkstra(0, n);
        if(ans == MAX_S){
            pi(-1);
        }
        else
            pi(ans);
    }
    return 0;
}
