#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000007
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){	return N=N | (1<<pos);}
int RESET(int N,int pos){	return N= N & ~(1<<pos);}
int check(int N,int pos){	return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){	printf("("); for(int i=6;i>=1;i--)	{bool x=check(N,i);cout<<x;}	puts(")");}
int mod(int a, int b) { return a - a/b * b;}

int N;
pair<pair<int, int> , int> Arr[MXN];
double dp[100][100];
bool vis[100][100];

void inp()
{
	scanf("%d", &N);
	Arr[0] = mpa(mpa(0, 0), 0);
	for(int i = 1; i <= N; ++i) {
		scanf("%d%d%d", &Arr[i].ff.ff, &Arr[i].ff.ss, &Arr[i].ss);
	}
}

inline bool cmp(pair<pair<int, int>, int> p1, pair<pair<int, int>, int> p2)
{
	if(p1.ff.ff == p2.ff.ff)
		return p1.ff.ss < p2.ff.ss;
	return p1.ff.ff < p2.ff.ff;
}

double rec(int pre, int cur)
{
	if(cur == N + 1)
		return 0.00;
	
	if(vis[pre][cur])
		return dp[pre][cur];
	vis[pre][cur] = true;
	
	double ans1 = 0.00;
	if(Arr[cur].ff.ff >= Arr[pre].ff.ss) 
		ans1 = rec(cur, cur + 1) + (((double)Arr[cur].ss)/100.0);
	
	ans1 = max(ans1, rec(pre, cur + 1));
	return dp[pre][cur] = ans1;
}

void solve()
{
	memset(vis, false, sizeof vis);
	sort(Arr + 1, Arr + (N + 1), cmp);
	double ans = rec(0, 1);
	printf("%.2lf\n", ans);
}

int main()
{
	int T;
	scanf("%d", &T);
	
	while(T--) {
		inp();
		solve();
	}
	
	return 0;
}
