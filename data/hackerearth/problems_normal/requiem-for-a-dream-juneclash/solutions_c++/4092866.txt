#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <set>
#include <map>
#include <vector>
#include <list>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#include <queue>
#include <bitset>		//UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic
#include <cassert>
#include <iomanip>		//do setprecision
#include <ctime>
#include <complex>
using namespace std;

#define FOR(i,b,e) for(int i=(b);i<(e);++i)
#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)
#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)
#define REP(x, n) for(int x = 0; x < (n); ++x)

#define ST first
#define ND second
#define PB push_back
#define MP make_pair
#define LL long long
#define ULL unsigned LL
#define LD long double

const double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;

#define MR 100010
#define MS 20

vector < pair < int, pair < int, int > > > g[MR];

int sz[MR];

int done[MR], cnt;

LL dpc[MS][MR], dpv[MS][MR], dp[MS][MR];

void dfs(int nr)
{
	done[nr] = cnt;
	sz[nr] = 1;
	REP(i, g[nr].size())
		if (done[g[nr][i].first] != cnt)
		{
			dfs(g[nr][i].first);
			sz[nr] += sz[g[nr][i].first];
		}
}

void go(int nr, LL sum, const int& phase)
{
	done[nr] = cnt;
	REP(i, g[nr].size())
	{
		if (done[g[nr][i].first] != cnt)
		{
			dpc[phase][g[nr][i].first] = max(dpc[phase][nr], sum + g[nr][i].second.first);
			dpv[phase][g[nr][i].first] = max(dpv[phase][nr] + g[nr][i].second.first, (LL)g[nr][i].second.first);
			dp[phase][g[nr][i].first] = max(dp[phase][nr], dpv[phase][g[nr][i].first]);
			go(g[nr][i].first, sum + g[nr][i].second.first, phase);
		}
	}
}

int prevC[MR], layer[MR];

void CD(int nr, int phase, int prev)
{
	cnt++;
	dfs(nr);
	// find centroid
	int n = sz[nr], left = 0, centroid = nr, par = -1;
	while (true)
	{
		int wsk = -1;
		REP(i, g[centroid].size())
			if (g[centroid][i].first != par && (wsk == -1 || sz[g[centroid][i].first] > sz[g[centroid][wsk].first]))
				wsk = i;
		if (wsk == -1 || sz[g[centroid][wsk].first] <= n / 2) break;
		left += sz[centroid] - sz[g[centroid][wsk].first];
		par = centroid;
		centroid = g[centroid][wsk].first;
	}
	// add link to previous centroid
	prevC[centroid] = prev;
	layer[centroid] = phase;
	// count dp
	cnt++;
	go(centroid, 0, phase);
	// remove from graph and recurse on children
	REP(i, g[centroid].size())
	{
		int nr = g[centroid][i].first;
		int wsk = g[centroid][i].second.second;
		int nr1 = g[nr].back().first;
		int wsk1 = g[nr].back().second.second;
		g[nr1][wsk1].second.second = wsk;
		swap(g[nr][wsk], g[nr].back());
		g[nr].pop_back();
		CD(nr, phase + 1, centroid);
	}
	g[centroid].clear();
}


int main()
{
	int n, q;
	scanf("%d%d", &n, &q);
	REP(i, n - 1)
	{
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c); a--; b--;
		g[a].push_back(MP(b, MP(c, g[b].size())));
		g[b].push_back(MP(a, MP(c, g[a].size() - 1)));
	}
	CD(0, 0, -1);
	REP(i, q)
	{
		int a, b;
		scanf("%d%d", &a, &b); a--; b--;
		int p = a, q = b;
		while (p != q)
		{
			if (layer[p] > layer[q]) p = prevC[p];
			else if (layer[p] < layer[q]) q = prevC[q];
			else 
			{
				p = prevC[p];
				q = prevC[q];
			}
		}
		if (p == b) swap(a, b);
		if (p == a)
		{
			printf("%lld\n", dp[layer[a]][b]);
		}
		else
		{
			printf("%lld\n", max(dp[layer[p]][a], max(dp[layer[p]][b], dpc[layer[p]][a] + dpc[layer[p]][b])));
		}
	}
	return 0;
}