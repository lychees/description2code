#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <iostream>
#include <set>
#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <complex>
#include <map>
#include <queue>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vi> vvi;
typedef vector<double> vd;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pii> vii;
typedef vector<string> vs;
const int mod = 1000000007;

int n;
ll p2(ll x) {
    return x*x%mod;
}

const int N = 1 << 18;
ll s[2*N], a0[2*N];

void update (int v, int tl, int tr, int l, int r, ll add) {
	if (l > r)
		return;
	if (l == tl && tr == r) {
		a0[v] = (a0[v] + add)%mod;
        s[v] = (s[v] + add * (r - l + 1)) % mod;
    } else {
		int tm = (tl + tr) / 2;
        int l1 = max(l,tm+1), r1 = min(r,tm);
        int l2 = max(l, tl), r2 = min(r, tr);
        if (l2 <= r2) {
            s[v] = (s[v] + add * (r2 - l2 + 1)) % mod;
        }
		update (v*2, tl, tm, l, r1, add);
		update (v*2+1, tm+1, tr, l1, r, add);
	}
}
 
int getsum (int v, int tl, int tr, int l, int r, ll add) {
    if (l > r) 
        return 0;
	if (l == tl && tr == r) {
        return (s[v] + add * (r - l + 1)) % mod;
    } else {
	   int tm = (tl + tr) / 2;
       add = (add + a0[v])%mod;
	   return (getsum (v*2, tl, tm, l, min(r,tm), add) + 
                 getsum (v*2+1, tm+1, tr, max(l,tm+1), r, add)) % mod;
    }
}


/*ll f(const vi & v) {
    if (v.empty()) return c2(n);
    ll res = c2(v[0]) + c2(n - v.back() - 1);
    for (int i = 1; i < v.size(); ++i) res += c2(v[i] - v[i-1] - 1);
    return res % mod;
}*/

/*vl f;

void add(int i, ll val) {
    for (; i < n; i |= (i+1))
        f[i] += val;
}

ll sum(int i) {
    ll res = 0;
    for (; i >= 0; i = (i & (i + 1)) - 1)
        res += f[i];
    return res;
}*/

int main() {
    cin >> n;
    vi a(n), nx(n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    vi was(n + 1, n);
    for (int i = n-1; i >= 0; --i) {
        nx[i] = was[a[i]];
        was[a[i]] = i;
    }
    was.assign(n + 1, 0);
    ll res = 0, cnt = 0;
    for (int i = 0; i < n; ++i) {
        if (!was[a[i]]) ++cnt;
        was[a[i]] = 1;
        res += p2(cnt);
        update(1, 0, N-1, i, i, cnt);
//        cerr << cnt << endl;
    }
    ll sum = res;
    for (int i = 0; i + 1 < n; ++i) {
        sum += nx[i] - i;
        sum -= 2*getsum(1, 0, N-1, i, nx[i] - 1, 0);
        sum %= mod;
//        cerr << nx[i] << ' ' << sum << ' ' << res << endl;
        update(1, 0, N-1, i, nx[i] - 1, -1);
        res += sum;
    }
/*    vii a(n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i].first);
        a[i].second = i;
    }
    sort(a.begin(), a.end());
    ll res = 0;
    vvi v(1, vi(1, a[0].second));
    for (int i = 1; i < a.size(); ++i) {
        if (a[i].first == a[i - 1].first) {
            v.back().push_back(a[i].second);
        } else {
            v.push_back(vi(1, a[i].second));
        }
    }
    ll all = c2(n) % mod;
    for (int i = 0; i < v.size(); ++i) {
        res += all - f(v[i]);
    }
    cerr << (res % mod + mod) % mod << endl;
    while (v.size() > 1) {
        vvi nv(v.size()/2);
        for (int i = 0; i + 1 < v.size(); i += 2) {
            nv[i/2] = v[i];
            for (auto x : v[i+1]) nv[i/2].push_back(x);
            sort(nv[i/2].begin(), nv[i/2].end());
            ll x = f(v[i]);
            ll y = f(v[i+1]);
            ll z = f(nv[i/2]);
            res += 2*(all - x - y + z);
            cerr << x << ' ' << y << ' ' << z << endl;
        }
        if (v.size() % 2) nv.push_back(v.back());
        v.swap(nv);
    }*/
    cout << (res % mod + mod) % mod << endl;
    return 0;
}