#include<bits/stdc++.h>
using namespace std;

long long modular_pow(long long a, long long b, long long m)
{
long long remainder;
long long ans = 1;

while (b != 0)
{
remainder = b % 2;
b= b/2;

if (remainder == 1)
{
    ans = (ans * a) % m;
}

a= (a * a) % m; 
}

return ans;
}

long long int gcd(long long int a,long long int b)
{
    if(b==0)
    return a;
    else
    return gcd(b,a%b);
}

struct node{
	int c;
	int r;	
};

struct node a[1001];
int e[1001][1001]={0};

	
long long dfs(int u,int n)
{
	a[u].c=1;
	for(int i=1;i<=n;i++)
	{
		if(a[i].c==0 && e[u][a[i].r]==1)
		{
			return 1+dfs(a[i].r,n);
		}
	}	
	a[u].c=2;
	return 0;
}

int main()
{
	long long t;
	scanf("%lld",&t);
	
	for(;t>0;t--)
	{
		long long a,b;
		scanf("%lld %lld",&a,&b);
		
		long long c=0,ans=0,val=0,j=0,z=0;
		while(a>0 || b>0)
		{
			int v1=a%10,v2=b%10;
			
			if(v1+v2+c<=9)
			{
				z=v1+v2+c;
				val+=pow(10,j)*z;
				j++;
				c=0;
			}
			else
			{
				ans++;
				z=(v1+v2+c)%10;
				c=(v1+v2+c)/10;
				val+=pow(10,j)*z;
				j++;
			}
			
			a/=10;
			b/=10;
		}
		
		if(ans==0)
		printf("No carry operation\n");
		else if(ans==1)
		printf("%lld carry operation\n",ans);
		else
		printf("%lld carry operations\n",ans);
	}
    return 0;    
} 