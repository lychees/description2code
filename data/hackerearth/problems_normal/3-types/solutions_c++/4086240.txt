#include <bits/stdc++.h>
using namespace std;

struct subset {
 	int parent;
 	int rank;
};

int find(struct subset sub[],int i);
void Union(struct subset sub[],int x,int y);
void solve(pair<int,pair<int,int>> p[],int n,int m, struct subset subM[], struct subset subW[]);

int find(struct subset sub[],int i)
{
	if(sub[i].parent!=i)
		sub[i].parent=find(sub,sub[i].parent);
	return sub[i].parent;	
}

void Union(struct subset sub[],int x,int y)
{
	int xroot=find(sub,x);
	int yroot=find(sub,y);
	if(sub[xroot].rank < sub[yroot].rank)
		sub[xroot].parent=yroot;
	else if(sub[xroot].rank > sub[yroot].rank)
		sub[yroot].parent=xroot;	
	else
	{
		sub[yroot].parent=xroot;	
		sub[xroot].rank++;
	}
}

void solve(pair<int,pair<int,int>> p[],int n,int m, struct subset subM[], struct subset subW[])
{
	int x,y,type,i;
	map<pair<int,int>,int> mp;
	
	for(i=0;i<m;i++)
	{
		x=p[i].second.first;
		y=p[i].second.second;
		type=p[i].first;
		
		if(type==2)
			continue;
		
		
		if(find(subM,x)!=find(subM,y))
		{
			if(mp.find(make_pair(x,y))==mp.end())
				mp.insert(make_pair(make_pair(x,y),1));
			Union(subM,x,y);	
		}
	}
	
	for(i=0;i<m;i++)
	{
		x=p[i].second.first;
		y=p[i].second.second;
		type=p[i].first;
		if(type==1)
			continue;
		if(find(subW,x)!=find(subW,y))
		{
			if(mp.find(make_pair(x,y))==mp.end())
				mp.insert(make_pair(make_pair(x,y),1));
			Union(subW,x,y);	
		}
	}
	
	int countM=0,countW=0;
	for(i=0;i<n;i++)
	{
		if(subM[i].parent==i)
			countM++;
		if(subW[i].parent==i)
			countW++;	
	}
	
	if(countM>1 || countW>1)
		cout<<"-1";
	else	
		cout<<m-mp.size();
}

int main() {
	int n,m,i,x,y,type;
	cin>>n>>m;
	pair<int,pair<int,int>> p[m];
	for(i=0;i<m;i++)
	{
		cin>>x>>y>>type;
		p[i]=make_pair(type,make_pair(x-1,y-1));
		
	}
	
	struct subset *subM=(struct subset *)malloc(n*sizeof(struct subset));
	struct subset *subW=(struct subset *)malloc(n*sizeof(struct subset));
	
	for(i=0;i<n;i++)
	{
		subM[i].parent=i;
		subM[i].rank=0;
		subW[i].parent=i;
		subW[i].rank=0;
	}
	
	sort(p,p+m);
	reverse(p,p+m);
	
	solve(p,n,m,subM,subW);
	
	return 0;
}