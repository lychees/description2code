#include <iostream>
using namespace std;
 
int maze[1000][1000];
int smtime[1000][1000];
 
class queuex{
	int *arr,front,rear,capacity;
public:
	queuex(int size){
		arr = new int[size];
		front = 0;
		rear = 0;
		capacity = size;
	}
	
	void enqueue(int val){
		arr[rear]=val;
		rear++;
	}
	
	int top(){
		return arr[front];
	}
	
	void dequeue(){
		front++;
	}
	
	bool empty(){
		if(front==rear)
			return true;
		return false;
	}
	
	void clear(){
		int i;
		front=0;
		rear=0;
	}
};
 
queuex qx(1000000),qy(1000000);
 
void bfs(int u,int v,int n,int m){
	int x,y;
	qx.clear();
	qy.clear();
	smtime[u][v] = maze[u][v];
	
	qx.enqueue(u);
	qy.enqueue(v);
	while(!qx.empty()){
		x = qx.top();
		qx.dequeue();
		y = qy.top();
		qy.dequeue();
		
		if(x+1<n && (smtime[x][y]+maze[x+1][y]<smtime[x+1][y])){
			qx.enqueue(x+1);
			qy.enqueue(y);
			smtime[x+1][y]=smtime[x][y]+maze[x+1][y];
		}
		if(x-1>=0 && (smtime[x][y]+maze[x-1][y]<smtime[x-1][y])){
			qx.enqueue(x-1);
			qy.enqueue(y);
			smtime[x-1][y]=smtime[x][y]+maze[x-1][y];
		}
		if(y+1<m && (smtime[x][y]+maze[x][y+1]<smtime[x][y+1])){
			qx.enqueue(x);
			qy.enqueue(y+1);
			smtime[x][y+1]=smtime[x][y]+maze[x][y+1];
		}
		if(y-1>=0 && (smtime[x][y]+maze[x][y-1]<smtime[x][y-1])){
			qx.enqueue(x);
			qy.enqueue(y-1);
			smtime[x][y-1]=smtime[x][y]+maze[x][y-1];
		}
	}
}
 
int main()
{
   int num_cases,ctr,N,M,i,j,A,B,etime,ans;
   cin>>num_cases;
  
   for(ctr=1;ctr<=num_cases;ctr++){
   	
   	cin>>N>>M;
   	
   	
   	for(i=0;i<N;i++){
   		for(j=0;j<M;j++){
   			cin>>maze[i][j];
   			smtime[i][j]=1000000000;
   		}
   	}
   	
   	cin>>A>>B>>etime;
   	
   	bfs(0,0,N,M);
   	
   	ans=smtime[A-1][B-1];
   	
   	if(ans<=etime){
   		cout<<"YES"<<endl;
   		cout<<(etime-ans)<<endl;
   	}
   	else
   		cout<<"NO"<<endl;
   }
   
   return 0;
}

