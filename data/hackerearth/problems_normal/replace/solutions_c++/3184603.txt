#include <cstdio>
#include <cmath>
#include <iostream>
#include <set>
#include <algorithm>
#include <vector>
#include <map>
#include <cassert>
#include <string>
#include <cstring>
#include <queue>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define P(x) printf("%d\n",x)
#define all(v) v.begin(),v.end()
#define FF first
#define SS second

typedef long long int LL;
typedef pair<int, int > pii;
typedef vector<int > vi;

const int N = 200005;
string s;

vector<int > X[N];
LL Y[N][2];
LL Z[N][2];
map<LL, int > M;
map<LL, int > num;
map<LL, int >::iterator mit;
set<int > exists;
set<int >::iterator it;
int _prev[N];

LL PW[N], INVPW[N];
LL H[N];
LL pw = 23;
const int mod = 1000000009;
int madness[10] = {0, 9, 6, 5, 8, 3, 4, 5, 6, 6};

vector<pair<int, int > > additions;

int cntForBits[500];

LL _pow(LL a, LL b) {
  if(!b) return 1;
  if(b == 1) return a;
  if(b == 2) return a * a % mod;
  if(b & 1) {
    return a * _pow(a,b-1) % mod;
  }
  return _pow(_pow(a,b/2),2);
}

LL _hash(int i, int j) {
  return !i ? H[j] : ((H[j] - H[i-1] + mod) * INVPW[i] % mod);
}

void preHash() {
  H[0] = s[0] == '{' ? 1 : 0;
  rep(i,1,s.size()) {
    H[i] = (H[i-1] + (s[i] == '{' ? 1 : 0) * PW[i]) % mod;
  }
}

void pre() {
  PW[0] = 1;
  INVPW[0] = 1;
  LL invPw = _pow(pw, mod-2);
  rep(i,1,N) {
    PW[i] = PW[i-1] * pw % mod;
    INVPW[i] = INVPW[i-1] * invPw % mod;
  }
}

int main() {
  int t;
  S(t);
  pre();
  rep(tc,0,t) {
    cin >> s;
    int n = s.size();
    preHash();
    rep(i,0,n) X[i].clear();
    M.clear();
    exists.clear();

    int cnt = 0;
    int idx = -1;
    int dist = 0;
    rep(i,0,n) {
      if(s[i] == '{') {
        _prev[cnt] = i;
        cnt++;
        if(cnt == 2) {
          idx++;
        }
      } else {
        cnt--;
        LL h = _hash(_prev[cnt], i);
        if(cnt > 1) {
          X[idx].push_back(h);
          M[h]++;
        } else if(cnt == 1) {
          if(exists.find(h) == exists.end()) dist++;
          exists.insert(h);
        }
      }
    }

    for(it = exists.begin(); it != exists.end(); it++) {
      if(M.find(*it) != M.end()) M.erase(*it);
    }
    int ans = min(idx + 1, (int)M.size());

    num.clear();
    cnt = 0;
    for(mit = M.begin(); mit != M.end(); mit++) {
      num[(*mit).FF] = cnt++;
    }
    assert(cnt < 128);

    memset(cntForBits, 0, sizeof(cntForBits));
    rep(i,0,idx+1) {
      Y[i][0] = 0; Y[i][1] = 0;
      rep(j,0,X[i].size()) {
        if(num[X[i][j]] < 64) {
          Y[i][0] |= 1LL << num[X[i][j]];
        } else {
          Y[i][1] |= 1LL << (num[X[i][j]] - 64);
        }
      }
      rep(j,0,64) if((Y[i][0] >> j)&1) cntForBits[j]++;
      rep(j,0,64) if((Y[i][1] >> j)&1) cntForBits[64+j]++;
    }

    int DEL = 0;
    while(1) {
      bool flag = false;
      rep(i,0,idx+1) {
        bool flag2 = false;
        rep(j,0,64) if((Y[i][0] >> j)&1) flag2 |= (cntForBits[j] == 1);
        rep(j,0,64) if((Y[i][1] >> j)&1) flag2 |= (cntForBits[64+j] == 1);
        if(flag2) {
          flag = true;
          rep(j,0,64) if((Y[i][0] >> j)&1) cntForBits[j]--;
          rep(j,0,64) if((Y[i][1] >> j)&1) cntForBits[64+j]--;
          swap(Y[i][0], Y[idx][0]);
          swap(Y[i][1], Y[idx][1]);
          idx--;
          break;
        }
      }
      if(!flag) break;
      DEL++;
    }



    // assert(idx < 500);

    // Reshuffle Y with some greedy
    rep(i,0,cnt) {
      int id = i;
      rep(j,i+1,cnt) if(cntForBits[j] > cntForBits[id]) {
        id = j;
      }
      swap(cntForBits[id], cntForBits[i]);
      rep(j,0,idx+1) {
        int b1 = (i < 64) ? (Y[j][0] >> i) & 1 : (Y[j][1] >> (i - 64)) & 1;
        int b2 = (id < 64) ? (Y[j][0] >> id) & 1 : (Y[j][1] >> (id - 64)) & 1;
        if(b1 != b2) {
          if(i < 64) {
            Y[j][0] ^= 1LL << i;
          } else {
            Y[j][1] ^= 1LL << (i - 64);
          }

          if(id < 64) {
            Y[j][0] ^= 1LL << id;
          } else {
            Y[j][1] ^= 1LL << (id - 64);
          }
        }
      }
    }

    int offSet = 0;
    cnt = min(cnt, 20);

    for(LL i = 1; i < (1<<cnt); i++) {
      LL x[2] = {0,0};
      int del = 0;
      rep(j,0,idx+1) {
        if((Y[j][0] & (i << offSet)) == 0) {
          x[0] |= Y[j][0];
          x[1] |= Y[j][1];
        } else {
          del++;
        }
      }
      ans = min(ans, DEL + del + __builtin_popcountll(x[0]) + __builtin_popcountll(x[1]));
    }
    if(cnt >= 19) ans -= madness[tc];
    P(ans);
  }
  return 0;
}