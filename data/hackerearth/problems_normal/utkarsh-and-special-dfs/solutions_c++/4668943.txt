#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define maxn 100001
#define mod 1000000007

ll euclid(ll a)
{
	ll pr = a, r = mod;
	ll ps = 1, s = 0, q, h;
	while(r)
	{
		q = pr/r;
		h = r;
		r = pr - q*r;
		pr = h;
		h = s;
		s = ps - q*s;
		ps = h;
	}
	ps %= mod;
	return (ps + mod) % mod;
}
struct node
{
	ll l, r, val;
	node(){}
	node(ll a, ll b)
	{
		l = a;
		r = b;
	}
};
node T[5*maxn];
ll p[maxn], cnt = 1, L[maxn], R[maxn], ord[maxn], vis[maxn], lazy[5*maxn];
bool mark[5*maxn];
vector<ll> gr[maxn];
void dfs(ll u, ll d)
{
	ord[cnt] = u;
	L[u] = ++cnt;
	if(d == -1)
		vis[u] = 1;
	else
		vis[u] = p[d]*vis[d] % mod;
	for(ll i = 0; i < gr[u].size(); i++)
	{
		ll v = gr[u][i];
		if(v != d)
			dfs(v, u);
	}
	R[u] = cnt - 1;
}
void check(ll i)
{
	if(mark[i])
	{
		T[i].val = T[i].val * lazy[i] % mod;
		if(T[i].l < T[i].r)
		{
			for(ll x = 0; x <= 1; x++)
			{
				mark[2*i + x] = true;
				if(lazy[2*i + x])
					lazy[2*i + x] = lazy[2*i + x] * lazy[i] % mod;
				else
					lazy[2*i + x] = lazy[i];
			}
		}
		lazy[i] = 1;
		mark[i] = false;
	}
}
void go(ll i, ll l, ll r)
{
	T[i] = node(l, r);
	lazy[i] = 1;
	if(l == r)
	{
		T[i].val = vis[ord[l]];
		return;
	}
	ll m = (l + r) >> 1;
	go(2*i, l, m);
	go(2*i + 1, m + 1, r);
	T[i].val = (T[2*i].val + T[2*i + 1].val) % mod;
}
void update(ll i, ll l, ll r, ll val)
{
	check(i);
	if(T[i].l == l && T[i].r == r)
	{
		T[i].val = T[i].val * val % mod;
		if(l < r)
		{
			for(ll x = 0; x <= 1; x++)
			{
				mark[2*i + x] = true;
				if(lazy[2*i] + x)
					lazy[2*i + x] = lazy[2*i + x] * val % mod;
				else
					lazy[2*i + x] = val;
			}
		}
		return;
	}
	ll m = (T[i].l + T[i].r) >> 1;
	if(r <= m)
	{
		update(2*i, l, r, val);
		check(2*i + 1);
	}
	else
		if(l > m)
		{
			update(2*i + 1, l, r, val);
			check(2*i);
		}
		else
		{
			update(2*i, l, m, val);
			update(2*i + 1, m + 1, r, val);
		}
	T[i].val = (T[2*i].val + T[2*i + 1].val) % mod;
}
ll get(ll i, ll l, ll r)
{
	check(i);
	if(T[i].l == l && T[i].r == r)
		return T[i].val;
	ll m = (T[i].l + T[i].r) >> 1;
	if(r <= m)
		return get(2*i, l, r);
	if(l > m)
		return get(2*i + 1, l, r);
	return (get(2*i, l, m) + get(2*i + 1, m + 1, r)) % mod;
}

int main()
{
	ll n, q, i, a, b, t, l, r;
	scanf("%lld %lld", &n, &q);
	for(i = 1; i < n; i++)
	{
		scanf("%lld %lld", &a, &b);
		gr[a].push_back(b);
		gr[b].push_back(a);
	}
	for(i = 1; i <= n; i++)
		scanf("%lld", p + i);
	dfs(1, -1);
	go(1, 1, n);
	while(q--)
	{
		scanf("%lld %lld", &t, &a);
		l = L[a];
		r = R[a];
		if(t == 1)
		{
			scanf("%lld", &b);
			if(l <= r)
				update(1, l, r, b * euclid(p[a]) % mod);
			p[a] = b;
		}
		else
		{
			b = get(1, l - 1, l - 1);
			if(l <= r)
				b = (b + get(1, l, r)) % mod;
			printf("%lld\n", b);
		}
	}
	return 0;
}