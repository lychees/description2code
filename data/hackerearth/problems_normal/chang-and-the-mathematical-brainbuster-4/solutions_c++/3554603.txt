#include<bits/stdc++.h>
#include <iostream>
#include <numeric>
#define ll long long
#define ull unsigned long long  
#define mpa make_pair
#define pb push_back
#define ff first
#define ss second
#define boost ios_base::sync_with_stdio(0)
#define ss second
#define forp(i,a,b) for(ll i=a;i<=b;i++)
#define rep(i,n)    for(ll i=0;i<n;++i)
#define ren(i,n)    for(ll i=n-1;i>=0;i--)
#define forn(i,a,b) for(ll i=a;i>=b;i--)
#define fre     freopen("input.txt","r",stdin),freopen("output.txt","w",stdout)
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define scan(x) scanf("%lld",&x)
using namespace std;
ll modpow(ll a,ll n,ll temp){ll res=1,y=a;while(n>0){if(n&1)res=(res*y)%temp;y=(y*y)%temp;n/=2;}return res%temp;} 
//ll a[100005],n,dp[1000005]={0},b[1000005],c[100005],dp1[1000005],bit[100005];
//ll vis[100005];
//vector<ll> adj[100005];
#define pi 3.1415926536
#define sz(x) x.size()
ll ison(ll mask,ll pos){
	return (mask&(1<<pos));
}
typedef vector<ll> vi;
typedef vector<vi> vvi;
typedef pair<ll, ll> pii;
ll cbit(ll n){ll k=0;while(n) n&=(n-1),k++;return k;}
ll nbit(ll n){ll k=0;while(n) n/=2,k++;return k;}
//ll b1[1001][1001],b2[1001][1001],g1[1001][1001],g2[1001][1001],w[1001][1001];
//bool a1[101][101],a2[102][101],a3[103][101];
ll mod=1e9+7;
int sgn(ll x) {
  return x < 0 ? -1 : !!x;
}
/*ll b[200005],c[200005];
ll csum[20005];
ll bit[400005],n,bit2[40005];
void upd(ll ind,ll val){
    if(ind==0) return;
    while(ind<=n){
        bit[ind]+=val;
        ind+=(ind&-ind);
    }
}
ll qu(ll ind){
  ll k=0; while(ind>0){
    k+=bit[ind];
    ind-=(ind&-ind);
  }
    return k;
}
void upd2(ll ind,ll val){
    if(ind==0) return;
    while(ind<=n){
        bit2[ind]+=val;
        ind+=(ind&-ind);
    }
}
ll qu2(ll ind){
  ll k=0; while(ind>0){
    k+=bit2[ind];
    ind-=(ind&-ind);
  }
    return k;
}

*/
//ll tree[500005];

//vector<ll,pair<ll,ll> > b;
//vector<ll> adj[100005];

/*Tarjan incomplette
void dfs(ll s){
	vis[s]=1;
	for(ll i=0;i<adj[s].size();i++) if(!vis[adj[s][i]]) dfs(adj[s][i]);
    ofvs.pb(s);
}
void dfs2(ll s){
	vis[s]=1;
	if(wt[s]<optc){optn=0,optc=wt[s];}
	if(optc==wt[s]) optn++;
	for(ll i=0;i<rdj[s].size();i++) if(!vis[rdj[s][i]]) dfs2(rdj[s][i]);
}
*/
typedef pair<ll,pair<ll,ll> >ver;
//string s;
/*void build(ll node,ll ss,ll se)
{
	if(ss==se){
	tree[node]=a[ss];
	if(s[ss]=='{') o[node]++;
	else c[node]++;
    }
	else
	{
		int mid=(ss+se)/2;
		build(2*node,ss,mid);
		build(2*node+1,mid+1,se);
		ll t=min(o[2*node],c[2*node+1]);
		o[node]=o[2*node]+o[2*node+1]-t;
		c[node]=c[node*2]+c[node*2+1]-t;
		tree[node]=tree[node*2]+tree[node*2+1]+t;
	}
}
/*void upd(ll node,ll ss,ll se,ll idx,ll val)
{
	if(ss==se)
	a[idx]=val,tree[node]=a[idx];
	else
	{
		ll mid=(ss+se)/2;
		if(ss<=idx && idx<=mid)
		upd(2*node,ss,mid,idx,val);
		else
		upd(2*node+1,mid+1,se,idx,val);
	    tree[node]=tree[node*2]+tree[node*2+1];
	}
}
ver query(int node,int ss,int se,int l,int r)
{
	if(r<ss || se<l)
	return mpa(0,mpa(0,0));
	if(l<=ss && se<=r)
	return mpa(tree[node],mpa(o[node],c[node]));
	ll mid=(ss+se)/2;
	ver p1=query(2*node,ss,mid,l,r);
	ver p2=query(2*node+1,mid+1,se,l,r);
    ll t=min(p1.ss.ff,p2.ss.ss);
	o[node]=p1.ss.ff+p2.ss.ff-t;
	c[node]=p1.ss.ss+p2.ss.ss-t;
	return mpa(p1.ff+p2.ff+t,mpa(o[node],c[node]));
}
/*ll pow(ll n){
	ll t=1,i=1;
	while(i<=n) t*=10;
	return t;
}*/
//stack<ll> help;
//ll dp[1ll<<11];

//ll csum[100005],b[100005],help[100005];
//vector<ll> adj[1005];
//vector<ll> ans;
/*ll kmp[1000005];
ll zee[1000005];
void kmpm(string p){
	ll i,j,k=0,l;
	kmp[0]=0;
	j=0;
	for(i=1;i<p.size();i++){
		while(k && p[i]!=p[k]) k=kmp[k-1];
		if(p[i]==p[k]) k++;
		kmp[i]=k;
	}
}
ll isp(ll n){
	ll f=1,i;
	for(i=2;i<=sqrt(n);i++) if(!(n%i)) return 0;
	return 1;
}*/
/*void zee(string s){}*/
//map<ll,ll> help;
/*ll chk(ll val,ll n,ll m){
	ll t=0,i;
	val--;
	for(i=1;i<=n;i++) t+=min(m,val/i);
	return t;
}*/

/*ll size[100005u];
void init(ll n)
{for(int i=1;i<=n;i++) a[i]=i;}
ll root(ll x)
{
	while(a[x]!=x)
	{
		a[x]=a[a[x]];
		x=a[x];
	}
	return x;
}
ll u1(ll x,ll y)
{
	int p=root(x);
	int q=root(y);
	a[p]=a[q];
}
*/
/*ll tree[100005];
void update(ll idx, ll val){
	while(idx < 100005){
		tree[idx] = max(tree[idx], val);
		idx += (idx & (-idx));
	}
}
ll query(ll idx){
	ll ret = 0;
	while(idx > 0){
		ret = max(ret, tree[idx]);
		idx -= (idx & (-idx));
	}
	return ret;
}*/
//pair<char ,pair<ll,ll> >p[5005];[10004]
ll xo(ll i)
{
	if ((i&3)==0) return i;
	if ((i&3)==1) return 1;
	if ((i&3)==2) return i+1;
	return 0;
}
//pair<ll,ll> p[10005];
struct node{
	node *next[2];
};
node *gn(void){
	node *p=NULL;
	p=(node*)malloc(sizeof(node));
	rep(i,1) p->next[i]=0;
	return p;
}
ll a[100005];

int main(){
	ll ans=0,i,j,k,l,m,n;
	cin>>n;
	for(i=0;i<n;i++) cin>>a[i];
	sort(a,a+n);
	for(i=0;i<n;i++){
		ll ind=lower_bound(a+i,a+n,3*a[i]+1)-a;
		if(ind-i>ans) ans=ind-i;
		
	}
	cout<<n-ans;
	
	
	
}
	



  
  
  
  

   

       	
   	
   	
   	
   
   
   

    
    
    
    

	 
   
   
    
   
   











 	
 	
 	
 	
 	
 
 
 









 	
 	
 	
 





  
  
  
  
  	

  
  
  
   
   
   



	














 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
  
  
  




	
	
	









  
   	
   	

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   	
   	
   	
   	
   	
  		
   		
	

	
	





	









    	
    	
    	
    	
    	
    	
	
    
		
		
		




	
	
	 
	 
	 
	 
	 
	 
	 
	 
	 
 	
  	
  
  
 
 
 

	 
	 

	  
	  
	  
	  
	  
    
    
    
    
    
    
    
    
    
   