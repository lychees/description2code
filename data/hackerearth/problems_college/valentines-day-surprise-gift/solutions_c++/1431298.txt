#include<iostream>
#include <map>
#include<cmath>
#define MOD 1000000007
using namespace std;
map<int,int> list;
map<int,int> power;
int pw(int x)
{
	if(power.find((int)(x+3)/4)==power.end());
		power[(x+3)/4]=(int)pow(2.0,(x+3)/4);
	return power[(x+3)/4];
}
int lt(int x, int y)
{
	if(list.find((x+y-1)/y)==list.end())
		list[(x+y-1)/y]=pw((x+y-1)/y) * lt((x+y-1)/y,5) * lt((x+y-1)/y,10);
	return list[(x+y-1)/y];
}
int gcd( int a, int b )
{
  if ( a==0 ) return b;
  return gcd ( b%a, a );
}
long long modular_pow(long long base, long long exponent)
{
	if (base == 0)
		return 0;
	long long result = 1;
	while (exponent > 0)
	{
		if (exponent % 2 == 1)
			result = (result * base) % MOD;
		exponent = exponent >> 1;
		base = (base * base) % MOD;
	}
	return result;
}
int main()
{
	int t,n,r;
	long long max,ans;
	cin >>t;
	list[0]=list[1]=list[2]=1,list[3]=3,list[4]=3,list[5]=15,list[6]=15,list[7]=105,list[8]=105,list[9]=105,list[10]=105;
	power[0] = 1;
	power[1] = 2;
	while(t--)
	{
		ans = 0;
		max = 0;
		cin >> n;
		if(n<=10)
			r = list[n];
		else
			r = (pw(n)* (lt(n,5) * lt(n,10)) % MOD)%MOD;
		for(int i=r; i <= 5*r; i=i+r)
			for(int j=r; j <= 5*r; j=j+r)
			{
				if(gcd(i,j) == r)
					max = modular_pow(i,j);
				if(max >= ans)
					ans=max;
			}
		cout << ans << endl;	
	}
	return 0;
}
