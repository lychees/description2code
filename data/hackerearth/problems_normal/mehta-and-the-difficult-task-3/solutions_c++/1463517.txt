#include <bits/stdc++.h>
using namespace std;
#define DBG(x) cout << #x << " = " << x << endl;
/*
Compile:
    -Wall -Wextra -pedantic -std=c++11 -O2 -Wshadow -Wformat=2 -Wfloat-equal -Wconversion -Wlogical-op -Wcast-qual -Wcast-align -fwhole-program -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -lmcheck -fsanitize=address 

Check for memory usage:
    valgrind --tool=massif
 */

const int MOD = 1e9 + 7;
const long long MOD2 = static_cast<long long>(MOD) * MOD;
const int N = 32;

int pos[10];
int res[N][N], a[N][N], tmp[N][N];

void mul(int x[N][N], int y[N][N])
{
    for(int i = 0; i < N; i++)
        for(int j = 0; j < N; j++) {
            long long ttt = 0;
            for(int k = 0; k < N; k++) {
                ttt += static_cast<long long>(x[i][k]) * y[k][j];
                while(ttt >= MOD2)
                    ttt -= MOD2;
            }
            tmp[i][j] = ttt % MOD;
        }

    memcpy(res, tmp, sizeof(res));
}

void get_pow(long long n)
{
    if(n == 0) {
        for(int i = 0; i < N; i++)
            for(int j = 0; j < N; j++)
                res[i][j] = i == j;
        return;
    } 
    if(n == 1) {
        for(int i = 0; i < N; i++)
            for(int j = 0; j < N; j++)
                res[i][j] = a[i][j];
        return;
    }

    get_pow(n / 2);
    mul(res, res);
    if(n % 2)
        mul(res, a);
}

int stupid(int n, int mask) 
{
    int lim = 1;
    for(int i = 0; i < n; i++)
        lim *= 10;
    int ret = 0;
    for(int i = 0; i < lim; i++) {
        int cmask = 0;
        int k = i;
        while(k) {
            int t = k % 10;
            k /= 10;
            if(pos[t] != -1)
                cmask ^= 1 << pos[t];
        }
        if(cmask == mask)
            ret++;
    }

    return ret;
}

int solve()
{
    int m, b, c, d;
    long long n;
    cin >> n >> m >> b >> c >> d;

    for(int i = 0; i < N; i++)
        for(int j = 0; j < N; j++)
            a[i][j] = 0;

    for(int i = 0; i < (1 << 4); i++) {
        for(int k = 0; k < 10; k++) {
            int t = pos[k];
            if(t == -1) {
                a[i][i]++;
            } else {
                int nx = i;
                nx ^= (1 << t);
                a[i][nx]++;
            }
        }

        a[i][i + N / 2] = 1;
        a[i + N / 2][i + N / 2] = 1;
    }

    int base[N];

    fill(base, base + N, 0);
    for(int j = 1; j < 10; j++) {
        if(pos[j] == -1) {
            base[0]++;
        } else {
            base[1 << pos[j]]++;
        }
    }

    get_pow(n - 1);

    int nx[N];
    fill(nx, nx + N, 0);

    for(int i = 0; i < N; i++)
        for(int j = 0; j < N; j++)
            nx[i] = (nx[i] + static_cast<long long>(base[j]) * res[j][i]) % MOD;

    int mask = 0;
    if(m)
        mask |= 1 << 0;
    if(b) 
        mask |= 1 << 1;
    if(c) 
        mask |= 1 << 2;
    if(d)
        mask |= 1 << 3;

    int ret = (nx[mask] + nx[N / 2 + mask] + (mask == 0)) % MOD;
    //assert(ret == stupid(n, mask));
    return ret;
}


int main()
{
    for(int i = 0; i < 10; i++)
        pos[i] = -1;
    pos[2] = 0;
    pos[3] = 1;
    pos[5] = 2;
    pos[7] = 3;

    int t;
    cin >> t;
    for(int i = 0; i < t; i++)
        cout << solve() << "\n";
    return 0;
}
