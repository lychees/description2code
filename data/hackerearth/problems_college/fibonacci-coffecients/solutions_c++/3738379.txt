#include <bits/stdc++.h>
#define rep(i,x,y) for (int i = (x); i<=(y); i++)
#define repe(i,x,y) for (int i = (x); i < (y);i++)
#define drep(i,x,y) for (int i = (x); i >= (y); i--)
#define mp make_pair
#define pb emplace_back
#define mt make_tuple
#define gcd __gcd
#define sf(n) scanf("%Lf",&n)
#define prf(n) printf("%.12Lf",n)
#define	s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define pr(n) printf("%d",n)
#define prl(n) printf("%lld",n)
#define endc printf("\n")
#define psp printf(" ")

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;

const int maxn = 2e5 + 7;


typedef struct mat {
	ll M[2][2];
} mat;

ll md;

inline mat operator * (const mat A, const mat B) {
	mat C = *new mat();
	C.M[0][0] = (((A.M[0][0] * B.M[0][0])%md) + (A.M[0][1]*B.M[1][0])%md)%md;
	C.M[0][1] = (((A.M[0][0] * B.M[0][1])%md) + (A.M[0][1]*B.M[1][1])%md)%md;
	C.M[1][0] = (((A.M[1][0] * B.M[0][0])%md) + (A.M[1][1]*B.M[1][0])%md)%md;
	C.M[1][1] = (((A.M[1][0] * B.M[0][1])%md) + (A.M[1][1]*B.M[1][1])%md)%md;
	return C;
}

inline mat operator + (const mat A, const mat B) {
	mat C = *new mat();
	C.M[0][0] = (A.M[0][0] + B.M[0][0])%md;
	C.M[0][1] = (A.M[0][1] + B.M[0][1])%md;
	C.M[1][0] = (A.M[1][0] + B.M[1][0])%md;
	C.M[1][1] = (A.M[1][1] + B.M[1][1])%md;
	return C;
}

inline mat operator * (const ll a, const mat A) {
	mat C = *new mat();
	C.M[0][0] = (A.M[0][0]*a)%md; C.M[0][1] = (A.M[0][1]*a)%md;
	C.M[1][0] = (A.M[1][0]*a)%md; C.M[1][1] = (A.M[1][1]*a)%md;
	return C;
}

inline mat operator - (const mat A, const mat B) {
	mat C = *new mat();
	C.M[0][0] = (A.M[0][0] - B.M[0][0] + md)%md;
	C.M[0][1] = (A.M[0][1] - B.M[0][1] + md)%md;
	C.M[1][0] = (A.M[1][0] - B.M[1][0] + md)%md;
	C.M[1][1] = (A.M[1][1] - B.M[1][1] + md)%md;
	return C;
}

mat bit[maxn];
mat F[maxn];
mat G[maxn];
mat I,O;
ll A[maxn];

void upd(int x,mat M) {
	while (x < maxn) {
		bit[x] = bit[x] + M;
		x += x & (-x);
	}
}

mat qry(int x) {
	mat ans = O;
	while (x > 0) {
		ans = ans + bit[x];
		x -= x & (-x);
	}
	return ans;
}

int main() {
	int n,m; s(n); s(m); sl(md);	

	I.M[0][0] = I.M[1][1] = 1; I.M[1][0] = I.M[0][1] = 0;
	O.M[0][0] = O.M[0][1] = O.M[1][0] = O.M[1][1] = 0;

	F[0] = I;
	G[0] = I;

	F[1].M[0][0] = F[1].M[1][0] = F[1].M[0][1] = 1; F[1].M[1][1] = 0;
	G[1].M[0][0] = 0; G[1].M[0][1] = G[1].M[1][0] = 1; G[1].M[1][1] = md-1;

	bit[0] = bit[1] = O;

	rep(i,2,n) {
		bit[i] = O;
		F[i] = F[i-1] * F[1];
		//cout<<F[i].M[0][1]<<endl;
		G[i] = G[i-1] * G[1];
	}

	rep(i,1,n) {
		sl(A[i]);
		upd(i,A[i]*F[i]);
	}

	//int q; s(q);

	//cout<<"Ok"<<endl;

	while (m--) {
		int t; s(t);
		if (t == 1) {
			int x; ll v; s(x); sl(v);
			upd(x,O-A[x]*F[x]);
			A[x] = v;
			upd(x,v*F[x]);
		} else {
			int l,r; s(l); s(r);

			//cout<<qry(r).M[0][1]<<" : "<<qry(l-1).M[0][1]<<endl;

			mat Z = qry(r) - qry(l-1);
			Z = Z*G[l-1];
			prl(Z.M[0][1]); endc;
		}
	}

}
