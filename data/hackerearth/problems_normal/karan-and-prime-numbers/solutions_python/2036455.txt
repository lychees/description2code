t = int(raw_input().strip())
import math
# Generators are iterators but not vice versa
# Generators are implemented on iterators
# Generator is tied to function with yield
# iterator is tied to __next__ method implementation.
from itertools import count, islice

P = [1]*1000001
P[1] = 0
P[0] = 0
def sieve():
	for i in islice(count(2), int(math.sqrt(1000000))+1):
		if P[i]:
			# using islice which returns iterator and count (start, step=1) 
			# which also return iterator
			for j in islice(count(i*i, i), 1000000/i-i+1):
				try:
					P[j] = 0
				except:
					print j
			
	## Slows down speed due to 10^6 writes.
	# Prefix sum:
	#for i in range(1, 1000001):
	#		if P[i]:
	#		P[i] = P[i-1] + i
	#	else:
	#		P[i] = P[i-1]


while t:
	t-=1
	
	sieve()
	x, y = map(int, raw_input().strip().split(" "))
	s = 0
	for i in range(x, y+1):
		if P[i]:
			s += i
	print s