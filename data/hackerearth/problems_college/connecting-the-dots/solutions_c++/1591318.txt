//    Author : Nishanth Vijayan IIT Ropar,India.
//
//	  Spoj 		  : http://www.spoj.com/users/nishanth_v/
//	  HackerEarth : http://www.hackerearth.com/users/nishanththegr8/
//	  Facebook	  : https://www.facebook.com/NishanthTheGr8
//    Motto       : The Less You Give A Fuck, The Happier You'll Be. :)


#include <iostream>
#include <cstdio>
#include <map>
#include <set>
#include <vector>
#include <stack>
#include <list>
#include <algorithm>
#include <utility>
#include <cmath>
#include <string>
#include <cstring>


#define ABS(x) ((x)<0?-(x):(x))
#define pnl printf("\n");
#define REP(i,n) for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b) for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b) for(__typeof(b) i=(a);i<=(b);++i)
#define FOREACH(i,s) for(__typeof((s).begin()) i=(s).begin();i!=(s).end();i++)
#define UNIQUE(v) sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b) memset(a,b,sizeof(a))

#define pi acos(-1)
#define INF 0x3f3f3f3f
#define MEMSET_INF 127 // about 2B
#define MEMSET_HALF_INF 63 // about 1B
#define LLI long long 
#define gc getchar_unlocked
#define pc putchar_unlocked

using namespace std;

typedef pair<LLI, LLI> ii;
typedef vector<LLI, LLI> vi;

//Fast Input & Output

LLI scanint()
{register int c = gc();LLI x = 0;int neg = 0;
for(;((c<48 || c>57) && c != '-');c = gc());
if(c=='-') {neg=1;c=gc();}
for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
if(neg) x=-x;return x;}


class Graph
{
    int V;    // No. of vertices
    list< pair<int,int> > *adj;    // Pointer to an array containing adjacency lists

public:
    Graph(int V);   // Constructor
    void addEdge(int v, int w,int ray);   // function to add an edge to graph
    int BFS(long v,long t);    // DFS traversal of the vertices reachable from v
};
 
Graph::Graph(int V)
{
    this->V = V;
    adj = new list< pair<int,int> >[V];
}
 
void Graph::addEdge(int v, int w , int ray)
{
    adj[v].push_back(make_pair(w,ray));
}
int Graph::BFS(long s,long t)
{   
    
    bool *visited = new bool[V];
    
    long *dist     = new long[V];

    long *parent   = new long[V];
    
    for(long i = 0; i < V; i++)
        {   visited[i] = false;
            dist[i]    = 0;
            parent[i]   = -1;
        }
 
    int prev_ray =0;

    list<long> queue;    
 
    
    visited[s] = true;
    dist[s]    = 0;
    queue.push_back(s);
 
    parent[0]=0;
    list< pair<int,int> >::iterator i;
 
    while(!queue.empty())
    {
        
        s = queue.front();
        
        queue.pop_front();
 
        for(i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if(!visited[i->first] && i->second!=parent[s])
            {	//cout<<s<<" "<<i->first<<" "<<i->second<<" "<<prev_ray<<endl;
                
                visited[i->first] = true;
                dist[i->first] = dist[s] +1;
                parent[i->first] = i->second;
                queue.push_back(i->first);
            }
            
        }
    }
    //FOR(k,0,V)cout<<dist[k]<<endl;
    if (dist[t]!=0)return dist[t];
    else return -1;
}

int main(){


int N,M,x,y,r;
cin>>N>>M;

Graph G(N);
FOR(i,0,M){
	x=scanint();y=scanint();r=scanint();
	G.addEdge(x-1,y-1,r);
}
cout<<G.BFS(0,N-1);
return 0;
}