#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cstdio>
#include <algorithm>
#include <deque>
#include <vector>
#include <map>
#include <cmath>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <string>
#include <cstring>
#include <climits>
#include <cctype>
#include <utility>
#include <cassert>
#include <ctime>
using namespace std;

#define ft first
#define sd second
#define pb push_back
#define endl '\n'
#define buli(x) __builtin_popcountll(x)
#define cpy(a,e) memcpy(a,e,sizeof(e))
#define clr(a,e) memset(a,e,sizeof(a))
#define iter(c) __typeof((c).begin())
#define tr(c,i) for (iter(c) i=(c).begin();i!=(c).end();i++)
#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)
#define rep(i,n) for (int (i)=0;(i)<(n);i++)
#define repd(i,n) for (int (i)=(n)-1;(i)>=0;i--)
#define reps(i,s,e) for (int (i)=(s);(i)<=(e);i++)
#define repds(i,s,e) for (int (i)=(s);(i)>=(e);i--)
#define repl(i,s,e) for (int (i)=(s);(i);i=e[i])

#define TASK "C"

const int INF = 1e9 + 7;
                          
int n, m;
int V;
int a[355], f[1055];
int level[1055], iter[1055];
bool used[1055];

struct edge {
    int to,cap,rev;
};
vector<edge> g[1055];
void add_edge(int from,int to,int cap) {
    g[from].pb((edge){to,cap,g[to].size()});
    g[to].pb((edge){from,0,g[from].size()-1});
}  
void bfs(int s) {
    clr(level,-1);
    queue<int> que;
    level[s]=0;
    que.push(s);
    while(!que.empty()) {
        int v=que.front();que.pop();
        rep(i,g[v].size()) {
            edge &e=g[v][i];
            if (e.cap>0&&level[e.to]<0) {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}
int dfs(int v,int t,int f) {
    if (v==t) return f;
    used[v]=1;
    for (int &i=iter[v];i<g[v].size();i++) {
        edge &e=g[v][i];
        if (e.cap>0&&level[v]<level[e.to]) {
            int d=dfs(e.to,t,min(f,e.cap));
            if (d>0) {
                e.cap-=d;
                g[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}
int max_flow(int s,int t) {
    int flow=0;
    for (;;) {
        bfs(s);
        if (level[t]<0) return flow;
        clr(iter,0);
        int f;
        while((f=dfs(s,t,INF))>0) flow+=f;
    }
}   
bool C(int mid) {
	int s = n + n, t = s + 1;
   	for (int i = 0; i < n + n + 5; i++) g[i].clear();

	for (int i = 0; i < n; i++) add_edge(s, i, 1);

	for (int i = 0; i < n; i++) {
	 	for (int j = 0; j < n; j++) {
	 	 	if (f[j + a[i]] > mid) continue;
			add_edge(i, j + n, 1);
		}
	}

	for (int i = n; i < s; i++) add_edge(i, t, 1);

	return max_flow(s, t) >= n;
}                                                            
int main() {
	#ifdef home
		freopen(TASK".in","r",stdin);
		freopen(TASK".out","w",stdout);
	#endif
	ios::sync_with_stdio(false);
	cin.tie(0); 

	cin >> n >> m;

	for (int i = 0; i < n; i++) cin >> a[i];
	for (int i = 0; i < n + m - 1; i++) cin >> f[i];

	int lb = -1, ub = (int)1e9;

	while (ub - lb > 1) {
	 	int mid = (lb + ub) >> 1;
		if (C(mid)) ub = mid;
		else lb = mid;
	}

	cout << ub << endl;
           
	#ifdef home
		eprintf("time = %d ms\n", (int)(clock() * 1000. / CLOCKS_PER_SEC));
	#endif                                                                          
	return 0;
}