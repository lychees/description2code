#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <cstring>
#include <cmath>
#include <cassert>
#include <list>
#define FI first
#define SE second
#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i)
#define REV(i,a,b) for(int i= (int )a ; i >= (int)b ; --i)
#define REP(i,n) FOR(i,0,n)
#define DEP(i,n) REV(i,n,0)
#define PB push_back
#define PP pop()
#define MAX(x,y) (x)>(y)?(x):(y)
#define MIN(x,y) (x)<(y)?(x):(y)
#define PF push_front
#define ALL(x) x.begin(),x.end()
#define SORT(x) sort(ALL(x))
#define V(x) vector< x >
#define Debug false
#define PRINT(x)        cout << #x << " " << x << endl
#define LET(x,a)         __typeof(a) x(a)
#define IFOR(i,a,b)     for(LET(i,a);i!=(b);++i)
#define EACH(it,v)      IFOR(it,v.begin( ),v.end( ))
#define PRESENT(c,x)    ((c).find(x) != (c).end( ))
#define SZ(x)           x.size()
#define CPRESENT(c,x)   (find(c.begin(),c.end(),x) != (c).end())
#define D(N)            int N
#define S(N)            scanf("%d",&N)
#define SD(N)           int N;scanf("%d",&N)
#define MP make_pair
#define EM empty()
using namespace std;
typedef pair<int ,int >   PI;
typedef pair<int,PI>    TRI;
typedef V( int ) VI;
typedef V( PI  )        VII;
typedef V( string )     VS;
typedef long long LL;
typedef long double LD;
 
 
list < int >  positions;
VI allEdges[1010];
int isVisited[1010];
int main(int argc, char const *argv[]){
    int cases;
    int position;
    S(cases);
    REP(i,cases){
        int edges;
        S(edges);
        
        REP(j,edges){
            allEdges[j].clear();
            isVisited[j] = 0;
        }
 
        REP(j,edges){
            int count;
            S(count);
            REP(k,count){
                S(position);
                allEdges[j].PB(position-1);
            }
        }
        int flag = 0;
        REP(j,edges){
            while(!positions.empty())
                positions.pop_front();
            REP(k,edges)
                isVisited[k] = 0;
            positions.PB(j);
            isVisited[j] = 1;
            while(!positions.empty()){
                int node = positions.front();
                //printf("%d  ", node);
                positions.pop_front();
                REP(l,allEdges[node].size()){
                    int edge = allEdges[node][l];
                    positions.PB(edge);
                    if (isVisited[edge] == 1)
                    {
                        flag = 1;
                        break;
                    }
                    isVisited[edge] = 1;
                }
            }
            //printf("\n");
            if (flag)
                break;
        }
        if (flag)
            printf("#%d:Yes\n",i+1);
        else  printf("#%d:No\n",i+1);
 
    }
}