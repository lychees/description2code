// Paste me into the FileEdit configuration dialog
#include <bits/stdc++.h>
using namespace std;

#define ll	int
#define FL(i,a,b) for(ll i=a;i<b;i++)
#define FOR(i,n) for(ll i=0;i<n;i++)
#define SORTF(x) sort(x.begin(),x.end(),func);
#define SORT(x) sort(x.begin(),x.end())
#define pb(x) push_back(x)
#define SET(v, val) memset(v, val, sizeof(v)) ;
#define RSORT(v) { SORT(v) ; REVERSE(v) ; }
#define ALL(v) v.begin(),v.end()
#define REVERSE(v) { reverse(ALL(v)) ; }
#define UNIQUE(v) unique((v).begin(), (v).end())
#define RUNIQUE(v) { SORT(v) ; (v).resize(UNIQUE(v) - (v).begin()) ; }
#define fill(x,n) memset(x,n,sizeof(x))
#define S(n) scanf("%d",&n)

//ll dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};
//ll dx[] = {1,1,1,0,0,-1,-1,-1}, dy[] = {1,0,-1,1,-1,1,0,-1};
//ll gcd(ll a, ll b) {if (a == 0 || b == 0) return maX(a,b); if (b % a == 0) return a; return gcd(b%a, a);}
//ll small_primes[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349};
//ll toll(const string &s) { stringstream ss; ss << s; ll x; ss >> x; return x; }
//ll modPow(ll a,ll b) {ll res=1;a%=MOD;for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}
//ll modInverse(ll a){return modPow(a,MOD-2);}
//ll nCk(ll n, ll k){if(k<0)return 0;ll numerator = 1;forall(il,0,k)numerator =(numerator*(n-il))%MOD;ll denominator = 1;forall(il,1,k+1)denominator=(denominator*il)%MOD;return (numerator*modInverse(denominator))%MOD;}


#define MAX 2000000 // Why? :D
#define inf 0x7fffffff

ll N;
int arr[2000000];
int tree[MAX];
int lazy[MAX];
int prime[2000000] = {0};

void build_tree(int node, int a, int b) {
    if(a > b) return; // Out of range
  	
  	if(a == b) { // Leaf node
    		tree[node] = arr[a]; // Init value
		return;
	}
	
	build_tree(node*2, a, (a+b)/2); // Init left child
	build_tree(node*2+1, 1+(a+b)/2, b); // Init right child
	
	tree[node] = max(tree[node*2], tree[node*2+1]); // Init root value
}
 
/**
 * Increment elements within range [i, j] with value value
 */
void update_tree(int node, int a, int b, int i, int j, int value) {
    
	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return;
    
  	if(a == b) { // Leaf node
    		tree[node] = value;
    		return;
	}
 
	update_tree(node*2, a, (a+b)/2, i, j, value); // Updating left child
	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value); // Updating right child
 
	tree[node] = max(tree[node*2], tree[node*2+1]); // Updating root with max value
}
 
/**
 * Query tree to get max element value within range [i, j]
 */
int query_tree(int node, int a, int b, int i, int j) {
	if(a > b || a > j || b < i) return -inf; // Out of range
 
	if(a >= i && b <= j) // Current segment is totally within range [i, j]
		return tree[node];
 
	int q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child
	int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); // Query right child
 
	int res = max(q1, q2); // Return final result
	
	return res;
}
 

int main() {
	ll i,j;
	for(i =  2;i <= 1000;i++) 
		if(prime[i] == 0) 
			for(j = i + i;j <= 1000000;j += i) 
				prime[j] = 1;
				
	prime[1] = 1;
	ll M;
	S(N);
	S(M);
	for(int i = 0; i < N; i++) {
		S(arr[i]);
		if(prime[arr[i]] == 1) {
			arr[i] = 0;
		}
	}
 
	build_tree(1, 0, N-1);
 
	memset(lazy, 0, sizeof lazy);
 	for(i = 0;i < M;i++) {
 		ll q;
 		S(q);
 		ll l,r;
 		S(l);
 		S(r);
 		if(q == 0)  {
 			if(prime[r] == 1) {
 				r = 0;
 			}
			update_tree(1, 0, N-1, l -1 , l- 1, r); // Increment range [0, 6] by 
		}
		else{
			ll va =  query_tree(1, 0, N-1, l- 1, r -1) ; // G	et max element in range [0, N-1]
			if(va == 0) {
				cout << "-1\n";	
			}
			else {
				cout << va <<"\n";
			}
		}
		
		//cout << "\n";
	}
}

