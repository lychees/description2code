#include <iostream>
#include <algorithm>
#include <iterator>
 
#include <map>
#include <vector>
#include <list>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <string>
 
#include <functional>
#include <utility>
#include <fstream>
#include <iosfwd>
#include <sstream>
#include <iomanip>
 
#include <cmath>
#include <cstring>
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cassert>
 
#include <complex>
#include <numeric>
 
using namespace std;
 
#define DEBUG                            1
#define Bug(X)                           if(DEBUG) cout<<#X<<" = "<<X<<endl
#define SYS                              system("pause")
#define VAR(x,a)                         __typeof(a) x(a)
#define FORD(i,a,b)                      for(int i = (int)a,_b = (int)b;i>=(_b);--i)
#define FOREACH(it,v)                    for(VAR(it,(v).begin());it!=(v).end();++it)
#define FOR(i,a,b)                       for(int i=(int)(a),_b = (int)b;i<(int)(_b);++i)
#define REP(i,n)                         FOR(i,0,n)
#define REPD(i,n)                        FORD(i,n,0)
#define PB                               push_back
#define PF                               push_front
#define MP                               make_pair
#define SZ                               size()
#define ALL(X)                           X.begin(),X.end()
#define RALL(X)                          X.rbegin(),X.rend()
#define Clear(X)                         memset(X,0,sizeof(X))
#define EPS                              1e-7
#define INF                              100000000
#define INFLL                            10000000000000000LL
 
typedef vector< int > VI; typedef vector< string > VS; typedef long long LL;
typedef vector<VI> VVI; typedef pair< int,int > PII; typedef vector<VS> VVS;
typedef unsigned long long ULL;  typedef vector<PII> VPII; typedef vector<LL> VLL;
 
int rInt(){int nT = -1; scanf( "%d", &nT ); return nT; }
int strToInt( string &S ) { int nT = 0; REP( i, S.SZ ) nT = nT * 10 + ( S[i] - '0' ); return nT;}
string intToStr(int N){string S;do{S.PB(N%10+'0');N/=10;}while(N);reverse(ALL(S));return S;}
string vIntToStr(VI V){string S;REP(i,V.SZ) S.PB(V[i]+'0');return S;}
string rStr(){char nStr[1024]; scanf( "%s", nStr ); return nStr; }
VI strToVInt(string &S){VI V;REP(i,S.SZ) V.PB(S[i]-'0');return V;}
LL rLL(){LL nT = -1; cin>>nT; return nT; }
template<class T> ostream& operator << (ostream &O,vector<T> &V) { O<<"{"; REP(i,V.SZ-1) O<<V[i]<<", ";O<<V[V.SZ-1];O<<"}";return O;}
 
LL countPalindromes( string& inStr, int lowIdx, int highIdx );
const int gSentinel = -1;
vector<VLL> gMemo;
 
// The program counts the number of palindromic subsequences of
// a given string using Top Down Dynamic Programming Approach
 
int main()
{
	int nTest = rInt();
	while( nTest-- ) {
		string inputStr( rStr() );
		gMemo.clear();
		gMemo.resize( inputStr.SZ, VLL( inputStr.SZ, gSentinel ) );
		LL retPal = 0;
		const int lastIdx = inputStr.SZ - 1;
		for( int i = 0; i < inputStr.SZ; ++i )
			retPal += countPalindromes( inputStr, i, lastIdx );
		cout << retPal << endl;
	}
    return 0;
}
 
LL countPalindromes( string& inStr, int lowIdx, int highIdx )
{
	if( gMemo[ lowIdx ][ highIdx ] != gSentinel )
		return gMemo[ lowIdx ][ highIdx ];
	else {
		if( lowIdx == highIdx )
			return gMemo[ lowIdx ][ highIdx ] = 1;
		else if( lowIdx + 1 == highIdx ) {
			if( inStr[ lowIdx ] == inStr[ highIdx ] )
				return gMemo[ lowIdx ][ highIdx ] = 2;
			else
				return gMemo[ lowIdx ][ highIdx ] = 1;
		} 
		else {
			LL retPal = 1LL;
			for( int i = lowIdx + 1; i <= highIdx; ++i )
				if( inStr[i] == inStr[ lowIdx ] ) {
					retPal++;
					for( int j = lowIdx + 1; j <= i - 1; ++j )
						retPal += countPalindromes( inStr, j, i - 1 );
				}
			return gMemo[ lowIdx ][ highIdx ] = retPal;
		}
	}
}
