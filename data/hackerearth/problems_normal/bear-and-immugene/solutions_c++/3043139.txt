#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>

#include <cassert>
#include <limits>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#define each(it,o) for(auto it= (o).begin(); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
#define inrep int t;cin>>t; while(t--)
using namespace std;

typedef vector<int> vi;
typedef pair<int,int> pii;
typedef vector<pii > vpii;
typedef long long ll;
typedef vector<ll> vll;
typedef pair<ll,ll> pll;
typedef vector<pll > vpll;
typedef vector<string> vs;
typedef long double ld;

template<typename T> ostream& operator<< ( ostream &o,vector<T> v ) {
    if ( v.size() >0 )
        o<<v[0];
    for ( unsigned   i=1; i<v.size(); i++ )
        o<<" "<<v[i];
    return o<<endl;
}
template<typename U,typename V> ostream& operator<< ( ostream &o,pair<U,V> p ) {
    return o<<"("<<p.first<<", "<<p.second<<") ";
}
template<typename T> istream& operator>> ( istream &in,vector<T> &v ) {

    for ( unsigned   i=0; i<v.size(); i++ )
        in>>v[i];
    return in;
}


const int MOD=1000000007;


void matMult ( const vector<vi> &A, const vector<vi> &B, vector<vi> &C ) {
    rep ( i,5 ) {
        rep ( j,5 ) {
            ll res=0;
            rep ( k,5 )   res+= (ll) A[i][k]*B[k][j];
            if ( res>=MOD ) res%=MOD;
            C[i][j]=res;
        }
    }
}

struct SegmentMatTree {
    struct node {
        vector<vi> A;
        node() :A ( 5,vi ( 5 ) ) {
            rep ( i,5 ) A[i][i]=1;
        }
        node ( char c ) :node() {
            A[4][4]=2;
            A[4][c]=MOD-1;
            A[c][4]=1;
            A[c][c]=0;

        }
    };
    int n;
    int size;
    vector<node> tree;
    vector<char> &init;
    SegmentMatTree ( vector<char> &_init ) :init ( _init ) {
        int _n=init.size();
        n=1;
        while ( n<_n ) n*=2;
        size=2*n;
        tree=vector<node> ( size );
        build ( 1,0,n );
    }
    void build ( int no,int L,int R ) {
        if ( R-L==1 ) {
            if ( L<init.size() ) tree[no]=node ( init[L] );
            return;
        }
        int s= ( L+R ) >>1;
        build ( 2*no,L,s );
        build ( 2*no+1,s,R );
        matMult ( tree[2*no+1].A,tree[2*no].A,tree[no].A );
    }

    void  set ( int no, int L, int R, int idx, char v ) {
        if ( R-L==1 ) {
            tree[no]=node ( v );
            return;
        }
        int s= ( L+R ) >>1;
        if ( idx<s ) set ( 2*no, L,s,idx,v );
        if ( idx>=s ) set ( 2*no+1,s,R,idx,v );
        matMult ( tree[2*no+1].A,tree[2*no].A,tree[no].A );
//         cout<<"Interval "<<L<<" "<<R<<":"<<endl<<tree[no].A<<endl;

    }
    void set ( int idx, char val ) {
// cout<<"setting "<<idx<<" to "<<int(val)<<endl;
        set ( 1,0,n,idx,val );

    }

    int getAll() {
        return tree[1].A[4][4];
    }

};
ll modPow ( ll x, int b ) {
    ll res=1;
    while ( b ) {
        if ( b&1 ) res=res*x%MOD;
        x=x*x%MOD;
        b>>=1;
    }
    return res;
}
struct Solve2 {
    const int n;
    SegmentMatTree sm;
    
    Solve2 ( vector<char> &_g ) :n ( _g.size() ),sm ( _g ) {
    }
    void update ( int idx, char c ) {
        c=toId ( c );
        sm.set ( idx,c );
    }
    int val() {
        return sm.getAll();
    }



   static char toId ( char c ) {
        switch ( c ) {
        case 'A':
            c=0;
            break;
        case 'C':
            c=1;
            break;
        case 'G':
            c=2;
            break;
        case 'T':
            c=3;
            break;
        default:
            assert ( 0 );
        }
        return c;
    }
};
struct Solve {
    const int n;
    vector<char> &gene;
    vector<set<int>> occs;
    vi lastOcc;
    vi vals;
    Solve ( vector<char> &_g ) :n ( _g.size() ),gene ( _g ) ,occs ( 4 ),lastOcc ( n ),vals ( n ) {
        vi lO ( 4,-1 );

        rep ( i,n ) {
            char &c=gene[i];
            c=toId ( c );
            lastOcc[i]= lO[c] ;
            lO[c]=i;
            occs[c].insert ( i );
        }
        compute();

    }
    void compute() {
        ll last=1;
        rep ( i,n ) {
            last=2*last;
            if ( lastOcc[i]>0 ) last=MOD+last-vals[lastOcc[i]-1];
            else if ( !lastOcc[i] ) last=MOD+last-1;
            vals[i]=last=last%MOD;
        }
        cout<<"current"<<vi ( all ( gene ) );
        cout<<"last: "<<lastOcc;
        cout<<"vals: "<<vals;

    }

    void updateVals ( int idx, int nxtOld, int nxtNew, int lstOld, int lstNew ) {

        int dFIdx=0;
        if ( lstOld>=0 ) dFIdx=MOD-vals[lstOld];
        else dFIdx=MOD-1;
        if ( lstNew>=0 ) dFIdx+=vals[lstNew];
        else dFIdx+=1;


    }
    char toId ( char c ) {
        switch ( c ) {
        case 'A':
            c=0;
            break;
        case 'C':
            c=1;
            break;
        case 'G':
            c=2;
            break;
        case 'T':
            c=3;
            break;
        default:
            assert ( 0 );
        }
        return c;
    }
    void update ( int idx, char c ) {
        c=toId ( c );
        char c2=gene[idx];

        int nxtOld=-1,nxtNew=-1;
        if ( c==c2 ) return;
        auto it=occs[c2].find ( idx );
        assert ( it!=occs[c2].end() );
        auto it2=it;
        it2++;
        if ( it2!=occs[c2].end() ) {
            lastOcc[*it2]=lastOcc[idx];
            nxtOld=*it2;
        }
        auto it3=occs[c].lower_bound ( idx );
        if ( it3!=occs[c].begin() ) {
            auto it4=it3;
            it4--;
            lastOcc[idx]=*it4;

        } else lastOcc[idx]=-1;
        if ( it3!=occs[c].end() ) {
            lastOcc[*it3]=idx;
            nxtNew=idx;
        }
        gene[idx]=c;
        occs[c2].erase ( it );
        occs[c].insert ( idx );
//         updateVals ( idx,nxtOld,nxtNew );
        compute();

    }
    int val() {
        return vals[n-1];

    }
};
int main() {
    ios_base::sync_with_stdio ( false );
    int n;
    int q;
    cin>>n>>q;
    vector<char> gene ( n );
    cin>>gene;
  
     rep ( i,gene.size() ) {
            gene[i]=Solve2::toId ( gene[i] );
           }
            Solve2 s ( gene );
    rep ( i,q ) {
        int x;
        char y;
        cin>>x>>y;
        x--;
        s.update ( x,y );
        cout<<s.val() <<'\n';
    }


}
