#include<bits/stdc++.h>
using namespace std;
vector< pair <int,int> >G[109];
int maxflow[109];
int parent_of[109];
int main()
{	
	int v,e;
	cin>>v>>e;
	for(int i=1;i<=e;++i)
	{
		int u,v,w;
		cin>>u>>v>>w;
		G[u].push_back(make_pair(v,w));
		G[v].push_back(make_pair(u,w));
	}
	int source,destination,t;
	cin>>source>>destination>>t;
	memset(maxflow,0,sizeof maxflow);
	maxflow[source]=INT_MAX;
	memset(parent_of,0,sizeof parent_of);
	parent_of[source]=-1;
	queue<int>q;
	q.push(source);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=0;i<(int)G[x].size();++i)
		{
			pair<int,int>node=G[x][i];
			int a=node.first;
			int p=node.second;
			if(min(maxflow[x],p)>maxflow[a])
			{
				maxflow[a]=min(maxflow[x],p);
				q.push(a);
				parent_of[a]=x;
			}
		}
	}//time complexity is O(|V|2)
	vector<int>finalpath;
	finalpath.push_back(destination);
	int k=parent_of[destination];
	while(parent_of[k]>0)
	{
		finalpath.push_back(k);
		k=parent_of[k];
	}
	finalpath.push_back(source);
	for(int i=finalpath.size()-1;i>=0;--i)
	{
		cout<<finalpath[i]<<" ";
	}
	printf("\n");
	int x1=maxflow[destination]-1;
	//cout<<x1<<endl;
	cout<<ceil(t/(x1*1.0))<<endl;//ignoring the return trip by the travel agent
	return 0;
}
