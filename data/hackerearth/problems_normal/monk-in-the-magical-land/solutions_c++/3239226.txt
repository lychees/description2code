/*******************************
*  Bismillahir Rahmanir Rahim
*  Harunur Rashid
********************************

************Template Starts Here***********/

#include<bits/stdc++.h>

using namespace std;

#define endl       "\n"
#define eps        1e-9
#define sf         scanf
#define xx         first
#define yy         second
#define pf         printf
#define ppb        pop_back
#define sqr(x)     ((x)*(x))
#define mp         make_pair
#define pb         push_back
#define pi         acos(-1.0)
#define mod        1000000007
#define degree(a)  180.0*a/pi
#define radiun(a)  pi*a/180.0
#define pr(a)      cout<<a<<"\n"
#define sz(x)      ((int)x.size())
#define all(a)     a.begin(),a.end()
#define mem(a,b)   memset(a,b,sizeof(a))
#define leadingzero(x) __builtin_clz(x)
#define trailingzero(x) __builtin_ctz(x)
#define countbit(x) __builtin_popcount(x)
#define lcm(a,b)   (abs(a)/gcd(a,b))*abs(b)


typedef long long int          lld;
typedef unsigned long long int llu;
typedef vector<int>            vi;
typedef pair<int,int>          pii;

template<class T>
T mod_f(T num)
{
    if(num>=0) return num%mod;
    else       return ((num%mod)+mod)%mod;
}

template<class T>
T fast_pow(T b,T p)
{
    if(p==0)
        return 1;
    if(p%2)
    {
        T x=mod_f(mod_f(b)*mod_f(fast_pow(b,p-1)));
        return x;
    }
    else
    {
        T x=mod_f(fast_pow(b,p/2));
        x=mod_f(mod_f(x)*mod_f(x));
        return x;
    }
}

template<class T>
T gcd(T a,T b)
{
    a=abs(a);
    b=abs(b);
    while(b)
    {
        T r=a%b;
        a=b;
        b=r;
    }
    return a;
}

template<class T>
ostream& operator<<(ostream& out,vector<T>v)
{
    int sz=v.size()-1;
    for(int i=0; i<=sz; i++) out<<v[i]<<" ";
    return out;
}

template<class T>
ostream& operator,(ostream& out,T a)
{
    out<<a<<" ";
    return out;
}

/* int gcd , x , y
void extendedEuclid(int A,int B)
{
    if(B==0)
    {
        gcd=A;
        x=1;
        y=0;
    }
    else
    {
        extendedEuclid(B,A%B);
        int u=x;
        x=y;
        y=u-(A/B)*y;
    }
}
*/
//bool isEqual(double a,double b) { return fabs(a-b)<=eps; }
//bool isLessThan(double a,double b) { return a+eps<b; }
//bool isLessThanEqual(double a,double b) { return a<b+eps; }
//bool isGreaterThan(double a,double b) { return a>b+eps; }
//bool isGreaterThanEqual(double a,double b) { return a+eps>b; }

/*/ 4 direction ....

int dx[]= {+0,+1,+0,-1};
int dy[]= {+1,+0,-1,+0};

// 8 direction ....

int dx[]= {+0,+1,+1,+1,+0,-1,-1,-1};
int dy[]= {+1,+1,+0,-1,-1,-1,+0,+1};

// Knight direction...

int dx[]= {+1,-1,+2,-2,+2,-2,+1,-1};
int dy[]= {+2,+2,+1,+1,-1,-1,-2,-2};
*/

/***********Template Ends Here***********/

int K[20],L[100],Z[100],SelectedKey[10];
bool visited[100];
vector<int>adj[20];

int main()
{
    //ios_base::sync_with_stdio(0);cin.tie(false);cout.tie(false);
    int T,n,m,k,i,j,z,u,c,LL,UL,cnt,ans,sum,key;

    cin>>T;

    while(T--)
    {
        cin>>n>>m>>k;

        for(i=0; i<n; i++) cin>>K[i];
        for(i=0; i<m; i++) cin>>L[i];
        for(i=0; i<m; i++) cin>>Z[i];

        for(i=0; i<n; i++)
        {
            for(j=0; j<m; j++)
            {
                u=__gcd(K[i],L[j]);
                if(u!=1) adj[i].pb(j);
            }
        }

        LL=(1<<k)-1;
        UL=(1<<n)-1;

        c=k;
        ans=0;

        for(i=LL; i<=UL; i++)
        {
            for(cnt=j=0; j<c; j++)
            {
                if(i&(1<<j))
                {
                    if(cnt==k)
                    {
                        ++cnt;
                        break;
                    }
                    SelectedKey[cnt]=j;
                    ++cnt;
                }
            }

            if(i==(1<<c)-1) ++c;
            if(cnt!=k) continue;

            sum=0;
            mem(visited,0);

            for(z=0; z<k; z++)
            {
                key=SelectedKey[z];
                for(j=0; j<adj[key].size(); j++)
                {
                    u=adj[key][j];
                    if(visited[u]) continue;
                    visited[u]=1;
                    sum+=Z[u];
                }
            }

            ans=max(ans,sum);
        }
        cout<<ans<<endl;

        for(z=0; z<20; z++)
        adj[z].clear();
    }
    return 0;
}
