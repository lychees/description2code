#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

bool sieve[1000010];
vector<long long int> primes;

long long int mf;

bool comp(const long long int &a, const long long int &b)
{
	return a < b;
}

int main()
{
	int i,j,z,T,L,R;
	for (i = 0; i <= 1000009; i++)
		sieve[i] = true;
	
	int k = sqrt(1000009);
	sieve[0] = false;
	sieve[1] = false;

	for(i = 2; i <= k; ++i)
	{
		if(sieve[i] == true)
		{
			for(j = i; ; ++j)
			{
				z = i*j;
				if(z > 1000009) break;
				sieve[z] = false;
			}
		}
	}    
	
	for(i = 0; i <= 1000000; ++i)
		if(sieve[i] == true) primes.push_back(i);
		
	scanf("%d", &T);
	int ans;
	long long int test, val;
	while(T--)
	{
		scanf("%d", &L);
		scanf("%d", &R);
		ans = 0;
		
		z = primes.size()-1;
		vector<long long int>::iterator it = primes.begin(), y,x;
				
		for(i = 0; i < z; ++it, ++i)
		{
			test = (long long int)primes[i];
			test *= primes[i+1];
			if(test > R) break;
			
			mf = primes[i];
			val = L / primes[i];			
			if(L % primes[i] == 0) --val;			
			
			x = upper_bound(it+1, primes.end(), val , comp);
			//printf("Upper Bound = %d\n", *x);
			
			val = (R/primes[i]) + 1;
						
			y = lower_bound(it+1, primes.end(), val, comp);
			//printf("Lower Bound = %d\n", *y);
			
			ans += y-x;
		}
		
		printf("%d\n", ans);
	}
    return 0;
}
