//mishraiiit
#include<bits/stdc++.h>
#define ll long long int
#define MOD 1000000007LL
#define fastScan ios_base::sync_with_stdio(0); cin.tie(NULL);
using namespace std;
typedef pair <ll, ll> pll;

class SegmentTree {
  
  typedef pair<ll, pair<double, ll> > NODETYPE;
  typedef pair<ll, pair<double, ll> > UPDATETYPE;
  typedef ll RANGETYPE;

  public:
  
    NODETYPE merge(NODETYPE A, NODETYPE B) {
      if(max(A.first, B.first) == 0) return make_pair(0, make_pair(1.0, 1));
      else if(A.first > B.first) return A;
      else if(A.first < B.first) return B;
      else if(A.first == B.first) return make_pair(A.first, make_pair(A.second.first + B.second.first, (A.second.second + B.second.second) % MOD));
    }
    
    NODETYPE leafNodeValue(RANGETYPE index) {
      return make_pair(0, make_pair(0.0, 1));
    }
    
    void updateNode (NODETYPE & node, UPDATETYPE & value, RANGETYPE & start, RANGETYPE & end) {
      if(value.first == node.first) node.second.second = (node.second.second + value.second.second) % MOD, node.second.first += value.second.first;
      else node = value;
    }
    
    void updateLazy (UPDATETYPE & child, UPDATETYPE & parent) {
      assert(0);
    }
    
    NODETYPE outOfRange;       // When we query outside require segment, what value to return by default, so that main query has no impact.
    UPDATETYPE defaultLazyValue; // Default value of lazy, initially.. or after updating a node.
    
    void setDefaultAndOutOfRange() {
      outOfRange = make_pair(0, make_pair(0.0, 0));
      defaultLazyValue = make_pair(0, make_pair(0.0, 0));
    }
    
   /* Don't need to change below this */

    SegmentTree( RANGETYPE n ) {
      setDefaultAndOutOfRange();
      size = n;
      tree = new NODETYPE[n << 3];
      lazy = new UPDATETYPE[n << 3];
      build(1, 0, size - 1);
    }


    void update(RANGETYPE start, RANGETYPE end, UPDATETYPE value) {
      update(1, 0, size - 1, start, end, value);
    }

    NODETYPE query(RANGETYPE start, RANGETYPE end) {
      return query(1, 0, size - 1, start, end);
    }

  private:


    void build(RANGETYPE node, RANGETYPE start, RANGETYPE end) {
      RANGETYPE into2 = node << 1, mid = (start + end) / 2;
      if(start == end) {
        tree[node] = leafNodeValue(start);
        lazy[node] = defaultLazyValue;
      } else {
        build(into2, start, mid), build(into2 + 1, mid + 1, end);
        lazy[node] = defaultLazyValue;
        tree[node] = merge(tree[into2], tree[into2 + 1]);
      }
    }

    void push(RANGETYPE node, RANGETYPE start, RANGETYPE end) {
      if(lazy[node] != defaultLazyValue) {
        updateNode(tree[node], lazy[node], start, end);
        if(start != end) {
          updateLazy(lazy[node + node], lazy[node]);
          updateLazy(lazy[node + node + 1], lazy[node]);
        }
        lazy[node] = defaultLazyValue;
      }
    }

    void update(RANGETYPE node, RANGETYPE start, RANGETYPE end, RANGETYPE rangestart, RANGETYPE rangeend, UPDATETYPE value) {
      RANGETYPE into2 = node << 1, mid = (start + end) / 2;
      push(node, start, end);
      if(start > end || start > rangeend ||  end < rangestart) return;
      if(rangestart <= start && end <= rangeend) {
        updateNode(tree[node], value, start, end);
        if(start != end) {
          updateLazy(lazy[into2 + 1], value);
          updateLazy(lazy[into2], value);
        }
        return;
      }
      update(into2, start, mid, rangestart, rangeend, value), update(into2 + 1, mid + 1, end, rangestart, rangeend, value);
      tree[node] = merge(tree[into2], tree[into2 + 1]);
    }

    NODETYPE query(RANGETYPE node, RANGETYPE start, RANGETYPE end, RANGETYPE rangestart, RANGETYPE rangeend) {
      RANGETYPE into2 = node << 1, mid = (start + end) / 2;
      if(start > end || start > rangeend ||  end < rangestart) return outOfRange;
      push(node, start, end);
      if(rangestart <= start && end <= rangeend) return tree[node];
      return merge( query(into2, start, mid, rangestart, rangeend), query(into2 + 1, mid + 1, end, rangestart, rangeend));
    }

    long long int size;
    NODETYPE * tree;
    UPDATETYPE * lazy;

};

int arr[100001];

int main() {

    fastScan;

    SegmentTree POS(100001);
    SegmentTree NEG(100001);

    ll n, elem;
    cin >> n;
    for(int i = 0; i < n; i++) {
      cin >> elem;
      arr[i] = elem;
      if(elem > 0) {
        pair<ll, pair<double, ll> > q = NEG.query(0, elem - 1);
        POS.update(elem, elem, make_pair(q.first + 1, make_pair(q.second.first , q.second.second) ));
      } else {
        elem = - elem;
        pair<ll, pair<double, ll> > q = POS.query(0, elem - 1);
        NEG.update(elem, elem, make_pair(q.first + 1, make_pair(q.second.first, q.second.second)));
      }
    }

    cout << POS.merge(POS.query(0, 100000), NEG.query(0, 100000)).first << " " << POS.merge(POS.query(0, 100000), NEG.query(0, 100000)).second.second << endl;
     
    return 0;
}
