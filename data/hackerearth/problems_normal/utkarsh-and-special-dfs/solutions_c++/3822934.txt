#include <bits/stdc++.h>

#define all(x) (x).begin(), (x).end()
#define li long long

using namespace std;

inline int nxt(){
	int n;
	scanf("%d", &n);
	return n;
}

const int mod = 1000000007;

li pw(li a, li b){
	li res = 1;
	while (b){
		if (b & 1ll)
			res = res * a % mod;
		b >>= 1;
		a = a * a % mod;
	}
	return res;
}

li inv(li x){
	return pw(x, mod - 2);
}

struct SegTree{
	int n;
	vector<int> a;
	vector<int> mult;

	SegTree(int nn){
		n = 1;
		while (n < nn)
			n *= 2;
		a.resize(n + n);
		mult.resize(n + n, 1);
	}

	SegTree(const vector<int>& ar){
		n = 1;
		while (n < ar.size())
			n *= 2;
		a.resize(n + n);
		for (int i = 0; i < ar.size(); i++)
			a[i + n] = ar[i];
		for (int i = n - 1; i > 0; i--){
			a[i] = (a[i + i] + a[i + i + 1]) % mod;
		}
		mult.resize(n + n, 1);
	}

	void relax(int v){
		a[v] = 1ll * a[v] * mult[v] % mod;
		mult[v + v] = 1ll * mult[v + v] * mult[v] % mod;
		mult[v + v + 1] = 1ll * mult[v + v + 1] * mult[v] % mod;
		mult[v] = 1;
	}

	int _get(int v, int l1, int r1, int l, int r){
		if (l >= r1 || l1 >= r)
			return 0;
		if (l < l1)
			l = l1;
		if (r > r1)
			r = r1;
		if (l == l1 && r == r1)
			return 1ll * a[v] * mult[v] % mod;
		relax(v);
		int mid = (l1 + r1) / 2;
		return (_get(v + v, l1, mid, l, r) + _get(v + v + 1, mid, r1, l, r)) % mod;
	}

	void _mul(int v, int l1, int r1, int l, int r, int x){
		if (l >= r1 || l1 >= r)
			return;
		if (l < l1)
			l = l1;
		if (r > r1)
			r = r1;
		if (l == l1 && r == r1){
			mult[v] = 1ll * mult[v] * x % mod;
			return;
		}
		relax(v);
		int mid = (l1 + r1) / 2;
		_mul(v + v, l1, mid, l, r, x);
		_mul(v + v + 1, mid, r1, l, r, x);
		a[v] = (1ll * a[v + v] * mult[v + v] + 1ll * a[v + v + 1] * mult[v + v + 1]) % mod;
	}

	int get(int l, int r){
		return _get(1, 0, n, l, r);
	}

	void mul(int l, int r, int x){
		_mul(1, 0, n, l, r, x);
	}

	void out(){
		cerr << "--\n";
		for (int i = 1; i < n + n; i++){
			cerr << a[i] << " ";
			if (__builtin_popcount(i + 1) == 1)
				cerr << "\n";
		}
		for (int i = 1; i < n + n; i++){
			cerr << mult[i] << " ";
			if (__builtin_popcount(i + 1) == 1)
				cerr << "\n";
		}
		cerr << "--\n";
	}
};

vector<int> order;
vector<int> tin, tout;
vector<char> used;
vector<vector<int>> a;

void dfs(int v){
	used[v] = 1;
	tin[v] = order.size();
	order.push_back(v);
	for (auto x : a[v]){
		if (!used[x])
			dfs(x);
	}
	tout[v] = order.size();
	order.push_back(v);
}

void solve(){
	int n = nxt(), q = nxt();
	a.resize(n);
	for (int i = 0; i < n - 1; i++){
		int u = nxt() - 1, v = nxt() - 1;
		a[u].push_back(v);
		a[v].push_back(u);
	}
	vector<int> ar(n);
	for (int i = 0; i < n; i++)
		ar[i] = nxt();

	tin.assign(n, 0);
	tout.assign(n, 0);
	used.assign(n, 0);
	order.clear();
	dfs(0);

	vector<int> qw(order.size());
	for (int i = 0; i < n; i++){
		qw[tin[i]] = 1;
	}

	SegTree tree(qw);
	for (int i = 0; i < n; i++){
		tree.mul(tin[i] + 1, tout[i], ar[i]);
	}

	while (q--){
		// tree.out();
		int t = nxt();
		if (t == 1){
			int v = nxt() - 1;
			int x = nxt();
			tree.mul(tin[v] + 1, tout[v], 1ll * x * inv(ar[v]) % mod);
			ar[v] = x;
		} else {
			int v = nxt() - 1;
			printf("%d\n", tree.get(tin[v], tout[v]));
		}
	}
}

int main(){

	int T = 1;//nxt();
	while (T--){
		solve();
	}

	return 0;
}