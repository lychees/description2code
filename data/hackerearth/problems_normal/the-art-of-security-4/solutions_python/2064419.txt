# Awesome Recursion Problem.
# TODO(hapie): Learn iterative permutation generation algorithms.
# 2^n recursions.

doors = [0, 0]
powers_sum = 0
arrangement_sum = 0


def recurse(item, idx):
	if idx == len(item):
		global arrangement_sum
		arrangement_sum += 1
		return
	
	for i in range(2):
		if i == 0 and doors[0] + item[idx] > doors[1]:
			# No need to recurse for bad arrangements
			continue
		doors[i] += item[idx]
		recurse(item, idx+1)
		doors[i] -= item[idx]


N = int(raw_input())
if N == 0:
	print "%i %i" % (1, 0)
	print "We will win!"
else:
	L = map(int, raw_input().strip().split(" "))
	
	powers_sum = sum(L)
	#L.sort()
	
	# Generating lexigraphically sorted permutations in python
	from itertools import permutations
	patterns = map(list, permutations(L))
	
	for item in patterns:
		doors = [0, 0]
		recurse(item, 0)
		
	print "%i %i" % (arrangement_sum, powers_sum)
	print "We will win!" if arrangement_sum >= powers_sum else "Got no way out!"
