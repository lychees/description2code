#include<bits/stdc++.h>
using namespace std;

void computeLPSArray(string pat, int M, int *lps);
vector<int> v;
void KMPSearch(string pat, string txt)
{
    int M = pat.length();
    int N = txt.length();
 
    int lps[1001000];
    int j  = 0;  
   
    computeLPSArray(pat, M, lps);
 
    int i = 0;  // index for txt[]
    while (i < N)
    {
      if (pat[j] == txt[i])
      {
        j++;
        i++;
      }
 
      if (j == M)
      {
        v.push_back(i-j);
        j = lps[j-1];
      }
 
      // mismatch after j matches
      else if (i < N && pat[j] != txt[i])
      {
        // Do not match lps[0..lps[j-1]] characters,
        // they will match anyway
        if (j != 0)
         j = lps[j-1];
        else
         i = i+1;
      }
    }
    
}
 
void computeLPSArray(string pat, int M, int *lps)
{
    int len = 0;  // length of the previous longest prefix suffix
    int i;
 
    lps[0] = 0; // lps[0] is always 0
    i = 1;
 
    // the loop calculates lps[i] for i = 1 to M-1
    while (i < M)
    {
       if (pat[i] == pat[len])
       {
         len++;
         lps[i] = len;
         i++;
       }
       else // (pat[i] != pat[len])
       {
         if (len != 0)
         {
           // This is tricky. Consider the example 
           // AAACAAAA and i = 7.
           len = lps[len-1];
 
           // Also, note that we do not increment i here
         }
         else // if (len == 0)
         {
           lps[i] = 0;
           i++;
         }
       }
    }
}

#define MOD 1000000007
int dp[2][4][3][2][2]={0};
#define MAXN 10010
int Z[2*MAXN];//Z-array as in Z-function

int main(){
	int cur=0, prev=1;
/*	string p="", t="";
	cin>>p>>t;
	int cur=0, prev=1;
	KMPSearch(p, t);*/
	char P[MAXN], T[MAXN];
	scanf("%s",P);
	scanf("%s",T);
	/* Formation of Z-array starts where Z[i] denotes 
	   Longest Common Prefix between a Sting S, and its suffix starting at 'i'.
	   To do that we have a new string S = pattern + '$' + text
	   Rest you can read online.
	*/
	int lenP=strlen(P);
	int cc=lenP;
	int lenT=strlen(T);
	P[lenP++]='$';
	for(int i=0;i<lenT;i++) P[lenP++]=T[i];
	P[lenP]='\0';
	Z[0]=0;
	int l=0,r=0;
	for(int i=1;i<lenP;i++) {
		Z[i]=0;
		if(i<=r) Z[i]=max(Z[i-l],r-i+1);
		while(i+Z[i]<lenP and P[i+Z[i]]==P[Z[i]]) ++Z[i];
		if(i+Z[i]-1>r) l=i,r=i+Z[i]-1;
	}
	/*Z-array formed*/
//	counter=0;
	for(int i=cc+1;i<lenP;i++) if(Z[i]==cc) v.push_back(i-cc);
//	for(int i=0; i<v.size(); i++)cout<<v[i]<<" ";cout<<endl;
	for(int i=0; i<(int)v.size(); i++){
		for(int j=0; j<4; j++)
		for(int k=0; k<3; k++)
		for(int l=0; l<2; l++)
		for(int x=0; x<2; x++)
			dp[cur][j][k][l][x]=dp[prev][j][k][l][x];
		
		int two=0, three=0, five=0, seven=0;
		if(v[i]%5 == 0)five=1;
		if(v[i]%7 == 0)seven=1;
		if(v[i]%8 == 0)two = 3;
		else if(v[i]%4 == 0)two=2;
		else if(v[i]%2 == 0)two=1;
		if(v[i]%9 == 0)three = 2;
		else if(v[i]%3 == 0)three=1;
		for(int j=0; j<4; j++)
		for(int k=0; k<3; k++)
		for(int l=0; l<2; l++)
		for(int x=0; x<2; x++){
			 int ntwo = min(3, two+j);
			 int nthree = min(2, three+k);
			 int nfive = min(1, five+l);
			 int nseven = min(1, seven+x);
			 dp[cur][ntwo][nthree][nfive][nseven] = (dp[cur][ntwo][nthree][nfive][nseven]+dp[prev][j][k][l][x])%MOD; 
			 if(!j && !k && !l && !x)
			 	dp[cur][ntwo][nthree][nfive][nseven]=(dp[cur][ntwo][nthree][nfive][nseven]+1)%MOD;
		}
		cur=!cur;prev=!prev;
	}
	cout<<dp[prev][3][2][1][1]<<endl;
	return 0;
}