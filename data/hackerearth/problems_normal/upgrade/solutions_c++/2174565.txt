#include <bits/stdc++.h>
using namespace std;
int bit[100100];
inline void add(int x, int v)
{
    for(x++; x<100100; x+=x&-x)
        bit[x]+=v;
}
inline int sum(int x)
{
    int ret=0;
    for(x++; x>0; x-=x&-x)
        ret+=bit[x];
    return ret;
}
const int L=0, R=1, P=2;
struct node
{
    int sz, sum, val, rev;
    node *link[3];
} pool[100100], *nextpool=pool, *nil;
inline node* alloc(int v)
{
    node *ret=nextpool++;
    ret->sz=1;
    ret->sum=ret->val=v;
    ret->rev=0;
    ret->link[L]=ret->link[R]=ret->link[P]=nil;
    return ret;
}
inline int child(node *root, node *top=nil)
{
    if(root->link[P]==top)
        return P;
    return root->link[P]->link[R]==root;
}
inline void maintain(node *root)
{
    root->sz=1;
    root->sum=root->val;
    if(root->rev)
    {
        swap(root->link[L], root->link[R]);
        root->link[L]->rev^=1;
        root->link[R]->rev^=1;
        root->rev=0;
    }
    for(int i=0; i<2; i++) if(root->link[i]!=nil)
    {
        root->sz+=root->link[i]->sz;
        root->sum+=root->link[i]->sum;
        root->link[i]->link[P]=root;
    }
}
inline void rotate(node *root, int dir)
{
    int c=child(root);
    node *parent=root->link[P];
    node *oldroot=root;
    root=oldroot->link[dir^1];
    oldroot->link[dir^1]=root->link[dir];
    root->link[dir]=oldroot;
    maintain(oldroot);
    maintain(root);
    if(c!=P)
    {
        parent->link[c]=root;
        maintain(parent);
    }
    else
        root->link[P]=parent;
}
inline void splay_maintain(node *root)
{
    if(child(root, nil)!=P)
        splay_maintain(root->link[P]);
    maintain(root);
}
inline void splay(node *root, node *top)
{
    splay_maintain(root);
    while(child(root, top)!=P)
    {
        int c=child(root, top);
        int cc=child(root->link[P], top);
        if(cc==P)
            rotate(root->link[P], c^1);
        else if(c==cc)
        {
            rotate(root->link[P]->link[P], cc^1);
            rotate(root->link[P], c^1);
        }
        else
        {
            rotate(root->link[P], c^1);
            rotate(root->link[P], cc^1);
        }
    }
}
inline node* find(node *root, int pos)
{
    maintain(root);
    while(root->link[L]->sz+1!=pos)
    {
        if(pos>root->link[L]->sz+1)
            pos-=root->link[L]->sz+1, root=root->link[R];
        else
            root=root->link[L];
        maintain(root);
    }
    return root;
}
inline node* get(node *root, int l, int r)
{
    node *lroot=find(root, l-1);
    node *rroot=find(root, r+1);
    splay(lroot, nil);
    splay(rroot, lroot);
    return lroot;
}
int N, Q;
int A[100001];
vector<int> adj[100001];
int parent[100001];
int level[100001];
int sz[100001];
int son[100001];
int top[100001];
int newid[100001], nextid;
int oldid[100001];
void dfs(int u, int p)
{
    sz[u]=1;
    for(auto& v: adj[u]) if(v!=p)
    {
        parent[v]=u;
        level[v]=level[u]+1;
        dfs(v, u);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])
            son[u]=v;
    }
}
void dfs2(int u, int p)
{
    newid[u]=++nextid;
    oldid[newid[u]]=u;
    if(son[parent[u]]==u)
        top[u]=top[parent[u]];
    else
        top[u]=u;
    if(son[u])
        dfs2(son[u], u);
    for(auto& v: adj[u]) if(v!=p && v!=son[u])
        dfs2(v, u);
}
vector<pair<int, int>> get_path(int u, int v)
{
    vector<pair<int, int>> retL, retR;
    while(top[u]!=top[v])
    {
        if(level[top[u]]>level[top[v]])
        {
            retL.push_back(make_pair(newid[u], newid[top[u]]));
            u=parent[top[u]];
        }
        else
        {
            retR.push_back(make_pair(newid[top[v]], newid[v]));
            v=parent[top[v]];
        }
    }
    retL.push_back(make_pair(newid[u], newid[v]));
    for(int i=retR.size()-1; i>=0; i--)
        retL.push_back(retR[i]);
    return retL;
}
node* init(int l, int r)
{
    if(l>r)
        return nil;
    int m=(l+r)/2;
    node *ret=alloc(A[oldid[m]]);
    ret->link[L]=init(l, m-1);
    ret->link[R]=init(m+1, r);
    maintain(ret);
    return ret;
}
int main()
{
    nil=alloc(0);
    nil->sz=0;
    nil->link[L]=nil->link[R]=nil->link[P]=nil;
    scanf("%d%d", &N, &Q);
    for(int i=1; i<=N; i++)
        scanf("%d", A+i);
    int a, b;
    for(int i=1; i<N; i++)
    {
        scanf("%d%d", &a, &b);
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    dfs(1, 1);
    nextid=1;
    dfs2(1, 1);
    node *root=init(1, N+2);
    char op;
    while(Q--)
    {
        scanf(" %c%d%d", &op, &a, &b);
        vector<pair<int, int>> path=get_path(a, b);
        if(op=='R')
        {
            node *troot=nil;
            for(size_t i=0; i<path.size(); i++)
            {
                int l=path[i].first, r=path[i].second;
                int rl=min(l, r), rr=max(l, r);
                add(rr+1, rr-rl+1);
                int tmp=sum(rl);
                rl-=tmp;
                rr-=tmp;
                root=get(root, rl, rr);
                node *spliced=root->link[R]->link[L];
                if(l>r)
                    spliced->rev^=1;
                root->link[R]->link[L]=nil;
                maintain(root->link[R]);
                maintain(root);
                spliced->link[P]=nil;
                spliced=find(spliced, 1);
                splay(spliced, nil);
                spliced->link[L]=troot;
                troot=spliced;
                maintain(troot);
            }
            troot->rev^=1;
            for(size_t i=0; i<path.size(); i++)
            {
                int l=path[i].first, r=path[i].second;
                int rl=min(l, r), rr=max(l, r);
                int len=rr-rl+1;
                add(rr+1, -len);
                int tmp=sum(rl);
                rl-=tmp;
                root=get(root, rl, rl-1);
                node *spliced=nil;
                if(i+1==path.size())
                    spliced=troot;
                else
                {
                    troot=find(troot, len+1);
                    splay(troot, nil);
                    spliced=troot->link[L];
                    spliced->link[P]=nil;
                    troot->link[L]=nil;
                    maintain(troot);
                }
                if(l>r)
                    spliced->rev^=1;
                root->link[R]->link[L]=spliced;
                maintain(root->link[R]);
                maintain(root);
            }
        }
        else
        {
            int ans=0;
            for(auto& it: path)
            {
                int l=it.first, r=it.second;
                if(l>r)
                    swap(l, r);
                root=get(root, l, r);
                ans+=root->link[R]->link[L]->sum;
            }
            printf("%d\n", ans);
        }
    }
    return 0; 
}