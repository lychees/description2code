/*
*
*	FileName:
*	Created By: r3gz3n
*	Description:
*
*/

#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <istream>
#include <ostream>
#include <sstream>
#include <fstream>
#include <set>
#include <list>
#include <map>
#include <utility>
#include <stack>
#include <queue>
#include <cmath>
#include <iomanip>
#include <algorithm>

#define ll long long
#define ull unsigned long long
#define MP make_pair
#define PB push_back
#define FOR(i, a, b, c) for(int i = a;i < b;i += c)
#define FORI(i, a, b, c) for(int i = a;i > b;i -= c)

template<class T> inline T gcd(T a, T b) { while(b) b ^= a ^= b ^= a %= b; return a; }
template<class T> inline T pow(T a, T b, T c){ T re = 1; while(b){ if(b & 1) re = (re * a) % c; a = (a * a) % c; b >>= 1; } return re; }
template<class T> inline void read(T&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c=='-')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-'0';if(fu)x=-x;};
template<class T> inline void read(T&x,T&y){read(x);read(y);}
template<class T> inline void read(T&x,T&y,T&z){read(x);read(y);read(z);}


using namespace std;
const int MAX = 1e5 + 5;
const ll MOD = 1e9 + 7;
typedef pair <int, int> PII;
typedef pair <int, pair<int, int> > PPII;

struct node
{
    int mx;
    ll nmx;
} Ptree[8*MAX], Ntree[8*MAX];

node process(node a, node b)
{
    if(a.mx < b.mx)
        return b;
    else if(a.mx > b.mx)
        return a;
    else
    {
        a.nmx = (a.nmx + b.nmx) % MOD;
        return a;
    }
}

void update(node tree[], int parent, int start, int end, int idx, node val)
{
    if(start == end)
        tree[parent] = process(val, tree[parent]);
    else
    {
        int mid = (start + end) >> 1;
        int left = parent << 1;
        int right = left + 1;
        if(start <= idx and idx <= mid)
            update(tree, left, start, mid, idx, val);
        else
            update(tree, right, mid + 1, end, idx, val);
        tree[parent] = process(tree[left], tree[right]);
    }
}

node query(node tree[], int parent, int start, int end, int l, int r)
{
    if(r < start or end < l)
    {
        node l;
        l.mx = 0;
        l.nmx = 0;
        return l;
    }
    if(l <= start and end <= r) return tree[parent];
    int mid = (start + end) >> 1;
    int left = parent << 1;
    int right = left + 1;
    node p1 = query(tree, left, start, mid, l, r);
    node p2 = query(tree, right, mid+1, end, l, r);
    return process(p1, p2);
}

int main()
{
    //freopen("input.txt", "r", stdin);
    int n, a;
    node l;
    read(n);
    FOR(i, 0, n, 1)
    {
        read(a);
        if(a < 0)
        {
            a = -a;
            l = query(Ptree, 1, 0, 1e5, 0, a-1);
            if(l.nmx == 0) l.nmx++;
            l.mx++;
            update(Ntree, 1, 0, 1e5, a, l);
        }
        else
        {
            l = query(Ntree, 1, 0, 1e5, 0, a-1);
            if(l.nmx == 0) l.nmx++;
            l.mx++;
            update(Ptree, 1, 0, 1e5, a, l);
        }
    }
    l = process(Ptree[1], Ntree[1]);
    cout << l.mx << ' ' << l.nmx << endl;
    return 0;
}
