queue = []
N, M, Q = map(int, raw_input().split())
grid = []


def n_m_zero_array(N, M):
    visited = []
    for n in range(N):
        arr = [0]*M
        visited.append(arr)
    return visited


for n in range(N):
    arr = map(int, raw_input().split())
    grid.append(arr)

for q in range(Q):
    count = 0
    X, Y, D = map(int, raw_input().split())
    visited = n_m_zero_array(N, M)
    count_set = set()
    queue.append((X-1, Y-1))
    while (len(queue) != 0):

        # incrementing count of black

        ele = queue[0]
        x, y = ele
        visited[x][y] = 1
        del queue[0]

        # get adjacent elements
        if x-1 >= 0 and abs(grid[x-1][y]-grid[x][y]) <= D:
            if visited[x-1][y] != 1:
                queue.append((x-1, y))
                count += 1
                count_set.add((x-1, y))
        if x+1 < N and abs(grid[x+1][y]-grid[x][y]) <= D:
            if visited[x+1][y] != 1:
                queue.append((x+1, y))
                count += 1
                count_set.add((x+1, y))

        if y-1 >= 0 and abs(grid[x][y-1]-grid[x][y]) <= D:
            if visited[x][y-1] != 1:
                queue.append((x, y-1))
                count += 1
                count_set.add((x, y-1))
        if y+1 < M and abs(grid[x][y+1]-grid[x][y]) <= D:
            if visited[x][y+1] != 1:
                queue.append((x, y+1))
                count += 1
                count_set.add((x, y+1))

    print len(count_set)+1
