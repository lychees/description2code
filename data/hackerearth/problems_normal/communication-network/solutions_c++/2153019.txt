#include <bits/stdc++.h>

#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)
#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)
#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)
#define EACH(it,a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)

#define DEBUG(x) { cout << #x << " = "; cout << (x) << endl; }
#define PR(a,n) { cout << #a << " = "; FOR(_,1,n) cout << a[_] << ' '; cout << endl; }
#define PR0(a,n) { cout << #a << " = "; REP(_,n) cout << a[_] << ' '; cout << endl; }

#define sqr(x) ((x) * (x))
#define ll long long
using namespace std;

const int MAX_TOWER = 60;
const int MN = 100111;
ll f[2][MN], a[MN];
int n, k;

struct Fraction {
    ll x, y;

    Fraction(ll _x, ll _y) {
        ll g = __gcd(_x, _y);
        x = _x / g;
        y = _y / g;

        if (y < 0) x = -x, y = -y;
    }

    Fraction(ll _x = 0) {
        x = _x;
        y = 1;
    }
};

bool operator <= (const Fraction& a, const Fraction& b) {
    return a.x*b.y <= a.y*b.x;
}

struct Hull {
    ll a[MN], b[MN];
    Fraction x[MN];
    int head, tail;

    Hull(): head(1), tail(0) {}

    ll get(ll xQuery) {
        if (head > tail) return 0;
        while (head < tail && x[head + 1] <= Fraction(xQuery)) head++;
        x[head] = xQuery;
        return a[head] * xQuery + b[head];
    }

    void add(ll aNew, ll bNew) {
        Fraction xNew(-1e6);
        while (head <= tail) {
            if (aNew == a[tail]) return;
            xNew = Fraction(b[tail] - bNew, aNew - a[tail]);
            if (head == tail || x[tail] <= xNew) break;
            tail--;
        }
        a[++tail] = aNew;
        b[tail] = bNew;
        x[tail] = xNew;
    }
};

int main() {
    ios :: sync_with_stdio(false);
    while (cin >> n >> k) {
        FOR(i,1,n) cin >> a[i];
        ll k0 = k;

        if (k > MAX_TOWER) k = MAX_TOWER;
        if (k > n) k = n;

        f[1][1] = k0*k0*a[1];
//        DEBUG(f[1][1]);
        ll res = 1e18;
        FOR(x,2,k) {
            Hull hull;
            int turn = x % 2;
            FOR(i,x-1,n) {
                if (i >= x) {
                    f[turn][i] = hull.get(i) + k0*k0*a[i]+i*(ll)i;
                }
                if (x-1 == 1) {
                    if (i == 1) {
                        hull.add(-2*i, f[1-turn][i] + i*(ll)i);
                    }
                }
                else {
                    if (i < n) {
                        hull.add(-2*i, f[1-turn][i] + i*(ll)i);
                    }
                }
            }
            res = min(res, f[x % 2][n]);
//            PR(f[x], n);
        }
        cout << res << endl;
    }
}

