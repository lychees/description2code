#pragma comment(linker, "/STACK:102400000,102400000")
#include <bits/stdc++.h>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define inf 1000000007
#define mod 1000000007
#define x first
#define y second
#define pi acos(-1.0)
#define DBG(x) cerr<<(#x)<<"="<<x<<"\n";
//#define debug(...) fprintf(stderr,__VA_ARGS__)
#define debug(...)
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ull unsigned long long
#define ll long long
#define N 100005

template <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}
template <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}

inline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;}

ll cal(ll x){return x*(x+1)/2;}
struct node{
    ll l,r,ls,rs,all,len;
    node operator +(const node&a){
        node b;
        b.l=l,b.r=a.r;
        b.ls=ls,b.rs=a.rs;
        b.all=all+a.all;
        b.len=len+a.len;
        if(r!=a.l)return b;
        b.all=b.all-cal(rs)-cal(a.ls)+cal(rs+a.ls);
        if(ls==len)b.ls+=a.ls;
        if(a.rs==a.len)b.rs+=rs;
        return b;
    }
}t[N<<2];
int c[N<<2];
void upd(int p,int l,int r,int v){
    t[p].l=t[p].r=v;
    t[p].ls=t[p].rs=t[p].len=r-l+1;
    t[p].all=cal(r-l+1);
    c[p]=v;
    return;
}
void down(int p,int l,int r){
    if(c[p]){
        int m=(l+r)>>1;
        upd(p<<1,l,m,c[p]);
        upd(p<<1|1,m+1,r,c[p]);
        c[p]=0;
    }
}
void upd(int p,int l,int r,int x,int y,int v){
    if(l==x&&r==y){
        upd(p,l,r,v);return;
    }
    int m=(l+r)>>1;
    down(p,l,r);
    if(y<=m)upd(p<<1,l,m,x,y,v);
    else if(x>m)upd(p<<1|1,m+1,r,x,y,v);
    else{   
        upd(p<<1,l,m,x,m,v);
        upd(p<<1|1,m+1,r,m+1,y,v);
    }
    t[p]=t[p<<1]+t[p<<1|1];
}
node query(int p,int l,int r,int x,int y){
    if(l==x&&r==y)return t[p];
    int m=(l+r)>>1;
    down(p,l,r);
    node a,b;
    if(y<=m)a=query(p<<1,l,m,x,y);
    else if(x>m)a=query(p<<1|1,m+1,r,x,y);
    else{
        a=query(p<<1,l,m,x,m);
        b=query(p<<1|1,m+1,r,m+1,y);
        a=a+b;
    }
    t[p]=t[p<<1]+t[p<<1|1];
    return a;
}
int a[N];
void build(int p,int l,int r){
    c[p]=0;
    if(l==r){
        upd(p,l,r,a[l]);c[p]=0;return;
    }
    int m=(l+r)>>1;
    build(p<<1,l,m);
    build(p<<1|1,m+1,r);
    t[p]=t[p<<1]+t[p<<1|1];
}
int main(){
    //ios_base::sync_with_stdio(0);
    //cout<<fixed<<setprecision(18);
    int T,i,j,k,m,n;
    scanf("%d%d",&n,&m);
    for(i=0;i<n;i++)scanf("%d",&a[i]);
    build(1,0,n-1);
    while(m--){
        scanf("%d%d%d",&k,&i,&j);i--,j--;
        if(k==0){
            scanf("%d",&k);
            upd(1,0,n-1,i,j,k);
        }
        else{
            node ans=query(1,0,n-1,i,j);
            printf("%lld\n",ans.all);
        }
    }
    return 0;
}