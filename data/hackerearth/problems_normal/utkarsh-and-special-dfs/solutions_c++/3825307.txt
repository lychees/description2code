#include <bits/stdc++.h>

using namespace std;

#define sd(x) scanf("%d", &x)
#define boost ios_base::sync_with_stdio(false);
#define mp make_pair
#define pb push_back
#define all(a) a.begin(), a.end()
#define f first
#define s second

typedef pair<int, int> pii;
typedef long long ll;

const int mod = 1000000007;
const int inf = 50000000;
const int maxn = 100010;

int n, q, tim = 0;
int arr[maxn], vis[maxn], strt[maxn], en[maxn];
int st[maxn*10], lazy[maxn*10];
vector<int> dfstree, adj[maxn];

int mul(int x, int y)
{
	ll ret = x;
	ret = (ret*y)%mod;
	return ret;
}

int add(int x, int y)
{
	int ret = (x+y)%mod;
	return ret;
}

ll modpow(ll a, ll b)
{
	ll x=1, y=a;
	while(b){
		if(b&1)
			x = (x*y)%mod;
		y = (y*y)%mod;
		b/=2;
	}
	return x;
}

void dfs(int cur, int p, int val)
{
	strt[cur] = (int)dfstree.size();
	dfstree.pb(cur);
	vis[cur] = val;
	int nxtval = mul(val, arr[cur]);
	for(int it:adj[cur]){
		if(it!=p)
			dfs(it, cur, nxtval);
	}
	en[cur] = (int)dfstree.size() - 1;
}

void init(int s, int e, int node)
{
	if(s==e){
		st[node] = vis[dfstree[s]];
		lazy[node] = 1;
		return;
	}
	int mid, lc, rc;
	mid = (s+e)>>1;
	lc = 2*node + 1;
	rc = lc + 1;
	init(s, mid, lc);
	init(mid+1, e, rc);
	st[node] = add(st[lc], st[rc]);
	lazy[node] = 1;
}

void propagate_down(int s, int e, int node)
{
	st[node] = mul(st[node], lazy[node]);
	if(s!=e){
		int lc = 2*node + 1;
		int rc = lc + 1;
		lazy[lc] = mul(lazy[lc], lazy[node]);
		lazy[rc] = mul(lazy[rc], lazy[node]);
	}
	lazy[node] = 1;
}

int query(int s, int e, int qs, int qe, int node)
{
	propagate_down(s, e, node);
	if(s>e || s>qe || qs>e)
		return 0;
	if(s>=qs && qe>=e)
		return st[node];
	int mid, lc, rc;
	mid = (s+e)>>1;
	lc = 2*node + 1;
	rc = lc + 1;
	return add(query(s, mid, qs, qe, lc), query(mid+1, e, qs, qe, rc));
}

void update(int s, int e, int qs, int qe, int node, int val)
{
	propagate_down(s, e, node);
	if(s>e || s>qe || qs>e)
		return;
	int mid, lc, rc;
	mid = (s+e)>>1;
	lc = 2*node + 1;
	rc = lc + 1;
	if(s>=qs && qe>=e){
		st[node] = mul(st[node], val);
		if(s!=e){
			lazy[lc] = mul(lazy[lc], val);
			lazy[rc] = mul(lazy[rc], val);
		}
		return;
	}
	update(s, mid, qs, qe, lc, val);
	update(mid+1, e, qs, qe, rc, val);
	st[node] = add(st[lc], st[rc]);
}

int main()
{
	//freopen("i.txt", "r", stdin);
	//freopen("o.txt", "w", stdout);
	int i, u, v, x, t, rs, re, ans, val;
	scanf("%d%d", &n, &q);
	for(i=1; i<n; i++){
		scanf("%d%d", &u, &v);
		adj[u].pb(v);
		adj[v].pb(u);
	}
	for(i=1; i<=n; i++)
		scanf("%d", &arr[i]);
	dfs(1, -1, 1);
	//for(int it:dfstree)
	//	cout << it << " ";
	//cout << "\n";
	//for(i=1; i<=n; i++)
	//	cout << i << " " << strt[i] << " " << en[i] << " " << vis[i] << "\n";
	init(0, dfstree.size()-1, 0);
	//for(i=0; i<9; i++)
	//	cout << "st " << i << " " << st[i] << "\n"; 
	while(q--){
		scanf("%d%d", &t, &u);
		rs = strt[u];
		re = en[u];
		if(t==1){
			scanf("%d", &x);
			val = modpow(arr[u], mod-2);
			update(0, dfstree.size()-1, rs+1, re, 0, val);
			update(0, dfstree.size()-1, rs+1, re, 0, x);
			arr[u] = x;
		}
		else{
			ans = query(0, dfstree.size()-1, rs, re, 0);
			printf("%d\n", ans);
		}
	}
	return 0;
}
