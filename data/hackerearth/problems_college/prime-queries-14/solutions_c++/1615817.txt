#include <iostream>
#include <cassert>
#include <algorithm>
using namespace std;

int MAX=100001;
int MIN=-1;
class node
{
	public:
	int ans;
};

bool p[1000001];

static int a[1000001];
int prime(int n)
{
	int i=2;
	for (i=2;i<=n;i++) a[i]=0;
	p[1]=false;
	i=2;
	while (i<=n)
	{
		if (a[i]==0)
		{
			p[i]=true;
			if (i>10000)
			{
				i+=1;
				continue;
			}			
			int j=i*i;
			while (j<=n)
			{
				a[j]=1;
				j+=i;
			}
		}
		else
		{
			p[i]=false;
		}
		i+=1;
	}
}
node f(node left,node right)
{
/*
Function specific to the problem .
*/
	node aa;
	aa.ans=max(left.ans,right.ans);
	return aa;
}

node maketree(int a[],node tree[],int index,int low,int high)
{
/*
Initialziation of a tree
index=Current x
[low high]=current range
*/
	assert(high>=low);
	if (low==high)
	{
		if (p[a[low]]==1)
			tree[index].ans=a[low];
		else
			tree[index].ans=-1;
		return tree[index];
	}
	else
	{
		int mid=(low+high)/2;
		node left=maketree(a,tree,2*index+1,low,mid);
		node right=maketree(a,tree,2*index+2,mid+1,high);
		tree[index]=f(left,right);
		return tree[index];
	}
}

node updatetree(node tree[],int index,int low,int high,int x,int newv,int oldv)
{
/*
To update the node in a tree. Node at index x in updated to newvalue from oldvalue.
index=Current x
[low high]=current range
*/
	assert(high>=low);
	if (low==high)
	{
		if (p[newv]==1)
			tree[index].ans=newv;
		else
			tree[index].ans=-1;
		return tree[index];
	}
	else
	{
		int mid=(low+high)/2;
		if (x<=mid)
		{
			node left=updatetree(tree,2*index+1,low,mid,x,newv,oldv);
			node right=tree[2*index+2];
			tree[index]=f(left,right);
			return tree[index];
		}
		else
		{
			node left=tree[2*index+1];
			node right=updatetree(tree,2*index+2,mid+1,high,x,newv,oldv);
			tree[index]=f(left,right);
			return tree[index];
		}
	}
}

node searchtree(node tree[],int low,int high,int x,int y,int index)
{
/*
To search in a segment tree in the range [x-y], while the current range is [low-high] and the current index index.
*/
	assert(y>=low);
	assert(x<=high);
	if (low>=x && high<=y)
		return tree[index];
	else
	{
		int mid=(low+high)/2;
		if (mid>=y)
		{
			return searchtree(tree,low,mid,x,y,2*index+1);
		}
		else if (mid<x)
		{
			return searchtree(tree,mid+1,high,x,y,2*index+2);
		}
		else
		{
			node left=searchtree(tree,low,mid,x,y,2*index+1);
			node right=searchtree(tree,mid+1,high,x,y,2*index+2);
			return f(left,right);;
		}
	}
}
int main()
{
	prime(1000000);
	int a[MAX];
	static node tree[400001],temp;
	int i,n,m,x,y;
	int t;
	cin>>n;
	cin>>m;
	for (i=0;i<n;i++)
		cin>>a[i];
	maketree(a,tree,0,0,n-1);
	
	while (m--)
	{
		cin>>t>>x>>y;
		x--;
		if (t==1)
		{
			y--;
			temp=searchtree(tree,0,n-1,x,y,0);
			cout<<temp.ans<<endl;
		}
		else
		{
			updatetree(tree,0,0,n-1,x,y,a[x]);
			a[x]=y;
		}
	}
	return 0;
}