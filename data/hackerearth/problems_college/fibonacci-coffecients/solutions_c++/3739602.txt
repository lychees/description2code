#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll mod;
int arr[1000010];
long long tree[2][2][4000010];
long long ret[2][2];
void fibonacci(int n)
{
	ret[0][0]=1;
	ret[0][1]=0;
	ret[1][0]=0;
	ret[1][1]=1;
    long long fib[2][2]= {{0,1},{1,1}},tmp[2][2]= {{0,0},{0,0}};
    int i,j,k;
    while(n)
    {
        if(n&1)
        {
            memset(tmp,0,sizeof tmp);
            for(i=0; i<2; i++) for(j=0; j<2; j++) for(k=0; k<2; k++)
                        tmp[i][j]=(tmp[i][j]+ret[i][k]*fib[k][j])%mod;
            for(i=0; i<2; i++) for(j=0; j<2; j++) ret[i][j]=tmp[i][j];
        }
        memset(tmp,0,sizeof tmp);
        for(i=0; i<2; i++) for(j=0; j<2; j++) for(k=0; k<2; k++)
                    tmp[i][j]=(tmp[i][j]+fib[i][k]*fib[k][j])%mod;
        for(i=0; i<2; i++) for(j=0; j<2; j++) fib[i][j]=tmp[i][j];
        n/=2;
    }
    
}
 
 
 
void build_tree(int node, int a, int b) {
    if(a > b) return;
  	
  	if(a == b) {
  		tree[0][0][node]=0;
  		tree[0][1][node]=arr[a];
  		tree[1][0][node]=arr[a];
  		tree[1][1][node]=arr[a];
		return;
	}
	
	build_tree(node*2, a, (a+b)/2); // Init left child
	build_tree(node*2+1, 1+(a+b)/2, b); // Init right child
	
	fibonacci((a+b)/2-a+1);
	tree[0][0][node] = (tree[0][0][node*2]+tree[0][0][node*2+1]*ret[0][0]+tree[0][1][node*2+1]*ret[1][0])%mod;
	tree[0][1][node] = (tree[0][1][node*2]+tree[0][0][node*2+1]*ret[0][1]+tree[0][1][node*2+1]*ret[1][1])%mod;
	tree[1][0][node] = (tree[1][0][node*2]+tree[1][0][node*2+1]*ret[0][0]+tree[1][1][node*2+1]*ret[1][0])%mod;
	tree[1][1][node] = (tree[1][1][node*2]+tree[1][0][node*2+1]*ret[0][1]+tree[1][1][node*2+1]*ret[1][1])%mod;
	//cout<<tree[0][0][node]<<" "<<tree[0][1][node]<<" "<<tree[1][0][node]<<" "<<tree[1][1][node]<<endl;
	
}
 
void update_tree(int node, int a, int b, int i, int j, long long value) {
    
	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return;
    
  	if(a == b) { // Leaf node
    		tree[0][0][node]=0;
  			tree[0][1][node]=value;
  			tree[1][0][node]=value;
  			tree[1][1][node]=value;
    		return;
	}
 
	update_tree(node*2, a, (a+b)/2, i, j, value); // Updating left child
	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value); // Updating right child
	
	fibonacci((a+b)/2-a+1);
	tree[0][0][node] = (tree[0][0][node*2]+tree[0][0][node*2+1]*ret[0][0]+tree[0][1][node*2+1]*ret[1][0])%mod;
	tree[0][1][node] = (tree[0][1][node*2]+tree[0][0][node*2+1]*ret[0][1]+tree[0][1][node*2+1]*ret[1][1])%mod;
	tree[1][0][node] = (tree[1][0][node*2]+tree[1][0][node*2+1]*ret[0][0]+tree[1][1][node*2+1]*ret[1][0])%mod;
	tree[1][1][node] = (tree[1][1][node*2]+tree[1][0][node*2+1]*ret[0][1]+tree[1][1][node*2+1]*ret[1][1])%mod;
	
	
}
 
vector<long long> query_tree(int node, int a, int b, int i, int j) {
	
	if(a > b || a > j || b < i){
		vector<long long> vt;
		vt.push_back(0);
		vt.push_back(0);
		vt.push_back(0);
		vt.push_back(0);
		return vt;
	}
 
	if(a >= i && b <= j) // Current segment is totally within range [i, j]
	{
		vector<long long> vt;
		vt.push_back(tree[0][0][node]);
		vt.push_back(tree[0][1][node]);
		vt.push_back(tree[1][0][node]);
		vt.push_back(tree[1][1][node]);
		return vt;
	}
	vector<long long > q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child
	vector<long long >  q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); // Query right child
	vector<long long> res;
	
	fibonacci(max(0,(a+b)/2-max(a,i)+1));
	
	
	res.push_back((q1[0]+q2[0]*ret[0][0]+q2[1]*ret[1][0])%mod);
	res.push_back((q1[1]+q2[0]*ret[0][1]+q2[1]*ret[1][1])%mod);
	res.push_back((q1[2]+q2[2]*ret[0][0]+q2[3]*ret[1][0])%mod);
	res.push_back((q1[3]+q2[2]*ret[0][1]+q2[3]*ret[1][1])%mod);
	
	
	return res;
}
 
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n,m;
	
	cin>>n>>m>>mod;
	for(int i=0;i<n;i++){
		cin>>arr[i];
	}
	build_tree(1, 0, n-1);
	
	for(int i=0;i<m;i++){
		int c;
		cin>>c;
		ll a,b;
		cin>>a>>b;
		if(c==2){
			cout<<query_tree(1,0,n-1,a-1,b-1)[1]<<endl;
		}
		else update_tree(1,0,n-1,a-1,a-1,b);
	}
 
} 