#include <bits/stdc++.h>

using namespace std;
#define initial 1
#define waiting 2
#define visited 3
#define mp(a, b) make_pair(a, b)

int n, num_edges, weight;
vector <int> vec[100002];
int key[100002];
int state[100002];
int parent[100002];
int toPrint[100002] = {};
map<pair<int, int> , int> w;
int cnt = 0;
priority_queue<pair<int,int>, vector<pair<int,int> >, greater<pair<int,int> > >pq; ///min heap
pair<int, int> pair_v;
#define pb push_back

using namespace std;

void create_graph() {
    int i, o, d;
    scanf("%d", &n); /// number of vertices if no of vertices if  10 then vertex are ** 1 2 3 4 5 6 7 8 9
    scanf("%d", &num_edges); /// enter no of edges of you want to enter
    int dub = num_edges;
    for(i = 0; i < num_edges; i++) {
        scanf("%d %d", &o, &d);


        vec[o].pb(d);
        vec[d].pb(o);
        w[mp(d, o)] = dub;
        w[mp(o, d)] = dub;



        //output[mp(d, o)] = 0;
       // output[mp(o, d)] = dub;
      //  vec[d].pb(o); /// undirected
        dub--;

    }


}

void primsMst() {
    int v, j;

    for(v = 1; v <= n; v++) {
        state[v] = initial;
        key[v] = INT_MAX;
    }


   // cout << "starting vertex ";
   // cin >> v;

    key[1] = 0;
    pq.push(mp(key[1], 1));
    state[1] = waiting;

    //cout <<"mst is \n";
    int c = 1;
    while(!pq.empty()) {

        pair_v = pq.top();
        v = pair_v.second;
        pq.pop();

        if(state[v] == initial) {
           // cout <<" "<< v <<" "<<parent[v]<<endl; /// a vertex can be present in queue for more than one time

            toPrint[w[mp(v, parent[v])]] = 1;
            cnt++;
        }
        state[v] = visited;


        for(int i = 0; i < vec[v].size(); i++) {
            int nebr = vec[v][i];
            if(state[nebr] == initial && w[mp(v, nebr)] < key[nebr]) { /// vec[v][i] represent here the particular vertex value that is i th neighbour
                                                                        /// of v in the graph
                key[nebr] = w[mp(v, nebr)];
                pq.push(mp( key[nebr], nebr) );
                parent[nebr] = v;
//state[nebr] = waiting; ///proble was when you are assigning nodes in queue to be waiting you are not checking them for even lesser distance poosbile now the solution could be either for checking minimum distance you either don't make queue nodes waiting let them me initial they can made pe permanent only when they are out of queue and their state is visited 2) secoond solutoin could be when checing for min distance possbiltiy add a cond eihter node == waiting or inital (!= visited) both the soulution will work

            }
        }

    }


}

int main() {
    create_graph();
    primsMst();
    //cout <<endl;
    /*for(int v = 1; v <= n; v++) {
        cout << key[v] <<endl;
    }*/
    cout << num_edges - cnt<<endl;
    for(int i = num_edges; i >= 1; i--) {
        //cout <<"entere\n";
       // cout << toPrint[i]<<endl;
        if(toPrint[i] == 0) {
            cout <<(num_edges + 1) - i <<endl;
        }
    }
}

/*
7
16
1 2 8
1 3 2
3 1 5
1 4 7
3 4 4
3 7 3
7 3 6
7 4 3
4 5 9
7 5 4
5 1 4
8 7 5
5 8 8
5 6 5
2 6 16
8 6 2

6
9
1 2 4 2 3 8 3 6 2
2 5 11
1 5 8
5 6 7
4 6 6
3 4 4
4 5 1

7
11
1 2 1
1 4 2
2 4 10
2 3 9
4 3 11
4 5 4
3 5 5
3 6 6
5 6 8
5 7 9
6 7 2


*/
