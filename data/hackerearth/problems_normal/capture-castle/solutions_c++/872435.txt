#include <algorithm>
#include <assert.h>
#include <bitset>
#include <cmath>
#include <ctype.h>
#include <deque>
#include <fstream>
#include <functional>
#include <iostream>
#include <list>
#include <limits.h>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <stdio.h>
#include <string>
#include <string.h>
#include <time.h>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;
typedef pair<int,int> ipair;
typedef vector<int> vi;

#define MAX 1000000007
#define F first
#define S second
#define SZ size()
#define BG begin()
#define EN end()
#define MP(a,b) make_pair(a,b)
#define PB(a) push_back(a)
#define REP(i,a,b) for(int i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)
#define rev(i,n) for(int i=n;i>=0;i--)
#define take(ar,n) int ar[n]; rep(i,n) cin>>ar[i]
#define MS(a,b) memset(a,b,sizeof(a))
int ar[1000+7][1000+7],R[1000+7][1000+7];
int dx[]={1,0,-1,0},dy[]={0,-1,0,1};
int vis[1000+7][1000+7];
bool valid(int a,int b,int n,int m)
{
    if((a>=0 && a<n) && (b>=0 && b<m)) return true;
    else return false;
}
void fill(int n,int m)
{
    rep(i,n) rep(j,m) R[i][j]=INT_MAX;
}
void bfs(int n,int m,int x,int y)
{
    list<ipair>queue;
    queue.PB(MP(--x,--y));
    //vis[x][y]=4;
    fill(n,m);
    R[x][y]=ar[x][y];
    while(!queue.empty())
    {
        ipair s=queue.front();
        queue.pop_front();
        for(int i=0;i<4;i++)
        {
            if(valid(s.F+dx[i],s.S+dy[i],n,m) && R[s.F][s.S]+ar[s.F+dx[i]][s.S+dy[i]]<R[s.F+dx[i]][s.S+dy[i]])
            {
                R[s.F+dx[i]][s.S+dy[i]]=R[s.F][s.S]+ar[s.F+dx[i]][s.S+dy[i]];
                queue.PB(MP(s.F+dx[i],s.S+dy[i]));
            }
        }
    }
}
int main()
{
    int t;
	scanf("%d",&t);
	while(t--)
    {
        int n,m;
        cin>>n>>m;
        rep(i,n) rep(j,m) cin>>ar[i][j];
        int x,y,t;
        cin>>x>>y>>t;
        bfs(n,m,x,y);
        if(R[0][0]<=t) printf("YES\n%d\n",t-R[0][0]);
        else printf("NO\n");
    }
    return 0;
}
