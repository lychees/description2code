//Done by: gohan95

#include<bits/stdc++.h>

using namespace std;

//Taken from "competitive programming" by Steven Halim
// Shortcuts for "common" data types in contests
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef vector<pii> vii;
typedef set<int> si;
typedef map<string, int> msi;
// To simplify repetitions/loops, Note: define your loop style and stick with it!
#define REP(i, a, b) \
for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local!
#define TRvi(c, it) \
for (vi::iterator it = (c).begin(); it != (c).end(); it++)
#define TRvii(c, it) \
for (vii::iterator it = (c).begin(); it != (c).end(); it++)
#define TRmsi(c, it) \
for (msi::iterator it = (c).begin(); it != (c).end(); it++)

#define s(x) scanf("%d", &x)
#define sl(x) scanf("%lld", &x)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define set0(a) memset(a, 0, sizeof(a))
#define setdp(a) memset(a, -1, sizeof(a))
#define setinf(a) memset(a, 127, sizeof(a))
#define INF 2000000000
#define MOD 1000000007
#define gc getchar_unlocked

#define N 500005

vector <int> adj[N];
int sz[N], lvl[N], tin[N], tout[N], tim, chh[N], has[N], chid[N], chno, num, p[21][N], kk;
ll bit[N];

inline void scanint(int &x){register int c=0;x=0;int flag=0;for(;((c!=45)&&(c<48||c>57));c=gc());
for(;((c==45)||(c>47&&c<58));c=gc()){if(c==45)flag=1;else x=(x<<1)+(x<<3)+c-48;}if(flag)x=-x;}

void update(int idx, int val)
{
    while (idx < kk) {
        bit[idx] += val;
        idx += (idx & -idx);
    }
}

ll query(int idx)
{
    ll retval = 0;

    while (idx > 0) {
        retval += bit[idx];
        idx -= (idx & -idx);
    }

    return retval;
}

void HLD(int cur, int pre)
{
    if (chh[chno] == -1)
        chh[chno] = cur;

    chid[cur] = chno;
    has[cur] = num++;

    int maxval = -1, id = -1;

    TRvi(adj[cur], it) {
        if (*it != pre) {
            if (sz[*it] > maxval) {
                maxval = sz[*it];
                id = *it;
            }
        }
    }

    if (id != -1) {
        HLD(id, cur);
    }

    TRvi(adj[cur], it) {
        if (*it != pre && *it != id) {
            chno++;
            HLD(*it, cur);
        }
    }
}

void dfs(int cur, int pre)
{
    tin[cur] = tim++;

    sz[cur] = 1;
    TRvi(adj[cur], it) {
        if (*it != pre) {
            lvl[*it] = lvl[cur] + 1;
            p[0][*it] = cur;

            dfs(*it, cur);

            sz[cur] += sz[*it];
        }
    }

    tout[cur] = tim++;
}

bool anc(int u, int v)
{
    if (tin[u] <= tin[v] && tout[u] >= tout[v])
        return 1;

    return 0;
}

int LCA(int u, int v)
{
    if (lvl[u] > lvl[v])
        swap(u, v);

    if (anc(u, v))
        return u;

    int i, j;

    for (i = 20; i >= 0; i--) {
        if (!anc(p[i][u], v))
            u = p[i][u];
    }

    return p[0][u];
}

void upd_hld(int u, int v, int val)
{
    int uch, vch = chid[v];

    while (1) {
        uch = chid[u];

        if (uch == vch) {
            update(has[v], val);
            update(has[u] + 1, -val);

            //cout << has[v] << " " << has[u] + 1 << endl;

            return ;
        }

        update(has[chh[uch]], val);
        update(has[u] + 1, -val);

        //cout << has[chh[uch]] << " " << has[u] + 1 << endl;
        u = p[0][chh[uch]];
    }
}

void upd_main(int u, int v)
{
    int lc = LCA(u, v);

    //cout << u << " " << v << " " << lc << endl;

    upd_hld(u, lc, 1);
    upd_hld(v, lc, 1);
    upd_hld(lc, lc, -1);
}

ll query_main(int u)
{
    return query(has[u]);
}

int main()
{
    int n, qu, x, y, type;

    scanint(n);
    scanint(qu);

    kk = n + 1;

    REP (i, 1, n - 1) {
        scanint(x);
        scanint(y);

        adj[x].pb(y);
        adj[y].pb(x);
    }

    lvl[1] = 0;
    p[0][1] = 1;
    dfs(1, -1);

    REP (j, 1, 20) {
        REP (i, 1, n) {
            p[j][i] = p[j - 1][p[j - 1][i]];
        }
    }

    setdp(chh);
    num = 1;
    chno = 1;
    HLD(1, -1);

    /*REP (i, 1, n) {
        cout << i << " " << has[i] << " " << chid[i] << " " << chh[chid[i]] << endl;
    }*/

    while (qu--) {
        scanint(type);
        scanint(x);

        if (type == 1) {
            scanint(y);

            upd_main(x, y);
        }

        else {
            printf("%lld\n", query_main(x));
        }
    }

    return 0;
}
