#include <bits/stdc++.h>

using namespace std;

#define rep(i, a, b) for(int i = (a); i < int(b); ++i)
#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)
#define trav(it, v) for(typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it)
#define all(v) (v).begin(), (v).end()

typedef double fl;
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<pii> vpi;

ll N, K;
int a[100005];
// used, position
//map<int, ll> dp[200005];
ll dp[2][200005];
bool read=0, write=1;

struct Node{
	Node* parent;
	Node* child;
	int ind;
	bool alive;

	Node(int _ind){
		ind=_ind;
		alive=1;
		parent=NULL;
		child=NULL;
	}

	void remove(){
		child->parent=parent;
		parent->child=child;
		alive=0;
	}
};

queue<Node*> dying[100005];
ll ans=1000000000000000000LL;

void addDying(Node* node, ll minVal){
	ll pos=node->ind;
	ll i=node->child->ind;
	ll val=dp[read][pos];
	ll otherval=dp[read][i];
	ll change=(otherval-val+i*i-pos*pos+4*(i-pos))/(2*(i-pos))-1;
	//change=max(change, minVal);
	if(change < minVal)
		change=minVal;
	assert(pos*pos-i*i+2*change*(i-pos) >= otherval-val);
	//assert(pos*pos-i*i+2*(change-1)*(i-pos) <= otherval-val);
	if(change <= N)
		dying[change].push(node);
}

int main(){
	cin >> N >> K;
	rep(i,0,N){
		scanf("%d", a+i);
	}
	/*if(1024*K*K+((N-1)*(N-1))/2 > (N-1)*(N-1)){
		printf("%lld\n", K*K*(a[0]+a[N-1])+(N-1)*(N-1));
		return 0;
	}*/
	rep(i,0,N){
		dp[write][i]=1000000000000000000LL;
	}
	dp[write][0]=K*K*a[0];
	ll k=N/(K*1024);
	if(k < 2)
		k=2;
	if(k > K)
		k=K;
	ll upperBound=0;
	ll pre=0;
	for(int i=0; i < k; ++i){
		ll pos=(i*(N-1))/(k-1);
		upperBound += K*K*a[pos];
		ll dx=pos-pre;
		upperBound += dx*dx;
		pre=pos;
	}
	ans=min(ans, upperBound);
	for(int used=2; used <= K && used*K*K*1024 < ans; ++used){
		read^=1;
		write^=1;
		Node* root = new Node(-1);
		Node* leaf = root;
		rep(i,0,N){
			Node* newnode = new Node(i);
			newnode->parent=leaf;
			leaf->child=newnode;
			if(leaf->ind != -1)
				addDying(leaf, i);
			leaf=newnode;
			while(!dying[i].empty()){
				Node* par=dying[i].front()->parent;
				bool alive=dying[i].front()->alive;
				if(alive)
					dying[i].front()->remove();
				dying[i].pop();
				if(!alive)
					continue;
				if(par->ind == -1)
					continue;
				addDying(par, i);
			}
			int bestind=root->child->ind;
			ll val=dp[read][bestind];
			ll dx=i-bestind;
			dp[write][i]=val+dx*dx+a[i]*K*K;
			if(dp[write][i] > ans)
				dp[write][i]=ans;
			if(i == N-1)
				ans=min(ans, dp[write][i]);
		}
		/*Node* curNode=root;
		while(curNode != NULL){
			Node* nextNode=curNode->child;
			delete curNode;
			curNode=nextNode;
		}*/
		/*int start=0;
		for(auto it=dp[used].begin(); it != dp[used].end(); ++it){
			int pos=it->first;
			ll possq=pos;
			possq *= pos;
			ll val=it->second;
			if(pos == N-1)
				ans=min(ans, val);
			if(dp[used-1].count(pos) && dp[used-1][pos] <= val)
				continue;
			ll stop=N;
			start=max(start, pos+1);
			for(ll i=pos+1; i <= stop; ++i){
				ll dx=i-pos;
				ll newVal=val+K*K*a[i]+dx*dx;
				if(!dp[used+1].count(i) || newVal < dp[used+1][i])
					dp[used+1][i]=newVal;
				if(dp[used].count(i))
				{
					ll otherval=dp[used][i];
					ll change=(otherval-val+i*i-possq)/(2*(i-pos));
					stop=min(stop, change+1);
				}
			}
			start=stop-1;
		}*/
	}
	cout << ans << endl;
}
