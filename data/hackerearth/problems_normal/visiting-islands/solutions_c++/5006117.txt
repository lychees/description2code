/*Program created by Shantanu Tripathi(SHAAN)
   IPG_2014079
   ABV-IIITM,Gwalior */
#include<bits/stdc++.h>
using namespace std;
#define _ ios::sync_with_stdio(false); cin.tie(0);
#define T() int t; cin>>t; while(t--)
#define f0(i,n) for(int i=0;i<n;i++)
#define f1(i,n) for(int i=1;i<=n;i++)
#define fk(i,k,n) for(int i=k;i<=n;i++)
#define fr(i,r,n) for(int i=r;i>=n;i--)
#define ll long long
#define l long
#define ri(n) int n; cin>>n;
#define ri2(x,y) int x,y; cin>>x>>y;
#define ri3(x,y,z) int x,y,z; cin>>x>>y>>z;
#define max(a,b) (((a)>(b))?(a):(b))
#define min(a,b) (((a)<(b))?(a):(b))
#define max3(a,b,c) ((max(a,b)>(c))?max(a,b):c)
#define min3(a,b,c) ((min(a,b)<(c))?min(a,b):c)

typedef vector<int> vi;
typedef vector<l> vl;
typedef vector<ll> vll;
typedef vector<bool> vb;
typedef vector<vi > matrix;
typedef pair<int ,int> pi;
typedef pair<l,l> pl;
typedef pair<ll,ll> pll;
typedef vector<pi > vpi;
typedef vector<pll > vpll;
#define sz(a) int((a).size())
#define pb push_back
#define mp make_pair
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(decltype((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())
#define apresent(c,x) (find(all(c),x) != (c).end())
#define F first
#define S second
inline bool ispalindrome(string s) { for(int i=0,j=s.size()-1;i<=j;i++,j--) if(s[i]!=s[j]) return false; return true; }
inline bool ispalindrome(vi s) { for(int i=0,j=s.size()-1;i<=j;i++,j--) if(s[i]!=s[j]) return false; return true; }
#define ispalin(x) ispalindrome(x)
#define MOD 1000000007
inline ll gcd(ll a,ll b) {  return ((b==0)?a:gcd(b,a%b)); }
inline ll modexp(ll a,ll b,ll m) { ll d=1; while(b>0) { if(b&1) d=(d*a)%m; a=(a*a)%m; b=b>>1; } return (d<0?d+m:d); }
inline bool isPrime(ll x) { for(ll a = 2; a * a <= x; ++a) if(x % a == 0) return false; return true; }
inline ll powf(ll a,ll b) { ll d=1; while(b>0) { if(b&1) d=d*a; a=(a*a); b=b>>1; } return d;}
ll ncr(l n ,l r){vector<vl > dp(2,vl(r+1,0)); f1(i,n) fk(j,0,min(i,r)) dp[i&1][j] = ((i==j || j==0)?1:(dp[(i-1)&1][j] + dp[(i-1)&1][j-1])%MOD); return dp[n&1][r]; }
ll ncr2(l n, l r) { ll ans=1; for(l i = n;i>r;i--) ans = (ans*i)%MOD;  f1(i,n-r) ans = (ans*(modexp(i,MOD-2,MOD)))%MOD;  return ans; }
ll phi(ll n){ ll ret=n; ll i = 2; if(n%i==0){ ret-=ret/i; while(n%i==0)n/=i;} for(i=3; i*i<=n; i++)if(n%i==0){ ret-=ret/i; while(n%i==0)n/=i;} if(n>1)ret-=ret/n;return ret;}
#define MAX 1000007
/*
int sq = sqrt(MAX);
vb isprime(MAX+1,1);
vi small(MAX+1);
void sieve() { isprime[0]=isprime[1]=0; int i,j; for(i=4;i<=MAX;i+=2) isprime[i]=0;for(i=3;i<=sq;i+=2) if(isprime[i]) for(j=i*i;j<=MAX;j+=(i+i)) isprime[j]=0;  }
void smallprime(){int i,j; small[0]=small[1]=0;for(i=2;i<=MAX;i++) small[i]=(i&1)?i:2;for(i=3;i<=sq;i+=2) if(small[i]==i) for(j=2*i;j<=MAX;j+=i) if(small[j]==j) small[j]=i;}
void fact(ll n){ll temp=small[n],prod=1,count=0;while(n>1) {if(temp==small[n])count++;else{cout<<temp<<"^"<<count<<" ";prod*=(count+1);temp=small[n];count=1;}n/=small[n];}cout<<temp<<"^"<<count<<" "<<endl;prod*=(count+1);}
ll phi2(ll n){if(n==1)return 1; ll temp=small[n], count=n; while(n>1){if(temp!=small[n]){ count -= count/temp; temp = small[n];} n /= small[n]; }count -= count/temp; return count;}
*/
vi adj1[MAX],adj2[MAX],adj3[MAX];
bool vis[MAX];
stack<int> s;
matrix gr(MAX);
int group, parent[MAX], dp[MAX];
void dfs1(int u)
{
	vis[u] = true;
	tr(adj1[u],i) if(!vis[*i]) dfs1(*i); s.push(u);
}
void dfs2(int u)
{
	vis[u] = true;
	gr[group].pb(u); parent[u] = group;
	tr(adj2[u],i) if(!vis[*i]) dfs2(*i);
}
void dfs3(int u)
{
	vis[u] = true;
	tr(adj1[u],i)
	{
		int v = *i;
		int p = parent[u], m = parent[v];
		if(p == m) continue;
		adj3[p].pb(m);
		if(!vis[v]) dfs3(v);
	}
}
int find_max(int i)
{
	if(dp[i]!=-1) return dp[i];
	int max1 = gr[i].size();
	tr(adj3[i],j)
	{
		int v = *j;
		max1 = max(max1, gr[i].size() + find_max(v));
	}
	return dp[i] = max1;
}
int main()
{
	_
    T()
    {
    	ri(n)
    	f0(i,n)
    	{
    		adj1[i].clear();
    		adj2[i].clear();
    		adj3[i].clear();
    		vis[i] = false;
    		parent[i] = -1;
    		dp[i] = -1;
    		gr[i].clear();
		}
		f0(i,n)
		{
			ri(x)
			adj1[i].pb(x);
			adj2[x].pb(i);
		}
		// dfs to find the topological order
		f0(i,n)
		{
			if(!vis[i])
			dfs1(i);
		}
		memset(vis, false, n+1);
		// dfs on the reverse graph to get the strongly connected componnets
		group = 0;
		while(!s.empty())
		{
			int x = s.top(); s.pop();
			if(!vis[x])
			dfs2(x);
			sort(gr[group].begin(), gr[group].end());
			group++;
		}
		// now eliminating cycles and joining all the strongly connneceted comp through their group numbers i.e. adding edges between scc's
		memset(vis, false, n+1);
		f0(i,n)
		{
			if(!vis[i])
			dfs3(i);
		}
		// now using dp to calcuate the maximum number of islands reachable 
		int ans = 0,x;
		f0(i,group)
		{
			int y = find_max(i);
			if( y > ans )
			{
				ans = y;
				x = gr[i][0];
			}
			else if(y == ans && gr[i][0] < x)
			x = gr[i][0];
		}
		cout<<x<<endl;
	}
	return 0;
}




