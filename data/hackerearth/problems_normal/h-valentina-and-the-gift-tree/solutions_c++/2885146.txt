#include <bits/stdc++.h>
using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
//#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define tr(it,v) for(auto it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

#if 0
	#define DEB printf
#else
	#define DEB(...)
#endif

typedef long long ll;
typedef long long LL;
typedef double D;
typedef pair<int,int> pii;
typedef vector<int> vi;

const ll inft = 1LL<<60;
const int mod = 1000000007;
const int MAXN = 1000006,N=MAXN;

vi G[N];

namespace LCAO{
	const int N=MAXN,P=MAXN;
	int LCA[P];
	int kolor[N],REP[N],przodek[N];
	vector<pii> pyt[N];
	int find(int x){return REP[x]<0?x:REP[x]=find(REP[x]);}
	void DfsTarjan(int x,int par){
		kolor[x]=1;REP[x]=-1;przodek[x]=x;
		tr(it,G[x])if(*it!=par){
			DfsTarjan(*it,x);
			int a=find(x),b=find(*it);
			if(REP[a]<REP[b])swap(a,b);
			REP[b]+=REP[a];REP[a]=b;
			przodek[b]=x;
		}
		tr(it,pyt[x])if(kolor[it->x]==2){
			int lca=przodek[find(it->x)];
			LCA[it->y]=lca;
		}
		kolor[x]=2;
	}
	void dodaj_krawedz(int a,int b){
		G[a].pb(b);
		G[b].pb(a);
	}
	int nr=0;
	void dodaj_pytanie(int a,int b){
		if(a==b)LCA[nr]=a;
		else{
			pyt[a].pb(pii(b,nr));
			pyt[b].pb(pii(a,nr));
		}
		nr++;
	}
}
int f[MAXN];
struct Tp{
	ll pr,su,sum,best;
	Tp(ll a=0,ll b=0,ll c=0,ll d=-inft){
		pr=a;su=b;sum=c;best=d;
	}
};
Tp rev(Tp a){
	return Tp(a.su,a.pr,a.sum,a.best);
}
Tp merge(Tp t1,Tp t2){
	DEB("merge %lld, %lld, # %lld,%lld\n",t1.pr,t1.su,t1.sum,t1.best);
	DEB("merge %lld, %lld, # %lld,%lld\n",t2.pr,t2.su,t2.sum,t2.best);
	Tp ret;
	if(t2.best==-inft)swap(t1,t2);
	if(t1.best==-inft){
		if(t2.best==-inft)ret=t1;
		else ret=t2;
	}else{
		ll best=max(t1.best,t2.best);
		best=max(best,t1.su+t2.pr);
		ret=Tp(max(t1.pr,t1.sum+t2.pr),max(t2.su,t2.sum+t1.su),t1.sum+t2.sum,best);
	}
	DEB("mergezwracam %lld, %lld, # %lld,%lld\n",ret.pr,ret.su,ret.sum,ret.best);
	return ret;
}
ll eval(Tp t1){
	return t1.best;
}
struct drzewo{
	vector<Tp> drz;
	int T;
	void update(int a,int val){
		a+=T;
		drz[a]=Tp(val,val,val,val);
		a/=2;
		while(a){
			drz[a]=merge(drz[2*a],drz[2*a+1]);
			a/=2;
		}
	}
	
	void init(int n){
		T=1;
		while(T<n)T*=2;
		drz.resize(2*T);
	}

	Tp get(int a,int b){
		Tp ta,tb;
		a+=T;b+=T;
		while(a<=b){
			if(a%2==1){ta=merge(ta,drz[a]);a++;}
			if(b%2==0){tb=merge(drz[b],tb);b--;}
			a/=2;
			b/=2;
		}
		return merge(ta,tb);
	}
	
};

namespace HLD{
	drzewo CS[N];
	int nrc[N];
	int ind[N];
	int hop[N];
	int siz[N];
	int sciezek;

	Tp get(int a,int anc,int coef){
		DEB("get %d %d\n",a,anc);
		Tp ret;
		while(nrc[a]!=nrc[anc]){
			ret=merge(ret,rev(CS[nrc[a]].get(0,ind[a])));
			a=hop[nrc[a]];
		}
		ret=merge(ret,rev(CS[nrc[a]].get(ind[anc]+coef,ind[a])));
		DEB("zwracam %lld, %lld, # %lld,%lld\n",ret.pr,ret.su,ret.sum,ret.best);
		return ret;
	}
	void update(int a,int val){
		DEB("update %d %d\n",a,val );
	/*	while(nrc[a]!=nrc[anc]){
			CS[nrc[a]].update(0,ind[a]);
			a=hop[nrc[a]];
		}*/
		CS[nrc[a]].update(ind[a],val);
	}
	int rozm(int u, int pr){
		siz[u]=1;
		tr(it,G[u]) if(*it!=pr) siz[u]+=rozm(*it,u);
		return siz[u];
	}
	void ciezka(int u,int pr,int csc,int index){
		nrc[u]=csc;
		ind[u]=index;
		int dz=-1;
		tr(it,G[u]) if(*it!=pr && (dz==-1 || siz[*it]>siz[dz])) dz=*it;
		tr(it,G[u]) if(*it==dz) ciezka(*it,u,csc,index+1);
		else if(*it!=pr){
			hop[sciezek++]=u;
			ciezka(*it,u,sciezek-1,0);
		}
		if(dz==-1){
			CS[csc].init(index+1);
		}
	}
	void init(int root){
		rozm(root,-1);
		sciezek=1;
		hop[0]=-1;
		ciezka(root,-1,0,0);
	}
}
pii Q[MAXN];
void solve() {
	int n;
	scanf("%d",&n);
	fru(i,n-1){
		int a,b;
		scanf("%d%d",&a,&b);a--;b--;
		LCAO::dodaj_krawedz(a,b);
	}
	fru(i,n)scanf("%d",&f[i]);
	int q;
	scanf("%d",&q);
	fru(i,q){
		int a,b;
		scanf("%d%d",&a,&b);a--;b--;
		Q[i]=pii(a,b);
		LCAO::dodaj_pytanie(a,b);
	}
	LCAO::DfsTarjan(0,-1);
	HLD::init(0);
	fru(i,n)HLD::update(i,f[i]);
	fru(i,q){
		int u=LCAO::LCA[i];
		Tp t1=HLD::get(Q[i].x,u,0),t2=HLD::get(Q[i].y,u,1);
	DEB("aa %lld, %lld, # %lld,%lld\n",t1.pr,t1.su,t1.sum,t1.best);
	DEB("aa %lld, %lld, # %lld,%lld\n",t2.pr,t2.su,t2.sum,t2.best);
		printf("%lld\n",eval(merge(t1,rev(t2))));
	}
}

int main() {
	int te = 1;
//	scanf("%d",&te);
	fru(ti,te) solve();
	return 0;
}
