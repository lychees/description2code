#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <climits>
#include <map>
using namespace std;

#define ld int
typedef vector<ld> VI;
typedef vector < VI > VVI;

const int maxn=200;
vector<int> adj[210];
map<int, int> mp[210];
int d[10010];
bool mark[10010];

int MinCostMatching(const VVI &cost) {
	int n = int(cost.size());// construct dual feasible solution
	VI u(n);
	VI v(n);
	VI Lmate;
	VI Rmate;
	for (int i = 0; i < n; i++) {
		u[i] = cost[i][0];
		for (int j = 1; j < n; j++) u[i] = min(u[i], cost[i][j]);
	}
	for (int j = 0; j < n; j++) {
		v[j] = cost[0][j] - u[0];
		for (int i = 1; i < n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
	}
	Lmate = VI(n, -1);
	Rmate = VI(n, -1);
	int mated = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (Rmate[j] != -1) continue;
			if (fabs(cost[i][j] - u[i] - v[j]) < 1e-10) {
				Lmate[i] = j;
				Rmate[j] = i;
				mated++;
				break;
			}
		}
	}
 
	VI dist(n);
	VI dad(n);
	VI seen(n);
	while (mated < n) {
		int s = 0;
		while (Lmate[s] != -1) s++;
		fill(dad.begin(), dad.end(), -1);
		fill(seen.begin(), seen.end(), 0);
		for (int k = 0; k < n; k++)
			dist[k] = cost[s][k] - u[s] - v[k];
		int j = 0;
		while (true) {
			j = -1;
			for (int k = 0; k < n; k++) {
				if (seen[k]) continue;
				if (j == -1 || dist[k] < dist[j]) j = k;
			}
			seen[j] = 1;
			if (Rmate[j] == -1) break;
			const int i = Rmate[j];
			for (int k = 0; k < n; k++) {
				if (seen[k]) continue;
				const int new_dist = dist[j] + cost[i][k] - u[i] - v[k];
				if (dist[k] > new_dist) {
					dist[k] = new_dist;
					dad[k] = j;
				}
			}
		}
		for (int k = 0; k < n; k++) {
			if (k == j || !seen[k]) continue;
			const int i = Rmate[k];
			v[k] += dist[k] - dist[j];
			u[i] -= dist[k] - dist[j];
		}
		u[s] += dist[j];
		while (dad[j] >= 0) {
			const int d = dad[j];
			Rmate[j] = Rmate[d];
			Lmate[Rmate[j]] = j;
			j = d;
		}
		Rmate[j] = s;
		Lmate[s] = j;
		mated++;
	}
	
	ld value = 0;
	for (int i = 0; i < n; i++) 
		value += cost[i][Lmate[i]];
	return value;
}

int main() {
	// your code goes here
	int T, n, m, k, u, v, l, i, j, ans, s, f, c;
	scanf("%d", &T);
	while(T--) {
		scanf("%d %d %d", &n, &m, &k);
		for(i=0; i<m; ++i) {
			scanf("%d %d %d", &u, &v, &c);
			adj[u].push_back(v);
			adj[v].push_back(u);
			if(mp[u][v])	mp[u][v]=min(mp[u][v], c);
			else	mp[u][v]=c;
			if(mp[v][u])	mp[v][u]=min(mp[v][u], c);
			else	mp[v][u]=c;
		}
		
		vector<vector<int> > cost;
		vector<int> vv;
		for(i=1; i<=k; ++i) {
			for(j=0; j<=n; ++j) {
				d[j]=INT_MAX;
				mark[j]=false;
			}
			s=i;
			d[s]=0;
			priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;
			pq.push(make_pair(d[s], s));
			while(!pq.empty()) {
				u=pq.top().second;
				pq.pop();
				if(mark[u])
					continue;
				mark[u]=true;
				for(auto p: adj[u]) {
					if(d[p]>d[u]+mp[u][p]) {
						d[p]=d[u]+mp[u][p];
						pq.push(make_pair(d[p], p));
					}
				}
			}
			for(j=n-k+1, l=0; j<=n; ++j, ++l) {
				vv.push_back(min(10000, d[j]));
				//printf("%d ", d[j]);
			}
			cost.push_back(vv);
			vv.clear();
		}
		
		/*for(i=0; i<k; ++i) {
			for(j=0; j<k; ++j)
				printf("%d ", cost[i][j]);
			printf("\n");
		}*/
		printf("%d\n", MinCostMatching(cost));
		cost.clear();
		for(i=0; i<=200; ++i) {
			adj[i].clear();
			mp[i].clear();
		}
	}
	return 0;
}