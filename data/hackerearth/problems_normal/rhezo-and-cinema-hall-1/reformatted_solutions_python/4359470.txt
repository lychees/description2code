# import time

# time1=time.time()

MOD = 1000000007
# rowlen i, people j, f(i,j)=0 if j<(i+1)/2 else i if j==1 else
# f(i-1,j)+f(i-2,j-1)
combs = {
    3: {
        2: 1}, 4: {
            2: 3}, 5: {
                2: 6, 3: 1}, 6: {
                    2: 10, 3: 4}, 7: {
                        2: 15, 3: 10, 4: 1}, 8: {
                            2: 21, 3: 20, 4: 5}, 9: {
                                2: 28, 3: 35, 4: 15, 5: 1}, 10: {
                                    2: 36, 3: 56, 4: 35, 5: 6}}
# combs=[[0,0,1,0,0,0],[0,0,3,0,0,0],[0,0,6,1,0,0],[0,0,10,4,0,0],[0,0,15,10,1,0],
#       [0,0,21,20,5,0],[0,0,28,35,15,1],[0,0,36,56,35,6]]

# print time.time()
N, M = map(int, raw_input().split())
K = int(raw_input())
# N,M,K=[500,10,500]
actcombs = {1: combs[M]}
numrows = 1
while numrows*2 <= N:
    newcombs = {}
    lastcombs = actcombs[numrows]
    for i in lastcombs:
        for j in lastcombs:
            toadd = (lastcombs[i]*lastcombs[j]) % MOD
            newcombs[i+j] = (newcombs[i+j]+toadd) % MOD if i + \
                j in newcombs else toadd
    numrows *= 2
    actcombs[numrows] = newcombs
newcombs = {0: 1}
actrows = 0
for i in reversed(sorted(actcombs.keys())):
    if actrows+i <= N:
        lastcombs = newcombs
        newcombs = {}
        for k1 in lastcombs:
            for k2 in actcombs[i]:
                toadd = (lastcombs[k1]*actcombs[i][k2]) % MOD
                newcombs[k1+k2] = (newcombs[k1+k2] +
                                   toadd) % MOD if k1+k2 in newcombs else toadd
        actrows += i
total = 0
for i in xrange(K, N*M+1):
    if i in newcombs:
        total = (total+newcombs[i]) % MOD
print total
# print time.time()-time1
