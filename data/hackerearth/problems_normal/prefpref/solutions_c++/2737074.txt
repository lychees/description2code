/*
In the problem, we are given two strings S and T. We need to find the largest prefix of S that is a subsequence of T.

Clearly, in order to find a prefix of length n, we must first find the prefix of length n-1 and then look for S[n-1] (0-based indexing) in T. 
Similarly, to find a prefix of length n-1, we must first find the prefix of length n-2 and then look for S[n-2] and so on.

Thus, we keep a counter which stores the current length of prefix found. We initialize it with 0 and begin with the first letter in S 
and keep iterating over T to find the occurrence of the first letter. As soon as we encounter the first letter of S we update the 
counter (we now have a prefix of length 1) and look for the second letter. We keep updating the counter and looking for the next letter,
 until either the entire string S is found or there are no more letters in T.
*/
#include<iostream>
#include<string>
using namespace std;
int main()
 {
 
    string s, t;
   
	cin>>s>>t;

    /*
     * len stores the length of the prefix of S already found.
     * pos stores the current index in T.
     */
    int len = 0, pos=0;
    while(len<s.length() && pos<t.length()) {

        /* if the letter at position len matches. */ 
        if(s[len]==t[pos]) {
            len++;
        }

        pos++;
    }

    cout<<len<<endl;
	return 0;
}