//Abhishek Bansal
#include<bits/stdc++.h>
#define PB push_back
#define MP make_pair
#define F first
#define S second
#define SZ(a) (int)(a.size())
#define SET(a,b) memset(a,b,sizeof(a))
#define LET(x,a) __typeof(a) x(a)
#define TR(v,it) for( LET(it,v.begin()) ; it != v.end() ; it++)
#define loop(i,a,b) for(int i=a;i<b;i++)
#define si(n) scanf("%d",&n)
#define sll(n) scanf("%lld",&n)
#define all(a) a.begin(),a.end()
#define bitcount(n) __builtin_popcount(n)
#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)

#define TRACE

using namespace std;
#ifdef TRACE
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1){
	cerr << name << " : " << arg1 << std::endl;
}
template <typename Arg1, typename... Args>
void __f(const char* names, Arg1&& arg1, Args&&... args){
	const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...);
}
#else
#define trace(...)
#endif
typedef long long int lli;
typedef pair<int,int> ii;
typedef vector<int> vi;
typedef vector< vi > vvi;
typedef vector< ii > vii;
lli modpow(lli a,lli n,lli temp){lli res=1,y=a;while(n>0){if(n&1)res=(res*y)%temp;y=(y*y)%temp;n/=2;}return res%temp;}
//***********************************END OF TEMPLATE*********************************************************************
int dp[102][102][502];
int A[102][102];
const int inf = -1000000000;
int solve(int N,int M,int K){
	for(int k=0;k<=K;++k){
		if(A[0][0]<=k)dp[0][0][k]=A[0][0];
		else dp[0][0][k]=inf;
	}
	for(int j=1;j<M;++j){
		for(int k=0;k<=K;++k){
			if(A[0][j]<=k)dp[0][j][k]=A[0][j]+dp[0][j-1][k-A[0][j]];
			else dp[0][j][k]=inf;
		}
	}
	for(int i=1;i<N;++i){
		for(int k=0;k<=K;++k){
			if(A[i][0]<=k)dp[i][0][k]=A[i][0]+dp[i-1][0][k-A[i][0]];
			else dp[i][0][k]=inf;
		}
	}
	for(int i=1;i<N;++i){
		for(int j=1;j<M;++j){
			for(int k=0;k<=K;++k){
				if(A[i][j]<=k){
					dp[i][j][k]=A[i][j]+max(dp[i-1][j][k-A[i][j]],max(dp[i][j-1][k-A[i][j]],dp[i-1][j-1][k-A[i][j]]));
				}
				else dp[i][j][k]=inf;
			}
		}
	}
	return dp[N-1][M-1][K];
}
int main(){
	int t;si(t);
	while(t--){
		int N,M,K;
		si(N);si(M);si(K);
		for(int i=0;i<N;++i)for(int j=0;j<M;++j)si(A[i][j]);
		int ans = solve(N,M,K);
		if(ans<=0)ans=-1;
		printf("%d\n",ans);
	}
	return 0;
}
