/*
    ****  AutoGenerated Header file ****
    * * Creation Date : 21-07-2015
    * * Last Modified : Wed Jul 22 00:44:41 2015
    * * Created By : chang
*/

#include <cstdio>
#include <iostream>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cstring>
#include <bitset>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#include <string>
#include <climits>
#include <cmath>

#define  each(v,c)  for(typeof((c).begin()) v = (c).begin(); v != (c).end(); ++v)
#define  sync(x)    ios_base::sync_with_stdio(x)
#define  sz(a)      ((int)(a.size()))
#define  all(a)     (a).begin(), (a).end()
#define  pb         push_back
#define  mp         make_pair
#define  fi         first
#define  se         second
using namespace std;

#define debug(a,n)    cerr << "["; for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << "\b]\n";
#define dbg(args...)  {debug1,args; cerr<<endl;}
#define pause()       cin.get();cin.get();

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug1;

template <typename T1, typename T2>
inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}

template<typename T>
inline ostream &operator << (ostream & os,const vector<T>& v) {
    bool first = true; os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {
        if(!first) os << ", ";
        os << *ii; first = false;
    }
    return os << "]";
}

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<int,pii> piii;
typedef vector<int> vi;

const int inf = 0x7fffffff;
const int ND = 212;
const int MD = 21234;

int head[ND], ptr[ND], mq[ND];
int to[MD], flow[MD], cap[MD], nxt[MD];
int dist[ND];

int source,sink,n,m;
int eg_no = 0;

inline void init(){
    eg_no = 0;
    memset(head,-1,sizeof(head));
}

inline void addEdge(int a,int b,int cp){
    to[eg_no] = b, flow[eg_no] = 0, cap[eg_no] = cp;
    nxt[eg_no] = head[a], head[a] = eg_no++;
}

inline void addEdge(int a,int b,int cp,int r_cp){
    addEdge(a,b,cp);
    addEdge(b,a,r_cp);
}

bool bfs(){
    memset(dist,-1,sizeof(dist));
    int st = 0, en = 0;
    mq[en++] = source;
    dist[source] = 0;

    while(st < en){
        int x = mq[st++];
        for(int i = head[x]; i >= 0; i = nxt[i]){
            int y = to[i];
            if (flow[i] < cap[i] and dist[y] == -1){
                mq[en++] = y;
                dist[y] = dist[x] + 1;
            }
        }
    }
    return (dist[sink] != -1);
}

int dfs(int x,int cflow){
    if (x == sink)
        return cflow;
    int ans = 0;
    for(int &i = ptr[x]; i >= 0; i = nxt[i]){
        int y = to[i];
        if (flow[i] < cap[i] and dist[y] == dist[x]+1){
            int addflow = dfs(y,min(cflow,cap[i]-flow[i]));
            if (addflow > 0){
                flow[i] += addflow;
                flow[i^1] -= addflow;
                return addflow;
            }
        }
    }
    return ans;
}

int dinitz(){
    int ans = 0;
    while(bfs()){
        memcpy(ptr,head,sizeof(ptr));
        while(true){
            int add = dfs(source,inf);
            if (add > 0) ans += add;
            else break;
        }
    }
    return ans;
}

int running[ND];
int link[ND];

void solve(){
    init();
    cin >> n;
    for(int i = 0; i < n; ++i)
        cin >> running[i];
    cin >> m;
    source = 0, sink = n+m+1;
    for(int i = 0; i < n; ++i)
        addEdge(i+m+1,sink,running[i],0);

    for(int i = 0; i < m; ++i){
        int length, num;
        cin >> length;
        for(int j = 0; j < length; ++j){
            cin >> num;
            addEdge(i+1,num+m,inf,0);
        }

        cin >> num;
        link[i] = eg_no;
        addEdge(source,i+1,num,0);
    }
    
    int mflow = dinitz();
    int ans = 0;

    for(int i = 0; i < m; ++i){
        ans += cap[link[i]] - flow[link[i]];
        //dbg(link[i],cap[link[i]],flow[link[i]]);
    }

    cout << ans << "\n";
}

int main()
{
    solve();
    return 0;
}
