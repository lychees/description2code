#include <iostream>
#include <vector>

class Board
{
public:
	static const int CELL_EMPTY = -1;
	static const int CELL_MINE = -2;
	
public:
	Board(int width, int height);
	
	int width() const;
	int height() const;
	
	int & operator()(int x, int y);
	int operator()(int x, int y) const;
	
	int mines_adjacent_to(int x, int y) const;
	
	void click(int x, int y);
	
	template <typename Func>
	void for_each_neighbor(int x, int y, Func f) const;
	
private:
	using board_vec = std::vector< std::vector<int> >;
	
	board_vec m_board;
	int const m_width;
	int const m_height;
};

template <typename S>
S & operator<<(S & stream, Board const & board)
{
	for (int y = 0; y < board.height(); ++y) {
		for (int x = 0; x < board.width(); ++x) {
			auto v = board(x, y);
			
			switch (v) {
				case Board::CELL_EMPTY:
					stream << '.';
					break;
					
				case Board::CELL_MINE:
					stream << '*';
					break;
					
				default:
					stream << v;
					break;
			}
		}
		stream << std::endl;
	}
	
	return stream;
}

Board::Board(int width, int height)
	: m_board(width, std::vector<int>(height, CELL_EMPTY)),
	  m_width(width),
	  m_height(height)
{
}

int Board::width() const
{
	return m_width;
}

int Board::height() const
{
	return m_height;
}

int & Board::operator()(int x, int y)
{
	return m_board[x][y];
}

int Board::operator()(int x, int y) const
{
	return m_board[x][y];
}

template <typename Func>
void Board::for_each_neighbor(int x, int y, Func f) const
{
	int const x_start = std::max(0, x - 1);
	int const x_end = std::min(m_width - 1, x + 1);
	
	int const y_start = std::max(0, y - 1);
	int const y_end = std::min(m_height - 1, y + 1);
	
	for (int ix = x_start; ix <= x_end; ++ix) {
		for (int iy = y_start; iy <= y_end; ++iy) {
			if (ix != x || iy != y) {
				if (f(ix, iy, m_board[ix][iy])) {
					return;
				}
			}
		}
	}
}

int Board::mines_adjacent_to(int x, int y) const
{
	int mines = 0;
	
	for_each_neighbor(x, y, [&mines, x, y] (int ix, int iy, int v) {
		if (v == CELL_MINE) {
			++mines;
		}
		
		return false;
	});
	
	return mines;
}

void Board::click(int x, int y)
{
	if (m_board[x][y] != CELL_EMPTY) { return; }
	
	auto mines = mines_adjacent_to(x, y);
	m_board[x][y] = mines;
	
	if (mines == 0) {
		for_each_neighbor(x, y, [this] (int ix, int iy, int v) {
			click(ix, iy);
			return false;
		});
	}
}

Board read_board(int & click_x, int & click_y)
{
	int w, h;
	
	std::cin >> h >> w;
	
	auto board = Board{w, h};
	
	int x = 0;
	int y = 0;
	
	while (y < h) {
		char c = static_cast<char>(std::cin.get());
		
		switch (c) {
			case 'c':
				click_x = x;
				click_y = y;
				// fall through
			case '.':
				board(x, y) = Board::CELL_EMPTY;
				break;
				
			case '*':
				board(x, y) = Board::CELL_MINE;
				break;
				
			default:
				continue;
		}
		
		if (++x == w) {
			x = 0;
			++y;
		}
	}
	
	return board;
}

int main()
{
    int tests;
    std::cin >> tests;
    
    while (tests-- > 0) {
    	int cx, cy;
    	Board board = read_board(cx, cy);
    	
    	board.click(cx, cy);
    	
    	std::cout << board;
    }
    
    return 0;
}