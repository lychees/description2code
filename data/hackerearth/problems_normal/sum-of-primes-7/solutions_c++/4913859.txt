//DARK LORD
#include<bits/stdc++.h>
#define ll long long
#define _ ios::sync_with_stdio(false);cin.tie(0);
#define max(a,b)                 (a>=b?a:b)
#define min(a,b)                 (a<b?a:b)
#define max3(a,b,c)               max(a,max(b,c))
#define min3(a,b,c)               min(a,min(b,c))
#define f0(i,a,b) for(int i=a;i<b;i++)
#define f1(i,a,b) for(int i=a;i<=b;i++)
#define fr(i,b,a) for(int i=b;i>=a;i--)
#define F first
#define S second
#define pb push_back
#define mp make_pair
#define mod 1000000007
#define T() int t;cin>>t;while(t--)
inline ll modexp(ll a,ll b){ll x=1;while(b>0){if(b&1){x*=a;if(x>=mod)x%=mod;};b>>=1;a*=a;if(a>=mod)a%=mod;}return x;}
inline ll digSum(ll n){ll s=0;n=abs(n);while(n){s+=(n%10);n/=10;}return s;}
using namespace std;
/*  Graph Part
static const int N  = 100001;
static bool visited[N];
vector<int> adj[N];
*/
#define mx 1000001
vector<ll> sumprim(mx,0);
vector<bool> isprime(mx,true);
int main()
{
   _
   isprime[0]=false;
    isprime[1]=false;
    ll i,j,primelen;
    for(i=4;i<mx;i+=2)
    	isprime[i] = false;
    for(i=3;i<=sqrt(mx);i+=2)
    if(isprime[i])
    for(j=i*i;j<=mx;j+=2*i)
    {
        isprime[j]=false;
    }  
    sumprim[2] = 2;
    for(i=3;i<=mx;i+=1){
    if(isprime[i])
    sumprim[i] = sumprim[i-1] + i;
	else sumprim[i] = sumprim[i-1];}
    T(){
    	int n,m;
    	cin>>n>>m;
    	//if(!isprime[n] && !isprime[m]) cout<<0<<endl;
    	 cout<<sumprim[m] - sumprim[n-1]<<endl;
	}

}

