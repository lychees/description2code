#include<stdio.h>
 
 int maze[52][52],N;
/* A utility function to check if x,y is valid index for N*N maze */
bool isSafe( int x, int y)
{
    // if (x,y outside maze) return false
    if(x >= 0 && x < N && y >= 0 && y < N && maze[x][y] == 1)
        return true;
 
    return false;
}
 
/* This function solves the Maze problem using Backtracking.  It mainly uses
solveMazeUtil() to solve the problem. It returns false if no path is possible,
otherwise return true and prints the path in the form of 1s. Please note that
there may be more than one solutions, this function prints one of the feasible
solutions.*/

/* A recursive utility function to solve Maze problem */
bool solveMazeUtil( int x, int y)
{
    // if (x,y is goal) return true
    if(x == N-1 && y == N-1)
    {
        
        return true;
    }
 
    // Check if maze[x][y] is valid
    if(isSafe( x, y) == true)
    {
        
        /* Move forward in x direction */
        if (solveMazeUtil( x+1, y) == true)
            return true;
 
        /* If moving in x direction doesn't give solution then
           Move down in y direction  */
        if (solveMazeUtil( x, y+1) == true)
            return true;
 
        /* If none of the above movements work then BACKTRACK: 
            unmark x,y as part of solution path */
        return false;
    }   
 
    return false;
}
 bool solveMaze()
{
    return (solveMazeUtil(0, 0));
}
 
// driver program to test above function
int main()
{
	int t; scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&N);
    	int i,j;
    	for(i=0;i<N;i++)
    		for(j=0;j<N;j++)
    			scanf("%d",&maze[i][j]);
    	if(solveMaze())
    		printf("POSSIBLE");
    	else
    		printf("NOT POSSIBLE");
    	printf("\n");
	}
    return 0;
}