#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>
#include <string.h>
#include<assert.h>
//#include<unordered_map>
using namespace std;
const double pi=acos(-1.0);
const double eps=1e-11;
#define ll long long int
#define sc(x) scanf("%d",&x)
#define scl(x) scanf("%lld",&x)
#define printl(x) printf("%lld\n",x)
#define print(x) printf("%d\n",x)
#define DEBUG(x) cout<<"Value of "<<#x<<" is "<<x<<endl
#define mp(A,B) make_pair(A,B)
#define pb(X) push_back(X)
#define INF 1000000000
#define SET(x,y) memset(x,y,sizeof(x))
#define endl "\n"
#define f first
#define s second
#define gc getchar

int visited[103][103];
bool vis[103][103];
int dist[103][103];
int BFS(int x, int y, int k)
{
	vis[x][y]=true;
	queue< pair<int,int> > q;
	q.push(mp(x,y));
	while(!q.empty())
	{
		pair<int,int> temp = q.front();
		if(temp.f==temp.s&&temp.f==k)
			return dist[temp.f][temp.s];
		q.pop();
		if(temp.s+1<=k&&temp.f<=k&&!vis[temp.f][temp.s+1]&&visited[temp.f][temp.s+1]==1)
		{
			vis[temp.f][temp.s+1]=true;
			dist[temp.f][temp.s+1]=dist[temp.f][temp.s]+1;
			q.push(mp(temp.f,temp.s+1));
		}
		if(temp.f+1<=k&&temp.s<=k&&!vis[temp.f+1][temp.s]&&visited[temp.f+1][temp.s]==1)
		{
			vis[temp.f+1][temp.s]=true;
			dist[temp.f+1][temp.s]=dist[temp.f][temp.s]+1;
			q.push(mp(temp.f+1,temp.s));
		}
	}
	return -1;
}
int main()
{
	int t,n,i,j,k;
	sc(t);
	while(t--)
	{
		SET(vis,false);
		SET(dist,0);
		sc(n);sc(k);
		for(i=1;i<=n;i++)
		{
			string str;
			cin>>str;
			for(j=1;j<=n;j++)
			{
				visited[i][j]=str[j-1]-48;
			}
		}
		dist[1][1]=0;
		if(visited[1][1]==1)
			print(BFS(1,1,k));
		else
			print(-1);
	}
	return 0;
}
