#include <iostream>
#include <cstring>

using namespace std;
#define INF 0x3f3f3f3f

typedef struct edge {
    int u, v, w;
} Edge;

int businessday()
{
    // E -> Number Of Edges. src = 1 (given)
    int V, E, src = 1;
    // three parameter to represent a edge
    int u, v, w;

    // Taking input V and E;
    cin >> V >> E;

    // Array to store the edges
    Edge edgeList[E];
    // distance and predecessor array
    int distance[V+1];
    int positiveLoop[V+1];
    // int predecessor[V+1];

    for (int i = 0; i < V+1; i++) positiveLoop[i] = -1;

    // Adding undirected of weightage 'd'
    for (int i = 0; i < E; i++) {
        cin >> u >> v >> w;
        if (u == v && w > 0) positiveLoop[u] = 0;
        w = -w;
        edgeList[i].u = u; edgeList[i].v = v; edgeList[i].w = w;
    }
    // REMEMBER: making weight of all the edges of oppsite sign than the original

    // for (int j = 0; j < E; j++) cout<< edgeList[j].u<< " " <<edgeList[j].v<< " "<< edgeList[j].w<< endl;
    for (int i = 0; i < V+1; i++) distance[i] = INF;
    distance[src] = 0;

    for (int i = 1; i < V-1; i++) {
        for (int j = 0; j < E; j++) {
            u = edgeList[j].u;
            v = edgeList[j].v;
            w = edgeList[j].w;
            if (u != v) {
                if (distance[u] != INF && distance[v] > distance[u] + w)
                    distance[v] = distance[u] + w;
            }
        }
        // for (int i = 1; i < V+1; i++) cout << distance[i] << "\t" << positiveLoop[i] << endl; cout << endl;
    }

    // for (int i = 0; i < E; i++) {u = edgeList[i].u; v = edgeList[i].v; w = edgeList[i].w; cout << u << " " << v << " " << w << " " << endl; }
    // cout << endl;
    // for (int i = 1; i < V+1; i++) cout << distance[i] << "\t" << positiveLoop[i] << endl;

    for (int i = 1; i < V+1; i++) {
        if ( distance[i] != INF && positiveLoop[i] == 0) return 0;
    }

    for (int i = 1; i < V-1; i++) {
        for (int j = 0; j < E; j++) {
            u = edgeList[j].u;
            v = edgeList[j].v;
            w = edgeList[j].w;
            if (u != v) {
                if (distance[u] != INF && distance[v] > distance[u] + w){
                    // cout << "belfordloopcheck" << endl;
                    return 0;
                }
            }
        }
    }

    // cout << "checkLast" << endl;
    return -1;
}

int main()
{
    int T, returnValue;
    cin >> T;

    for (int i = 0; i < T; i++) {
        returnValue = businessday();
        if (returnValue == 0)
            cout << "Yes" << endl;
        else
            cout << "No" << endl;

    }
    return 0;
}
