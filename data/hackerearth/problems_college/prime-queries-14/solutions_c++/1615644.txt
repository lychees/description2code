#include<bits/stdc++.h>

using namespace std;


bool primes[1000005];



struct SegmentTreeNode {
	long long prime=-1;

	void assignLeaf(long long  value) {
	if(primes[value])
        prime=value;
    else
        prime=-1;

        }

	void merge(SegmentTreeNode& left, SegmentTreeNode& right) {
		prime= max(left.prime,right.prime);
		//cout<<"prime:"<<prime<<endl;

	}

	long long  getValue() {

		return prime;
	}
};


// T is the type of input array elements
// V is the type of required aggregate statistic

SegmentTreeNode nodes[4000001];
long long  arr[1000001];
long long  N;







	SegmentTreeNode getValue(long long  stIndex, long long  left, long long  right, long long  lo, long long  hi) {
		if (left == lo && right == hi)
			return nodes[stIndex];

		long long  mid = (left + right) / 2;
		if (lo > mid)
			return getValue(2*stIndex+1, mid+1, right, lo, hi);
		if (hi <= mid)
			return getValue(2*stIndex, left, mid, lo, hi);

		SegmentTreeNode leftResult = getValue(2*stIndex, left, mid, lo, mid);
		SegmentTreeNode rightResult = getValue(2*stIndex+1, mid+1, right, mid+1, hi);
		SegmentTreeNode result;
		result.merge(leftResult, rightResult);
		return result;
	}


	long long  get_Value(long long  lo, long long  hi) {
		SegmentTreeNode result = getValue(1, 0, N-1, lo, hi);
		return result.getValue();
	}

	void updateUtil(long long  stIndex, long long  lo, long long  hi, long long  index, long long  value) {
		if (lo == hi) {
			nodes[stIndex].assignLeaf(value);
			return;
		}

		long long  left = 2 * stIndex, right = left + 1, mid = (lo + hi) / 2;
		if (index <= mid)
			updateUtil(left, lo, mid, index, value);
		else
			updateUtil(right, mid+1, hi, index, value);

		nodes[stIndex].merge(nodes[left], nodes[right]);
	}

	void update(long long  index, long long  value) {
		updateUtil(1, 0, N-1, index, value);
	}

	void buildTree(long long  arr[], long long  stIndex, long long  lo, long long  hi) {
		if (lo == hi) {
			nodes[stIndex].assignLeaf(arr[lo]);
			return;
		}

		long long  left = 2 * stIndex, right = left + 1, mid = (lo + hi) / 2;
		buildTree(arr, left, lo, mid);
		buildTree(arr, right, mid + 1, hi);
		nodes[stIndex].merge(nodes[left], nodes[right]);
	}



void sieve(long long n)
{
long long i,j;

for(i=0;i<=n;i++)
    primes[i]=1;
    primes[1]=0;
for(i=2;i<=n;i++)
{
    if(primes[i]==0)
        continue;
    j=2*i;

    for(;j<=n;j+=i)
    {
        primes[j]=0;
    }

}



}

int main()
{
long long  i,j,k,n,q,t,a,b,ans=0;

sieve(1000001);

cin>>N>>q;

for(i=0;i<N;i++)
    scanf("%lld",&arr[i]);

buildTree(arr, 1, 0, N-1);

while(q--)
{scanf("%lld%lld%lld",&t,&a,&b);

if(t==0)
{
update(a-1,b);
}

else
{
    printf("%lld\n",get_Value(a-1,b-1));

}



}





}
