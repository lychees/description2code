#include <stdio.h>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<cassert>
#include<set>
#include<queue>
#include<map>
#include <stack>
	
using namespace std;
	

#define ll long long
#define llu unsigned long long
#define MOD 1000000007

void test(ll n)
{
	int nRet =0;
	for(ll a = 1; a <= n; ++a)
		for(ll b=a;b<=n;++b)
			for(ll c=b;c<=n;++c)
				if((c*c) == (a*a+b*b))
				{	//printf("(%lld,%lld,%lld)",a,b,c);
					nRet++;
				}
	printf("\n%lld  %d   (check)-->",n,nRet);

}
//Matrix Linear Transformations
const ll A[3][3]= 
	{
		{-1,2,2 },
		{-2,1,2 },
		{-2,2,3 }
	};

const ll B[3][3]= 
	{
		{1,2,2 },
		{2,1,2 },
		{2,2,3 }
	};
const ll C[3][3]= 
	{
		{1,-2,2 },
		{2,-1,2 },
		{2,-2,3 }
	};
void multiply(const ll m[3][3],const ll n[3], ll out[3])
{
	for(int i =0; i< 3 ; ++i)
		out[i] = m[i][0]*n[0] + m[i][1]*n[1] +m[i][2]*n[2];
}

typedef struct _pytrip
{
	ll a,b,c;
	bool check2(ll n)
	{
		return (a*a<=n && b*b<=n && c*c <=n);
	}
	bool check1(ll n)
	{
		return (a<=n && b<=n && c <=n);
	}
}pytrip;
void Count(ll n)
{
	stack<pytrip> chain;
	ll temp[3],out[3];
	pytrip t ;
	ll count =0;
	//Place first value in chain and extract others like eculadian
	t.a = 3;
	t.b = 4;
	t.c = 5;
	chain.push(t);
	while(chain.size())
	{
		t = chain.top();
		chain.pop();
		count+=(n/t.c);
		temp[0]= t.a;
		temp[1] = t.b;
		temp[2] = t.c;
		multiply(A,temp,out);
		t.a = out[0],t.b=out[1],t.c=out[2];
		if(t.check1(n)) chain.push(t); 

		multiply(B,temp,out);
		t.a = out[0],t.b=out[1],t.c=out[2];
		if(t.check1(n)) chain.push(t); 

		multiply(C,temp,out);
		t.a = out[0],t.b=out[1],t.c=out[2];
		if(t.check1(n)) chain.push(t); 
	}

	printf("%lld\n",count);


}
int main(int, char **)
{
	int T;
	ll N;
	scanf("%d",&T);
	while(T--)
	{
		
		scanf("%lld",&N);
	//	for(ll N =0; N<= 100;++N)
		{

		//	test(N);
			Count(N);
		}
//		break;
	}

	return 0;
}

