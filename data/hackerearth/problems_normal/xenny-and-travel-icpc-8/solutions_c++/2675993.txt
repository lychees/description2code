#include <bits/stdc++.h>
using namespace std;
int a[1255][1255], b[1255][1255];
struct jer {
  int x, d;
  bool operator<(const jer& o) const {
    return d > o.d;
  }
};
int d1[1255], d2[1255], d3[1255], d4[1255];
bool visited[1255];
int best[1255];
int n;
void dijk(int src, int d[1255][1255], int* dist, bool rev) {
  priority_queue<jer> pq;
  pq.push({src, 0});
  memset(visited, 0, sizeof visited);
  memset(best, 1, sizeof best);
  while (!pq.empty()) {
    jer f = pq.top();
    pq.pop();
    if (visited[f.x]) continue;
    visited[f.x] = true;
    dist[f.x] = f.d;
    for (int i = 1; i <= n; i++) {
      if (visited[i]) continue;
      int d2 = f.d + (rev ? d[i][f.x] : d[f.x][i]);
      if (d2 >= best[i]) continue;
      best[i] = d2;
      pq.push({i, d2});
    }
  }
}
void solve() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      scanf("%d", &a[i][j]);
    }
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      scanf("%d", &b[i][j]);
    }
  }
  int u, v, ans = 99999999;
  scanf("%d %d", &u, &v);
  dijk(u, a, d1, false);
  dijk(v, a, d2, true);
  dijk(u, b, d3, false);
  dijk(v, b, d4, true);
  for (int i = 1; i <= n; i++) {
    if (i == u || i == v) {
      continue;
    }
    //printf("%d: %d %d %d %d\n", i, d1[i], d2[i], d3[i], d4[i]);
    ans = min(ans, d1[i] + d4[i]);
    ans = min(ans, d2[i] + d3[i]);
  }
  printf("%d\n", ans);
  return ;
}
int main() {
  int T = 1;
  //scanf("%d", &T);
  while (T--) {
    solve();
  }
  return 0;
}
