#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <functional>
#include <utility>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#define endl "\n"
#define pb push_back
#define sz() size()
#define all(a) a.begin(),a.end()
#define mp make_pair
#define ff first
#define ss second
#define mod 1000000007
#define d(x) printf(#x" = %d",x)
#define pl puts("")
#define ps pc(' ')
#define gc getchar_unlocked
#define pc putchar_unlocked
#define bitcount __builtin_popcount
#define gcd __gcd
#define SZ 1250
#define INF 1250000
using namespace std;
typedef long long ll;
typedef vector <int> vi;
typedef pair<int,int> pii;
#ifdef _WIN32
int getchar_unlocked() { return getchar(); }
int putchar_unlocked(char c) { return putchar(c); }
#endif
template <typename T>void sc(T &n){register int f=1;n=0;char c=gc();while(c!='-'&&c<'0')c=gc();if(c=='-')f=-1,c=gc();while(c>='0'&&c<='9')n=(n<<3)+(n<<1)+c-'0',c=gc();n=n*f;}
template <typename T>void pr(T &a){char s[30];if(a<0){pc('-');a*=-1;}int i=0;do{s[i++]=a%10+'0';a/=10;}while(a);i--;while(i>=0)pc(s[i--]);}
template <typename T>T sub(T x,T y){if(x<y)return y-x;return x-y;}
int n;
bool sptset[SZ];
int road[SZ][SZ];
int rail[SZ][SZ];
int droad[SZ];
int drail[SZ];
int transroad[SZ][SZ];
int transrail[SZ][SZ];
int mindist(int *dist)
{
    int i,min=INF,pos;
    for(i=0;i<n;i++)
        if(dist[i]<=min && !sptset[i])
            min=dist[i],pos=i;
    return pos;
}
void dijkstra(int *dist,int src,int adj[][SZ])
{
	int i,j;
	memset(sptset,0,sizeof(sptset));
	for(i=0;i<n;i++)dist[i]=INF;
	dist[src]=0;
	
    for(i=1;i<n;i++)//shortest path tree contains n-1 edges only
    {
        int x=mindist(dist);
        sptset[x]=1;
        for(j=0;j<n;j++)
        {
            if(adj[x][j]!=INF && !sptset[j] && (dist[x]+adj[x][j])<dist[j])
                dist[j]=dist[x]+adj[x][j];
        }
    }
}
int main()
{	
	sc(n);
	int i,j,k;
	
	for(i=0;i<n;i++)for(j=0;j<n;j++)sc(road[i][j]);
	for(i=0;i<n;i++)for(j=0;j<n;j++)sc(rail[i][j]);
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
		{	transroad[i][j]=road[j][i];
			transrail[i][j]=rail[j][i];
		}
	int st,end;
	sc(st); sc(end);
	st--;
	end--;
	dijkstra(droad,st,road);//start from road
	dijkstra(drail,end,transrail);//then rail
	int ans=INF;
	for(i=0;i<n;i++)
	{
		if(i==st || i==end)continue;
		if(droad[i]+drail[i]<ans)
			ans=droad[i]+drail[i];
	}
	dijkstra(drail,st,rail);
	dijkstra(droad,end,transroad);
	for(i=0;i<n;i++)
	{
		if(i==st || i==end)continue;
		if(droad[i]+drail[i]<ans)
			ans=droad[i]+drail[i];
	}
	pr(ans);
	return 0;
}