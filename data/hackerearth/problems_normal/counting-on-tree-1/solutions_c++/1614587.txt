#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <utility>
#include <cstdlib>
#include <memory>
#include <queue>
#include <cassert>
#include <cmath>
#include <ctime>
#include <complex>
#include <bitset>

using namespace std;

#define pb push_back
#define fst first
#define snd second
#define mp make_pair 
#define sz(C) ((int) (C).size())
#define forn(i, n) for (int i = 0; i < (int) n; ++i)
#define ford(i, n) for (int i = ((int) n) - 1; i >= 0; --i)
#define y1 gftxdtrtfhyjfctrxujkvbhyjice
#define y0 ehfoiuvhefroerferjhfjkehfjke
#define left sdhfsjkshdjkfsdfgkqqweqweh
#define right yytrwtretywretwreytwreytwr
#define next jskdfksdhfjkdsjksdjkgf
#define prev koeuigrihjdkjdfj
#define hash kjfdkljkdhgjdkfhgurehg
#define all(C) begin(C), end(C)

typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair <int,int> pii;
typedef pair <ll, ll> pll;
typedef vector <ll> vll;
typedef vector <int> vi;
typedef vector <vector <int> > vvi;
typedef vector <pii> vii;
typedef long double ld;
typedef complex<double> cd;
typedef vector<cd> vcd;

const double EPS = 1e-9;
const int MAXN = 5e4 + 10;
const int MAXK = 100 + 5;
const int MOD = 1e9 + 7;

inline void add(int& x, int y) {
  (x += y) >= MOD && (x -= MOD); 
}

vi g[MAXN];
int a[MAXN];
bool used[MAXN];
int sz[MAXN];
int n, k;
int dp[MAXN][MAXK];
int sum_dp[MAXN][MAXK];
int pos[MAXN];
int parent[MAXN];
int sum[MAXN];
vi top;

inline void dfs_sz(int v, int par) {
  sz[v] = 1;
  for (int to : g[v]) {
    if  (used[to] || to == par) {
      continue;
    }
    dfs_sz(to, v);
    sz[v] += sz[to];
  }
}

inline int centroid(int v, int par, int sz_all) {
  int mx_to = -1;
  for (int to : g[v]) {
    if  (used[to] || to == par) {
      continue;
    }
    if  (mx_to == -1 || sz[to] > sz[mx_to]) {
      mx_to = to;
    }
  }

  if  (mx_to == -1 || sz[mx_to] * 2 <= sz_all) {
    return v;
  }

  return centroid(mx_to, v, sz_all);
}

inline void dfs_top(int v, int par) {
  parent[v] = par;
  sum[v] = a[v];
  for (int to : g[v]) {
    if  (used[to] || to == par) {
      continue;
    }
    dfs_top(to, v);
    sum[v] += sum[to];
  }
  top.pb(v);
}

int calc(int v) {
  dfs_sz(v, -1);
  int root = centroid(v, -1, sz[v]);
  top.clear();
  dfs_top(root, -1);
  reverse(all(top));

  forn(i, sz(top)) {
    pos[top[i]] = i;
  }

/*
  printf("root = %d\n", root + 1);
  for (int v : top) {
    printf("%d ", v + 1);
  }
  puts("\n");
*/
  
  int ans = 0;
  if  (sum[root] >= k) {
    forn(i, sz(top) + 1) forn(j, k + 1) dp[i][j] = sum_dp[i][j] = 0;

    dp[0][a[top[0]]] = 1;
    sum_dp[0][a[top[0]]] = 1;
    for (int i = 1; i < sz(top); ++i) {
      int v = top[i];
      for (int j = 0; j <= k; ++j) {
        // take v
        if  (j - a[v] >= 0) {
          add(dp[i][j], sum_dp[i - 1][j - a[v]]);
          int pos_par = pos[parent[v]];
          if  (pos_par - 1 >= 0) {
            add(dp[i][j], - sum_dp[pos_par - 1][j - a[v]] + MOD);
          }
        }
      }

      for (int j = 0; j <= k; ++j) {
        sum_dp[i][j] = dp[i][j];
        add(sum_dp[i][j], sum_dp[i - 1][j]);
      } 
    }

    forn(i, sz(top)) {
      add(ans, dp[i][k]);
    }   
  }
  
  used[root] = true;
  for (int to : g[root]) {
    if  (!used[to]) {
      add(ans, calc(to));
    }
  }

  return ans;
}

int solve() {
  scanf("%d%d", &n, &k);
  forn(i, n) scanf("%d", &a[i]);
  forn(i, n - 1) {
    int v, u;
    scanf("%d%d", &v, &u);
    --v;
    --u;

    g[v].pb(u);
    g[u].pb(v);
  }

  memset (used, false, sizeof used);
  int ans = calc(0);

  forn(v, n) {
    g[v].clear();
  } 

  return ans;
}

int main() {
#ifdef LOCAL
  freopen(".in", "r", stdin);
//  freopen(".out", "w", stdout);
#endif

  int T;
  scanf("%d", &T);
  while (T--) {
    printf("%d\n", solve());
  }

  return 0;
}
