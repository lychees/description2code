#include <bits/stdc++.h>
#define FOR(x,n) for(int x = 0; x < n; x++)
#define MAXN 101
#define ll long long
using namespace std;

//node: 1..n
int n;
vector<int> edges[MAXN] = {}, colors(MAXN);
int dp[MAXN][MAXN] = {}; //dp[node  ][can't use colorID]

struct NetworkFlow{
    struct Edge{ int from, to, cap, cost; };
    vector<Edge> E;     vector<int> dist, P;
    vector< vector<int> > adj;  
    int N;

    NetworkFlow(int NN): N(NN) { adj.resize(N); }

    void addEdge(int from, int to, int cap, int cost){
        adj[from].push_back(E.size());     E.push_back(Edge{from,to,cap, cost});
        adj[to].push_back(E.size());     E.push_back(Edge{to,from,0,-cost});
    }

    bool find_path(int s, int t){
        P.assign(N,-1); P[s] = s;
        dist.assign(N, 1<<28); dist[s] = 0;        
        queue<int> q; q.push(s);
        bitset<300> in_queue; in_queue[s] = 1;
        while(!q.empty()){
            int u = q.front(); q.pop(); in_queue[u] = 0;
            for(int eID : adj[u]){
                int v = E[eID].to;
                if(E[eID].cap && dist[v] > dist[u] + E[eID].cost) {
                    dist[v] = dist[u] + E[eID].cost, P[v] = eID;
                    if(!in_queue[v])
                        q.push(v), in_queue[v] = 1;
                }
            }
        }
        return P[t] != -1;
    }

    pair<int,int> getMF(int s, int t){
        int mf = 0, cost = 0;
        while(find_path(s,t)){
            int mnE = (int)1e9;
            for(int u = t; u != s; u = E[P[u]].from) mnE = min(mnE, E[P[u]].cap);
            for(int u = t; u != s; u = E[P[u]].from)
                E[P[u]].cap -= mnE, E[P[u]^1].cap += mnE, cost += E[P[u]].cost * mnE;
            mf += mnE;
        }        
        return {mf,cost};
    }
};

int dfs(int u, int c, int p){
    if(dp[u][c] != -1) return dp[u][c];
    dp[u][c] = colors[c];
    
    NetworkFlow g = NetworkFlow(2*MAXN+2);
                
    map<int,int> m;
    for(int x = 1; x <= edges[u].size(); x++){
        m[x] = edges[u][x-1];
        g.addEdge(0,x,1,0);
    }
    
    for(int colors = 1; colors < n; colors++) {
        for(int x = 1; x <= edges[u].size(); x++)
            if(m[x] != p && colors != c)
                g.addEdge(x, edges[u].size()+colors, 1, dfs(m[x],colors,u));
        g.addEdge(colors+edges[u].size(), 2*MAXN+1, 1, 0);
    }
    return dp[u][c] += g.getMF(0, 2*MAXN+1).second;
}

int main(){
    int T; cin >> T;
    
    while(T--){
        memset(dp, -1, (sizeof dp[0][0]) * MAXN * MAXN);
        FOR(x,MAXN) edges[x].clear(), colors[x] = 0;
        
        cin >> n;
        
        for(int x = 1; x < n; x++) cin >> colors[x];
        for(int x = 1; x < n; x++) {
            int u, v; cin >> u >> v;
            edges[u].push_back(v); edges[v].push_back(u);
        }
        
        cout << dfs(1,0,-1) << '\n';
    }
}