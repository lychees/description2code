#include <bits/stdc++.h>
using namespace std;
#define ll long long

const long double pi = acos(-1.0);
typedef complex<long double> base;
inline ll rev(ll num, ll lg){
	ll res = 0;
	for (ll i = 0; i < lg; i++) if (num & (1 << i)) res |= (1 << (lg - i - 1));
	return res;
}
void fft(vector <base>& a, bool inv)
{
	ll n = a.size();
	for (ll i = 1, j = 0; i < n; i++)
	{
		ll bit = n >> 1;
		for (; j >= bit; bit >>= 1) j -= bit;
		j += bit;
		if (i < j) swap(a[i], a[j]);
	}
	for (ll len = 2; len <= n; len <<= 1)
	{
		long double ang = 2 * pi / len * (inv ? -1 : 1);
		base wlen(cos(ang), sin(ang));
		for (ll i = 0; i < n; i += len)
		{
			base w(1);
			for (ll j = 0; j < len/2; j++, w *= wlen)
			{
				base u = a[i+j], v = a[i+j+len/2] * w;
				a[i+j] = u + v, a[i+j+len/2] = u - v;
			}
		}
	}
	if (inv)
		for (ll i = 0; i < n; i++)
			a[i] /= n;
}
void multiply(vector<ll> &a, vector<ll> &b, vector <ll> &res){
	vector <base> ta(a. begin(), a.end()), tb(b.begin(), b.end());
	ll n = 1, mx = max(a.size(), b.size());
	while (n < mx) n *= 2; n *= 2;
	ta.resize(n); tb.resize(n);
	fft(ta, false); fft(tb, false);
	for (ll i = 0; i < n; i++) ta[i] *= tb[i];
	fft(ta, true);
	res.resize(n);
	for (ll i = 0; i < n; i++) res[i] = (ll)(ta[i].real() + 0.5);
}
vector <ll> a;
vector <ll> p1(100010), p2(100010), res(100010);
ll ret;
int main()
{
	ll n; scanf("%lld", &n);
	for (ll i = 0; i < n; i++){
		ll temp; scanf("%lld", &temp);
		a.push_back(temp);
	}
	sort(a.begin(), a.end());
	ll mx = a[n-1];
	ret = 0;
	for (int i = 0; i < n; i++){
		p1[a[i]]++;
		p2[mx - a[i]]++;
	}
	multiply(p1, p2, res);
	for (ll i = mx + 1; i < res.size(); i++) ret += (res[i] > 0);
	//~ cerr<<(unique(a.begin(), a.end()) != a.end())<<endl;
	printf("%lld", ret + (unique(a.begin(), a.end()) != a.end()));
	return 0;
}
