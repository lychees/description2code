#include <stdio.h>
#include<bits/stdc++.h>
using namespace std;

int n;
int m;
int x;
int a;
int c;
int MOD;

int X;

int getnex(){
	x=((long long int)x*(long long int)a+(long long int)c)%(long long int)(MOD);
	return x;
}

set<pair<int,pair<int,int> > > q;

int belong[100002];
int dar[100002];
int ii=0;
int root(int b){
	ii=0;
	dar[0]=b;
	ii++;
	while(belong[b]!=-1){
		b=belong[b];
		dar[ii]=b;
		ii++;
	}
	ii--;
	while(ii>=0){
		if(dar[ii]!=b){
			belong[dar[ii]]=b;
		}
		ii--;
	}
	return b;
}
void merge(int a,int b){
	a=root(a);
	b=root(b);
	belong[a]=b;
}
pair<int,pair<int,int> >  F[1];
long long int ans=0;
int main()
{
	memset(belong,-1,sizeof(belong));
   cin>>n>>m>>x>>a>>c>>MOD;
   X=x;
   while(1){
   		x=X;
	 auto it=q.begin();
	 for(int i=0;i<m;i++){
   		int aa=getnex()%n;
   		int bb=getnex()%n;
   		int cc=getnex();
   		if(root(aa)==root(bb)){
   			continue;
   		}
   		q.insert(make_pair(cc,make_pair(aa,bb)));
   		if(q.size()>100000){
   			it=q.end();
   			it--;
   			q.erase(it);
   		}
	 }
	 for(auto it=q.begin();it!=q.end();it++){
   		F[0]=(*it);
   		int i=0;
	 	if(root(F[i].second.first)!=root(F[i].second.second)){
	 		ans+=(long long int)F[i].first;
	 		merge(F[i].second.first,F[i].second.second);
	 	}
	 }
	 q.clear();
	 int f=root(0);
	 bool ok=false;
	 for(int i=0;i<n;i++){
	 	if(f!=root(i)){
	 		ok=true;
	 	}
	  }
	if(ok==false){
   		break;
   	}
   }
   printf("%lld\n",ans);
    return 0;
}
