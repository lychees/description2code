#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <map>
#include <set>
#include <vector>
#include <utility>
#include <queue>
#include <stack>

#define sd(x) scanf("%d",&x)
#define sd2(x,y) scanf("%d%d",&x,&y)
#define sd3(x,y,z) scanf("%d%d%d",&x,&y,&z)

#define fi first
#define se second
#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define LET(x, a)  __typeof(a) x(a)
#define foreach(it, v) for(LET(it, v.begin()); it != v.end(); it++)

#define _ ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define __ freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);

#define tr(x) cout<<x<<endl;
#define tr2(x,y) cout<<x<<" "<<y<<endl;
#define tr3(x,y,z) cout<<x<<" "<<y<<" "<<z<<endl;
#define tr4(w,x,y,z) cout<<w<<" "<<x<<" "<<y<<" "<<z<<endl;
#define tr5(v,w,x,y,z) cout<<v<<" "<<w<<" "<<x<<" "<<y<<" "<<z<<endl;
#define tr6(u,v,w,x,y,z) cout<<u<<" "<<v<<" "<<w<<" "<<x<<" "<<y<<" "<<z<<endl;

using namespace std;

const int N = 1<<15;

vector<int> primes;
vector<pair<int,int> > c[N];
int n, a[N];
long long ans, MOD = 1e9 + 7;

struct node{
	int cnt;
	void assign(int value){
		cnt = value;
	}
	void update(int value){
		cnt = value;
	}
	void combine(node &left, node &right){
		cnt = max(left.cnt, right.cnt);
	}
};

node tree[200][4*N];

// [l, r)
void build(int i, int id = 1, int l = 0, int r = n){
	if(l+1 == r){
		tree[i][id].assign(0);
		return;
	}
	int left = id<<1, right = left+1, mid = (l+r)>>1;
	
	build(i, left, l, mid); build(i, right, mid, r);
	
	tree[i][id].combine(tree[i][left], tree[i][right]);
	return;
}

// point update -> update(index, value);
void update(int i, int index, int val, int id = 1, int l = 0, int r = n){
	if(l+1 == r){
		tree[i][id].assign(val);
		return;
	}
	int left = id<<1, right = left+1, mid = (l+r)>>1;
	
	if(index < mid) update(i, index, val, left, l, mid);
	else update(i, index, val, right, mid, r);
	
	tree[i][id].combine(tree[i][left], tree[i][right]);
}

// range query -> query(x, y);
int query(int i, int x, int y, int id = 1, int l = 0, int r = n){
	if(x >= r or l >= y) return 0;
	if(x <= l && r <= y) return tree[i][id].cnt;
	
	int left = id<<1, right = left+1, mid = (l+r)>>1;
	
	return max(query(i, x, y, left, l, mid), query(i, x, y, right, mid, r));
}

long long fast(long long a, int b){
	long long ret = 1;
	while(b){
		if(b%2) ret = (ret*a)%MOD;
		a = (a*a)%MOD;
		b >>= 1;
	}
	return ret;
}

int main(){
	primes.pb(2);
	for(int i = 3; i < 1000; i += 2){
		bool ok = true;
		foreach(it, primes){
			if(i%(*it) == 0) ok = false;
		}
		if(ok) primes.pb(i);
	}
	
	sd(n);
	for(int i = 0; i < n; i++){
		sd(a[i]);
		
		for(int j = 0; j < primes.size() and  primes[j] <= a[i]; j++){
			if(a[i]%primes[j] == 0){
				int cnt = 0;
				while(a[i]%primes[j] == 0){
					a[i] /= primes[j];
					cnt++;
				}
				c[i].pb(mp(j, cnt));
			}
		}
	}
	
	for(int i = 0; i < n; i++){
		foreach(it, c[i]){
			update(it->fi, i, it->se);
		}
	}
	
	int q;
	sd(q);
	while(q--){
		int type; sd(type);
		if(type == 1){
			int i, j; sd2(i,j);
			i--;
			a[i] = j;
			
			foreach(it, c[i]){
				update(it->fi, i, 0);
			}
			
			c[i].clear();
			
			for(int j = 0; j < primes.size() and primes[j] <= a[i]; j++){
				if(a[i] % primes[j] == 0){
					int cnt = 0;
					while(a[i]%primes[j] == 0){
						a[i] /= primes[j];
						cnt++;
					}
					c[i].pb(mp(j, cnt));
				}
			}
			
			foreach(it, c[i]){
				update(it->fi, i, it->se);
			}
			
		}
		else{
			int l, r; sd2(l,r);
			l--;
			
			ans = 1;
			for(int i = 0; i < primes.size(); i++){
				ans = (ans * fast(primes[i],query(i,l,r)))%MOD;
			}
			
			printf("%lld\n", ans);
		}
	}
	
	return 0;
}