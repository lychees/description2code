// URL
// 
//     https://www.hackerearth.com/problem/algorithm/costly-phone-number-december-easy-easy-medium/
// 
// DESCRIPTION
// 
//     A cell phone company is trying out its new model of cell phone.
//     Here's how its structure is:
//     
//     The keypad has 11 buttons corresponding to digits from 0 to 9 and one additional button called Add.
//     After pressing any button from 0 to 9, the corresponding digit appears on the screen.
//     The Add button replaces the last two digits appearing on the screen with their sum taken modulo 10.
//     (See sample test for more clarity).
//     If there are less than two digits currently on the screen, pressing Add does nothing.
//     
//     Each button has a non-negative cost of pressing associated with it.
//     The cost of pressing Add button is always 0.
//     Given the cost of pressing each button and the target phone number,
//     find the minimum cost of feeding that number into the phone screen using a sequence of button presses.
// 
// INPUT
// 
//     The first line of input file consists of an integer T, which indicates the number of test cases.
//     Then the description of T test cases follow. Each test case is described by 3 lines.
//     The first of them contains 10 space separated integers, denoting the cost of pressing buttons from 0 to 9.
//     The second line contains the length of the target phone number.
//     The third line contains the target phone number S itself.
// 
// OUTPUT
// 
//     Print the minimum cost of feeding the phone screen with the target number for each test case in a separate line.
// 
// CONSTRAINTS
// 
//     1 <= T <= 1000
//     0 <= Cost of any button <= 1000
//     1 <= |S| <= 1000
// 
// SAMPLE INPUT
//
//     3
//     3 2 2 3 2 1 1 2 3 3 
//     3
//     171
//     3 2 3 1 1 1 1 3 1 2 
//     2
//     16
//     3 3 3 1 3 1 1 2 3 2 
//     2
//     43
// 
// SAMPLE OUTPUT
//
//     6
//     3
//     4
// 
// EXPLANATION
//
//     For Test Case 1: Button sequence with cost in brackets:
//     Press 6 (1) -> Press 5 (1) -> Press "Add" (0) -> Press 7 (2) -> Press 6 (1) -> Press 5 (1)-> Press "Add" (0).
//     
//     Total Cost = 1 + 1 + 0 + 2 + 1 + 1 + 0 = 6.
// 
// TESTCASE #1:
// 
//       d  : 0123456789
//     c(d) : 1219911991
//     cphn(793) = ?
//     d=7: c(7) = 9 <= [c(9) + c(8) = 2]
//     d=9: c(9) = 1
//     c(9) + c(4) = 1 + 9 = 10
//     d=3: c(9) + c(9) + c(5) = 3
//     9+9 === 8 (mod 10)
//     8+5 === 3 (mod 10)
//
//     cphn(793) = 2+1+3=6
//
//     c(793) <= [c(7) + c(9) + c(3) = 9+1+9 = 19]
//

#include <iostream>
    using std::cout;
    using std::endl;
    using std::cin;
#include <vector>
    using std::vector;

int main()
{
    vector<unsigned int> costs(10); // costs per digit
    unsigned int n;                 // number of testcases
    unsigned int pnl;               // phone number length
    
    // Read number of testcases
    cin >> n;

    for (unsigned int i = 0; i < n; i++)
    {
        // Read costs for pressing digit buttons
        for (unsigned int d = 0; d < 10; d++)
        {
            cin >> costs[d];
        }

        // Read phone number length
        cin >> pnl;

        // Calculate mincost for each digit by repeatedly trying
        // to lower the digit costs, until they have reached their
        // optimal minimum.
        // Every time that a better cost is found for a certain digit,
        // the costs for the other digits could potentially be improved
        // and at least one more iteration is necessary to check this.
        // This is achieved by setting a flag variable to false
        // and changing its value to true if a more optimal cost was
        // found. As long as the flag remains true (that is: as long
        // as at least one more optimal cost was found), other costs could
        // potentially be made more optimal. The iteration ends if no more
        // digit costs could be made more optimal.
        for (bool relax = true; relax; )
        {
            relax = false;

            for (unsigned int i = 0; i < costs.size(); ++i)
            {
                for (unsigned int j = i; j < costs.size(); ++j)
                {
                    unsigned int d = (i + j) % 10;

                    if (costs[i] + costs[j] < costs[d])
                    {
                        costs[d] = costs[i] + costs[j];
                        relax = true;
                    }
                }
            }
        }
        
        // Read a phone number and calculate its minimum cost
        unsigned int cost = 0;
        char digit;

        for (unsigned int i = 0; i < pnl; i++)
        {
            cin >> digit;
            cost += costs[digit - '0'];
        }

        // Output mincost for this phone number
        cout << cost << endl;
    }

    return 0;
}

