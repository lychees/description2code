def mergeSort(a, low, high):
    if low >= high:
        return
    mid = (low + high) / 2
    mergeSort(a, low, mid)
    mergeSort(a, mid+1, high)
    merge(a, low, mid, high)


def merge(a, low, mid, right):
    count = 0
    p = low
    q = mid + 1
    aux = []

    for i in range(right - low + 1):  # for the first part
        if p > mid:  # first part exhausted
            aux.append(a[q])
            q += 1
            continue
        if q > right:  # second half exhausted
            aux.append(a[p])
            p += 1
            if p <= mid:
                inv[weights[a[p]]] += count
            continue
        if a[p] > a[q]:
            count += 1
            aux.append(a[q])
            inv[weights[a[p]]] += 1
            q += 1
        else:
            aux.append(a[p])
            p += 1
            if p <= mid:  # carry forward the count to the next element in queue
                inv[weights[a[p]]] += count

    for i in range(right - low + 1):
        a[low + i] = aux[i]


t = int(raw_input())

inv = []
weights = {}
for i in range(t):
    n = int(raw_input())
    a = [int(raw_input()) for j in range(n)]
    inv = [0 for j in range(n)]
    for j in range(len(a)):
        weights[a[j]] = j
    mergeSort(a, 0, n-1)

    for j in inv:
        print j,
    print
