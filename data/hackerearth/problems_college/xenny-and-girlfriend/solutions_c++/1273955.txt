#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define ll long long
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define pb push_back
ll pwr(ll a,ll b,ll mod)
{
  ll ans=1;
  while(b)
  {
    if(b&1)
      ans=(ans*a)%mod;
    a=(a*a)%mod;
    b/=2;
  }
  return ans;
}
ll pwr(ll a,ll b)
{
  ll ans=1;
  while(b)
  {
    if(b&1)
      ans*=a;
    a*=a;
    b/=2;
  }
  return ans;
}
ll gcd(ll a,ll b)
{
  while(b)
    {
      ll temp=a;
      a=b;
      b=temp%b;
    }
  return a;
}
ll lcm(ll a,ll b)
{  
  return (a/gcd(a,b))*b;
}
ll modularInverse(ll a,ll m)
{     
      /*reminder: make sure m is prime*/
      assert(false);
      return pwr(a,m-2,m);
}
const int mod=1000000007;

vector<int> nbrs[10001];
int deg[10001];
bool vis[10001];
int cnt=0;
void dfs(int x)
{
  ++cnt;
  vis[x]=true;

  for(int i=0;i<nbrs[x].size();++i)
  {
    int v=nbrs[x][i];
    if(vis[v])
      continue;
    dfs(v);

  }
}
int main()
{
  std::ios::sync_with_stdio(false);
  
  int t;
  cin>>t;
  while(t--)
  {
    int n,m;
    cin>>n>>m;
    cnt=0;
    for(int i=1;i<=10000;++i)
      nbrs[i].clear();
    memset(vis,false,sizeof vis);
    memset(deg,false,sizeof deg);

    while(m--)
    {
      int u,v;
      cin>>u>>v;
      ++deg[u];
      ++deg[v];
      nbrs[u].pb(v);
      nbrs[v].pb(u);
    }

    dfs(1);
    int odd=0;
    for(int i=1;i<=n;++i)
    {
      if(deg[i]&1)
        ++odd;
    }

    if((odd==0 || odd==2) && cnt==n)
      cout<<"Yes\n";
    else
      cout<<"No\n";
  }
   


}