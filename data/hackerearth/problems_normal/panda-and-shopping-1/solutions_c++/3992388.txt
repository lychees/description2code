#include <bits/stdc++.h>
using namespace std;

const int maxn = 100010;
long long segtree[1000000];

void update(int idx , long long val , int l , int r , int pos)
{
	if(l > idx or r < idx) return ;
	if(l == r && r == idx){
		if(val > segtree[pos])
			segtree[pos] = val;
		return;
	}
	int mid = (l + r) >> 1;
	update(idx , val , l , mid , 2*pos);
	update(idx , val , mid+1, r , 2*pos + 1);
	segtree[pos] = max(segtree[2*pos] , segtree[2*pos + 1]);
}

long long query(int leftQuery, int rightQuery, int l, int r,int pos)
{
	if(l > rightQuery or r < leftQuery or l > r) return 0;
	else if(l >= leftQuery && r <= rightQuery) return segtree[pos];
	int mid = (l + r) >> 1;
	long long L = query(leftQuery,rightQuery,l,mid,2*pos);
	long long R = query(leftQuery,rightQuery,mid+1,r,2*pos+1);
	return max(L,R);
}

vector< pair<long,int> > arr;
int height[maxn];
long long value[maxn];

bool cmp(const pair<long,int> &A, const pair<long,int> &B)
{
	return ((A.first < B.first) or (A.first == B.first && A.second < B.second));
}

int main()
{
	int n;
	cin >> n;
	arr.resize(n);
	for(int i = 1; i <= n; i++){
		cin >> height[i] >> value[i];
		arr[i-1].first = value[i];
		arr[i-1].second = i;
	}
	sort(arr.begin(),arr.end(),cmp);
	long long ans = 0;
	for(int i = 0; i < n; i++){
		int idx = arr[i].second;
		long long temp = query(1,idx-1,1,n,1);
		temp = temp + height[idx];

		if(temp < 0)
			temp = 0;

		if(ans < temp)
			ans = temp;

		update(idx,temp,1,n,1);
	}
	cout << ans;
	return 0;
}