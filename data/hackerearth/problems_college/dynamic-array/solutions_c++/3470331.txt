#include<bits/stdc++.h>
#define ll long long
#define gc getchar_unlocked
#define pc putchar_unlocked
#define repl(i, a, b) for(i=a; i<b; i++)
#define repe(i, a, b) for(i=a; i<=b; i++)
#define per(i, a, b) for(i=a; i>=b; i--)
#define vi vector<int>
#define vl vector<long>
#define vll vector<long long>
#define pb(x) push_back(x)
#define ppb pop_back()
#define lt(i) (i<<1)
#define rt(i) ((i<<1)+1)
#define mp(a, b) make_pair(a, b)
#define ln length()
#define ms0(a) memset(a, 0, sizeof(a))
#define sz size()
#define md(a, b) ((a+b)>>1)
#define ff first
#define ss second
#define pii pair<int, int>
#define pll pair<long, long>
#define pLL pair<long long, long long>
#define all(v) v.begin(),v.end()
#define pn pc('\n');
using namespace std;


void sll(ll &x)
{
    register char c = gc();
    x = 0;
    int neg = 0;
    for(;((c<48 || c>57) && c != '-');c = gc());
    if(c=='-') {neg=1;c=gc();}
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
    if(neg) x=-x;
}

void wll(ll a)
{
        if(a<0)
        {
                pc('-');
                a=-a;
        }

        char snum[100];
        int i=0;
        do
        {
                snum[i++]=a%10+48;
                a=a/10;
        }
        while(a!=0);
        --i;
        while(i>=0)
        putchar_unlocked(snum[i--]);
        putchar_unlocked('\n');
}

ll power(ll a, ll b, ll mod)
{
        ll ret = 1 ;
        while(b)
        {
                if(b & 1 ) ret = ret*a % mod;
                a = a*a % mod;
                b >>= 1 ;
        }
        return ret;
}
ll gcd(ll a, ll b)
{
    while(b) b ^= a ^= b ^= a %= b;
    return a;
}
#define N 1000000
pLL tree[N<<2];
void update(ll s, ll e, ll x, ll val, ll i){
	if(s == e){
		tree[i].ff+=val;
		tree[i].ss=0;
		if(tree[i].ff!=0)
		tree[i].ss=x;
		return;
	}	
	ll m=md(s,e);
	if(x<=m)update(s, m, x, val, lt(i));	
	else update(m+1, e, x, val, rt(i));
	tree[i].ff=tree[lt(i)].ff+tree[rt(i)].ff;
	tree[i].ss=gcd(tree[lt(i)].ss, tree[rt(i)].ss);
}
ll q1(ll s, ll e, ll x, ll i){
	if(s == e)return s;
	ll m=md(s,e);
	if(tree[lt(i)].ff >= x)return q1(s, m, x, lt(i));
	else return q1(m+1, e, x-tree[lt(i)].ff, rt(i));
}

ll q2(ll s, ll e, ll l, ll r, ll i){
	if(l <= s && e <= r){
		return tree[i].ss;
	}
	if(l > e || s > r)return 0;
	ll left=q2(s, md(s,e), l, r, lt(i));
	ll right=q2(md(s,e)+1, e, l, r, rt(i));
	return gcd(left, right);
}
int main()
{
	ll t, i, j, k, l;
	repl(i,0,N<<2)tree[i]=mp(0,0);
	sll(t);
	int flag=0;
	while(t--)
	{
		ll x, y;
		ll ans;
		sll(k);sll(x);
		if(k == 1){update(1, N, x, 1, 1);}
		if(k == 2){update(1, N, x, -1, 1);}
		if(k == 3)wll((q1(1, N, x, 1)));
		if(k == 4){sll(y);wll(q2(1, N, x, y, 1));}
	}
	return 0;
}