#pragma region Template
#include <cstdio>
#include <cstring>
#include <vector>
#include <map>
#include <vector>
#include <list>
#include <utility>
#include <functional>
#include <algorithm>
#include <set>
#include <stack>
#include <cassert>
#include <cctype>
#include <cmath>
#include <deque>
#include <iostream>
#include <string>
#include <queue>

using namespace std;

#define SZ(a)        ((int)a.size())
#define LENGTH(a)    ((int)a.length())
#define ALL(a)       a.begin(), a.end()
#define REP(i, n)    for(int i = 0; i < (n); i++)
#define INC(i, a, b) for(int i = (a); i <= (b); i++)
#define DEC(i, a, b) for(int i = (a); i >= (b); i--)
#define CLEAR(a, b)  memset(a, b, sizeof a)
#define X            first
#define Y            second
#define si(a)        scanf("%d", &a)
#define ss(a)        scanf(" %s", a)
#define sll(a)       scanf("%lld", &a)

typedef long long int LL;

const double PI = acos(-1.0);
const double EPS = 1e-9;
const int    inf = 1000000000;
const LL     INF = ((LL)inf)*inf;
#pragma endregion

// Disjoint set
// Union find data-structure

class UnionFind {
private:
	vector<int> p, setSize;
	int numSets;
public:
	UnionFind(int N) {
		setSize.assign(N, 1); numSets = N;
		p.assign(N, 0); for (int i = 0; i < N; i++) p[i] = i;
	}
	int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }
	bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }
	void unionSet(int i, int j) {
		if (!isSameSet(i, j)) {
			numSets--;
			int x = findSet(i), y = findSet(j);
			p[x] = y;
			setSize[y] += setSize[x];
		}
	}
	int numDisjointSets() { return numSets; }
	int sizeOfSet(int i) { return setSize[findSet(i)]; }

	void setLead(int i) {
		int x = findSet(i);
		p[i] = p[x] = i;
	}
};

int main(void) {
	int n; int q; si(n); si(q);
	UnionFind tt(n);
	REP(i, q) {
		int t, u, v; si(t);
		if (t == 1) {
			si(u); si(v);
			tt.unionSet(u - 1, v - 1);
		}
		else if (t == 2) {
			si(u);
			tt.setLead(u - 1);
		}
		else if (t == 3) {
			si(u);
			printf("%d\n", tt.findSet(u - 1) + 1);
		}
	}
}