#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
using namespace std;
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, -1, 0, 1};
int numberOfPossiblePaths = 0;
vector <vector <bool> > visited;
bool isValid(int x, int y, vector <vector <int> > &matrix){
	int n = matrix.size();
	if(x >= 0 and x <= n - 1 and y >=0 and y <= n - 1){
		return true;
	}
	return false;
}
void PrisonBreak(int x, int y, vector <vector <int> > &matrix){
	int n = matrix.size();//nxn
	if(x == n-1 and y == n-1){//if destination is reached, BASE CASE
		numberOfPossiblePaths++;
		return;
	}
	else{
		visited[x][y] = true;//Mark (x,y) as visited
		for(int i = 0; i < 4; i++){
			int next_x = x + dx[i];
			int next_y = y + dy[i];
			if(isValid(next_x, next_y, matrix)){
				if(visited[next_x][next_y] == false and matrix[next_x][next_y] == 0){
					PrisonBreak(next_x, next_y, matrix);
					visited[next_x][next_y] = false;//backtrack step
				}
			}
		}
	}
}
int main(){
	int tests;
	cin>>tests;
	while(tests--){
		int n;
		cin>>n;
		numberOfPossiblePaths = 0;
		vector <vector <int> > matrix;
		matrix.assign(n, vector <int> (n, 0) );
		visited.assign(n, vector<bool> (n, false));
		for(int i = 0; i < n; i++){
			for(int j = 0; j < n; j++){	
				cin>>matrix[i][j];
			}
		}
		visited[0][0] = true;
		PrisonBreak(0,0, matrix);
		cout<<numberOfPossiblePaths<<endl;
	}
	return 0;
}
