#include <bits/stdc++.h>
using namespace std;
#define REP(i,n) for(int i=0;i<(int)(n);++i)
#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)
#define ALL(c) (c).begin(), (c).end()
#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)
#define tpl(...) make_tuple(__VA_ARGS__)
const int INF = 0x3f3f3f3f;
const double EPS = 1e-8;
const double PI = acos(-1);
typedef long long ll;
typedef pair<int,int> pii;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
template<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}
template<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}
template<int N,class Tp>void output(ostream&,const Tp&){}
template<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}
template<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}
template<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];
int k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}
template<class T>void outputs(T t){output(t);}
template<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}
template<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}
template<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}
template<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);
if(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}
template<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}

// bool check(ll x) {
//   ll sq = sqrt(x);
//   for (int i=-1; i<=1; ++i)
//     if ((sq+i)*(sq+i) == x)
//       return 1;
//   return 0;
// }
// int func(ll x) {
//   set<pii> S;
//   for (ll i=0; i*i<=x; ++i) {
//     if (check(x - i*i)) {
//       ll b = sqrt(x-i*i)+EPS;
//       S.emplace(i, b);
//       S.emplace(-i, -b);
//       S.emplace(-i, b);
//       S.emplace(i, -b);
//     }
//   }
//   // FOR(it, S) cout << *it << " ";
//   // cout << endl;
//   return (int)S.size();
// }

map<ll, int> factorize(ll n) {  // O(?n)
  map<ll, int> res;
  for (ll i=2; i*i<=n; ++i) {
    int cnt = 0;
    while (n%i==0) {
      n /= i;
      cnt++;
    }
    if (cnt) {
      res[i] = cnt;
    }
  }
  if (n!=1) res[n] = 1;
  return res;
}

template<int MOD>
struct ModInt {
  int x;
  ModInt() : x(0) {}
  ModInt(ll s) { if ((x = s % MOD) < 0) x += MOD; }
  ModInt operator+=(ModInt rhs) { if ((x+=rhs.x) >= MOD) x -= MOD; return *this; }
  ModInt operator-=(ModInt rhs) { if ((x-=rhs.x) < 0) x += MOD; return *this; }
  ModInt operator*=(ModInt rhs) { x = (ll)x*rhs.x % MOD; return *this; }
  ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }
  ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }
  ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }
  ModInt operator/=(ModInt rhs) {
    static const ll inv2 = ModInt(2).inv().x; // 2??????????????
    ll i = (rhs.x == 2 ? inv2 : rhs.inv().x);
    x = x*i%MOD; return *this;
  }
  ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }
  ModInt inv() { return pow(MOD-2); }
  ModInt pow(ll n) const {
    ModInt r = 1, t = x;
    for (;n;n>>=1,t*=t) if (n&1) r *= t;
    return r;
  }
  friend ostream& operator<<(ostream &os, const ModInt rhs){ return os << rhs.x; }
};
typedef ModInt<int(1e9+7)> mint;

mint func2(map<ll, int> mp) {
  mint ans = 1;
  bool ok = 1;
  bool hoge = 0;
  FOR(it, mp) {
    if (it->first % 4 == 3) {
      if (it->second % 2) return 0;
    } else if (it->first % 4 == 1) {
      hoge = 1;
      ans *= (it->second + 1);
      ok &= (it->second + 1) % 2 == 0;
    }
  }
  return ans;
  // cout << ans << endl;
  if (hoge && ok) ans /= 2;
  else ans = (ans - (mp[2]%2==0?1:-1)) / 2;
  // cout << ans << endl;
  return ans;
}

mint solve(map<ll,int> mp) {
  bool ok = 1;
  bool ok2 = 1;
  FOR(it, mp) {
    ok &= (it->second % 2 == 0);
    if (it->first > 2) ok2 &= it->second % 2 == 0;
    // cout << *it << endl;
  }
  mint ans = func2(mp)*4;
  // if (ok) ans -= 4;
  // if (ok2 && mp[2] >= 1 && mp[2] % 2 == 1) {
  //   ans -= 4;
  // }
  return ans;
}

int main() {
  // for (int i=1; i<=100000; ++i) {
  //   // if (i != 1) continue;
  //   map<ll,int> mp = factorize(i);
  //   assert(func(i) == solve(mp).x);
  //   // cout << i << " " << func(i) << " " << solve(mp) << endl;
  // }
  int n;
  while(cin >> n) {
    map<ll,int> mp;
    REP(i,n) {
      ll x; cin >> x;
      auto t = factorize(x);
      FOR(it, t) {
        mp[it->first] += it->second;
      }
    }
    auto ans = solve(mp);
    cout << ans << endl;
  }
}
