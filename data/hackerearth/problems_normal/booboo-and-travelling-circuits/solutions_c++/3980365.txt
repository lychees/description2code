// vipsharmavip ( Hunter )
#include<bits/stdc++.h>
#define mod 1000000003
#define ll long long
using namespace std;
ll pr[20001];
vector< ll > item[20001];
vector< ll > Left[20001];
vector< ll > Right[20001];
ll dp[20001];
ll A[20001] , B[20001] , Next[20001];
ll hashing[20001];
int main(){
   for(int i = 2 ; i <= 1e4 ; ++i ){
      if( !pr[i] ){
     for( int j = i ; j <= 1e4 ; j += i )
       if(!pr[j])
      pr[j] = i;
     }
   }
    ll N , M;
    cin >> N >> M;
      for(int i = 2 ; i <= M ; ++i ){
      item[pr[i]].push_back(i);
      Left[pr[i]].push_back(LONG_LONG_MAX);
      Right[pr[i]].push_back(LONG_LONG_MAX);
      hashing[i] = item[pr[i]].size() - 1;
      }
      ll s0 , p , q , r , w0 , x , y , z ;
      cin >> s0 >> p >> q >> r >> w0 >> x >> y >> z;
      for(int i = 1 ; i < N  ; ++i ){
       for(int j = 1 ; j <= M ; ++j ) {
        s0 =((((p*s0)%mod*s0)%mod + (q*s0)%mod)%mod + r)%mod;
        w0 =((((x*w0)%mod*w0)%mod + (y*w0)%mod)%mod + z)%mod;
        A[j] = s0;
        B[j] = w0;
        Next[j] = LONG_LONG_MAX;
        }
        for(int j = 2 ; j <= M ; ++j )
         for(int k = 0 ; k < Left[j].size() ; ++k )
          Left[j][k] = Right[j][k] = LONG_LONG_MAX;
      for( int j = 2 ; j <= M ; ++j ){
        ll Prime = pr[j];
        ll index = hashing[j];
        item[Prime][index] = dp[j] + B[j];
        Next[1] = min( Next[1] , dp[j] + B[j]);
      }
      Next[1] = min(Next[1] , dp[1] + A[1]);
            for(int j = 2 ; j <= M ; ++j ){
               if(Left[j].size()){
                 Left[j][0] = item[j][0];
                 int sz = item[j].size();
                 for(int k = 1 ; k < sz ; ++k )
                   Left[j][k] = min(Left[j][k-1],item[j][k]);
                 Right[j][sz-1] = item[j][sz-1];
                 for(int k = sz - 2 ; k >= 0 ; --k )
                 Right[j][k] = min(Right[j][k+1],item[j][k]);
               }
            }
          for(int j = 2 ; j <= M ; ++j ){
            int Prime = pr[j];
            int index = hashing[j];
            ll mn = LONG_LONG_MAX;
             if(item[Prime].size()==1)
             Next[j] = min(Next[j] , dp[j] + A[j]);
             else {
              if(index == 0)
              mn = Right[Prime][index+1];
              else
              if(index == item[Prime].size()-1)
              mn = Left[Prime][index-1];
              else
              mn = min(Left[Prime][index-1],Right[Prime][index+1]);
             }
              Next[j] = min( mn , dp[j] + A[j]);
          }
      for(int j = 1 ; j <= M ; ++j )
       dp[j] = Next[j];
    }
      ll Ans = LONG_LONG_MAX;
      for(int i = 1 ; i <= M ; ++i )
       Ans = min( Ans , dp[i]);
            cout << Ans << endl;
    return 0;
}
