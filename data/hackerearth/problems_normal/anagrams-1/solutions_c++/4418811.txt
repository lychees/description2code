/*
Two strings are said to be anagrams of each other if the letters of one string may be rearranged to make the other string. For example, the words 'elvis' and 'lives' are anagrams.

In this problem you’ll be given two strings. Your job is to find if the two strings are anagrams of each other or not. If they are not anagrams then find the lexicographically smallest palindrome (in lowercase alphabets) that may be appended to the end of either one of the two strings so that they become anagrams of each other.

The lower and upper case letters are considered equivalent. The number of spaces or any other punctuation or digit is not important.

One string is called lexicographically smaller than another if, at the first position where they differ the first one has smaller alphabet. For example, the strings 'hello' and 'herd' first differ at the third alphabet; 'l' is smaller than 'r', so 'hello' is lexicographically smaller than 'herd'.

A Palindrome is a string that is the same when read forward or backward. For example, the string 'bird rib' is a palindrome, whereas 'hello' is not.

INPUT:

The first line of the input contains a number T, the number of test cases. T test cases follow. Each test case consists of two lines, one string in each line.

OUTPUT:

For each test case output a single line. Print ‘YES’ (without the quotes) if the two strings are anagrams of each other. If they are not, then print the lexicographically smallest palindromic string as discussed above. If no such string exists, then print ‘NO LUCK’ (without the quotes).

CONSTRAINTS:

1<=T<=100

1<=length of the strings<=100
*/

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>       
using namespace std;

void cleararray(int alphabets[]) {
	for (int i = 0; i < 26; i++) {
		alphabets[i] = 0;
	}
}
void updateList(string str, int alphabets[]) {

	int c;
    for (int i = 0; i < str.size(); i++) {
		c = str[i];
		if (c >= 65 && c <= 90) {
			c = str[i] - 'A';
			alphabets[c]++;
		}
		else if (c >= 97 && c <= 122) {
			c = str[i] - 'a';
			alphabets[c]++;
		}
		
	}
}
bool manyOdds(int flag[]) {
	int c = 0;
	for (int i = 0; i < 26; i++) {
		if (flag[i] % 2 == 1) {
			c++;
		}
	}
	if (c > 1) {
		return true;
	}
	return false;
}
int main()
{
    int T, c, index;
    cin >> T;

    string str1, str2, diff, palim;
    getline(cin, str1);
    int alphabets1[26], alphabets2[26], flag[26];

    while(T--) {

    	diff = "";
    	cleararray(alphabets1);
    	cleararray(alphabets2);
    	cleararray(flag);

    	getline(cin, str1);
    	getline(cin, str2);

    	updateList(str1, alphabets1);
    	updateList(str2, alphabets2);


    	for (int i = 0; i < 26; i++) {

    		c = (str1.size() < str2.size()) ? (alphabets2[i] - alphabets1[i]) : (alphabets1[i] - alphabets2[i]);
		    if (c < 0) {
		    	break;
		    }
		    while (c) {
				diff += (char)(i + 'a');
				c--;
			}

    	}

		palim = "";
		char oddchar;
		bool oddpre = false; 
		int add = 0;

    	for (int i = 0; i < diff.size(); i++) {
    		//cout << diff[i];
    		flag[diff[i] - 'a']++;
    	}
    	//cout << endl;
    	if (c == -1 || manyOdds(flag)) {
    		cout << "NO LUCK" << endl;
		    continue;
		}
    	if (diff == "") {
    		cout << "YES" << endl;
    	}
    	else {
    		for (int i = 0; i < 26; i++) {
    			if (flag[i] % 2 == 0) {
    				add = flag[i]/2;
    			}
    			else {
    				oddpre = true;
    				add = (flag[i] - 1)/2;
    				oddchar = (char)(i + 'a');
    			}
			    while(add)
				{
					palim += (char)(i + 'a');
					add--;
				}
    		}
    		string rev = palim;
    		reverse(rev.begin(), rev.end());

    		if(oddpre) {
    			cout << palim + oddchar + rev << endl;
    		}
    		else {
    			cout << palim + rev << endl;
    		}

    	}



    }
    return 0;
}
