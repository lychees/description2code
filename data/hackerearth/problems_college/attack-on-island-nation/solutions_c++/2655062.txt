
#include <iostream>
#include <vector>
#include <set>
#include <climits>
#include <cstdio>
#include <cassert>

#define tr(c,it) for(vpii::iterator it = (c).begin() ; (it)!=(c).end() ; ++(it))
#define sz(a) a.size()
#define gc getchar_unlocked
#define pc(x) putchar_unlocked(x)
using namespace std;

typedef vector<int> vi;
typedef pair<int,int> pii;
typedef vector<pii> vpii;
typedef vector<vpii> graph;
inline void writeInt (int n){
	int N = n, rev, count = 0;
	rev = N;
	if (N == 0) { pc('0');; return ;}
	while ((rev % 10) == 0) { count++; rev /= 10;} 
	rev = 0;
	while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}  
	while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
	while (count--) pc('0');
}

inline int readInt(){
	
	char c;
	int ans=0;
	do{
		c=gc();
	}while(c<'0' || c>'9');
	do{
		ans = (ans<<3) + (ans<<1) + (c-48);
		c=gc();
	}while(c>='0' && c<='9');
	return ans;
	
}

void prim(graph &G,int v)
{
	int N = sz(G);

	vi done(N,0);
	vi d(N,INT_MAX);
	vi parent(N,-1);
	
	set<pii> Q;
	
	Q.insert(pii(0,v));
	d[v]=0;
	
	
	int total_cost =0 ;
	
	while(N--)
	{
		v = Q.begin()->second;
		int this_cost = Q.begin()->first;
		
		
		Q.erase(Q.begin());
		while(done[v])
		{
			
			
			v = Q.begin()->second;
			this_cost = Q.begin()->first;
			Q.erase(Q.begin());
			
		}
		
		done[v]=1;
		total_cost += this_cost;
		
		
		tr(G[v],i)
		{
			int v2 = i->first;
			int cost = i->second;
			
			if(!done[v2] && d[v2] > cost)
			{
				if(d[v2] != INT_MAX)
					Q.erase(Q.find(pii(d[v2],v2)));
				d[v2] = cost;
				Q.insert(pii(d[v2],v2));
				parent[v2] = v;
			}
		}
		
	}
	
	writeInt(total_cost);
	pc('\n');

}


int main(int argc, char **argv)
{

		int N,M;
		N=readInt();
		M=readInt();
		
		
		graph G(N);
		while(M--)
		{
			int x,y,w;
			x=readInt();
			y=readInt();
			w=readInt();
			x--;y--;
			G[x].push_back(pii(y,w));
			G[y].push_back(pii(x,w));
		}
		prim(G,0);
	
	return 0;
}
