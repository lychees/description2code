#pragma comment(linker, "/STACK:1024000000,1024000000") 
#include <iostream> 
#include <stdlib.h> 
#include <ctime> 
#include <cmath> 
#include <stdio.h> 
#include <vector> 
#include <algorithm> 
#include <queue> 
#include <string.h> 
#include <map> 
#include <set> 
#include <assert.h>
#define x first 
#define y second 
#define pb push_back 
#define mp make_pair 
#define vi vector<int> 
#define pii pair<int,int> 
#define ll long long 
#define inf 1000000007 
#define mod 1000000007 
#define all(x) x.begin(),x.end() 
#define N 100010 
#define pi 3.141592653 
#define DBG(x) cerr<<#x<<"="<<x<<"\n"; 
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) 
using namespace std; 
   

pair<ll,int>p[N];
ll s[N];int sz,root[N];
struct node
{
    int v,l,r;ll s;
}t[N*50];
int build(int l,int r)
{
    int p=++sz;t[p].v=t[p].s=0;
    if(l==r)return p;
    int m=(l+r)>>1;
    t[p].l=build(l,m);
    t[p].r=build(m+1,r);
    return p;
}
int insert(int q,int l,int r,int x,ll v)
{
    int p=++sz;t[p]=t[q];t[p].v++,t[p].s+=v;
    if(l==r){return p;}
    int m=(l+r)>>1;
    if(x<=m)t[p].l=insert(t[q].l,l,m,x,v);
    else t[p].r=insert(t[q].r,m+1,r,x,v);
    return p;
}
int query(int p,int l,int r,int x,int y)
{
    if(l>=x&&r<=y)return t[p].v;
    int m=(l+r)>>1,ans=0;
    if(x<=m)ans+=query(t[p].l,l,m,x,y);
    if(y>m)ans+=query(t[p].r,m+1,r,x,y);
    return ans;
}
ll ask(int p,int l,int r,int x,int y)
{
    if(l>=x&&r<=y)return t[p].s;
    int m=(l+r)>>1;ll ans=0;
    if(x<=m)ans+=ask(t[p].l,l,m,x,y);
    if(y>m)ans+=ask(t[p].r,m+1,r,x,y);
    return ans;
}
int main() 
{ 
    int T,i,j,k,m,n; 
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&k);
        for(i=0;i<n;i++)scanf("%d",&j),p[i].x=j-1LL*i*k,p[i].y=i,s[i+1]=p[i].x+s[i];
        sort(p,p+n);
        sz=0;
        root[0]=build(0,n-1);
        for(i=0;i<n;i++)
        {
            root[i+1]=insert(root[i],0,n-1,p[i].y,p[i].x);
        }
        scanf("%d",&m);
        while(m--)
        {
            int l,r,x,y;
            scanf("%d%d",&x,&y);x--,y--;
            l=1,r=n;
            while(l<=r)
            {
                int z=(l+r)>>1;
                if(2*query(root[z],0,n-1,x,y)>=y-x+1)r=z-1;
                else l=z+1;
            }
            r++;
            //DBG(r)DBG(p[r-1].x)
            ll w=ask(root[r],0,n-1,x,y),v=s[y+1]-s[x]-w;
            //cerr<<w<<" "<<v<<"\n";
            ll ans=v-w+((y-x+1)&1?1:0)*p[r-1].x;
            cout<<ans<<"\n";
        }
    }
}