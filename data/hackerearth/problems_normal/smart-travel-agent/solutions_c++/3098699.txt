#include<stdio.h>
#include<iostream>
#include<math.h>
#include<vector>
#include<map>
#include<string>
#include<stack>
#include<algorithm>
#define PI acos(-1.0)
#define SZ 107
#define Fi(a,n) for(int i=a;i<n;i++)
#define Fj(a,n) for(int j=a;j<n;j++)
#define Fk(a,n) for(int k=a;k<n;k++)
#define ri(a) scanf("%d",&a)
#define pb push_back
using namespace std;
typedef vector<int> vi;
int N,R,C1,C2,S,D,T,P;
int g[SZ][SZ], d[SZ];
int maxMinEdge;
stack<int> ans;
void minTripPathDFS(int v, int dest, int minEdge, stack<int> &path)
{
	path.push(v);
	d[v] = 1;
	if(v != dest )
		for(int i=1; i<=N; i++)
		{
			if(d[i] || g[v][i]==0)
				continue;
			minTripPathDFS(i, dest, min(minEdge, g[v][i]), path);
		}
	else if(minEdge > maxMinEdge)
	{
		maxMinEdge = minEdge;
		ans = stack<int>();
		stack<int> temp = path;
		while(!temp.empty())
		{
			ans.push(temp.top());
			temp.pop();
		}
	}
	if(!path.empty())
		path.pop();
	d[v] = 0;
}
void singleSourceMinTrip(int source, int dest)
{
	maxMinEdge = 0;
	stack<int> path = stack<int>();
	minTripPathDFS(source, dest, 10000007, path);
	for(int i = ans.size()-1; i>=0; ans.pop(),i--)
	printf("%d%c",ans.top(),i>0?' ':'\n');
	int trips = T/maxMinEdge + ((T%maxMinEdge) > 0);
	trips += (trips * maxMinEdge - trips - T) < 0;
	printf("%d\n", trips);
}
int main()
{
 
 ri(N);ri(R);
 
 Fi(0,N+1)Fj(0,N+1)g[i][j]=0;
 
 Fi(0,R)
 {
 	ri(C1);ri(C2);ri(P);
 	g[C1][C2] = g[C2][C1] = P;
 }
 
 ri(S);ri(D);ri(T);
 
 singleSourceMinTrip(S,D);
 
 return 0;
}
