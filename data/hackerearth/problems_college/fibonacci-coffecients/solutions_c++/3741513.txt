/*
* @problem: FIBONACCI COFFECIENTS
*/

#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <limits.h>
#include <vector>
#include <map>
#include <bitset>
#include <string>
#include <iterator>
#include <set>
#include <utility>
#include <queue>
#include <numeric>
#include <functional>
#include <ctype.h>
#include <stack>
#include <algorithm>
#include <cstdlib>
#define MAX 201000
#define bitcnt(x) __builtin_popcount(x)
#define MS0(x) memset(x, 0, sizeof(x))
#define MS1(x) memset(x, -1, sizeof(x))
#define ll long long int
#define mp(x, y) make_pair(x, y)
#define pii pair<int, int>
#define pll pair<ll, ll>
#define in(x) scanf("%lld", &x)
#define ind(x) scanf("%d", &x)
#define ins(x) scanf("%s", x)
#define pi acos(-1.0)

using namespace std;
int n, m, x[MAX];
ll mod, bit[MAX], bit1[MAX], f[MAX];

void update(int i, ll val, ll val1)
{
	if(i <= 0)
		return;
	for(int j = i; j <= n; j += (j & -j))
	{
		bit[j] = (bit[j] + val + mod) % mod;
		bit1[j] = (bit1[j] + val1 + mod) % mod;
	}
	return;
}

ll query(int i)
{
	if(i <= 0 || i > n)
		return 0;
	ll ans = 0;
	for(; i > 0; i -= (i & -i))
		ans = (ans + bit[i]) % mod;
	return ans;
}

ll query1(int i)
{
	if(i <= 0 || i > n)
		return 0;
	ll ans = 0;
	for(; i > 0; i -= (i & -i))
		ans = (ans + bit1[i]) % mod;
	return ans;
}

int main()
{
	#ifndef ONLINE_JUDGE
		freopen("../input.txt", "r", stdin);
	#endif
	// ios_base::sync_with_stdio(0);
    // cin.tie(0);
	ll tmp, tmp1, ans;
	int a, b, c;
	ind(n);
	ind(m);
	in(mod);
	f[0] = 0;
	f[1] = 1;
	for(int i = 2; i <= n + 3; i++)
		f[i] = (f[i - 1] + f[i - 2]) % mod;
	for(int i = 1; i <= n; i++)
	{
		ind(x[i]);
		tmp = (x[i] * f[i]) % mod;
		tmp1 = (x[i] * f[i + 1]) % mod;
		update(i, tmp, tmp1);
	}

	while(m--)
	{
		ind(a);
		ind(b);
		ind(c);
		if(a == 1)
		{
			tmp = (((c - x[b]) * f[b]) % mod + mod) % mod;
			tmp1 = (((c - x[b]) * f[b + 1]) % mod + mod) % mod;
			update(b, tmp, tmp1);
			x[b] = c;
		}
		else
		{
			tmp = (query(c) - query(b - 1) + mod) % mod;
			tmp1 = (query1(c) - query1(b - 1) + mod) % mod;
			//cout << tmp << " " << tmp1 << endl;
			tmp1 = (tmp1 * f[b - 1]) % mod;
			tmp = (tmp * f[b]) % mod;
			
			if(b & 1)
				ans = (tmp - tmp1 + mod) % mod;
			else
				ans = (tmp1 - tmp + mod) % mod;
			printf("%lld\n", ans);
		}
	}
	return 0;
}