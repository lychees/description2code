#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <set>
#include <map>
#include <cassert>
#include <numeric>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
	#define eprintf(...) 42
#endif

typedef long long int int64;

const int N = (int) 1e6 + 100;

struct Edge
{
	int a, b, c;
	Edge() : a(), b(), c() {}

	void read()
	{
		scanf("%d%d%d", &a, &b, &c);
		a--;
		b--;
	}
	bool operator < (const Edge &A) const
	{
		return c > A.c;
	}
} edge[N];

int par[N];
int listStart[N];
int listEnd[N];
int listNxt[N];
int listSize[N];
map <int, int> cnt[N];
long long answer[N];
int n, q;

void read()
{
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		cnt[i].clear();
		answer[i] = 0;
	}
	
	for (int i = 0; i < n - 1; i++)
		edge[i].read();

	for (int i = 0; i < n; i++)
	{
		par[i] = i;
		listSize[i] = 1;
		listStart[i] = listEnd[i] = i;
		listNxt[i] = -1;
	}

	scanf("%d", &q);
	for (int i = 0; i < q; i++)
	{
		int k;
		scanf("%d", &k);
		for (int j = 0; j < k; j++)
		{
			int x;
			scanf("%d", &x);
			x--;
			cnt[x][i]++;
		}
	}
}

void solve()
{
	sort(edge, edge + n - 1);
	for (int i = 0; i < n - 1; i++)
	{
		int a = par[edge[i].a], b = par[edge[i].b];
		if (a == b) throw;
		eprintf("merge %d + %d : %d\n", a, b, edge[i].c);

		if (listSize[a] < (int) listSize[b] )
			swap(a, b);
		for (int x = listStart[b]; x != -1; x = listNxt[x] )
			par[x] = a;

		listNxt[listEnd[a] ] = listStart[b];
		listEnd[a] = listEnd[b];
		listSize[a] += listSize[b];

		for (auto p : cnt[b] )
		{
			answer[p.first] += p.second * 1LL * cnt[a][p.first] * 1LL * edge[i].c;
			cnt[a][p.first] += p.second;
		}
		cnt[b].clear();
	}

	for (int i = 0; i < q; i++)
		printf("%lld\n", answer[i] );
}

int main(int,  char **)
{
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif

	read();
	solve();

	return 0;
}


