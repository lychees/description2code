#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000007
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){ return N=N | (1<<pos);}
int RESET(int N,int pos){   return N= N & ~(1<<pos);}
int check(int N,int pos){   return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){   printf("("); for(int i=6;i>=1;i--)  {bool x=check(N,i);cout<<x;}    puts(")");}
int mod(int a, int b) { return a - a/b * b;}

ll N;
ll Arr[102][102];
ll Dp[102][102];

void inp()
{
	scanf("%lld", &N);
	
	for(int i = 1; i <= N; ++i) {
		for(int j = 1; j <= N; ++j) {
			scanf("%lld", &Arr[i][j]);
		}
	}
}

ll rec(int pos, int x)
{
	if(pos == N + 1)
		return 0;
	
	if(Dp[pos][x] != -1)
		return Dp[pos][x];
	
	ll ans = 0;
	
	ans = rec(pos + 1, x) + Arr[pos][x];
	int y = x;
	
	bool row[N + 2];
	memset(row, false, sizeof row);
	
	while(y*2 <= N) {
			if(!row[y << 1])
				ans = max(ans, rec(pos + 1, 2*y) + Arr[pos][2*y]);
			y = y << 1;
			
			int z = y;
			while(z >> 1 >= 1) {
				if(!row[z >> 1])
					ans = max(ans, rec(pos + 1, z >> 1) + Arr[pos][z >> 1]);
				z >>= 1;
				row[z] = true;
			}
			row[y] = true;
	} 
	
	y = x;
	while(y >> 1 >= 1) {
			ans = max(ans, rec(pos + 1, y >> 1) + Arr[pos][y >> 1]);
			y = y >> 1;
			
			int z = y;
			while(z << 1 <= N) {
				if(!row[z << 1]) {
					ans = max(ans, rec(pos + 1, z << 1) + Arr[pos][z << 1]);
				}
				z <<= 1;
				row[z] = true;
			}
			row[y] = true;
	}
	return Dp[pos][x] = ans;
}

void solve()
{
	memset(Dp, -1, sizeof Dp);
	ll ans = 0;
	for(int i = 1; i <= N; ++i) {
			ans = max(ans, rec(2, i) + Arr[1][i]);
	}
	
	printf("%lld\n", ans);
}

int main()
{
	inp();
	solve();
	
	return 0;
}