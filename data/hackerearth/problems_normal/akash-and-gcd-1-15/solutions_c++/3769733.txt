/*
ye mera template hai
apna khud likho bc :P
*/

/*
Author : Sarvagya Agarwal
*/

#include<bits/stdc++.h>
using namespace std;

//defines
#define openin freopen("input.txt","r",stdin)
#define openout freopen("output.txt","w",stdout)
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define ll long long
#define int long long
#define mod 1000000007
#define rep(i,a,n) for(__typeof(n) i=a;i<=n;++i)
#define all(c) (c).begin(),(c).end()
#define ff first
#define ss second
#define pb push_back
#define mp make_pair

//templates
template <typename T>T expo(T e, T n){T x=1,p=e;while(n){if(n&1)x=x*p;p=p*p;n>>=1;}return x;}
template <typename T>T power(T e, T n, T m){T x=1,p=e;while(n){if(n&1)x=(x*p)%m;p=(p*p)%m;n>>=1;}return x;}
template <typename T> T InverseEuler(T a, T m){return (a==1? 1 : power(a, m-2, m));}
template <typename T> T gcd(T a, T b){while(a%=b^=a^=b^=a); return b;}
template <typename T> T lcm(T a, T b){return (a*(b/gcd(a,b)));}


//debug
#define TRACE

#ifdef TRACE
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1){
		cerr << name << " : " << arg1 << std::endl;
}
template <typename Arg1, typename... Args>
void __f(const char* names, Arg1&& arg1, Args&&... args){
		const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...);
}
#else
#define trace(...)
#endif

// DOBARA OVERFLOW KI GALTI HUI TO TU CHUTIYA HAI BC
// update : TU CHUTIYA HAI BC
int ans[5000002];
bool isprime[5000002];
int tree[4*1000001],arr[1000007];
int power(int a,int b)
{
	int ans = 1;
	while(b)
	{
		if(b%2)ans=(ans*a)%mod;
		b/=2;
		a=(a*a)%mod;
	}
	return ans ;
}
void sieve()
{
	memset(isprime,true,sizeof(isprime));
	isprime[1] = false;
	rep(i,1,500000)ans[i]=1ll;
	for(int i=2;i<=500000;i++)
	{
		if(isprime[i])
		{
			ans[i] = 2*i-1;
			ans[i]%=mod;
			for(int j=i*2;j<=500000;j+=i)
			{
				isprime[j] = false;
				int temp = j,cnt=0;
				while(temp%i==0)
				{
					temp/=i;
					cnt++;
				}
				ans[j] *= power(i,cnt-1);
				ans[j] *= ((i-1)*cnt + i);
				ans[j] %= mod;
			}
		}
	}
	return ;
}
void build(int l,int r,int node)
{
	if(l==r){
		tree[node] = (ans[arr[l]])%mod;
		return ;
	}
	int mid = (l+r)/2;
	build(l,mid,node*2);
	build(mid+1,r,node*2+1);
	tree[node] = (tree[node*2] + tree[1+node*2])%mod;
	return ;
}
void update(int node, int start, int end, int idx, int val)
{
    if(start == end)
    {
        // Leaf node
        arr[idx] = val;
        tree[node] = ans[val]%mod;
    }
    else
    {
        int mid = (start + end) / 2;
        if(start <= idx and idx <= mid)
        {
            // If idx is in the left child, recurse on the left child
            update(2*node, start, mid, idx, val);
        }
        else
        {
            // if idx is in the right child, recurse on the right child
            update(2*node+1, mid+1, end, idx, val);
        }
        // Internal node will have the sum of both of its children
        tree[node] = (tree[node*2] + tree[1+node*2])%mod;
    }
}
int query(int node, int start, int end, int l, int r)
{
    if(r < start or end < l)
    {
        // range represented by a node is completely outside the given range
        return 0;
    }
    if(l <= start and end <= r)
    {
        // range represented by a node is completely inside the given range
        return tree[node];
    }
    // range represented by a node is partially inside and partially outside the given range
    int mid = (start + end) / 2;
    int p1 = query(2*node, start, mid, l, r);
    int p2 = query(2*node+1, mid+1, end, l, r);
    return (p1 + p2)%mod;
}
int32_t main()
{
    fast;
    sieve();
    int n;
    cin>>n;
    rep(i,1,n)cin>>arr[i];
    build(1,n,1);
    //rep(i,1,5)trace(i,tree[i]);
    int q;
    cin>>q;
    while(q--)
    {
    	char type;
    	cin>>type ;
    	if(type=='C')
    	{
    		int l,r;
    		cin>>l>>r;
    		cout<<query(1,1,n,l,r)<<endl;
    	}
    	else
    	{
    		int idx,val;
    		cin>>idx>>val;
    		update(1,1,n,idx,val);
    	}
    }
    return 0;
}