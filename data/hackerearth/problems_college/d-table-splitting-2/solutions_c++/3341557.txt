#include <bits/stdc++.h>

using namespace std;

#define X first
#define Y second
#define INPUT freopen("D.inp","r",stdin)
#define OUTPUT freopen("D.out","w",stdout)
#define FOR(i,l,r) for(auto i=(l);i<=(r);i++)
#define REP(i,l,r) for(auto i=(l);i<(r);i++)
#define FORD(i,l,r) for(auto i=(l);i>=(r);i--)
#define REPD(i,l,r) for(auto i=(l);i>(r);i--)
#define ENDL printf("\n")
#define debug 1

typedef long long ll;
typedef pair<int,int> ii;

const int inf=1e9;
const int MOD=1e9+7;
const int N=1e6+10;
///RDLU
const int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
const int dx2[8]={-1,-1,-1,0,0,1,1,1},dy2[8]={-1,0,1,-1,1,-1,0,1};
const int pri[4]={1,0,3,2};
int n,n1,m,num[N],h[N],low[N],pa[N],ms[N];
string s[N];
queue <int> q;
vector <int> v[N];
void prepare(){
    cin>>n>>m;
    REP(i,0,n) cin>>s[i];
}
bool check(int x,int y){
    return x>=0&&x<n&&y>=0&&y<m;
}
void BFS(int st){
    num[st]=++n1;
//    cout<<st<<'\n';
    q.push(st);
    while (!q.empty()){
        int idx=q.front();q.pop();
        int x=idx/m,y=idx%m;
        FOR(i,0,3){
            int nx=x+dx[i],ny=y+dy[i];
            if (check(nx,ny)&&!num[nx*m+ny]&&s[nx][ny]==s[x][y]){
                int nidx=nx*m+ny;
                num[nidx]=num[idx];
                q.push(nidx);
            }
        }
    }
}
void DFS(){
    ms[1]=n1;
    pa[n1]=0;
    int top=1,c=0;
    memset(num,0,sizeof(num));
    memset(h,0,sizeof(h));
    while (top){
        int x=ms[top];
        if (!h[x]) low[x]=num[x]=++c;
        if (h[x]==int(v[x].size())){
            low[pa[x]]=min(low[pa[x]],low[x]);
            top--;
            continue;
        }
        int y=v[x][h[x]++];
        if (y==pa[x]) continue;
        if (num[y]){
            low[x]=min(low[x],num[y]);
            continue;
        }
        pa[y]=x;
        ms[++top]=y;
    }
}
void makeedge(int x,int y){
    if (x==y) return ;
    v[x].push_back(y);
}
string solve(){
    n1=0;
    memset(num,0,sizeof(num));
    REP(i,0,n*m) if (!num[i]) BFS(i);
    n1++;
    FOR(i,1,n1) v[i].clear();
    REP(x,0,n)
        REP(y,0,m)
            FOR(i,0,7){
                int nx=x+dx2[i],ny=y+dy2[i];
                if (!check(nx,ny)) {
                	makeedge(n1,num[x*m+y]);
                	makeedge(num[x*m+y],n1);
                }else makeedge(num[nx*m+ny],num[x*m+y]);
            }
    DFS();
    REP(i,1,n1) if (pa[i]!=n1&&low[i]>=num[pa[i]]) return "NO\n";
    return "YES\n";
}
int main(){
    int test;
    cin>>test;
    while (test--){
        prepare();
        cout<<solve();
    }
}
