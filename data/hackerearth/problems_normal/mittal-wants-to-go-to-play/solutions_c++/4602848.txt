/*--.--.--.--.--.--.--.--.--.--.--.--.--*
 *      By-Rohit Singh                   *
 *    CS , MNNIT Allahabad               *
 *      rohitmnnit1459@gmail.com         *
 *--.--.--.--.--.--.--.--.--.--.--.--.--*/

#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <queue>
#include <stack>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <set>
#include <limits.h>
#include <assert.h>
using namespace std;

#define mp make_pair
#define pb push_back
#define X first
#define Y second
#define null NULL
#define ll long long
#define llu unsigned long long
#define MAX 200005
#define mod 100000007
#define inf 100000
#define dnf -100000
#define pp pair <int, int>
//**********************************************HAPPY CODDING*****************************************************//
vector < pp > vec[MAX];
int n, adj, path[MAX];
bool vis[MAX];

bool solve(int root) {

    int i, node;
    bool f = false;
    priority_queue <pp, vector< pp >, greater< pp > > que;
    fill(path, path+n+1, inf);
    memset(vis, false, sizeof(vis));
    path[root] = 0;
    que.push(mp(0, root));
    while (!que.empty()) {
        node = que.top().Y;
        que.pop();
        if (vis[node])  continue;
        vis[node] = true;
        for (i = 0 ; i < vec[node].size() ; i++) {
            if (path[vec[node][i].X] > path[node]+vec[node][i].Y) {
                path[vec[node][i].X] = path[node]+vec[node][i].Y;
                que.push(mp(path[vec[node][i].X], vec[node][i].X));
            }
        } 
    }
    return f;
}

int main() {

    int t, u, v, wt, i, j, ans, q, q1, ti;
    bool f;
    scanf("%d", &t);
    while (t--) {
        scanf("%d %d", &n, &adj);
        for (i = 1 ; i <= adj ; i++) {
            scanf("%d %d %d", &u, &v, &wt);
            vec[u].pb(mp(v, wt));
            vec[v].pb(mp(u, wt));
        }
        f = solve(1);
        scanf("%d", &q);
        while (q--) {
            scanf("%d %d", &q1, &ti);
            ans = ti - 2*path[q1]; 
            if (ans > 0) {
                printf("%d\n", ans);
            }
            else {
                printf("0\n");
            }
        }    
        for (i = 1 ; i <= n ; i++)  vec[i].clear();
    }
    return 0;
}