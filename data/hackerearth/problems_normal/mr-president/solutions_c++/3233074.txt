#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll *id, cnt, *sz;
map<ll,ll> mp;  //use this map to map indexes with data.
void init(ll N)
{
    cnt = N;
	id = new ll[N+1];
	sz = new ll[N+1];
    for(ll i=1; i<=N; i++)
    {
        id[i] = i;
	    sz[i] = 1;
	}
}
ll find(ll p)
{
    ll root = p;
    while (root != id[root])
        root = id[root];
    while (p != root) {
        ll newp = id[p];
        id[p] = root;
        p = newp;
    }
    return root;
}
// Replace sets containing x and y with their union.
void merge(ll x, ll y)
{
    ll i = find(x);
    ll j = find(y);
    if (i == j) return;
    // make smaller root point to larger one
    if(sz[i]<sz[j])
    {
        id[i]=j;
        sz[j]+=sz[i];
    }
    else
    {
        id[j]=i;
        sz[i]+=sz[j];
    }
    cnt--;
}
// Are objects x and y in the same set?
bool connected(ll x, ll y)
{
    return find(x) == find(y);
}
// Return the number of disjoint sets.
ll count()
{
    return cnt;
}
void destroy()
{
    delete []id;
	delete []sz;
}
//////////////////////////UFDS ends.
//////////////////////////MST code begins
const ll MAX = 1000009;
pair <long long, pair<ll, ll> > p[MAX];
priority_queue<ll> pq;
ll nodes,edges;
long long kruskal(pair<long long, pair<ll, ll> > p[])
{
    ll x, y;
    long long cost, minimumCost = 0;
    for(ll i = 0;i < edges;++i)
    {
        x = p[i].second.first;
        y = p[i].second.second;
        cost = p[i].first;
        if(find(x) != find(y))
        {
            minimumCost += cost;
            pq.push(cost);
            merge(x, y);
        }
    }
    return minimumCost;
}
int main()
{
    ll x, y,k;
    long long weight, cost, minimumCost;

    cin >> nodes >> edges >> k;
    if(k<nodes-1)
    {
        cout<<-1;
        return 0;
    }
    init(nodes);     //creating the sets
    for(ll i = 0;i < edges;++i)
    {
        cin >> x >> y >> weight;
        p[i] = make_pair(weight, make_pair(x, y));
    }
    sort(p, p + edges);
    minimumCost=kruskal(p);
    if(pq.size()<nodes-1)
    {
        cout<<-1;
        return 0;
    }
    cnt=0;
    while(!pq.empty())
    {
        if(minimumCost<=k)
        {
            break;
        }
        minimumCost-=(pq.top());
        minimumCost++;
        pq.pop();
        cnt++;
    }
    cout<<cnt;
    destroy();  //destroying the UFDS

    return 0;
}

