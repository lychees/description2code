//Archit Rai
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define sz(a) (int)(a.size())
#define all(c) (c).begin(),(c).end()
#define F first
#define S second
#define si(n) scanf("%d",&n)
#define sll(n) scanf("%lld",&n)
#define REP(i,a,b) for(int i=a;i<b;i++)
#define MOD 1000000007
#define endl '\n'
#define PIN(n) printf("%d\n",n)
#define PLLN(n) printf("%lld\n",n)
#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)
typedef long long int ll;
ll powmod(ll a,ll b)
{
    if(b==0)return 1;
    ll x=powmod(a,b/2);
    ll y=(x*x)%MOD;
    if(b%2)
	return (a*y)%MOD;
    return y%MOD;
}
//Template ends here
int dp[(1<<16)][401],d[410][410];
int n,m,k;
vector<int> g;
void FloydWarshall()
{
    for(int k=1;k<=n;k++)
    {
	for(int i=1;i<=n;i++)
	{
	    for(int j=1;j<=n;j++)
	    {
		if(d[i][k]+d[k][j]<d[i][j])
		    d[i][j]=d[i][k]+d[k][j];
	    }
	}
    }
}
int rec(int mask,int last)
{
    if(dp[mask][last]!=-1)
	return dp[mask][last];
    if(mask==(1<<sz(g))-1)
	return d[last][n];
    int ret=MOD;
    REP(i,0,sz(g))
    {
	if(!(mask & (1<<i)))
	    ret=min(ret,rec((mask|(1<<i)),g[i])+d[last][g[i]]);
    }
    dp[mask][last]=ret;
    return ret;
}
int main()
{
    si(n),si(m),si(k);
    REP(i,0,n+3)
    {
	REP(j,0,n+3)
	    d[i][j]=MOD;
    }
    REP(i,0,m)
    {
	int u,v;
	int w;
	si(u),si(v),si(w);
	d[u][v]=min(d[u][v],w);
	d[v][u]=min(d[v][u],w);
    }
    REP(i,1,n+1)
	d[i][i]=0;
    FloydWarshall();
    while(k--)
    {
	int c;
	si(c);
	g.pb(c);
    }
    memset(dp,-1,sizeof(dp));
    int fin=rec(0,1);
    printf("%d\n",fin);
    return 0;
}

