#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define clr(X,a) memset((X), (a), sizeof((X)))
#define s(a) scanf("%d", &a)
#define ps(a) printf("%d ", a)
#define pn(a) printf("%d\n", a)
#define rep(i,n) for(i = 0; i < (n); i++)
#define repr(i,a,b) for(i = (a); i <= (b); i++)

int N,i,j,T,M,cnt;
string str[1010];
char g[1000111];
vector<vector<int>> G;
vector<int> dist;
unordered_set<int> v;
typedef pair<int,int> pii;

vector<int> dijkstra(int source, int N)
{
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    vector<int> dist(N+1, INT_MAX);
    dist[source] = 0;
    pq.push( {0, source} );
    while(!pq.empty())
    {
        pii top = pq.top(); pq.pop();
        int v = top.second;
        int d = top.first;
        if(d == INT_MAX) break;
        if(d <= dist[v])
        for(int n : G[v])
            if(dist[n] > d + 1)
            {
                dist[n] = d + 1;
                pq.push( {dist[n], n} );
            }
    }
    return dist;
}

int main()
{
    s(T);
    while(T--)
    {
        s(N); s(M);
        rep(i, N)
        {
            scanf("%s", g); 
            str[i] = g; 
        }
        G.clear();
        G.resize((N+1) * (M+1) + 1);
        v.clear();
        rep(i, N) rep(j, M)
        {
            if(j < M-1 && str[i][j] != str[i][j+1])
            {
                int up = i * (M+1) + j + 2, down = (i+1) * (M+1) + j + 2;
                G[up].pb(down);
                G[down].pb(up);
                v.insert(up); 
                v.insert(down);
                if(i == 0) G[1].pb(up), G[up].pb(1);
                else if(i == N-1) G[1].pb(down), G[down].pb(1);
            }
            if(i < N-1 && str[i][j] != str[i+1][j])
            {
                int left = (i+1) * (M+1) + j + 1, right = (i+1) * (M+1) + j + 2;
                G[left].pb(right);
                G[right].pb(left);
                v.insert(left);
                v.insert(right);
                if(j == 0) G[1].pb(left), G[left].pb(1);
                else if(j == M-1) G[1].pb(right), G[right].pb(1);
            }
        }
        dist = dijkstra(1, (N+1) * (M+1));
        bool yes = true;
        for(int n : v)
        {
//            cout << n << " " << dist[n] << endl;
            if(dist[n] == INT_MAX) { yes = false; break; }
        }
        printf("%s\n", yes ? "YES" : "NO");
    }   
    
    return 0;
}
