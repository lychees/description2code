//its not how good you are...its how good you want to be
#include <iostream>
#include<bits/stdc++.h>
using namespace std;
#define ll  long long int
#define inf 1000000000000
#define mod 1000000007
#define pb push_back
#define mp make_pair
#define all(v) v.begin(),v.end()
#define S second
#define F first
#define boost1 ios::sync_with_stdio(false);
#define boost2 cin.tie(0);
#define mem(a,val) memset(a,val,sizeof a)

struct st
{
	ll hash1,hash2,count;
	st()
	{
		hash1=0;
		hash2=0;
		count=0;
	}
}	tree1[400001],tree2[400001];
ll arr[100001],power1[1000001],power2[1000001],base=127,mod1=1000000007,mod2=1000000009;
void build1(ll node,ll a,ll b)
{
	if(a==b)
	{
		tree1[node].count=1;
		tree1[node].hash1=arr[a]%mod1;
		tree1[node].hash2=arr[a]%mod2;
		return;
	}
	ll mid=(a+b)/2;
	build1(2*node,a,mid);
	build1(2*node+1,mid+1,b);
	tree1[node].count=tree1[2*node].count+tree1[2*node+1].count;
	tree1[node].hash1=(tree1[2*node].hash1*power1[tree1[2*node+1].count]+tree1[2*node+1].hash1)%mod1;
	tree1[node].hash2=(tree1[2*node].hash2*power2[tree1[2*node+1].count]+tree1[2*node+1].hash2)%mod2;
}	
void build2(ll node,ll a,ll b)
{
	if(a==b)
	{
		tree2[node].count=1;
		tree2[node].hash1=arr[a]%mod1;
		tree2[node].hash2=arr[a]%mod2;
		return;
	}
	ll mid=(a+b)/2;
	build2(2*node,a,mid);
	build2(2*node+1,mid+1,b);
	tree2[node].count=tree2[2*node].count+tree2[2*node+1].count;
	tree2[node].hash1=(tree2[2*node+1].hash1*power1[tree2[2*node].count]+tree2[2*node].hash1)%mod1;
	tree2[node].hash2=(tree2[2*node+1].hash2*power2[tree2[2*node].count]+tree2[2*node].hash2)%mod2;
}
void update1(ll node,ll a,ll b,ll ind,ll val)
{
	if(a>b || a>ind || b<ind)
	return;
	if(a==b)
	{
		tree1[node].count=1;
		tree1[node].hash1=val%mod1;
		tree1[node].hash2=val%mod2;
		return;
	}
	ll mid=(a+b)/2;
	if(ind<=mid)
	update1(2*node,a,mid,ind,val);
	else
	update1(2*node+1,mid+1,b,ind,val);
	tree1[node].count=tree1[2*node].count+tree1[2*node+1].count;
	tree1[node].hash1=(tree1[2*node].hash1*power1[tree1[2*node+1].count]+tree1[2*node+1].hash1)%mod1;
	tree1[node].hash2=(tree1[2*node].hash2*power2[tree1[2*node+1].count]+tree1[2*node+1].hash2)%mod2;
}
void update2(ll node,ll a,ll b,ll ind,ll val)
{
	if(a>b || a>ind || b<ind)
	return;
	if(a==b)
	{
		tree2[node].count=1;
		tree2[node].hash1=val%mod1;
		tree2[node].hash2=val%mod2;
		return;
	}
	ll mid=(a+b)/2;
	if(ind<=mid)
	update2(2*node,a,mid,ind,val);
	else
	update2(2*node+1,mid+1,b,ind,val);
	tree2[node].count=tree2[2*node].count+tree2[2*node+1].count;
	tree2[node].hash1=(tree2[2*node+1].hash1*power1[tree2[2*node].count]+tree2[2*node].hash1)%mod1;
	tree2[node].hash2=(tree2[2*node+1].hash2*power2[tree2[2*node].count]+tree2[2*node].hash2)%mod2;
}
st query1(ll node,ll a,ll b,ll l,ll r)
{
	if(a>b || a>r || b<l)
	{
		struct st temp;
		temp.count=0;
		temp.hash1=0;
		temp.hash2=0;
		return temp;
	}
	if(a>=l && b<=r)
	return tree1[node];
	ll mid=(a+b)/2;
	struct st nd1=query1(2*node,a,mid,l,r);
	struct st nd2=query1(2*node+1,mid+1,b,l,r);
	struct st nd;
	nd.count=nd1.count+nd2.count;
	nd.hash1=(nd1.hash1*power1[nd2.count]+nd2.hash1)%mod1;
	nd.hash2=(nd1.hash2*power2[nd2.count]+nd2.hash2)%mod2;
	return nd;
}
st query2(ll node,ll a,ll b,ll l,ll r)
{
	if(a>b || a>r || b<l)
	{
		struct st temp;
		temp.count=0;
		temp.hash1=0;
		temp.hash2=0;
		return temp;
	}
	if(a>=l && b<=r)
	return tree2[node];
	ll mid=(a+b)/2;
	struct st nd1=query2(2*node,a,mid,l,r);
	struct st nd2=query2(2*node+1,mid+1,b,l,r);
	struct st nd;
	nd.count=nd1.count+nd2.count;
	nd.hash1=(nd2.hash1*power1[nd1.count]+nd1.hash1)%mod1;
	nd.hash2=(nd2.hash2*power2[nd1.count]+nd1.hash2)%mod2;
	return nd;
}
int main()
{
	boost1;
	boost2;
	ll i,j,n,q,x,y,type,ind,val,l,r;
	char ch;
	string s;
	power1[0]=1;
	power2[0]=1;
	for(i=1;i<=100000;i++)
	{
		power1[i]=(power1[i-1]*base)%mod1;
		power2[i]=(power2[i-1]*base)%mod2;
	}
	cin>>n>>q;
	cin>>s;
	for(i=1;i<=n;i++)
	arr[i]=s[i-1]-'a'+1;
	build1(1,1,n);
	build2(1,1,n);
	while(q--)
	{
		cin>>type;
		if(type==0)
		{
			cin>>ind>>ch;
			val=ch-'a'+1;
			update1(1,1,n,ind,val);
			update2(1,1,n,ind,val);
		}
		else
		{
			cin>>l>>r;
			struct st nd1=query1(1,1,n,l,r);
			struct st nd2=query2(1,1,n,l,r);
			if(nd1.hash1==nd2.hash1 && nd1.hash2==nd2.hash2)
			cout<<"Yes"<<endl;
			else
			cout<<"No"<<endl;
		}
	}
	return 0;
}
