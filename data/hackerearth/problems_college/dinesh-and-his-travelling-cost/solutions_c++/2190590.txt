#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<ctime>
#include<assert.h>

#include<cmath>
#include<iostream>
#include<fstream>

#include<string>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
#include<set>
#include<sstream>
#include<stack>
#include<limits.h>

using namespace std;

#define MAX(a,b) ((a)>(b) ? (a) : (b))
#define MIN(a,b) ((a)<(b) ? (a) : (b))
#define EPS 1e-9
#define asdf exit(0);
#define AB(a) ((a)<(0) ? (-(a)) : (a))
#define EQ(a,b) ( (fabs((a)-(b))<EPS) ? (1) : (0))



//Dijkstra O((E + V)*logV)
#define inf 1<<29
#define MS 510

struct node
{
  int dest,cost;
};

class cmp
{
public:
  bool operator()(const node &n1,const node &n2)
  {
    return n1.cost>n2.cost;
  }
};

priority_queue<node,vector<node>,cmp> pq;



vector<node> adj[MS];//adjacency list
int dis[MS];
bool vis[MS];



void dij_ini()
{
  int i;
  while(!pq.empty()) pq.pop();
  for(i=0;i<MS;i++)
  {
    vis[i]=false;
    dis[i]=inf;//inf=
  }
}


int dij(int src)
{
  int cnt,u,v,i;
  node x,y;
  dis[src]=0;
  x.cost=0;
  cnt=0;
  x.dest=src;
  pq.push(x);
  while(!pq.empty())//this loop will run node times
  {
    y=pq.top(); pq.pop();

    u=y.dest;
    if(vis[u]) continue;


    vis[u]=1;
    cnt++;

    for(i=0;i<adj[u].size();i++)
    {
      x=adj[u][i];
      v=x.dest;
      if( (dis[u]+x.cost)<dis[v])
      {
        dis[v]=dis[u]+x.cost;
        y.dest=v;
        y.cost=dis[v];
        pq.push(y);
      }
    }
  }
}


int main()
{
  //freopen("in.txt","r",stdin);
  int T,s,t,m,u,v,c,cnt;
  int i,cs;

  scanf("%d",&m);

  //initialization_main
  for(i=0;i<MS;i++) adj[i].clear();

  //input
  node x;
  for(i=0;i<m;i++)
  {
    scanf("%d%d%d",&u,&v,&c);
    x.dest=v;
    x.cost=c;
    adj[u].push_back(x);
    x.dest=u;
    adj[v].push_back(x);
  }

  //initialization_dij
  dij_ini();


  scanf("%d",&s);

  //dijkstra
  dij(s);

  int Q,dest;
  scanf("%d",&Q);

  while(Q--)
  {
    scanf("%d",&dest);
    if(vis[dest]==0)
      cout<<"NO PATH"<<endl;
    else
      cout<<dis[dest]<<endl;
  }

  return 0;
}


