#include<iostream>
#include<vector>
#include<algorithm>
#include<iterator>
using namespace std;
const unsigned long long MOD = 1000000007;
struct segment_tree
{
	vector<vector<int> >tree;
	void init(int n)
	{
		vector<int>tmp;
		tree.resize(4 * n + 7, tmp);
	}
	void build(vector<int>&a, int v, int l, int r)
	{
		if (l == r)
		{
			tree[v].push_back(a[l]);
		}
		else
		{
			int m = (l + r) / 2;
			build(a, 2 * v, l, m);
			build(a, 2 * v + 1, m + 1, r);
			merge(tree[2 * v].begin(), tree[2 * v].end(), tree[2 * v + 1].begin(), tree[2 * v + 1].end(), back_inserter(tree[v]));
		}
	}
	int havemore(int v, int tl, int tr, int l, int r, int x)
	{
		if (r<tl || l>tr) return 0;
		if (tl >= l && tr <= r)
		{
			if (tree[v][tree[v].size() - 1] <= x) return 0;
			if (tree[v].size() == 1) return 1;
			if (tree[v][0] > x) return tree[v].size();
			int bl = 0, br = tree[v].size();
			while (br - bl > 1)
			{
				int bm = (bl + br) / 2;
				if (tree[v][bm] <= x)
				{
					bl = bm;
				}
				else
				{
					br = bm;
				}
			}
			return tree[v].size() - br;
		}
		int tm = (tl + tr) / 2;
		return havemore(2 * v, tl, tm, l, r, x) + havemore(2 * v + 1, tm + 1, tr, l, r, x);
	}
	int haveless(int v, int tl, int tr, int l, int r, int x)
	{
		if (r<tl || l>tr) return 0;
		if (tl >= l && tr <= r)
		{
			if (tree[v][0] >= x) return 0;
			if (tree[v].size() == 1) return 1;
			if (tree[v][tree[v].size() - 1] < x) return tree[v].size();
			int bl = 0, br = tree[v].size();
			while (br - bl > 1)
			{
				int bm = (bl + br) / 2;
				if (tree[v][bm] < x)
				{
					bl = bm;
				}
				else
				{
					br = bm;
				}
			}
			return bl + 1;
		}
		int tm = (tl + tr) / 2;
		return haveless(2 * v, tl, tm, l, r, x) + haveless(2 * v + 1, tm + 1, tr, l, r, x);
	}
};
int main()
{
	unsigned long long n;
	cin >> n;
	if (n == 1)
	{
		cout << "1" << endl;
		return 0;
	}
	n *= 2;
	vector<int>a(n + 3);
	for (unsigned long long i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	segment_tree st;
	st.init(n);
	st.build(a, 1, 1, n);
	unsigned long long ans = 0, pow = 1;
	for (unsigned long long i = 1; i <= n / 2 - 2; i++)
	{
		pow = (pow * 2) % MOD;
	}
	for (unsigned long long i = 2; i <= n; i++)
	{
		unsigned long long havem = st.havemore(1, 1, n, 1, i - 1, a[i]), havel = st.haveless(1, 1, n, 1, i - 1, a[i]);
		ans = (ans + 3 * havem*pow + 2 * (i - 1 - havem - havel)*pow + havel*pow) % MOD;
	}
	cout << ans%MOD << endl;
}