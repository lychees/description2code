#include<bits/stdc++.h>
#include <iostream>
#include <numeric>
#define ll long long
#define ull unsigned long long  
#define mpa make_pair
#define pb push_back
#define ff first
#define ss second
#define boost ios_base::sync_with_stdio(0)
#define ss second
#define forp(i,a,b) for(ll i=a;i<=b;i++)
#define rep(i,n)    for(ll i=0;i<n;++i)
#define ren(i,n)    for(ll i=n-1;i>=0;i--)
#define forn(i,a,b) for(ll i=a;i>=b;i--)
#define fre     freopen("input.txt","r",stdin),freopen("output.txt","w",stdout)
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define scan(x) scanf("%lld",&x)
using namespace std;
ll modpow(ll a,ll n,ll temp){ll res=1,y=a;while(n>0){if(n&1)res=(res*y)%temp;y=(y*y)%temp;n/=2;}return res%temp;} 
//ll a[100005],n,dp[1000005]={0},b[1000005],c[100005],dp1[1000005],bit[100005];
//ll vis[100005];
//vector<ll> adj[100005];
#define pi 3.1415926536
#define sz(x) x.size()
ll ison(ll mask,ll pos){
	return (mask&(1<<pos));
}
typedef vector<ll> vi;
typedef vector<vi> vvi;
typedef pair<ll, ll> pii;
ll cbit(ll n){ll k=0;while(n) n&=(n-1),k++;return k;}
ll nbit(ll n){ll k=0;while(n) n/=2,k++;return k;}
//ll b1[1001][1001],b2[1001][1001],g1[1001][1001],g2[1001][1001],w[1001][1001];
//bool a1[101][101],a2[102][101],a3[103][101];
ll mod=1e9+7;
int sgn(ll x) {
  return x < 0 ? -1 : !!x;
}
//pair<ll,ll> a[1000005];
/*void upd(ll ind,ll val){
    if(ind==0) return;
    while(ind<=n){
        bit[ind]+=val;
        ind+=(ind&-ind);
    }
}
ll qu(ll ind){
  ll k=0; while(ind>0){
    k+=bit[ind];
    ind-=(ind&-ind);
  }
    return k;
}*/

ll o[100005],c[100005];
ll tree[500005];

//vector<ll,pair<ll,ll> > b;
vector<ll> adj[100005];
vector<ll> rdj[100005];
vector<ll> ofvs;
ll optc=mod,optn=0;
/*Tarjan incomplette
void dfs(ll s){
	vis[s]=1;
	for(ll i=0;i<adj[s].size();i++) if(!vis[adj[s][i]]) dfs(adj[s][i]);
    ofvs.pb(s);
}
void dfs2(ll s){
	vis[s]=1;
	if(wt[s]<optc){optn=0,optc=wt[s];}
	if(optc==wt[s]) optn++;
	for(ll i=0;i<rdj[s].size();i++) if(!vis[rdj[s][i]]) dfs2(rdj[s][i]);
}
*/
typedef pair<ll,pair<ll,ll> >ver;
string s;
/*void build(ll node,ll ss,ll se)
{
	if(ss==se){
	tree[node]=a[ss];
	if(s[ss]=='{') o[node]++;
	else c[node]++;
    }
	else
	{
		int mid=(ss+se)/2;
		build(2*node,ss,mid);
		build(2*node+1,mid+1,se);
		ll t=min(o[2*node],c[2*node+1]);
		o[node]=o[2*node]+o[2*node+1]-t;
		c[node]=c[node*2]+c[node*2+1]-t;
		tree[node]=tree[node*2]+tree[node*2+1]+t;
	}
}
/*void upd(ll node,ll ss,ll se,ll idx,ll val)
{
	if(ss==se)
	a[idx]=val,tree[node]=a[idx];
	else
	{
		ll mid=(ss+se)/2;
		if(ss<=idx && idx<=mid)
		upd(2*node,ss,mid,idx,val);
		else
		upd(2*node+1,mid+1,se,idx,val);
	    tree[node]=tree[node*2]+tree[node*2+1];
	}
}
ver query(int node,int ss,int se,int l,int r)
{
	if(r<ss || se<l)
	return mpa(0,mpa(0,0));
	if(l<=ss && se<=r)
	return mpa(tree[node],mpa(o[node],c[node]));
	ll mid=(ss+se)/2;
	ver p1=query(2*node,ss,mid,l,r);
	ver p2=query(2*node+1,mid+1,se,l,r);
    ll t=min(p1.ss.ff,p2.ss.ss);
	o[node]=p1.ss.ff+p2.ss.ff-t;
	c[node]=p1.ss.ss+p2.ss.ss-t;
	return mpa(p1.ff+p2.ff+t,mpa(o[node],c[node]));
}
/*ll pow(ll n){
	ll t=1,i=1;
	while(i<=n) t*=10;
	return t;
}*/
//stack<ll> help;
//ll dp[1ll<<11];
map<ll,ll> help;
ll a[100005];
ll b[100005];
 
int main(){

ll n,t,i,j,k;

cin>>t;
while(t--){
	cin>>n;
	
	for(i=1;i<=n;i++) cin>>a[i],b[i]=a[i];
	sort(a+1,a+n+1);
	reverse(a+1,a+n+1);
	ll r=1;
	help[a[1]]=1;
	for(i=2;i<=n;i++) {
    if(a[i]==a[i-1]) help[a[i]]==help[a[i-1]];
    else help[a[i]]=i;
	}
	for(i=1;i<=n;i++) cout<<help[b[i]]<<" ";
	cout<<endl;
	
	 
	
}




}

 	
 	
 	
 





  
  
  
  
  	

  
  
  
   
   
   



	














 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
  
  
  




	
	
	









  
   	
   	

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   	
   	
   	
   	
   	
  		
   		
	

	
	





	









    	
    	
    	
    	
    	
    	
	
    
		
		
		




	
	
	 
	 
	 
	 
	 
	 
	 
	 
	 
 	
  	
  
  
 
 
 

	 
	 

	  
	  
	  
	  
	  
    
    
    
    
    
    
    
    
    
    