//satyaki3794
#include <bits/stdc++.h>
#define ff first
#define ss second
#define pb push_back
#define MOD (1000000007LL)
#define LEFT(n) (2*(n))
#define RIGHT(n) (2*(n)+1)
 
using namespace std;
typedef long long ll;
typedef pair<int, int> ii;
typedef pair<int, ii> iii;
 
ll pwr(ll base, ll p, ll mod = MOD){
ll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;
}
 
ll gcd(ll a, ll b){
    if(b == 0)  return a;
    return gcd(b, a%b);
}

struct Data{
    ll dmax, umax, mmax, sum;
    Data(){}
    Data(ll dmax, ll umax, ll mmax, ll sum){
        this->dmax = dmax;
        this->umax = umax;
        this->mmax = mmax;
        this->sum = sum;
    }
};

#define N 100002
int n, par[20][N], depth[N];
vector<ii> adj[N];
Data sparse[20][N];

int LCA(int a, int b){
    if(depth[a] < depth[b]) swap(a, b);
    int diff = depth[a] - depth[b];
    for(int i=0;i<20;i++)
        if((diff >> i) & 1)
            a = par[i][a];
    if(a == b)  return a;
    for(int i=19;i>=0;i--)
        if(par[i][a] != par[i][b]){
            a = par[i][a];
            b = par[i][b];
        }
    if(a == b)  return a;
    return par[0][a];
}


void dfs(int v, int p, int d, int last){
    par[0][v] = p;
    depth[v] = d;
    sparse[0][v] = Data(last, last, last, last);
    for(auto e : adj[v])
        if(e.ff != p)
            dfs(e.ff, v, d+1, e.ss);
}


Data merge(Data a, Data b){
    //b is above a
    Data ans;
    ans.dmax = max(a.dmax, a.sum+b.dmax);
    ans.umax = max(b.umax, b.sum+a.umax);
    ans.mmax = max(a.umax+b.dmax, max(a.mmax, b.mmax));
    ans.sum = a.sum + b.sum;
    return ans;
}


Data query(int v, int dist){
    
    if(dist == 0)
        return Data(0, 0, 0, 0);
    
    int pos = -1;
    for(int i=19;i>=0;i--)
        if((dist>>i) & 1){
            pos = i;
            break;
        }
    return merge(sparse[pos][v], query(par[pos][v], dist-(1<<pos)));
}

int main(){
 
    // ios_base::sync_with_stdio(0);

    int q, e;
    scanf("%d%d", &n, &q);
    e = n-1;
    while(e--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        adj[a].pb(ii(b, c));
        adj[b].pb(ii(a, c));
    }

    memset(par, -1, sizeof(par));
    dfs(1, -1, 0, 0);
    for(int j=0;j<19;j++)
        for(int i=1;i<=n;i++){
            if(par[j][i] != -1) par[j+1][i] = par[j][par[j][i]];
            if(j == 0 || ((1<<j) > depth[i]))   continue;
            sparse[j][i] = merge(sparse[j-1][i], sparse[j-1][par[j-1][i]]);
        }

    while(q--){

        int a, b;
        scanf("%d%d", &a, &b);

        if(depth[a] > depth[b])
            swap(a, b);
        int lca = LCA(a, b);

        if(a == lca){
            Data ans = query(b, depth[b]-depth[a]);
            printf("%lld\n", ans.mmax);
        }
        else{
            Data da = query(a, depth[a]-depth[lca]);
            Data db = query(b, depth[b]-depth[lca]);
            ll ans = max(max(da.mmax, db.mmax), da.umax+db.umax);
            printf("%lld\n", ans);
        }
    }

    return 0;
}








