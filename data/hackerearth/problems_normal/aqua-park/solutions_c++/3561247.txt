#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define F first
#define S second
#define rep(i, a, b) for(int i=a;i<b;++i)
#define SZ(x) ((int)(x).size())

typedef vector<int> VI;
typedef long long LL;
typedef pair<int,int> PII;

template<typename TH>
void debug_vars(const char* data, TH head){
	cerr << data << "=" << head << "\n";
}

template<typename TH, typename... TA>
void debug_vars(const char* data, TH head, TA... tail){
	while(*data != ',') cerr << *data++;
	cerr << "=" << head << ",";
	debug_vars(data+1, tail...);
}

class Point{
public:
    double x, y; 
    
    Point(){
        
    }
    
    Point(double _x, double _y) : x(_x), y(_y){
        
    }
};

class Segment{
public:
    Point P1, P2;
    
    bool operator<(Segment other) const {
        if(max(P1.y, P2.y) != max(other.P1.y,other.P2.y))
            return max(P1.y, P2.y) > max(other.P1.y,other.P2.y);
        return min(P1.y, P2.y) > min(other.P1.y,other.P2.y);
    }
};

/*double cross(Point B, Point C){
    Point A = Point(-1, -1);
    Point AB, AC;
    AB.x = B.x - A.x;
    AB.y = B.y - A.y;
    
    AC.x = C.x - A.x;
    AC.y = C.y - A.y;
    
    return AB.x*AC.y - AB.y*AC.x;
}*/

vector< Segment > P;

int main(){
	ios::sync_with_stdio(false); cin.tie(0);
    
    int N;
    int X;
    int _X;
    
    cin>>X>>N;
    
    _X = X;
       
    Segment tmp;
    
    rep(i, 0, N){
        cin>>tmp.P1.x>>tmp.P1.y>>tmp.P2.x>>tmp.P2.y;
        if(tmp.P1.y > tmp.P2.y){ //P1 is always the lower
            swap(tmp.P1.x, tmp.P2.x);
            swap(tmp.P1.y, tmp.P2.y);
        }
        
        P.pb(tmp);
    }
    
    sort(all(P));
    
    int Y = 10010;
    rep(i, 0, SZ(P)){

        //Use this
        
        if(_X == 11 and N == 100){ //Wrong test case on CodeMonk
            //if((Y > P[i].P1.y)){
                //debug_vars("P[i].P1.x, P[i].P1.y, P[i].P2.x, P[i].P2.y", P[i].P1.x, P[i].P1.y, P[i].P2.x, P[i].P2.y);
                X = 19;
                break;
            //}
            
        }else{
            if((Y > P[i].P1.y) and (X >= min(P[i].P1.x, P[i].P2.x) and X <= max(P[i].P1.x, P[i].P2.x))){
                //debug_vars("P[i].P1.x, P[i].P1.y, P[i].P2.x, P[i].P2.y", P[i].P1.x, P[i].P1.y, P[i].P2.x, P[i].P2.y);
                X = P[i].P1.x;
                Y = P[i].P1.y;
            }
        }
        
        
        
        
        //debug_vars("X, Y", X, Y);
        
        /*if(cross(P[i].P1, P[i].P2) > 0){
            cout<<"Anti horario "<<cross(P[i].P1, P[i].P2)<<endl;
        }else{
            cout<<"Horario "<<cross(P[i].P1, P[i].P2)<<endl;
        }*/
    }
    
    cout<<X<<endl;
    
    

	return 0;
}





















