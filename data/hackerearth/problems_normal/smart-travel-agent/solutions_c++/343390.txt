///-----Neetesh--------- :)
#include<iostream>
#include<algorithm>
#include<vector>
#include<stack>
#include<set>
#include<map>
#include<queue>
#include<deque>
#include<cstring>
#include<cassert>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<string>
#include <iomanip>
#include<sstream>
#include<climits>
using namespace std;
#define rep(i,a,b) 				for(int i=a;i<b;i++) 
#define sqr(a)                  (a)*(a)
#define si(n)                   scanf("%d",&n)
#define sl(n)                   scanf("%lld",&n)
#define sf(n)                   scanf("%lf",&n)
#define ss(n)                   scanf("%s",n)
#define sc(n)                   scanf("%c",&n)
#define INF                     (int)1e9
#define LINF                    (long long)1e18
#define EPS                     1e-9
////------------Functions-------------------////
#define maX(a,b)                ((a)>(b)?(a):(b))
#define miN(a,b)                ((a)<(b)?(a):(b))
#define abS(x)                  ((x)<0?-(x):(x))
////------------Pairs-----------------------////
#define FF                      first
#define SS                      second
#define tri(a,b,c)              mp(a,mp(b,c))
#define XX                      first
#define YY                      second.first
#define ZZ                      second.second

#define fill(a,v)               memset(a,v,sizeof a)
#define all(x)                  x.begin(),x.end()
#define bug(x)   {cout << #x << " = " << x << endl;}
typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;


ll gcd(ll x, ll y) {return y == 0 ? x : gcd(y, x % y);}
inline int string_to_int(string s){stringstream ss ;ss<<s; int x; ss >> x;return x;}
inline string int_to_string(int x){stringstream ss ;ss<<x; string s ; ss >> s;return s;}
int modulo(int a,int b,int c){ //////   (a^b)%c
    long long x=1,y=a; // long long is taken to avoid overflow of intermediate results
    while(b > 0){
        if(b%2 == 1){
            x=(x*y)%c;
        }
        y = (y*y)%c; // squaring the base
        b /= 2;
    }
    return x%c;
}


long long mulmod(long long a,long long b,long long c){ ///////  (axb)%c
    long long x = 0,y=a%c;
    while(b > 0){
        if(b%2 == 1){
            x = (x+y)%c;
        }
        y = (y*2)%c;
        b /= 2;
    }
    return x%c;
}
////--------------------Fast IO ----------------------///////
#define gc getchar//_unlocked
//void input(int &x){register int c = gc();x = 0;for(;(c<48  c>57);c = gc());for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}}

////--------------------Main--------------------------///////
 
  int n;
#define V 120
 int st,ed,person;
 int graph[V][V];
int minDistance(int dist[], bool sptSet[])
{
   
   int min = -1, min_index;
 
   for (int v = 0; v < n; v++)
     if (sptSet[v] == false && dist[v] > min)
         min = dist[v], min_index = v;
 
   return min_index;
}

void dijkstra(int graph[V][V], int src)
{
     int dist[V];   
      int path[V];                
 
     bool sptSet[V]; 
 
     
     for (int i = 0; i < V; i++)
        dist[i] = -1, sptSet[i] = false,path[i]=-1;
 
    
     dist[src] = INT_MAX;
     path[src] = -1;		
    
     for (int count = 0; count < n-1; count++)
     {
       
       int u = minDistance(dist, sptSet);
       sptSet[u] = true;
       for (int v = 0; v < n; v++)
         if (!sptSet[v] && graph[u][v] && min(dist[u],graph[u][v]) > dist[v]){       	
         
            int p = min(dist[u] , graph[u][v]);
            if(p>dist[v])dist[v]=p,path[v]=u;
         }
			
     }
 
     
     	
     	
	 vector<int>r;
	 int u = ed-1;
	 while(u!=-1){
	 
 		r.push_back(u);
 		u = path[u];
 	}
	 int l = r.size();
	 if(l!=0)
	 {for(int i=l-1;i>=0;i--)cout<<r[i]+1<<" ";
cout<<endl;}

	cout<<ceil((person*1.000)/((dist[ed-1]-1)*1.00))<<endl;
}	
 
int main()
{
    int m;
    cin>>n>>m;
  
  	rep(i,0,n)rep(j,0,n)graph[i][j]=0;
  	rep(i,0,m){
	  	int from,to,cost;
	  	cin>>from>>to>>cost;
	  	graph[from-1][to-1]=cost;graph[from-1][to-1]=cost;
    }
    
    cin>>st>>ed>>person;
    

    dijkstra(graph, st-1);
 
    return 0;
}
