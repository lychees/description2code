class Topics:
    def __init__(self, id1, changeScore, score):
        self.id1 = id1
        self.changeScore = changeScore
        self.newScore = score

    def getId(self):
        return self.id1

    def getScore(self):
        if self.newScore is not None:
            return self.newScore
        else:
            return
        return self.newScore

    def getChangeScore(self):
        return self.changeScore


class MinHeap:

    def __init__(self):
        self.items = [0]
        self.current_size = 0

    def insert(self, data):
        if (self.current_size == 0):
            self.current_size += 1
            self.items.append(data)
        else:
            self.items.append(data)
            self.current_size += 1
            self.percUp(self.current_size)

    def percUp(self, current_index):
        parent_index = current_index / 2
        while (parent_index >= 1 and self.items[parent_index].getChangeScore(
        ) <= self.items[current_index].getChangeScore()):
            if (self.items[parent_index].getChangeScore() ==
                    self.items[current_index].getChangeScore()):
                if (self.items[parent_index].getId() <
                        self.items[current_index].getId()):
                    temp = self.items[parent_index]
                    self.items[parent_index] = self.items[current_index]
                    self.items[current_index] = temp
            else:
                temp = self.items[parent_index]
                self.items[parent_index] = self.items[current_index]
                self.items[current_index] = temp
            current_index = parent_index
            parent_index = current_index / 2

    def printItems(self):
        for i in range(1, len(self.items)):
            print self.items[i],
        print

    def size(self):
        return len(self.items)-1

    def isEmpty(self):
        return (self.current_size == 0)

    def delMin(self):
        min = self.items[1]
        self.items[1] = self.items[len(self.items)-1]
        self.items.pop()
        self.current_size -= 1
        if not self.isEmpty():
            self.percDown(1)
        return min

    def percDown(self, parent_index):
        while (parent_index * 2) <= self.current_size:
            min_index = self.get_Min_Index(parent_index)
            if (self.items[parent_index].getChangeScore()
                    <= self.items[min_index].getChangeScore()):
                if (self.items[parent_index].getChangeScore()
                        == self.items[min_index].getChangeScore()):
                    if (self.items[parent_index].getId()
                            < self.items[min_index].getId()):
                        temp = self.items[parent_index]
                        self.items[parent_index] = self.items[min_index]
                        self.items[min_index] = temp
                else:
                    temp = self.items[parent_index]
                    self.items[parent_index] = self.items[min_index]
                    self.items[min_index] = temp
            parent_index = min_index

    def get_Min_Index(self, parent_index):
        lchild_index = 2 * parent_index
        rchlid_index = 2 * parent_index + 1
        if rchlid_index > self.current_size:
            return lchild_index
        else:
            if (self.items[lchild_index].getChangeScore() >=
                    self.items[rchlid_index].getChangeScore()):
                if (self.items[lchild_index].getChangeScore() ==
                        self.items[rchlid_index].getChangeScore()):
                    if (self.items[lchild_index].getId() >
                            self.items[rchlid_index].getId()):
                        return lchild_index
                    else:
                        return rchlid_index
                else:
                    if (self.items[lchild_index].getChangeScore()
                            > self.items[rchlid_index].getChangeScore()):
                        return lchild_index
                    else:
                        return rchlid_index
            else:
                return rchlid_index
                # if (self.items[lchild_index].getChangeScore() < self.items[rchlid_index].getChangeScore()):
                # 	return lchild_index
                # else:
                # 	return rchlid_index

    def findMin(self):
        if not self.isEmpty():
            return self.items[1]
        else:
            return -1


heap = MinHeap()
for i in xrange(int(raw_input())):
    id1 = 0
    oldScore = 0
    newScore = 0
    tps = [int(x) for x in raw_input().strip().split(" ")]
    oldScore = tps[1]
    id1 = tps[0]
    if (tps[2] != 0):
        newScore += (tps[2] * 50)
    if (tps[3] != 0):
        newScore += (tps[3] * 5)
    if (tps[4] != 0):
        newScore += (tps[4] * 10)
    if (tps[5] != 0):
        newScore += (tps[5] * 20)
    changeScore = newScore - oldScore
    t = Topics(id1, changeScore, newScore)
    heap.insert(t)
count = 5
while (count > 0):
    out = heap.delMin()
    print out.getId(), out.getScore()
    count = count - 1
