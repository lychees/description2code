#include <iostream>
#include <queue>
#include <vector>
#include <map>
#include <cstring>
#include <stdio.h>

using namespace std;

bool v[1005];
int arr[1005];
vector<int> g[1005];

struct node
{
	int x, y, wt;
	node(int a, int b, int c)
	{
		x = a;
		y = b;
		wt = c;
	}
};

bool operator<(const node &A, const node &B)
{
	return A.wt<B.wt;
}

int dsFind(int pos)
{
	if(arr[pos]<0)
		return pos;
	arr[pos] = dsFind(arr[pos]);
	return arr[pos];
}

int dsUnion(int A, int B)
{
	int x = dsFind(A);
	int y = dsFind(B);
	if(x==y)
		return 0;
	if(arr[x]<=arr[y])
	{
		arr[x] += arr[y];
		arr[y] = x;
	}
	else
	{
		arr[y] += arr[x];
		arr[x] = y;
	}
	return 1;
}

pair<int, int> MST(int mat[][1005], int n, int type)
{
	int typ=0, th=0;
	priority_queue<node> Q;
	memset(v, 0, sizeof(v));
	for(int i=1; i<=n; i++)
	{
		for(int j=0; j<g[i].size(); j++)
		{
			if(mat[i][g[i][j]]==type || mat[i][g[i][j]]==4 || mat[i][g[i][j]]==3)
			{
				node t(i, g[i][j], mat[i][g[i][j]]);
				//cout<<"Pushing "<<i<<" "<<g[i][j]<<" "<<mat[i][g[i][j]]<<endl;
				Q.push(t);
			}
		}
	}
	while(!Q.empty())
	{
		node t = Q.top();
		Q.pop();
		//cout<<t.x<<" "<<t.y<<" "<<t.wt<<endl;
		if(dsUnion(t.x, t.y))
		{
			v[t.x] = v[t.y] = 1;
			//cout<<"Updated "<<t.x<<" "<<t.y<<endl;
			if(t.wt == 3)
				th++;
			else
				typ++;
		}
	}
	return make_pair(th, typ);
}

bool chk(int n)
{
	for(int i=1; i<=n; i++)
	{
		if(v[i]==0)//what if all nodes are not present?
		{
			//cout<<"Returning because of "<<i<<endl;
			return 0;
		}
	}
	return 1;
}

int main()
{
    int t, n, m, a, b, c, mat[1005][1005];
    	scanf("%d", &n);
    	scanf("%d", &m);
    	memset(mat, -1, sizeof(mat));
    	
    	int ed=0;
    	for(int i=0; i<=n; i++)
    		g[i].clear();
    	while(m--)
    	{
    		scanf("%d", &a);
    		scanf("%d", &b);
    		scanf("%d", &c);
    		if((mat[a][b]==1 && c==2) || (mat[a][b]==2 && c==1))
    		{
    			mat[a][b] = 4;
    			mat[b][a] = 4;
    		}
    		else
    		{
    			g[a].push_back(b);
    			g[b].push_back(a);
    			mat[a][b] = c;
    			mat[b][a] = c;
    		}
    		ed++;
    	}
    	pair<int, int> t1, t2;
    	memset(arr, -1, sizeof(arr));
    	t1 = MST(mat, n, 1);
    	bool ch2, ch1=chk(n);
    	memset(arr, -1, sizeof(arr));
    	t2 = MST(mat, n, 2);
    	ch2 = chk(n);
    	if(ch1&&ch2)
    	{
    		cout<<ed-(t1.first+t1.second+t2.second)<<endl;
    	}
    	else
    	{
    		cout<<-1<<endl;
    	}
    return 0;
}
