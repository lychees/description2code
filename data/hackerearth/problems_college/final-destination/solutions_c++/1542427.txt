#include <iostream>
#include <algorithm>
#include <cstdio>
#include <queue>
#include <cassert>
using namespace std;
inline void readint(int &a)
{
    register int c;
    a = 0;
    do c = getchar_unlocked(); while(c < '0');
    do{
    a = (a << 1) + (a << 3) + c - '0';
    c = getchar_unlocked();
    }while(c >= '0');
}
     
inline void printint(int a)
{
    char s[11];
    int t = -1;
    do{
    s[++t] = a % 10 + '0';
    a /= 10;
    }while(a > 0);
    while(t >= 0)putchar_unlocked(s[t--]);
    putchar_unlocked('\n');
}
int steps[1000001]; 

bool valid(long long int a)
{
	if (a>=2 && a<=1000000) return true;
	return false;
}
void bfs(long long int a,long long int b,long long int m,long long int d,long long int ad,long long int s,long long int st)
{
	queue<long long int> q;
	q.push(a);
	while (!q.empty())
	{
		a=q.front();
	//	cout<<a<<" "<<a*m<<endl;
		if (a==b)
		return;
		q.pop();
		if (valid(a*m) && steps[a*m]==-1)
		{
			steps[a*m]=steps[a]+1;
			q.push(a*m);
	//		bfs(a*m,m,d,ad,s,st+1);
		}
		if (valid(a/d) && steps[a/d]==-1)
		{
			steps[a/d]=steps[a]+1;
			q.push(a/d);
//			bfs(a/d,m,d,ad,s,st+1);
		}
		if (valid(a+ad) && steps[a+ad]==-1)
		{
			steps[a+ad]=steps[a]+1;
			q.push(a+ad);
//			bfs(a+ad,m,d,ad,s,st+1);
		}
		if (valid(a-s) && steps[a-s]==-1)
		{
			steps[a-s]=steps[a]+1;
			q.push(a-s);
//			bfs(a-d,m,d,ad,s,st+1);
		}	
	}

}
int main()
{
	long long int t,a,b,m,d,ad,s,i;
	cin>>t;
	
//	readint(t);
	while (t--)
	{
		cin>>a>>b>>m>>d>>ad>>s;
		assert(b>=2);
//		readint(a);
//		readint(b);
//		readint(m);
//		readint(d);
//		readint(ad);
//		readint(s);
		for (i=0;i<1000001;i++) steps[i]=-1;
		steps[a]=0;
		bfs(a,b,m,d,ad,s,0);
		cout<<steps[b]<<endl;
//		printint(steps[b]);
	}
	return 0;
}