#include<iostream>
#include<algorithm>
#include<vector>
#include<utility>
#include<cstring>
#include<set>
#include<map>
#include<numeric>

using namespace std;

#define Foreach(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))
#define rof(i,a,b) for(int (i)=(a);(i) > (b); --(i))
#define rep(i, c) for(auto &(i) : (c))
#define x first
#define y second
#define pb push_back
#define PB pop_back()
#define iOS ios_base::sync_with_stdio(false)
#define sqr(a) (((a) * (a)))
#define all(a) a.begin() , a.end()
#define error(x) cerr << #x << " = " << (x) <<endl
#define Error(a,b) cerr<<"( "<<#a<<" , "<<#b<<" ) = ( "<<(a)<<" , "<<(b)<<" )\n";
#define errop(a) cerr<<#a<<" = ( "<<((a).x)<<" , "<<((a).y)<<" )\n";
#define coud(a,b) cout<<fixed << setprecision((b)) << (a)
#define L(x) ((x)<<1)
#define R(x) (((x)<<1)+1)
#define umap unordered_map
template <class T> inline void smax(T &x,T y){ x = max((x), (y));}
template <class T> inline void smin(T &x,T y){ x = min((x), (y));}

template <typename WMT> struct Hungarian{
	static const int maxn = 90;
	static const WMT WMINF = WMT(1 << 29);
	bool S[maxn], T[maxn];
	int prv[maxn], mx[maxn], my[maxn], x, y, matched, slx[maxn];
	WMT lx[maxn], ly[maxn], w[maxn][maxn], n, slack[maxn];
	inline void init(int _n, WMT _w[][maxn]){
		n = _n;
		For(i,0,n)	For(j,0,n)	w[i][j] = _w[i][j];
	}
	inline void add_to_tree(int x, int p){
		S[x] = true;
		prv[x] = p;
		For(y, 0, n)
			if(slack[y] > lx[x] + ly[y] - w[x][y])
				slack[y] = lx[x] + ly[y] - w[x][y], slx[y] = x;
	}
	inline void AgumentInit(){
		memset(S, false, n * sizeof S[0]);
		memset(T, false, n * sizeof T[0]);
		memset(prv, -1, sizeof prv);
		For(j,0,n){
			slack[j] = WMINF;
			slx[j] = -1;
		}
	}
	inline void update_lables(){
		WMT delta = WMINF;
		For(i,0,n)	
			if(!T[i])
				smin(delta, slack[i]);
		For(i,0,n){
			if(S[i])
				lx[i] -= delta;
			if(T[i])
				ly[i] += delta;
			else
				slack[i] -= delta;
		}
	}
	inline void agument(){
		if(matched == n)	return ;
		AgumentInit();
		static int qu[maxn], head, tail;
		head = tail = 0;
		for(x = 0; x < n; x ++)
			if(mx[x] == -1){
				add_to_tree(x, -1);
				qu[tail ++] = x;
			}
		while(true){
			while(head < tail){
				x = qu[head ++];
				for(y = 0; y < n; y ++)	if(w[x][y] == lx[x] + ly[y] && !T[y]){
					if(my[y] == -1)
						break;
						T[y] = true;
					add_to_tree(my[y], x);
					qu[tail ++] = my[y];
				}
				if(y < n)	break;
			}
			if(y < n)	break;
			update_lables();
			for(y = 0; y < n;y ++)
				if(!T[y] && !slack[y]){
					x = slx[y];
					if(my[y] == -1)
							break ;
					T[y] = true;
					if(!S[my[y]]){
						add_to_tree(my[y], x);
						qu[tail ++] = my[y];
					}
				}
			if(y < n)	break ;
		}
		if(y >= n)	return ;
		++ matched;
		while(x + 1 && y + 1){
			int z = mx[x];
			mx[x] = y, my[y] = x;
			x = prv[x], y = z;
		}
		agument();
	}
	inline WMT hungarian(){
		memset(lx, 0, n * sizeof lx[0]);
		memset(ly, 0, n * sizeof ly[0]);
		memset(mx, -1, sizeof mx);
		memset(my, -1, sizeof my);
		matched = 0;
		For(i,0,n)
			For(j,0,n)
				smax(lx[i], w[i][j]);
		AgumentInit();
		agument();
		WMT ans = 0;
		For(i,0,n)
			ans += w[i][mx[i]];
		return ans;
	}
};

const int MAXN = 200 + 2;

int n, m, k, d[MAXN][MAXN];

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int te;	cin >> te;
	while (te--){
		memset(d, 63, sizeof(d));
		cin >> n >> m >> k;
		for (int i = 0; i < n; i++)	d[i][i] = 0;
		while (m--){
			int a, b, c;	cin >> a >> b >> c, a--, b--;
			d[a][b] = min(d[a][b], c);
			d[b][a] = min(d[b][a], c);
		}

		for (int kk = 0; kk < n; kk++)
			for (int i = 0; i < n; i++)
				for (int j = 0; j < n; j++)
					d[i][j] = min(d[i][j], d[i][kk] + d[kk][j]);

		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				d[i][j] = min(d[i][j], (int)1e4);

		Hungarian<int> f;
		f.n = k;
		for (int i = 0; i < k; i++)
			for (int j = n - k; j < n; j++)
				f.w[i][j - (n - k)] = -d[i][j];
		cout << -f.hungarian() << "\n";
	}
	return 0;
}	
