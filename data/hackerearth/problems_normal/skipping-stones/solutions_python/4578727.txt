def parser():
	a=map(int,raw_input().split())
	n,L,D=a[0],a[1],a[2]
	P=map(float,raw_input().split())
	dlist=map(int,raw_input().split())
	return n,L,D,P,dlist

def getStonesWhichCanBeStepped(dlist,L,stone,D):
	currentStone=stone-1
	res=[]
	if len(dlist) > stone :
		p=dlist[stone]
	else:
		p=D
	while(currentStone >=0 and p-dlist[currentStone] <=L):
		res.append(currentStone)
		currentStone=currentStone-1
	if p<=L:
		res.append(-1)
	return res	
		
	
def algo():
	n,L,D,P,dlist=parser()
	PFinalList=[]
	def getProbListFromStones(stList):
		if stList==[]:
			raise ValueError("")
		def temp(x):
			if x!=-1:
				return PFinalList[x]
			else:
				return 1	
		return map(lambda x:temp(x),stList)
	def printResults(PFList):
		ls=getStonesWhichCanBeStepped(dlist,L,n,D)	
		if ls==[]:
			print "IMPOSSIBLE"
		else:
			print '{0:.6f}'.format(max(getProbListFromStones(ls)))
		
	for i in range(0,n):
		#print i
		listOfStonesCanBeStepped=getStonesWhichCanBeStepped(dlist,L,i,D)
		probList=getProbListFromStones(listOfStonesCanBeStepped)
		#print probList
		PFinalList.append(max(probList)*P[i])
		#print PFinalList
	printResults(PFinalList)		
	#print '{0:.6f}'.format(PFinalList[n-1])
if __name__=="__main__":
	algo()
