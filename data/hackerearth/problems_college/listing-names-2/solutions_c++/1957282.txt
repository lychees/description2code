#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <cstring>
#include <cmath>
#include <set>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <sstream>
#include <iomanip>
#include <stack>
#include <ctime>
#include <typeinfo>

using namespace std;

#define pi 3.141592653589793238463
#define ll long long
#define tpi cout
#define nt endl
#define tab '\t'
#define length length()
#define fsyo return 0
#define toint(a) atoi(a.c_str())
#define sor(i,j,n) for(int i=j; i<n; i++)
#define mod 1e9+7
#define chka string::npos
#define all(c) c.begin(), c.end()
#define pow(a,b) pow((double)a,(double)b)
#define tr(container, it) for (typeof(container.begin()) it = container.begin(); it != container.end(); it++)

//long double pi = 3.141592653589793238463;


string tostring(int a)
{
	ostringstream temp;
	temp << a;
	return temp.str();
}

int gcd(int a, int b)
{
	if (a == 0)
		return b;
	else
		return gcd(b%a, a);
}

bool isPrime(unsigned ll n) {
	if (n <= 3) {
		return n > 1;
	}

	if (n % 2 == 0 || n % 3 == 0) {
		return false;
	}

	for (unsigned ll i = 5; i * i <= n; i += 6) {
		if (n % i == 0 || n % (i + 2) == 0) {
			return false;
		}
	}

	return true;
}


ll lcm(ll a, ll b)
{
	return a*b / gcd(a, b);
}

void multiply(ll F[2][2], ll M[2][2]);
void power(ll F[2][2], ll n);

ll fib(ll n)
{
	ll F[2][2] = { { 1, 1 }, { 1, 0 } };
	if (n == 0)
		return 0;
	power(F, n - 1);
	return F[0][0];
}

void power(ll F[2][2], ll n)
{
	if (n == 0 || n == 1)
		return;
	ll M[2][2] = { { 1, 1 }, { 1, 0 } };
	power(F, n / 2);
	multiply(F, F);
	if (n % 2 != 0)
		multiply(F, M);
}

void multiply(ll F[2][2], ll M[2][2])
{
	ll x = F[0][0] * M[0][0] + F[0][1] * M[1][0];
	ll y = F[0][0] * M[0][1] + F[0][1] * M[1][1];
	ll z = F[1][0] * M[0][0] + F[1][1] * M[1][0];
	ll w = F[1][0] * M[0][1] + F[1][1] * M[1][1];

	F[0][0] = x;
	F[0][1] = y;
	F[1][0] = z;
	F[1][1] = w;
}
//correct until 92

/*void multiply(ll F[2][2], ll M[2][2])
{
ll x = ((F[0][0]) % mod * (M[0][0]) % mod + (F[0][1]) % mod * (M[1][0]) % mod) % mod;
ll y = ((F[0][0]) % mod * (M[0][1]) % mod + (F[0][1]) % mod * (M[1][1]) % mod) % mod;
ll z = ((F[1][0]) % mod * (M[0][0]) % mod + (F[1][1]) % mod * (M[1][0]) % mod) % mod;
ll w = ((F[1][0]) % mod * (M[0][1]) % mod + (F[1][1]) % mod * (M[1][1]) % mod) % mod;

F[0][0] = x;
F[0][1] = y;
F[][0] = z;
F[1][1] = w;
}//fibonacci with mod e9 + 7
*/

ll sumOfDigits(ll in){
	ll sum = 0;
	while (in > 0){
		sum += in % 10;
		in /= 10;
	}
	return sum;
}

ll fact(ll in){
	ll res = 1, mult = 2;
	while (mult < in + 1){
		res *= mult;
		mult++;
	}
	return res;
}
//until 20!

/*

for (char c : STRING){
tpi << c - 'a' + 1 << nt;
}

does the same thing for every char in STRING

*/

/*

stillpos:
tpi << n << " ";
n--;

if (n > 0){
goto stillpos;
}

*/

void reverse(char* ar, int n){
	char *skizb = ar, *verj = ar + n - 1;
	while (skizb < verj){
		swap(*skizb, *verj);
		skizb++;
		verj--;
	}
}

template <typename T> void rev(T * begin, T* end){
	if (begin != end){
		end--;
		if (begin != end){
			while (true){
				swap(*begin, *end);
				begin++;
				if (begin == end){
					break;
				}
				end--;
				if (begin == end){
					break;
				}
			}
		}
	}
}

void reverse(int* ar, int n){
	int *skizb = ar, *verj = ar + n - 1;
	while (skizb < verj){
		swap(*skizb, *verj);
		skizb++;
		verj--;
	}
}

void reverse(string* ar, int n){
	string *skizb = ar, *verj = ar + n - 1;
	while (skizb < verj){
		swap(*skizb, *verj);
		skizb++;
		verj--;
	}
}

void reverse(ll* ar, int n){
	ll *skizb = ar, *verj = ar + n - 1;
	while (skizb < verj){
		swap(*skizb, *verj);
		skizb++;
		verj--;
	}
}

void rsort(vector <int> &T){	
	sort(all(T));
	reverse(all(T));
}


template <typename T> void rsort(T* begin, T* end){
	sort(begin, end);
	rev(begin, end);
}

struct str{
	int x, y, z;

	bool operator<(const str rhs) const
	{
		if (x < rhs.x)
		{
			return true;
		}
		else if (x == rhs.x)
		{
			if (y < rhs.y)
			{
				return true;
			}
			else if (y == rhs.y)
			{
				return z < rhs.z;
			}
		}
		return false;
	}

}struct1[100];

int n, m, r, k;

char alph[26] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

multiset <string> ms;
vector <ll> vec;
pair <ll, ll> p[170000];
queue <int> que;
map <string,int> mp;
set <int> st;
stack <int> sta;

// string A, getline(cin, A); will read line from console and assign it to A

pair <string, int> s[100007];

int main(){	
	string in;
	int t;
	cin >> t;
	while (t--){
		cin >> in;
		if (mp.count(in) == 0){
			mp[in] = 1;
		}
		else{
			mp[in]++;
		}
	}

	int i = 0;
	for (auto it = mp.begin(); it != mp.end(); it++){
		s[i].first = it->first;
		s[i].second = it->second;
		i++;
	}

	sort(s, s + mp.size());

	sor(i, 0, mp.size()){
		tpi << s[i].first << " " << s[i].second << nt;
	}

	fsyo;
}



/*

cin >> n;

first* point;
point = &a[0];

sor(i, 0, n){
point->x = rand() % 3;
point->y = rand() % 3;
point->z = rand() % 3;
point++;
}

tpi << nt;

sort(a, a + n);

sor(i, 0, n){
tpi << a[i].x << " " << a[i].y << " " << a[i].z << nt;
}

*/

/*

cin >> n;
tpi << nt;

srand(time(NULL));

sor(i, 0, n){
vec.push_back(rand() % 20);
tpi << vec[i] << " ";
}

tpi << nt << nt;

sort(all(vec));

sor(i, 0, n){
tpi << vec[i] << " ";
}

tpi << nt << nt;

set <int> ud(all(vec));

for (set<int>::const_iterator it = ud.begin(); it != ud.end(); it++){
tpi << *it << " ";
}
tpi << nt << nt << ud.size() << nt;

*/
