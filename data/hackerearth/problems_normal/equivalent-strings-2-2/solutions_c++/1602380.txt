#include<deque>
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;

typedef long long LL;
typedef vector<int> VI;

#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)
#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)

template<class T> inline void amin(T &a, const T &b) { if (a>b) a=b; }
template<class T> inline void amax(T &a, const T &b) { if (a<b) a=b; }
// MOD 2^64
typedef unsigned long long ULL;
struct RollingHash {
    static const ULL BASE = 2e9 + 11; // 3e9+19, 4e9+7 
    static const int MAX_LEN = 1000000;
    static const vector<ULL>powB;
    static const vector<ULL>buildB();
    deque<char> S;
    deque<ULL> H; // H[i] := hash(S[0 .. i])
    RollingHash(){}
    RollingHash(const string &str) {
	init(str);
    }
    void init(const string &str) {
	S.clear(); H.assign(1, 0ULL);
	for (int i=0; i<(int)str.size(); i++) {
	    S.push_back(str[i]);
	    H.push_back(H.back() * BASE + str[i]);
	}
    }
    ULL get(int l, int r) { // hash(S[l .. r-1])
	return H[r] - H[l] * powB[r-l];
    }
    void push(char c) {
	S.push_back(c);
	H.push_back(H.back() * BASE + c);
    }
    void pop() {
	S.pop_back();
	H.pop_back();
    }
};
const vector<ULL>RollingHash::buildB() {
    vector<ULL>h(MAX_LEN);
    h[0] = 1;
    for (int i=1; i<MAX_LEN; i++) h[i] = h[i-1]*BASE;
    return h;
}
const vector<ULL>RollingHash::powB = RollingHash::buildB();

int T;
char A[2][100111];
int Q, X[2], L;

RollingHash R[2][26];

int main() {
    scanf("%d", &T);
    REP ($, T) {
        scanf("%s%s%d", A[0], A[1], &Q);
        int n = strlen(A[0]);
        REP (t, 2) REP (i, 26) {
            string S(n, '0');
            REP (j, n) if (A[t][j] == i+'a') S[j] = 1;
            R[t][i] = RollingHash(S);
        }
            
        REP ($$, Q) {
            scanf("%d%d%d", X, X+1, &L);
            X[0]--; X[1]--;
            vector<ULL> v[2];
            REP (t, 2) {
                REP (i, 26) v[t].push_back(R[t][i].get(X[t], X[t]+L));
                sort(v[t].begin(), v[t].end());
            }
            
            bool yes = (v[0] == v[1]);

            puts(yes? "yes": "no");
        }

    }
    return 0;
}
