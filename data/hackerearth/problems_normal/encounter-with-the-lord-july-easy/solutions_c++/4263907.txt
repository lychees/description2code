//
//  main.cpp
//  Encounter with the Lord
//
//  Created by Siddhant Bharti on 7/2/16.
//  Copyright Â© 2016 Siddhant Bharti. All rights reserved.
//

#ifdef __APPLE__
    #include<cassert>
    #include<iostream>
    #include<iomanip>
    #include<ctime>
    #include<cstdio>
    #include<vector>
    #include<algorithm>
    #include<utility>
    #include<queue>
    #include<stack>
    #include<string>
    #include<cstring>
    #include<sstream>
    #include<map>
    #include<set>
    #include<stdio.h>  
    #include<string.h>
    #include<math.h>
    #include <cstring>
    #include <cctype>
    #include <list>
    #include <cmath>
    #include <limits>
    #include <iomanip>
    #include <bitset> 
    #include <numeric>
    #include <climits>

#else

    #include<bits/stdc++.h>

#endif  // __APPLE__

using namespace std;

typedef pair<int,int>   PII;
typedef vector<PII>     VPII;
typedef vector<int>     VI;
typedef vector< VI > 	VVI;

typedef  unsigned long long int ULL;

#define PB push_back
#define MP make_pair
#define F first
#define S second
#define SZ(a) (int)(a.size())
#define SET(a,b) memset(a,b,sizeof(a))
#define LET(x,a) __typeof(a) x(a)
#define ALL(c) (c).begin(),(c).end()

#define si(n) scanf("%d",&n)
#define dout(n) printf("%d\n",n)
#define sll(n) scanf("%lld",&n)
#define lldout(n) printf("%lld\n",n)
#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)

#define TR(container, it)  for( typeof(container.begin()) it = container.begin(); it != container.end(); it++  )
#define REP(i,a,b) for(int i = (int)a; i < (int)b; i++)

#define fr freopen("input.txt","r",stdin)
#define fw freopen("ouput.txt","w",stdout)

#define DRT() int t; din(t); while(t--)

#define PlUSWRAP(index,n) index = (index+1)%n		//index++; if(index>=n) index=0
#define MINUSWRAP(index,n) index = (index + n -1)%n 	//index--; if(index<0) index=n-1
#define ROUNDOFFINT(d) d = (int)((double)d + 0.5)	//Round off d to nearest integer

//#define FLUSHN while(gu()!='\n')
//#define FLUSHS while(gu()!=' ')

#define TRACE
#ifdef TRACE
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1){
		    cerr << name << " : " << arg1 << std::endl;
		     
}
template <typename Arg1, typename... Args>
void __f(const char* names, Arg1&& arg1, Args&&... args){
		    	    const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...);

}
#else
#define trace(...)
#endif


const int N =202,INF1=int(1e9);


int dist[N][N];

//////////////////////////////////////////////////////////////////////
// Min cost bipartite matching via shortest augmenting paths
//
// This is an O(n^3) implementation of a shortest augmenting path
// algorithm for finding min cost perfect matchings in dense
// graphs.  In practice, it solves 1000x1000 problems in around 1
// second.
//
//   cost[i][j] = cost for pairing left node i with right node j
//   Lmate[i] = index of right node that left node i pairs with
//   Rmate[j] = index of left node that right node j pairs with
//
// The values in cost[i][j] may be positive or negative.  To perform
// maximization, simply negate the cost[][] matrix.
//////////////////////////////////////////////////////////////////////

#include <algorithm>
#include <cstdio>
#include <cmath>
#include <vector>

using namespace std;

typedef vector<int> VD;
typedef vector<VD> VVD;
typedef vector<int> VI;
int MinCostMatching(const VVD &cost, VI &Lmate, VI &Rmate) {
    int n = int(cost.size());
    
    // construct dual feasible solution
    VD u(n);
    VD v(n);
    for (int i = 0; i < n; i++) {
        u[i] = cost[i][0];
        for (int j = 1; j < n; j++) u[i] = min(u[i], cost[i][j]);
    }
    for (int j = 0; j < n; j++) {
        v[j] = cost[0][j] - u[0];
        for (int i = 1; i < n; i++) v[j] = min(v[j], cost[i][j] - u[i]);
    }
    
    // construct primal solution satisfying complementary slackness
    Lmate = VI(n, -1);
    Rmate = VI(n, -1);
    int mated = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (Rmate[j] != -1) continue;
            if (fabs(cost[i][j] - u[i] - v[j]) < 1e-10) {
                Lmate[i] = j;
                Rmate[j] = i;
                mated++;
                break;
            }
        }
    }
    
    VD dist(n);
    VI dad(n);
    VI seen(n);
    
    // repeat until primal solution is feasible
    while (mated < n) {
        
        // find an unmatched left node
        int s = 0;
        while (Lmate[s] != -1) s++;
        
        // initialize Dijkstra
        fill(dad.begin(), dad.end(), -1);
        fill(seen.begin(), seen.end(), 0);
        for (int k = 0; k < n; k++)
            dist[k] = cost[s][k] - u[s] - v[k];
        
        int j = 0;
        while (true) {
            
            // find closest
            j = -1;
            for (int k = 0; k < n; k++) {
                if (seen[k]) continue;
                if (j == -1 || dist[k] < dist[j]) j = k;
            }
            seen[j] = 1;
            
            // termination condition
            if (Rmate[j] == -1) break;
            
            // relax neighbors
            const int i = Rmate[j];
            for (int k = 0; k < n; k++) {
                if (seen[k]) continue;
                const int new_dist = dist[j] + cost[i][k] - u[i] - v[k];
                if (dist[k] > new_dist) {
                    dist[k] = new_dist;
                    dad[k] = j;
                }
            }
        }
        
        // update dual variables
        for (int k = 0; k < n; k++) {
            if (k == j || !seen[k]) continue;
            const int i = Rmate[k];
            v[k] += dist[k] - dist[j];
            u[i] -= dist[k] - dist[j];
        }
        u[s] += dist[j];
        
        // augment along path
        while (dad[j] >= 0) {
            const int d = dad[j];
            Rmate[j] = Rmate[d];
            Lmate[Rmate[j]] = j;
            j = d;
        }
        Rmate[j] = s;
        Lmate[s] = j;
        
        mated++;
    }
    
    int value = 0;
    for (int i = 0; i < n; i++)
        value += cost[i][Lmate[i]];
    
    return value;
}

int main()
{
    //fr;fw;
	//fast_io;
    
   
    int t;
    si(t);
    
    while(t--)
    {
        int n,m,k;
        cin>>n>>m>>k;
        
        REP(i,0,N)
        {
            REP(j,0,N)
            {
                dist[i][j]=INF1;
            }
        }
        
        REP(i,0,m)
        {
            int x,y,c;
            si(x);si(y);si(c);
            
            dist[x][y]=min(dist[x][y],c);
            dist[y][x]=min(dist[y][x],c);
        }
        
        for(int k=1;k<=n;k++)
        {
            for(int i=1;i<=n;i++)
            {
                for(int j=1;j<=n;j++)
                {
                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
                }
            }
        }
        
        
        VVI C(k,VI(k,0));
        
        for(int i=0;i<k;i++)
        {
            for(int j=0;j<k;j++)
            {
                C[i][j]=min(10000,dist[i+1][n-k+j+1]);
            }
        }
        
        VI l,r;
        
        dout(MinCostMatching(C, l, r));
      
        
        
    }//



	return 0;
}










