#include <cstdio>
#include <vector>
#include <queue>
#include <iostream>
using namespace std;
 
#define MAX 100000
 
int numberVertex, numberEdges;
int particion[MAX], visited[MAX];
vector< int > adjacencyMatrix[MAX];
 
bool bfs(int begin)
{
    int i, origin, destination;
    queue< int > queueVertex;
    queueVertex.push(begin);
    particion[begin] = 1; // 1 left,
    visited[begin] = 1; // set adjacencyMatrixray
 
    while(!queueVertex.empty())
    {
        origin = queueVertex.front(); queueVertex.pop();
        for(i=0; i < adjacencyMatrix[origin].size(); i++)
        {
            destination = adjacencyMatrix[origin][i];
            if(particion[origin] == particion[destination])
            {
                return false;
            }
            if(visited[destination] == 0)
            {
                visited[destination] = 1;
                particion[destination] = 3 - particion[origin]; // alter 1 and 2 subsets
                queueVertex.push(destination);
            }
        }
    }
    return true;
}
 
bool is_bipartite()
{
    for(int i=0; i< numberVertex; i++)
    {
       if (visited[i] == 0 && !bfs(i)) {
           return false;
       }
    }
    return true;
}
 
int main()
{
    //freopen("tarea2.in", "r", stdin);
    int t;
    scanf("%d",&t);
    while(t--){
    	for(int i=0;i<MAX;i++){ visited[i] = particion[i] = 0;
    	adjacencyMatrix[i].clear();}
    int i,j, nodeOrigin, nodeDestination;
    scanf("%d%d", &numberVertex, &numberEdges);
    for(i=0; i<numberEdges; i++)
    {
        scanf("%d%d", &nodeOrigin, &nodeDestination);
        nodeOrigin--;
        nodeDestination--;
        adjacencyMatrix[nodeOrigin].push_back(nodeDestination);
        adjacencyMatrix[nodeDestination].push_back(nodeOrigin);
    }
    if(is_bipartite()) {
 
        printf("YES\n");
 
    }
    else {printf("NO\n");}
    }
 
    return 0;
}