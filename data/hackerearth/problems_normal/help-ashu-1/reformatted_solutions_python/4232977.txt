import math


class segment:
    def log2n(self, n):
        return math.log(n) / math.log(2)

    def __init__(self, arr):
        self.arr = arr
        N = len(self.arr)
        x = int(math.ceil(self.log2n(N)))
        self.st = [[] for i in xrange(2*(2 ** x) - 1)]
        self.build(0, N-1, 0)

    def build(self, start, end, node):
        if start == end:
            self.st[node] = self.arr[start] % 2
            return self.st[node]
        mid = (start + end) / 2
        n1 = self.build(start, mid, 2*node + 1)
        n2 = self.build(mid + 1, end, 2*node + 2)
        self.st[node] = n1 + n2
        return self.st[node]

    def update(self, node, start, end, ix, value):
        # print "**",self.st
        if start == end:
            self.arr[ix] = value
            self.st[node] = value % 2
        else:
            mid = (start + end) / 2
            if start <= ix <= mid:
                self.update(2*node + 1, start, mid, ix, value)
            else:
                self.update(2*node + 2, mid+1, end, ix, value)
            self.st[node] = self.st[2*node+1] + self.st[2*node+2]

    def count_odd(self, node, start, end, l, r):
        if start > r or end < l:
            return 0
        if start >= l and end <= r:
            return self.st[node]
        mid = (start + end) / 2
        p1 = self.count_odd(2 * node + 1, start, mid, l, r)
        p2 = self.count_odd(2 * node + 2, mid + 1, end, l, r)
        return p1 + p2


def solution():
    N = int(input())
    arr = list(map(int, raw_input('').strip().split(' ')))
    t = segment(arr)
    Q = int(input())
    for i in xrange(Q):
        case, x, y = map(int, raw_input().strip().split(' '))
        # print t.st
        if case == 0:
            t.update(0, 0, N-1, x-1, y)
            # print t.st
            # print t.arr
        elif case == 1:
            print "%d" % ((y - x + 1) - t.count_odd(0, 0, N-1, x-1, y-1))
        else:
            print "%d" % (t.count_odd(0, 0, N-1, x-1, y-1))


solution()
