// 2016-02-06
#include <bits/stdc++.h>
using namespace std;


#ifdef NOT_ONLINE_JUDGE
//#include <vld.h>
#pragma comment(linker, "/STACK:256000000")
#endif


#define ff first
#define ss second
#define sz(x) (int)((x).size())
#define szo(x) sizeof(x)
#define mem2d(arr, value) (fill(&arr[0][0], &arr[0][0] + szo(arr) / szo(decltype(value)), value));
#define mem(arr, value) memset(arr, value, szo(arr));
#define fo(i, j, k) for (int i = j; i <= (int)(k); ++i) // [j..k]
#define fd(i, j, k) for (int i = j; i >= (int)(k); --i) // [j..k]
#define wmm(x) while ((x)--)
#define gg cout << "OK\n"
#define dd(x) cout << #x << " = " << x << "\n";
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front

#define SET_BIT(mask, index) (mask |= (1LL << index))
#define TEST_BIT(mask, index) (mask & (1LL << index))
#define CLEAR_BIT(mask, index) (mask &= ~(1LL << index))
#define TOGGLE_BIT(mask, index) (mask ^= (1LL << index))
const int INF = 1000000000;
const int NO_VALUE = -1;
using pii = pair<int, int>;
using pip = pair<int, pii>;
using ll = long long;
using vi = vector<int>;
using vll = vector<ll>;
using vs = vector<string>;
#define umap unordered_map
#define uset unordered_set


template <class T>
T scan() {
    T t;
    cin >> t;
    return t;
}

#define sc(T) scan<decltype(T)>()
#define sci scan<int>()
#define scll scan<ll>()
#define scs scan<string>()
#define scd scan<double>()


int mod;

struct Matrix {
    Matrix(int R, int C) {
        this->R = R;
        this->C = C;
        mat = vector<vll>(R, vll(C, 0));
    }

    void makeIdentity() {
        fo(i, 0, R - 1) {
            fo(j, 0, C - 1) {
                mat[i][j] = (i == j);
            }
        }
    }

    void print() {
        fo(i, 0, R - 1) {
            fo(j, 0, C - 1) {
                cout << mat[i][j] << " ";
            }
            cout << "\n";
        }
    }

    int R, C;
    vector<vll> mat;
};


Matrix matrixMult(Matrix a, Matrix b) {
    assert(a.C == b.R);

    Matrix ans(a.R, b.C);

    fo(i, 0, ans.R - 1) {
        fo(j, 0, ans.C - 1) {
            fo(k, 0, a.C - 1) {
                ans.mat[i][j] += ((a.mat[i][k] % mod) * (b.mat[k][j] % mod)) % mod;
                ans.mat[i][j] %= mod;
            }
        }
    }

    return ans;
}


Matrix matrixPow(Matrix base, int expo) {
    Matrix ans(base.R, base.C);
    ans.makeIdentity();

    while (expo) {
        if (expo & 1) {
            ans = matrixMult(ans, base);
        }
        base = matrixMult(base, base);
        expo >>= 1;
    }

    return ans;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
#ifdef NOT_ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w+", stdout);
#endif


    mod = 10000003;
    vi f{0, 1, 1};

    int tc = sci;
    wmm(tc) {
        int n = sci;

        Matrix M(5, 5);
        M.mat = {{0, 1, 1, 1, 0},{1, 0, 0, 0, 0},{0, 1, 0, 0, 0},{0, 0, 0, 1, 1},{0, 0, 0, 0, 1}};
        Matrix A(5, 1);
        A.mat = {{1},{1},{0},{6},{2}};

        if (n < 3) {
            cout << f[n] << "\n";
        }
        else {
            Matrix B = matrixMult(matrixPow(M, n), A);
            cout << B.mat[2][0] << "\n";
        }
    }


    return 0;
}

