/*   Mobile Conversations 
You have just purchased a new mobile phone and you want to call all of your relatives to brag about your new phone. You have N relatives. You will talk to ith relative for exactly Ti minutes. Each minute costs you 1 dollar . However, your relatives are generous. Hence after the conversation, they will add a recharge of Xi dollars in your mobile. Initially, you have M dollars balance in your mobile phone. 

Find the minimum value of M, that you must have initially, in your phone, so that you don't run out of balance during any of the call (encounter negative balance). 

Note : You can call relatives in any order. Each relative will be called exactly once.

INPUT
The first line will contain N, the number of relatives. Next N lines will have two space separated integers, "Ti Xi" (quotes for clarity), representing call duration with the ith relative and the amount of recharge you will get from that relative after the conversation.

OUTPUT
Output a single integer M, the minimum required initial balance in your mobile phone.

CONSTRAINTS
1 ≤ N,X,T ≤ 105 
 */
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

 
struct call {
	long int T, X;
	call (long int a, long int b) {
		T = a;
		X = b;
	}
};

bool compareEle(call p1, call p2) {
		long int m, n;
		m = p1.X - p1.T;
		n = p2.X - p2.T;
		return (m > n);
}
bool compareasc(call p1, call p2) {
	return (p1.T < p2.T);
}
bool comparedesc(call p1, call p2) {
	return (p1.X > p2.X);
}
int main(int argc, char const *argv[])
{
	long int N, T, X;
	long int sum =0, min = 0;
	cin >> N;
	vector <call> arrays;
	

	for (long int n = 0; n < N; n++) {
		cin >> T >> X;
		arrays.push_back(call(T, X));
	}
	sort(arrays.begin(), arrays.end(), compareEle);

	vector < call > :: iterator it;
	for (it = arrays.begin();; it++) {
		if (it == arrays.end()) {
			break;
		}
		if (it->X < it->T) {
			break;
		}
		//cout << it<< endl;
	}
	sort(arrays.begin(), it, compareasc);
	sort(it, arrays.end(),comparedesc);

	for (long int i = 0; i < N; i++) {
		sum -= arrays[i].T;
		if(sum < min) {
			min = sum;
		}
		sum += arrays[i].X;
	}
	cout << -(min) << endl;
	return 0;
}