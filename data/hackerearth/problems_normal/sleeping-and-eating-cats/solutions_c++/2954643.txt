#include <stdio.h>
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define FILL(a,x) memsetval(a,x,sizeof(a))
#define	foreach( gg,ii ) for( typeof(gg.begin()) ii=gg.begin();ii!=gg.end();ii++)
#define	mp make_pair
#define	pb push_back
#define	X first
#define	Y second
#define sz(a) ll((a).size())
#define mod 1000000007
#define N 100010
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(ll i=a;i<b;++i)
const ll INF = 1e18+1;

inline ll input(void)
{
	char t;
	ll x=0;
	ll neg=0;
	t=getchar();
	while((t<48 || t>57) && t!='-')
		t=getchar();
	if(t=='-')
		{neg=1; t=getchar();}
    while(t>=48 && t<=57)
    {
        x=(x<<3)+(x<<1)+t-48;
        t=getchar();
    }
	if(neg)
		x=-x;
	return x;
}

inline void output(ll x)
{
	char a[20];
	ll i=0,j;
	a[0]='0';
	if (x<0) {putchar('-'); x=-x;}
	if (x==0) putchar('0');
	while(x)
	{
		a[i++]=x%10+48;
		x/=10;
	}
	for(j=i-1;j>=0;j--)
	{
		putchar(a[j]);
	}
	putchar('\n');
}

typedef struct node {ll lcol; ll rcol; ll num; ll llen; ll rlen; bool lazy;} node;

node Tree[3*N];
ll a[N];

inline void setval(ll vertex, ll l, ll r, ll col)
{
	Tree[vertex].lcol=col;
	Tree[vertex].rcol=col;
	Tree[vertex].num=((r-l+1)*(r-l+2))/2;
	Tree[vertex].llen=r-l+1;
	Tree[vertex].rlen=r-l+1;
	if (l!=r) Tree[vertex].lazy=true;
	else Tree[vertex].lazy=false;
}

inline void maketree(ll vertex, ll l, ll r)
{
	if (l==r)
	{
		Tree[vertex].lcol=a[l];
		Tree[vertex].rcol=a[r];
		Tree[vertex].llen=1;
		Tree[vertex].rlen=1;
		Tree[vertex].num=1;
		Tree[vertex].lazy=false;
		return;
	}
	ll m=(l+r)/2,left=2*vertex,right=left+1;
	maketree(left,l,m);
	maketree(right,m+1,r);
	Tree[vertex].lcol=Tree[left].lcol;
	Tree[vertex].rcol=Tree[right].rcol;
	Tree[vertex].llen=Tree[left].llen;
	if (Tree[left].llen==m-l+1&&Tree[left].rcol==Tree[right].lcol) Tree[vertex].llen+=Tree[right].llen;
	Tree[vertex].rlen=Tree[right].rlen;
	if (Tree[right].rlen==r-m&&Tree[left].rcol==Tree[right].lcol) Tree[vertex].rlen+=Tree[left].rlen;
	Tree[vertex].num=Tree[left].num+Tree[right].num;
	if (Tree[right].lcol==Tree[left].rcol) Tree[vertex].num+=Tree[left].rlen*Tree[right].llen;
	Tree[vertex].lazy=false;
	return;
}

inline void updatechilds(ll vertex, ll l, ll r)
{
	ll m=(l+r)/2,left=2*vertex,right=left+1;
	setval(left,l,m,Tree[vertex].lcol);
	setval(right,m+1,r,Tree[vertex].lcol);
	Tree[vertex].lazy=false;
}

inline void lazyupdate(ll vertex, ll l, ll r, ll u, ll v, ll col)
{
	if (l==u&&r==v)
	{
		Tree[vertex].lcol=col;
		Tree[vertex].rcol=col;
		Tree[vertex].num=((v-u+1)*(v-u+2))/2;
		Tree[vertex].rlen=v-u+1;
		Tree[vertex].llen=v-u+1;
		if (l!=r) Tree[vertex].lazy=true;
		else Tree[vertex].lazy=false;
		return;
	}
	ll m=(l+r)/2,left=2*vertex,right=left+1;
	if (Tree[vertex].lazy) updatechilds(vertex,l,r);
	if (u>m) lazyupdate(right,m+1,r,u,v,col);
	else if (v<=m) lazyupdate(left,l,m,u,v,col);
	else
	{
		lazyupdate(right,m+1,r,m+1,v,col);
		lazyupdate(left,l,m,u,m,col);
	}
	Tree[vertex].lcol=Tree[left].lcol;
	Tree[vertex].rcol=Tree[right].rcol;
	Tree[vertex].llen=Tree[left].llen;
	if (Tree[left].llen==m-l+1&&Tree[left].rcol==Tree[right].lcol) Tree[vertex].llen+=Tree[right].llen;
	Tree[vertex].rlen=Tree[right].rlen;
	if (Tree[right].rlen==r-m&&Tree[left].rcol==Tree[right].lcol) Tree[vertex].rlen+=Tree[left].rlen;
	Tree[vertex].num=Tree[left].num+Tree[right].num;
	if (Tree[right].lcol==Tree[left].rcol) Tree[vertex].num+=Tree[left].rlen*Tree[right].llen;
	Tree[vertex].lazy=false;
	return;
}

inline node query(ll vertex, ll l, ll r, ll u, ll v)
{
	if (l==u&&r==v) return Tree[vertex];
	ll m=(l+r)/2,left=2*vertex,right=left+1;
	if (Tree[vertex].lazy) updatechilds(vertex,l,r);
	if (v<=m) return query(left,l,m,u,v);
	if (u>m) return query(right,m+1,r,u,v);
	node ans,a,b;
	a=query(left,l,m,u,m);
	b=query(right,m+1,r,m+1,v);
	ans.lcol=a.lcol;
	ans.rcol=b.rcol;
	ans.llen=a.llen;
	if (a.llen==m-l+1&&a.rcol==b.lcol) ans.llen+=b.llen;
	ans.rlen=b.rlen;
	if (b.rlen==r-m&&a.rcol==b.lcol) ans.rlen+=a.rlen;
	ans.num=a.num+b.num;
	if (b.lcol==a.rcol) ans.num+=a.rlen*b.llen;
	ans.lazy=false;
	return ans;
}

void printtree(int vertex, int l, int r)
{
	if (l!=r)
	{
		ll m=(l+r)/2,left=2*vertex,right=left+1;
		printtree(left,l,m);
		printtree(right,m+1,r);
	}
	printf("Vertex of %d to %d, having rlen as %lld, llen as %lld and num as %lld\n",l+1,r+1,Tree[vertex].rlen,Tree[vertex].llen,Tree[vertex].num);
}

int main()
{
ll n,m,i,u,v,code;
n=input();
m=input();
for(i=0;i<n;i++) a[i]=input();
maketree(1,0,n-1);
while(m--)
{
	code=input();
	if (code==1)
	{
	u=input();
	v=input();
	u--;
	v--;
	output(query(1,0,n-1,u,v).num);
	}
	else
	{
		u=input();
		u--;
		v=input();
		v--;
		code=input();
		lazyupdate(1,0,n-1,u,v,code);
		//printtree(1,0,n-1);
	}
}
return 0;
}
