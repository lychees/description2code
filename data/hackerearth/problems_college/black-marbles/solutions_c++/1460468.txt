#include <bits/stdc++.h>
typedef unsigned long long int ull;
typedef long long int ll;
 
 
int Y=0, X=0;
char C[701][701];
size_t ix[700][700];
 
 
struct pos
{
	pos(): x(), y() {}
	pos(int _x, int _y): x(_x), y(_y) {}
	pos &operator+= (pos const &d) { x+=d.x; y+=d.y; return *this; }
	pos operator+ (pos const &rhs) const { return pos(x+rhs.x,y+rhs.y); }
	pos operator- (pos const &rhs) const { return pos(x-rhs.x,y-rhs.y); }
	pos operator* (int m) const { return pos(x*m,y*m); }
	friend pos operator* (int m, pos const &rhs) { return pos(rhs.x*m,rhs.y*m); }
	friend std::ostream& operator<< (std::ostream &o, pos const &p) { o << "(" << p.x << "," << p.y << ")"; return o; }
	void rot_ccw90() { int m=y; y=x; x=-m; }
	void rot_cw90() { int m=y; y=-x; x=m; }
	int x, y;
};
 
 
template <size_t N, size_t O>
struct max_bipartite_matching_hopcroft_karp
{
	static size_t const INF=size_t(-1);
	size_t ord[N];
	size_t adj[N][O];
	size_t nx, ny;
	size_t dist[N];
	size_t xy[N];
	size_t q[N];
 
	bool bfs()
	{
		size_t qr=0, qw=0;
		for(size_t i=1; i<=nx; ++i)
		{
			if(xy[i]==0)
			{
				dist[i]=0;
				q[qw++]=i;
			}
			else dist[i]=INF;
		}
		dist[0]=INF;
		while(qr!=qw)
		{
			size_t u=q[qr];
			qr=(qr+1)%N;
			if(u!=0)
			{
				for(size_t i=0; i<ord[u]; ++i)
				{
					size_t v=adj[u][i];
					if(dist[xy[v]]==INF)
					{
						dist[xy[v]]=dist[u]+1;
						q[qw]=xy[v];
						qw=(qw+1)%N;
					}
				}
			}
		}
		return dist[0]!=INF;
	}
 
	bool dfs(size_t u)
	{
		if(u!=0)
		{
			for(size_t i=0; i<ord[u]; ++i)
			{
				size_t v=adj[u][i];
				if(dist[xy[v]]==dist[u]+1)
				{
					if(dfs(xy[v]))
					{
						xy[v]=u;
						xy[u]=v;
						return true;
					}
				}
			}
			dist[u]=INF;
			return false;
		}
		return true;
	}
 
	size_t solve()
	{
		size_t matching=0;
		for(size_t i=0; i<=nx+ny; ++i)
			xy[i]=0;
		while(bfs())
			for(size_t i=1; i<=nx; ++i)
				if(xy[i]==0 && dfs(i))
					++matching;
		return matching;
	}
};
 
 
max_bipartite_matching_hopcroft_karp<701*701/8, 4> wat;
 
 
size_t solve(int mx, int my)
{
	// index every node in this group
	size_t n1=0, n2=0;
	for(int y=my; y<Y; y+=2)
		for(int x=(mx+y-my)%4; x<X; x+=4)
			if(C[y][x]=='F')
			{
				if(x/2%2)
					ix[y][x]=n1++;
				else ix[y][x]=n2++;
			}
	wat.nx=n1;
	wat.ny=n2;
	for(size_t i=0; i<=n1+n2; ++i)
		wat.ord[i]=0;
 
	// connect nodes in group
	for(int y=my; y<Y; y+=2)
		for(int x=(mx+y-my)%4; x<X; x+=4)
			if(C[y][x]=='F')
				if(x/2%2)
				{
					size_t i=ix[y][x];
					pos d(1,1);
					for(size_t rot=0; rot<4; ++rot)
					{
						int p1x=x+d.x, p1y=y+d.y;
						int p2x=x+2*d.x, p2y=y+2*d.y;
						if(0<=p2x && p2x<X && 0<=p2y && p2y<Y
							&& C[p2y][p2x]=='F' && C[p1y][p1x]!='P')
						{
							wat.adj[i+1][wat.ord[i+1]++]=1+n1+ix[p2y][p2x];
						}
						d.rot_ccw90();
					}
				}
 
	// max cardinality matching
	size_t c=wat.solve();
	return n1+n2-c;
}
 
 
int main()
{
	while(1)
	{
		scanf("%d %d", &Y, &X);
		if(X==0 || Y==0)
			break;
 
		for(int y=0; y<Y; ++y)
			scanf("%s", C[y]);
		for(pos p(0,0); p.y<Y; ++p.y)
			for(p.x=0; p.x<X; ++p.x)
				if(C[p.y][p.x]=='G')
				{
					pos d(1,1);
					for(size_t rot=0; rot<4; ++rot)
					{
						pos p1=p+d;
						pos p2=p1+d;
						if(0<=p2.x && p2.x<X && 0<=p2.y && p2.y<Y
							&& C[p1.y][p1.x]!='P' && C[p2.y][p2.x]=='F')
						{
							C[p2.y][p2.x]='X';
						}
						d.rot_ccw90();
					}
				}
 
		size_t r=0;
		for(int mx=0; mx<4; ++mx)
			for(int my=0; my<2; ++my)
				r+=solve(mx, my);
		printf("%zu\n", r);
	}
	return 0;
}