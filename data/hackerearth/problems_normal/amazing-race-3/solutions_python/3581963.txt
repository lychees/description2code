n, m, k = [int(i) for i in raw_input().split()]
XA, YA, XB, YB = [[] for i in xrange(4)] 
for t in xrange(n):
	x, y = [int(i) for i in raw_input().split()]
	XA.append(x); YA.append(y)
for t in xrange(m):
	x, y = [int(i) for i in raw_input().split()]
	XB.append(x); YB.append(y)
s = [int(i) * int(i) for i in raw_input().split()]

def ok(lim):
	g = [[] for i in xrange(n) ]
	sqr = lambda x : x * x
	dist = lambda x, y, X, Y : sqr(X - x) + sqr(Y - y)  
	for i in xrange(n):
		for j in xrange(m):
			if (dist(XA[i], YA[i], XB[j], YB[j]) + s[i] - 1) / s[i] <= lim:
				g[i].append(j)
	match = [-1 for i in xrange(m)]
	vis = [0 for i in xrange(n)]
	ret, tim = 0, 42
	
	def dfs(u):
		vis[u] = tim
		for v in g[u]:
			if match[v] == -1 or (vis[match[v]] != tim and dfs(match[v])):
				match[v] = u
				return True
		return False

	for i in xrange(n):
		if dfs(i):
			ret += 1
			tim += 1

	return ret >= k

low, high, poss = 0, int(4e12), 0
while high >= low:
	mid = (high + low) // 2
	if(ok(mid)):
		poss =  mid; high = mid - 1
	else:
		low = mid + 1 

print poss