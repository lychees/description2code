#include <stdio.h>
#include <string>
#include <vector>
#include <iostream>
#include <stdlib.h>
#include <queue>
#include <set>
#include <algorithm>
#include <climits>
#include <cstring>
#define infty 10000000
using namespace std;
int M,N;
char G[709][709];
int vertid[709][709];
 
int dx[]={-2,2,-2,2};
int dy[]={-2,-2,2,2};
 
 
char buf[6400002];
 
int readint() {
        int m;
        static char *bp=buf;
        while(*bp<'0' || *bp>'9')
        *bp++;
 
        for(m=*bp++-48; *bp>=48; bp++) m = m*10+*bp-48;
        bp++;
        return m;
}
 
char readchar() {
        int m;
        static char *bp=buf;
        while(*bp!='F' && *bp!='G' && *bp!='P')
          *bp++;
        //printf("%c\n",*bp);
        char c = *bp;
        bp++;
        //printf("%c\n",c);
        return c;
}
 
 
bool inbounds(int x,int y,int maxx,int maxy)
{
  return (x>-1 && x<maxx && y>-1 && y<maxy);
 
}
 
bool safe(int x1,int y1,int x2,int y2)
{
  return G[(x1+x2)>>1][(y1+y2)>>1]=='P';
 
}
bool guarantee(int x,int y)
{
  if(G[x][y]!='F')
    return false;
  for(int d=0;d<4;d++)
    {
      if(inbounds(x+dx[d],y+dy[d],M,N) &&
         (G[x+dx[d]][y+dy[d]]=='G' || G[x+dx[d]][y+dy[d]]=='F') &&
         !safe(x,y,x+dx[d],y+dy[d]))
        return false;
    }
  return true;
}
bool canput(int x,int y)
{
  for(int d=0;d<4;d++)
    {
      if(inbounds(x+dx[d],y+dy[d],M,N) &&
         G[x+dx[d]][y+dy[d]]=='G' &&
         !safe(x,y,x+dx[d],y+dy[d]))
        return false;
    }
  return true;
}
 
 
 
typedef long long int64;
 
 
typedef int T;
 
 
#define mem(a, b) memset(a, b, sizeof(a))
 
 
#define Sqr(x) ((x) * (x))
 
 
 
inline T Max ( T a, T b )
{
    if ( a < b ) a = b;
    return a;
}
 
 
inline T Min ( T a, T b )
{
    if ( a > b ) a = b;
    return a;
}
 
 
inline void Swap ( T & a, T & b )
{
    T t = a;
    a = b;
    b = t;
}
 
 
 
const int maxn = 40000;
 
 
const int maxm = 160000;
 
 
const double EPS = 1e-10;
 
 
const int INF = INT_MAX / 2;
 
 
 
 
 
struct EDGE
{
    int a, b;
    int next;
};
 
 
 
 
 
int nx, ny, m;
 
 
EDGE edge[maxm];
 
 
int edge_num;
 
 
int first[maxn];
 
 
int cx[maxn], cy[maxn];
 
int Degree_x[maxn], Degree_y[maxn];
 
 
int distx[maxn], disty[maxn]; 
 
 
 
 
 
int que[maxn];
 
 
int head, tail;
 
 
 
 
 
int ans;
 
 
 
 
 
void Debug ( void )
{
    int i, j;
}
 
 
 
 
 
int Adj[701*361][4];
 
int available[701*361];
 
 
queue<int> vertices_pq[5];
 
void solve(int u, int d, int* new_single, bool* change, int* matching)
{
 
  if(available[u]!=d || cx[u] != -1)
    return;
  for (int j = first[u]; j != -1; j = edge[j].next )
  {
    int v = edge[j].b;
    if(cy[v] == -1)
    {
      cy[v]=u;
      cx[u]=v;
      for(int k=0;k<Degree_y[v];k++)
      {
        int w = Adj[v][k];
        available[w]--;
        if(available[w] > 0)
        {
          if(available[w] == 1)
           *new_single = w;
          //else
          vertices_pq[available[w]].push(w);
        }
      }
      *change = true;
      (*matching)++;
      return;
    }
  }
}
 
 
 
int Init_Match()
{
  for(int i=0;i<5;i++)
  {
    while(!vertices_pq[i].empty())
      vertices_pq[i].pop();
  }
  int matching = 0;
  for(int u=0;u<nx;u++)
  {
    if(cx[u] == -1 && Degree_x[u]>0)
      vertices_pq[Degree_x[u]].push(u);
    available[u] = Degree_x[u];
  }
  bool change = true;
  while(change)
  {
    change = false;
    for(int d=1;d<=4;d++)
    {
      while(!vertices_pq[d].empty())
      {
        int u = vertices_pq[d].front();
        vertices_pq[d].pop();
        int new_single = -1;
        solve(u,d,&new_single,&change,&matching);
        while(new_single != -1) {
          int next = new_single;
          new_single = -1;
          solve(next, available[next], &new_single, &change, &matching);
        }
      }
    }
  }
  return matching;
}
 
 
 
 
 
 
 
 
 
 
 
 
void Init ( void )
{
    int i, j;
    fill ( cx, cx + nx+2, -1 );
    fill ( cy, cy + ny+2, -1 );
    fill ( Degree_x, Degree_x + nx+1,0);
    fill ( Degree_y, Degree_y + ny+1,0);
    fill ( first, first + nx+ny+2, -1 );
    edge_num = 0;
    ans = 0;
}
 
 
 
 
void AddEdge ( int a, int b )
{
    edge[edge_num].a = a, edge[edge_num].b = b;
    edge[edge_num].next = first[a], first[a] = edge_num++;
    Adj[b][Degree_y[b]++]=a;
    Degree_x[a]++;
}
 
 
 
 
 
bool BFS ( void )
{
    int i, j, k;
    bool flag ( 0 );
    int h, t;
    mem ( distx, 0);
    mem ( disty, 0);
    head = tail = 0;
    for ( i = 1; i <= nx; i++ )
    {
        if ( cx[i] == -1 ) que[tail++] = i;
    }
    while ( head != tail )
    {
        for ( h = head, t = tail; h != t; h = ( h + 1 ) % maxn )
        {
            i = que[h];
            for ( k = first[i]; k != -1; k = edge[k].next )
            {
                j = edge[k].b;
                if ( !disty[j] )
                {
                    disty[j] = distx[i] + 1;
                    if ( cy[j] == -1 ) flag = 1;
                    else
                    {
                        distx[cy[j]] = disty[j] + 1;
                        que[tail] = cy[j];
                        tail = ( tail + 1 ) % maxn;
                    }
                }
            }
        }
        head = t;
    }
    return flag;
}
 
 
 
 
 
bool DFS ( int i )
{
    int j, k;
    for ( k = first[i]; k != -1; k = edge[k].next )
    {
        j = edge[k].b;
        if ( disty[j] == distx[i] + 1 )
        {
            disty[j] = 0;
            if ( cy[j] == -1 || DFS ( cy[j] ) )
            {
                cx[i] = j, cy[j] = i;
                return 1;
            }
        }
    }
    return 0;
}
 
 
 
 
 
void Hopcroft_Karp ( void )
{
  //ans+=Init_Match();
    int i, j;
    int iters=0;
    while ( BFS() )
    {
      iters++;
 
        for ( i = 1; i <= nx; i++ )
        {
            if ( cx[i] == -1 && DFS ( i ) ) ans++;
        }
    }
}
 
int main()
{
  //fread(buf, 1, 6300000, stdin);
  while(1)
    {
      //M=readint();
      //N=readint();
      scanf("%d%d",&M,&N);
      if(M+N==0)
        break;
      //printf("%d %d\n",M,N);
      //M=N=700;
      for(int i=0;i<M;i++)
      {
        scanf("%s",&G[i]);
        continue;
        //printf("%d\n",i);
        for(int j=0;j<N;j++)
        {
          G[i][j]=readchar();
          //G[i][j]='F';
        }
      }
      int final_answer=0;
      for(int cx=0;cx<4;cx++)
        for(int cy=0;cy<2;cy++)
        {
          nx = 0;
          for(int i=cx;i<M;i+=4)
            for(int j=cy;j<N;j+=4)
              vertid[i][j] = (G[i][j]=='F' && canput(i,j) ? nx++ : -1);
          ny = 0;
          for(int i=(cx+2)%4;i<M;i+=4)
            for(int j=(cy+2)%4;j<N;j+=4)
              vertid[i][j] = (G[i][j]=='F' && canput(i,j) ? ny++ : -1);
 
          //printf("%d %d\n",nx,ny);
          Init();
          for(int i=cx;i<M;i+=4)
            for(int j=cy;j<N;j+=4)
            {
              if(vertid[i][j]>=0)
                for(int d=0;d<4;d++)
                {
                  int ni = i+dx[d];
                  int nj = j+dy[d];
                  if(inbounds(ni,nj,M,N) && vertid[ni][nj]!=-1 && !safe(i,j,ni,nj))
                  {
                    if(vertid[i][j]>=nx || vertid[ni][nj]>=ny)
                      printf("err\n");
                    AddEdge(vertid[i][j]+1, vertid[ni][nj]+1);
                    //printf("added\n");
                  }
                }
            }
          Hopcroft_Karp();
          final_answer += nx+ny-ans;
        }
      // printf("%d-%d\n",nx+ny,ans);
      printf("%d\n",final_answer);
      //exit(-1);
    }
}