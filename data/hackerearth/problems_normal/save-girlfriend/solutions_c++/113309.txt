

#include <vector>
#include <algorithm>
#include <list>
#include <map>
#include <deque>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <iostream>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>


#define sqr(x) ( (x)*(x) )
#define Size(a) int((a).size()) 
#define pb push_back
#define mset(x,v) memset(x,v,sizeof(x))
#define all(c) (c).begin(),(c).end() 
#define SORT(x) sort(all(x))
#define present(c,x) ((c).find(x) != (c).end()) 
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define chk(x,n) ( x[n>>6] & (1<< ( (n>>1) & 31) )  ) // checks if  the bit corresponding to n is 1 
#define set(x,n) ( x[n>>6] |= (1<< ( (n>>1) & 31) )  ) // sets the bit corresponding to n to 1 - meaning its composite 
#define mod 1000000007
#define limit (int)1e6
typedef long long int ll;
typedef long double ld;
typedef unsigned int ui;
typedef unsigned long long int ull;	
using namespace std;
typedef vector<int> VI;
typedef set<int> SI;
typedef map<int,int> MII;
typedef pair<int,int> PII;

int is_prime[limit>>6];
VI p;
void sieve()
{
	int i,j;		
	mset(is_prime,0);

	
	for( i=3;i*i < limit;i+=2) 
	{
		if(!chk(is_prime,i))
		{

			for( j=i*i;j < limit;j+=(2*i)) 
			{
				set(is_prime,j);
			}
		}
	}

	p.pb(2);
	for( i=3;i < limit;i+=2)
	{
		if ( !chk(is_prime,i) )
		{
			p.pb(i);
		}
	}
}
int arr[10001];
ll numdiv[10001];
int main()
{
	sieve();
	int t,n,a,b,N;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&a,&b);
		for (int i = a; i<=b; i++) 
		{
			arr[i-a]=i;
		}

		for (int i = 0; i<b-a+1;i++)
		{
			int n=arr[i];
			int no=n;
			ll divs=1;
			for (int j = 0; j<Size(p)&&sqr(p[j])<=no; j++) 
			{
				int power=0;
				while(no%p[j]==0)
				{
					no/=p[j];power++;
				}
				divs=divs*(ll)(1+power);
			}
			if(no>1)
			{
				divs*=2;
			}
			numdiv[i]=divs;
		}
		vector<ll> divisors(numdiv,numdiv+b-a+1);
		SORT(divisors);
		pair<vector<ll>::iterator,vector<ll>::iterator> bounds;
		bounds=equal_range(all(divisors),divisors[b-a]);
		printf("%d\n",bounds.second-bounds.first+1);
	}
	return 0;
}

