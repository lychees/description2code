#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for (int i=(a);i<=(b);(i)++)
#define per(i,a,b) for (int i=(a);i>=(b);(i)--)
#define reps(i,a,b,s) for (int i=(a); i<=(b); (i)+=(s))
#define pers(i,a,b,s) for (int i=(a); i>=(b); (i)-=(s))
#define sz(x) ((int)(x).size())
#define F first
#define S second
#define gc getchar
#define mp make_pair
#define pb push_back
#define fill(a, v) memset((a), (v), sizeof(a))
#define fore(v, c) for(auto&& (v): (c))
#define gcd __gcd
#define bcnt __builtin_popcount
#define prd(x) std::fixed<<std::setprecision(10)<<(x)
#define mt make_tuple
#define eb emplace_back

typedef long long ll;
typedef unsigned int ui;
typedef long double ld;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;

template<typename T1, typename T2>
std::ostream &operator <<(std::ostream &os, const std::pair<T1,T2> &v) {
  os<<"("<<v.first<<","<<v.second<<")";
  return os;
}

template<typename T>
std::ostream &operator <<(std::ostream &os, const std::vector<T> &v) {
  fore(x,v) {
    os<<x<<",";
  }
  return os;
}

#ifdef loc
  #define tra1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl
  #define tra2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl
  #define tra3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl
  #define tra4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl
  #define tra5(a,b,c,d,e)   cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<" | "#e" = "<<e<<endl
  #define tra6(a,b,c,d,e,f) cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<" | "#e" = "<<e<<" | "#f" = "<<f<<endl
  #define traa(x,a,b)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "; rep(i,a,b) cerr<<x[i]<<","; cerr<<endl;
#else
  #define tra1(x)
  #define tra2(x,y)
  #define tra3(x,y,z)
  #define tra4(a,b,c,d)
  #define tra5(a,b,c,d,e)
  #define tra6(a,b,c,d,e,f)
  #define traa(x,a,b)
  #define endl '\n'
#endif

ll mod=1000000007;
const ld pi = 3.14159265358979323846264338327950288419716939937510;
inline void fm(ll &a, ll &m=mod) { a%=m; if(a<0) a+=m; }
inline ll po(ll a,ll b, ll &m=mod) {ll res=1%m;fm(a,m);for(;b;b>>=1){if(b&(1LL))res=res*a%m;a=a*a%m;}return res;}
inline ll inv(ll a, ll &m=mod) { fm(a,m); return po(a,m-2,m); }
const ld eps = 1e-10;
const int oo = 1000000009;
const ll ooo = 2e18+5;


ll sl(){ 
  int c =gc();
  while((c<'0' || c>'9') && c!='-') {
    c = gc();
  }
  bool sign = 0;
  if(c=='-') {
    sign = 1;
    c = gc();
  }
  ll ret = 0;
  while(c>='0' && c<='9') {
    ret = 10 * ret + c - 48;
    c = gc();
  }
  if(sign) return -ret;
  return ret;
}

int ss(char *s) {
  int n = 0;
  int c = gc();
  while(!((c>='a' && c<='z') || (c>='A' && c<='Z'))) c = gc();
  while(((c>='a' && c<='z') || (c>='A' && c<='Z'))) {
    s[n] = (char)(c);
    n++;
    c = gc();
  }
  return n;
}

struct node{/*{{{*/
public:
  ll p, sum, sq, up;
  void merge(node& l, node& r){
    sum = l.sum+r.sum; fm(sum);
    p = l.p+r.p; fm(p);
    sq = l.sq+r.sq; fm(sq);
  }
  void split(node& l, node& r){
    if(up) {
      ll temp = up*up; fm(up);
      l.sq+=(l.p*temp+2*up*l.sum); fm(l.sq);
      l.sum+=l.p*up; fm(l.sum);
      l.up+=up; fm(l.up);
      r.sq+=(r.p*temp+2*up*r.sum); fm(r.sq);
      r.sum+=r.p*up; fm(r.sum);
      r.up+=up; fm(r.up);
      up = 0;
    }
  }
  node() {
    p = sum = sq = up = 0;
  }
};/*}}}*/
template<class node>
class segtree{/*{{{*/
	template<bool b>class param{};
	inline void spltdwn(int idx,param<true>){splt(idx);}
	inline void splt(int idx){/*{{{*/
		idx>>=1;
		if(idx>0)splt(idx);
		tree[idx].split(tree[idx<<1],tree[(idx<<1)|1]);
	}/*}}}*/
	inline void spltdwn(int,param<false>){};
	inline void split(node& a, node& b, node& c, param<true> ){return a.split(b,c);}
	inline void split(node&, node&, node&, param<false>){}
	template<typename t,void (t::*)(t&,t&)> class T{};
	template<typename t> static char test(T<t,&t::split>*){return 0;}
	template<typename t> static long double test(...){return 0;}
	int u,v;
	node query(int root, int left_range, int right_range){/*{{{*/
		if(u<=left_range && right_range<=v)
			return tree[root];
		int mid = (left_range + right_range)>>1,
			l = root<<1,
			r = l|1;
		if(has_split)split(tree[root],tree[l],tree[r],param<has_split>());
		node res;
		if(u>=mid)res=query(r,mid,right_range);
		else if(v<=mid)res=query(l,left_range,mid);
		else{
			node n1 = query(l,left_range,mid),
				 n2 = query(r,mid,right_range);
			res.merge(n1,n2);
		}
                if(has_split) tree[root].merge(tree[l],tree[r]);
		return res;
	}/*}}}*/
 	template<void(*fn)(node&)>
	void local_update(int root, int left_range,int right_range){/*{{{*/
		if(u<=left_range && right_range<=v){
			return fn(tree[root]);
		}
		int mid = (left_range + right_range)>>1,
			l = root<<1,
			r = l|1;
		if(has_split)split(tree[root],tree[l],tree[r],param<has_split>());
		if(v>mid)local_update<fn>(r,mid,right_range);
		if(u<mid)local_update<fn>(l,left_range,mid);
		tree[root].merge(tree[l],tree[r]);
	}/*}}}*/
	void mrgup(int idx){/*{{{*/
		idx>>=1;
		while(idx>0)
			tree[idx].merge(tree[idx<<1],tree[(idx<<1)|1]),
			idx>>=1;
	}/*}}}*/
public:
	static bool const has_split = (sizeof(test<node>(0))==sizeof(char));
	int N;
	int leftmost_leaf, rightmost_leaf;
	node* tree;
	node identity;
	segtree(){ tree=0; }
	~segtree(){
                if(tree) delete[] tree;
	}
	void init(int n, const node a[], const node& identity){/*{{{*/
                if(tree) delete[] tree;
		this->identity = identity;
		N=0;
		while((1<<N)<n)N++;
		leftmost_leaf = 1<<N;
		rightmost_leaf = leftmost_leaf<<1;
		tree = new node[rightmost_leaf];
		for(int i=0;i<n;i++)
			tree[i+leftmost_leaf] = a[i];
		for(int i=n+leftmost_leaf;i<rightmost_leaf;i++)
			tree[i]=identity;
		for(int i=leftmost_leaf-1;i;i--)
			tree[i].merge(tree[i<<1],tree[(i<<1)|1]);
	}/*}}}*/
	node query(int u, int v){//[u,v]/*{{{*/
		this->u=u+leftmost_leaf;
		this->v=v+leftmost_leaf+1;
		return query(1,leftmost_leaf,rightmost_leaf);
	}/*}}}*/
	node query(int u){//faster version of query(u,u)/*{{{*/
		//indexing starts from 0
		u+=leftmost_leaf;
		spltdwn(u,param<has_split>());
		return tree[u];
	}/*}}}*/
	template<void(*fn)(node&)>
	void update(int u, int v){/*{{{*/
		//0-indexed
		this->u=u+leftmost_leaf;
		this->v=v+leftmost_leaf+1;
		return local_update<fn>(1,leftmost_leaf,rightmost_leaf);
	}/*}}}*/
	template<void(*fn)(node&)>
	void update(int u){//faster version of update(u,u)/*{{{*/
		//indexing starts from 0
		u+=leftmost_leaf;
		spltdwn(u,param<has_split>());
		fn(tree[u]);
		mrgup(u);
	}/*}}}*/
	void split_down(int leaf_idx){/*{{{*/
		spltdwn(leaf_idx+leftmost_leaf,param<has_split>());
	}/*}}}*/
	void merge_up(int leaf_idx){/*{{{*/
		mrgup(leaf_idx+leftmost_leaf);
	}/*}}}*/
	bool is_leaf(int tree_idx){return tree_idx>=leftmost_leaf;}
	int binary_search(node k){/*{{{*/
	//search the last place i, such that merge( everyting to the left of i(including i) ) compares less than k
        int root = 1;
        node n=identity;
		//identity satisfies merge(identity,y) = merge(y,identity) = y for all y.
		assert(!(k<identity));
        while(!is_leaf(root)){
                int left_child = root<<1,
					right_child = left_child|1;
                if(has_split)
					split(tree[root],tree[left_child],tree[right_child],param<has_split>());
                node m;
                m.merge(n,tree[left_child]);
                if(m<k){//go to right side
                        n=m;
                        root=right_child;
                }else root=left_child;
        }
        node m;
        m.merge(n,tree[root]);
		mrgup(root);
        if(m<k)return root-leftmost_leaf;
        else return root-1-leftmost_leaf;
	}/*}}}*/
};/*}}}*/

node sn[200005];
segtree<node> st;
int pr[200005];

ll val;
void upd(node &c){ 
  ll temp = val*val; fm(temp);
  c.sq+=(c.p*temp+2*val*c.sum); fm(c.sq);
  c.sum+=c.p*val; fm(c.sum);
  c.up+=val; fm(c.up);
}

int main() {
  srand((ui)time(0));
  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
  int n;
  cin>>n;
  ll res =0;
  fill(pr,-1);
  rep(i,0,n-1) {
    sn[i].p = 1;
  }
  st.init(n,sn,sn[n]);
  rep(i,0,n-1) {
    int x;
    cin>>x;
    val = 1;
    st.update<&upd>(pr[x]+1,i);
    res+=st.query(0,i).sq; fm(res);
    pr[x] = i;
  }
  cout<<res<<endl;
  
  
  return 0;
}