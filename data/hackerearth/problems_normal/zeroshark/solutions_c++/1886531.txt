
//https://www.hackerearth.com/june-easy-15/algorithm/zeroshark/

#include <vector>
#include <queue>
#include <map>
#include <set>
#include <utility> //Pair
#include <algorithm>
#include <sstream> // istringstream>> ostring stream<<
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <limits>

using namespace std;
 
 
typedef long long ll;
typedef vector <int> vi;
typedef pair< int ,int > pii;
typedef istringstream iss;
typedef ostringstream oss;

#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define sz size()
#define ln length()
#define rep(i,n) for(int i=0;i<n;i++)
#define fu(i,a,n) for(int i=a;i<=n;i++)
#define fd(i,n,a) for(int i=n;i>=a;i--)
#define all(a) a.begin(),a.end()
#define ESP (1e-9)
#define INF (1e9) 
#define fill(space,a) memset(space,a,sizeof(space))
#define MAXL 1000001
#define MOD 1000000007
int dp[MAXL][5][5];
bool exist[MAXL][5][5];

// need to find how many of the n bit representations(2**n) have one consecutive 00
// dp[i][j][k] says for length i , last alphabet j(0,1) ,how many 00 comes(0,1,1+)
// n is the bits left starting from back we can as weel start from the front

ll solve(int n,int presPairs,int lastdigit){
	if(n == 0){
		if(presPairs == 1) return 1;
		return 0;
	}

	if(!exist[n][presPairs][lastdigit]){
		ll ret=0;
		if(lastdigit == 1){
			ret += solve(n-1,presPairs,0);
			ret += solve(n-1,presPairs,1);
			ret %= MOD;
		}
		else{
			ret += solve(n-1,presPairs,1);
			int newPairs =  ((presPairs == 0) || (presPairs == 1))? presPairs+1: presPairs;
			ret += solve(n-1,newPairs,0);
			ret %= MOD;
		}
		exist[n][presPairs][lastdigit] = true;
		dp[n][presPairs][lastdigit] = ret; 
	}
	return dp[n][presPairs][lastdigit];

}

int main(){
	int t;cin >> t;
	while(t--){
		fill(dp,0);
		fill(exist,0);
		int n;cin >> n;
		ll ways = solve(n-1,0,0);
		ways+=solve(n-1,0,1);
		ways %= MOD;
		cout << ways << endl;
	}
	return 0;
}