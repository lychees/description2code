#include <bits/stdc++.h>

using namespace std;

multiset < pair < int , int > > great;
multiset < int > good;
vector < pair < int , int > > v;
bool finished [100000 + 10];

int main()
{

    int t, n , m, tem1, tem2, g , h;

    cin >> t;

    while(t--){

        good.clear();                           // clear storage for every case
        great.clear();
        v.clear();
        memset(finished, false, sizeof finished);

        cin >> n >> m;

        for(int i = 0; i < m; i++){             // new subjects

            cin >> tem1 >> tem2;
            v.push_back({tem1, tem2});
        }

        for(int j = 0; j < n; j++){

            cin >> tem1 >> tem2;
            great.insert({tem1, tem2});     
            good.insert(tem1);
        }

        cin >> g >> h;

        int numGreat = 0, numGood = 0;

        for(int i = 0; i < m; i++){

            pair < int , int > check = v[i];

            if(great.find(check) != great.end()){       // check if this pair found in the old subjects

                finished[i] = true;                     // mark as selectedto be good pair and great combination
                great.erase(great.find(check));         // erase this old subjects from th set
                good.erase(good.find(v[i].first));

                numGreat++; 
                numGood++;
            }
        }

        for(int i = 0; i < m; i++){

            if(finished[i]) continue;               // we can't choose an old subject more than once

            if(good.find(v[i].first) != good.end()){

                numGood++;
                good.erase(good.find(v[i].first));
            }
        }

        if(numGood >= g && numGreat >= h) cout << "Great\n";
        else if (numGood >= g) cout << "Good\n";
        else cout << ":(\n";
    }

    return 0;
}