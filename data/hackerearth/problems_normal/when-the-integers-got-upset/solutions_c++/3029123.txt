#include<stdio.h>
#include<algorithm>
#include<string.h>

using namespace std;

typedef long long ll;

ll DP[(1<<12)+5][13][13];
ll a[15],n,P[15];
const ll one = 1;

ll bit_count(ll a)//count no. of set bits
{
    ll cnt = 0;
    while(a)
    {
       if(a&1)
            cnt++;
       a=a/2;
    }
    return cnt;
}

ll find_pos(ll mask, ll p, ll q)// calculates upset value for a particular arrangement determined by set bits in mask
{
    if(bit_count(mask) == n)
    {
        return 0;
        //all bits of mask is set means all positions have been selected
    }

    if(DP[mask][p][q]!= -1)
        return DP[mask][p][q];
    //mask has pth and qth bit set as active, p is taken as first stone and q as second
    ll ans = (1e+9);
    for(ll i=0; i<n;++i)
    {
        if((mask & (1<<i)) == 0)//selecting the ith bit which is not set in mask
        {
            ans = min(ans, (a[p]^a[q]^a[i])*P[bit_count(mask)] + find_pos((mask|(one<<i)),q,i));
        }
    }
    DP[mask][p][q] = ans;
    return ans;
}

int main()
{
    ll t;
    scanf("%lld",&t);
    while(t--)
    {
        scanf("%lld",&n);
        memset(DP,-1,sizeof DP);
        for(ll i=0;i<n;++i)
            scanf("%lld",&a[i]);
        for(ll i=0;i<n;++i)
            scanf("%lld",&P[i]);

        ll ans = (1e+9);

        for(ll i=0;i<n;++i)
        {
            for(ll j=0;j<n;++j)
            {
                if(i==j)
                    continue;
                ll mask = (one<<i|one<<j);//mask with i and j set
                ans = min(ans, find_pos(mask,i,j));
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}
