/*
* hackerearth.com/code-monk-binary-indexed-tree/algorithm/shil-and-wave-seqeuncemonk/
*/

#include <bits/stdc++.h>
using namespace std;

const int N = 1e5;
const int MOD = 1e9 + 7;
int BIT1[N + 1], BIT2[N + 1];

void updateBIT1(int k, int delta) {
	while (k) {
		BIT1[k] = (BIT1[k] + delta) % MOD;
		k -= k & -k;
	}
}

int getBIT1(int k) {
	long long ret = 0;
	while (k <= N) {
		ret += BIT1[k];
		k += k & -k;
	}
	return ret % MOD;
}

void updateBIT2(int k, int delta) {
	while (k <= N) {
		BIT2[k] = (BIT2[k] + delta) % MOD;
		k += k & -k;
	}
}

int getBIT2(int k) {
	long long ret = 0;
	while (k) {
		ret += BIT2[k];
		k -= k & -k;
	}
	return ret % MOD;
}

int main() {
	//freopen("input.txt", "rt", stdin);
	int n; scanf("%d", &n);
	int ai, t;
	for (int i = 0; i < n; ++i) {
		scanf("%d", &ai);
		t = 0;
		if (ai > 1) t = getBIT2(ai - 1);
		updateBIT1(ai, t + 1);
		t = 0;
		if (ai < N)	t = getBIT1(ai + 1);
		updateBIT2(ai, t + 1);
	}
	int res = (getBIT1(1) + getBIT2(N) - 2 * n) % MOD;
	cout << res;
}