#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <vector>
#include <string.h>
#include <limits.h>
#include <list>
#include <algorithm>
#define SIZE 102
using namespace std;
int adj[102][102];
int MaxMST[102][102];
int V,source,desti,tourists;
int maxKey(int key[], bool mstSet[])
{
   int max = INT_MIN, max_index;

   for (int v = 1; v <= V; v++)
     if (mstSet[v] == false && key[v] > max)
         max = key[v], max_index = v;

   return max_index;
}
int printMST(int parent[])
{
   for (int i = 2; i <= V; i++)
   {
       MaxMST[parent[i]][i]=adj[i][parent[i]];
       MaxMST[i][parent[i]]=adj[i][parent[i]];
   }
}
void primMST()
{
     int parent[V+1]; // Array to store constructed MST
     int key[V+1];   // Key values used to pick minimum weight edge in cut
     bool mstSet[V+1];  // To represent set of vertices not yet included in MST

     for (int i = 1; i <= V; i++)
        key[i] = INT_MIN, mstSet[i] = false;
     key[1] = 0;     // Make key 0 so that this vertex is picked as first vertex
     parent[1] = -1; // First node is always root of MST

     for (int count = 0; count < V-1; count++)
     {
        int u = maxKey(key, mstSet);
        mstSet[u] = true;
        for (int v = 1; v <= V; v++)
          if (adj[u][v] && mstSet[v] == false && adj[u][v] >  key[v])
             parent[v]  = u, key[v] = adj[u][v];
     }
     printMST(parent);
}
vector<int> path;
int arr[102],temp[102],indu=1;
bool visited[102];
void DFS(int v,int k)
{
    visited[v]=true;
    path.push_back(v);
        for(int i=1;i<=V;i++)
        {
          if(MaxMST[v][i]!=0 && visited[i]==false)
          {
              DFS(i,k);
          }
        }
        if(v==desti)
        {
            for (int f=0;f<path.size();f++)
              cout<<path[f]<<" ";
              cout<<endl;
            for (int f=0;f<path.size()-1;f++)
                temp[f]=MaxMST[path[f]][path[f+1]];
          /*  for (int f=0;f<path.size()-1;f++)
                cout<<temp[f]<<" ";
            cout<<endl; */
            int minian=INT_MAX;
            for (int f=0;f<path.size()-1;f++)
                if(minian>temp[f])
                   minian=temp[f];
           // cout<<minian;
            minian--;
            int ans=(tourists-tourists%minian)/minian;
            if(tourists%minian!=0)
                ans++;
            cout<<ans;
        }
            path.pop_back();

}
int main()
{
   // freopen("input.txt","r",stdin);
    int v,e,s,d,w;
    cin>>V>>e;
    while(e--)
    {
        cin>>s>>d>>w;
        adj[s][d]=w;
        adj[d][s]=w;
    }
    cin>>source>>desti>>tourists;
    primMST();
    int k=0;
    DFS(source,k);
   // for (int i=0;i<path.size();i++)
   //     cout<<path[i]<<" ";
    return 0;
}
/*
6 8
1 2 30
1 3 10
2 3 25
2 4 60
3 5 40
4 5 35
4 6 20
5 6 10
1 6 20
*/
