#include<bits/stdc++.h>
using namespace std;
int visited[1258];
int dist[1258];
int At[1251][1251],Bt[1251][1251];
int COST[1251],n;
typedef pair<int,int> mp;
void Dijkstra1(int start,int arr[1251][1251])
{
    memset(visited, 0, sizeof(visited));
    dist[start]=0;
    priority_queue < mp ,vector< mp > ,greater< mp > > Q;
    Q.push(mp(dist[start],start));
     while(!Q.empty())
    {
        mp tops = Q.top();
        Q.pop();
        int v=tops.second;
        int d=tops.first;
        if(visited[v]==1)                       //Vertex has been visited
                            continue;
        visited[v]=1;
        int siz=n;
        for(int i=1; i<=n; i++ )
        {
           // int v2=V[v][i].first;
            int cost=arr[v][i];
            if(dist[i]>=dist[v]+cost)
            {
                dist[i]=dist[v]+cost;
                if(visited[i]==0)
                {
                    Q.push(mp(dist[i],i));
                }
            }
        }
    }
    return;
}
void Dijkstra2(int start,int arr[1251][1251])
{
    memset(visited, 0, sizeof(visited));
    dist[start]=0;
    priority_queue < mp ,vector< mp > ,greater< mp > > Q;
    Q.push(mp(dist[start],start));
     while(!Q.empty())
    {
        mp tops = Q.top();
        Q.pop();
        int v=tops.second;
        int d=tops.first;
        if(visited[v]==1)                       //Vertex has been visited
                            continue;
        visited[v]=1;
        int siz=n;
        for(int i=1; i<=n; i++ )
        {
           // int v2=V[v][i].first;
            int cost=arr[i][v];
            if(dist[i]>=dist[v]+cost)
            {
                dist[i]=dist[v]+cost;
                if(visited[i]==0)
                {
                    Q.push(mp(dist[i],i));
                }
            }
        }
    }
    return;
}
int main()
{
    int i,T,tmp,j;
    scanf("%d",&n);
    
    for(i=1; i<=n; i++)
    {
    	for(j=1; j<=n; j++)
    	{
    		scanf("%d", &At[i][j]);
    	}
    	COST[i]=INT_MAX;
    }
    for(i=1; i<=n; i++)
    {
    	for(j=1; j<=n; j++)
    	{
    		scanf("%d", &Bt[i][j]);
    	}
    }
    
   
    int U,V,Z;
    scanf("%d %d",&U,&V);
   int k;
     
       
            for(k=1; k<=n; k++)
            {
                dist[k] = INT_MAX;
            }
            Dijkstra1(U,At);
            for(j=1;j<=n;j++)
            	At[U][j]=dist[j];
       
    
    
        for(int k=1; k<=n; k++)
            {
                dist[k] = INT_MAX;
            }
            Dijkstra2(V,At);
        for(j=1;j<=n;j++)
        {
            
            At[j][V]=dist[j];
        }
    
      
       for(int k=1; k<=n; k++)
            {
                dist[k] = INT_MAX;
            }
            Dijkstra1(U,Bt);
        for(j=1;j<=n;j++)
        {
            
            Bt[U][j]=dist[j];
        }
            for(int k=1; k<=n; k++)
            {
                dist[k] = INT_MAX;
            }
            Dijkstra2(V,Bt);
        for(j=1;j<=n;j++)
        {
            Bt[j][V]=dist[j];
        }
     /* for(i=1;i<=n;i++)
      	{
      		for(j=1;j<=n;j++)
      			cout<<At[i][j]<<" ";
      			cout<<endl;
      	}
      for(i=1;i<=n;i++)
      	{
      		for(j=1;j<=n;j++)
      			cout<<Bt[i][j]<<" ";
      			cout<<endl;
      	}*/
    int Ans= INT_MAX;
    for(i=1; i<=n; i++)
    {
    	if(i!=U && i!=V)
    	{
    		Z=i;
    		COST[i] = min(At[U][Z]+Bt[Z][V], Bt[U][Z]+At[Z][V]);
    	}
    	//cout<<COST[i]<<endl;
    	if(Ans>COST[i])
    				Ans = COST[i];
    	//cout<<Ans<<endl;
    }
    printf("%d\n",Ans);
    return 0;    
}