// template
#include <bits/stdc++.h>
#include <vector>

#define ll long long
#define ull unsigned long long
#define pb push_back
#define mp make_pair
#define f first
#define s second
#define PI 3.1415926535897

#define sd(a) scanf("%d", &a);
#define sc(a) scanf(" %c", &a);
#define sf(a) scanf("%f", &a);
#define sll(a) scanf("%lld", &a);
#define s1d(a,n) for(i=0;i<n;++i) scanf("%d", &a[i]);
#define s1l(a,n) for(i=0;i<n;++i) scanf("%ld", &a[i]);
#define s1ll(a,n) for(i=0;i<n;++i) scanf("%lld", &a[i]);

#define pd(a) printf("%d", a);
#define pc(a) printf("%c", a);
#define pf(a) printf("%f", a);
#define pll(a) printf("%lld", a);
#define p1d(a,n) for(i=0;i<n;++i) printf("%d ",a[i]);
#define p1l(a,n) for(i=0;i<n;++i) printf("%ld ",a[i]);
#define p1ll(a,n) for(i=0;i<n;++i) printf("%lld ",a[i]);
#define pn() printf("\n");

using namespace std;

const int MOD = 1e9 + 7;
const int N = 2e5;
int p[N], f[N], rf[N];

// GCD
ll gcd(ll a, ll b){
	if(b == 0) return a;
	else return gcd(b,a%b);
}

// modular multiplication
ll mult(ll x, ll y){
    return (x * y) % MOD;
}
/* 	This method is used for Euler's Theorem which states
	a^(phi(p)) mod p = 1
	But if p is prime, a^(p-1) mod p = 1 --- (1)
	Therefore, from (1)
 	a^(-1) mod p = a^(p-2) mod p
*/
ll pow_mod(ll base,ll exp){
    ll ans=1;
    while(exp){
        if(exp&1) ans = mult(ans,base);
        base = mult(base,base);
        exp >>= 1;
    }
    return ans;
}
ll inv(ll x){
	return pow_mod(x, MOD - 2);
}

// Modular Factorial and Modular Multiplicative inverse
void fact(){
    f[0] = 1;
	for (int i = 1; i < N; i++){
        f[i] = mult(f[i - 1], i);
	}
    rf[N - 1] = inv(f[N - 1]);
	for (int i = N - 1; i > 0; i--){
        rf[i - 1] = mult(rf[i], i);
	}
}
// Fn to compute Combination which eventually uses Euclid's Theorem
ll C(int n, int k){
	if (k < 0 || k > n) return 0;
	return mult(f[n], mult(rf[k], rf[n - k]));
}

// Sieve of Eratosthenes
void sieve(){
    memset(p,0,sizeof(p));
    p[0] = p[1] = 1;
	int m;
    for(int i=2; i<N; ++i){
        if(!p[i]){ // if prime then mark multiples of that no
			m = i+i;
			while(m <= N){
				p[m] = 1;
				m += i;
			}
        }
    }
}

// initial computation
void init(){
    //fact();
    //sieve();
    return;
}

int main(){
    //init();
    int t,x,i;
    sd(t)
    while(t--){
    	int n,k,p;
        sd(n) 
        sd(k) 
        sd(p)
        if(n-k < p){
        	for(i=0;i<k;++i) sd(x)
        	pd(-1)
        } 
        else{
        	for(i=0;i<k;++i){
        		sd(x)
        		if(x <= p) p++;
        	}
        	pd(p)
        }
        pn()
    }
    return 0;
}
