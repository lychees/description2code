#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <algorithm>
#include <cmath>

#define pb push_back
#define mp make_pair
#define sqr(x) ((x)*(x))
#define forn(i,n) for(int i  = 0;i<(int)n;i++)
#define dforn(i,n) for(int i = n-1;i>=0;i--)

using namespace std;

void dfs(int s,vector<vector<int>> &g, vector<int> &tp_s, vector<char> &used){
	used[s] = 1;
	forn(i,g[s].size()){
		if(used[g[s][i]]==0)
			dfs(g[s][i],g,tp_s,used);
	}
	tp_s.pb(s);
}

int main()
{
    #ifdef Home
    	freopen("in.txt","r",stdin);
    	freopen("out.txt","w",stdout);
    #endif
   	int n,m;
   	scanf("%d %d",&n,&m);
   	vector<vector<int>>g(n+1,vector<int>());
   	vector<vector<pair<int,int>>>pred(n+1,vector<pair<int,int>>());
   	forn(i,m){
   		int a,b,c;
   		scanf("%d %d %d",&a,&b,&c);
   		g[a].pb(b);
   		pred[b].pb(mp(a,c));
   	}
   	vector<char>used(n+1,0);
   	vector<int>topological_sorted;
   	for(int i = 1;i<=n;i++){
   		if(used[i]==0)
   			dfs(i,g,topological_sorted,used);
   	}
   	reverse(topological_sorted.begin(),topological_sorted.end());
   	long long ans = 0;
   	vector<long long>dp(n+1,0);
   	forn(i,n){
   		int v = topological_sorted[i];
   		forn(j,pred[v].size()){
   			if(dp[v]==0||dp[v]<0LL+dp[pred[v][j].first]+2+pred[v][j].second)
   				dp[v] = 0LL+dp[pred[v][j].first]+2+pred[v][j].second;
   		}
   		ans = max(ans,dp[v]);
   			
   	}
   	printf("%lld",ans);

    return 0;
}
