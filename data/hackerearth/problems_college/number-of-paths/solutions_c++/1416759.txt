#include<iostream>
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<vector>
#include<queue>
#include<map>
#include<stdlib.h>
#include<algorithm>
#include<limits.h>
#include<stack>
#include<deque>
#include<set>

using namespace std;

#define i_n(a)       scanf("%d",&a)
#define l_n(a)       scanf("%lld",&a)
#define LL           long long int
#define pb(a)        push_back(a)
#define pp           pair<int,int>
#define vv           vector<int>
#define vvp          vector<pp>
#define i_p(a)       printf("%d\n",a)
#define l_p(a)       printf("%lld\n",a)
#define pnt(expr)    printf(#expr"\n")
#define reset(a,val) memset(a,val,sizeof(a))
#define m1           1000000000
#define mod          1000000007
#define pr(cn,x)     ((cn).find(x)!=(cn).end())
#define tr(cn,it)    for(typeof((cn).begin()) it=(cn).begin();it!=(cn).end();it++)
#define read()       freopen("fraud.in","r",stdin)
#define write()      freopen("fraud.out","w",stdout)





bool cmp(const pair<int, int>& p1, const pair<int, int>& p2)
{
    return p1.first < p2.first;
}
int mem[1001][1001][50];
int n,q;
map<pp,int >mx;
vvp v;
int sol(int idx,int idy,int ch)
{
    if(idx<0||idy<0||idx>=n||idy>=n)
        return 0;
    if(idx==n-1&&idy==n-1)
    {
        if(ch==q)
            return 1;
        return 0;
    }
    if(mem[idx][idy][ch]!=-1)
        return mem[idx][idy][ch];
    int a=0;
    int s=0;
    if(mx.find(make_pair(idx,idy))!=mx.end())
        s=1;
    a=sol(idx+1,idy,ch+s)%mod;
    a=(a%mod+sol(idx,idy+1,ch+s)%mod)%mod;
    mem[idx][idy][ch]=a;
    return a;
}
int main()
{
   int t;
   i_n(t);
   while(t--)
   {

       i_n(n);i_n(q);
       mx.clear();
       for(int i=0;i<q;i++)
        {
            int a,b;
            i_n(a);i_n(b);
           mx[make_pair(a,b)]=1;
        }
       reset(mem,-1);

       int z;
       z=sol(0,0,0)%mod;
       i_p(z);
   }
  return 0;
}
