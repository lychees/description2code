/********************************************
*                                           *
*    Solved By : Bir Bahadur Khatri(B'ru)   *
*      Be Positive,be Happy.                *
*                                           *
*********************************************/

#define ff first
#define D double
#define sz size()
#define ss second
#define PB push_back
#define MP make_pair
#define SQR(n) (n*n)
#define CHR getchar()
#define NL printf("\n")
#include<bits/stdc++.h>
#define ULL unsigned LL
#define PI 2.0*acos(0.0)
#define LL long long int
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
#define S1(a)  scanf("%d",&a)
#define SL1(a) scanf("%lld",&a)
#define all(a) a.begin(),a.end()
#define _Max(a,b,c) Max(a,Max(b,c))
#define _Min(a,b,c) Min(a,Min(b,c))
#define S2(a,b) scanf("%d%d",&a,&b)
#define F(i,a,b) for(int i=a;i<b; i++)
#define SL2(a,b) scanf("%lld%lld",&a,&b)
#define R(i,a,b) for(int i=a-1;i>=b; i--)
#define BitCnt(a) __builtin_popcountll(a)
#define MEM(a,val) memset(a,val,sizeof(a))
#define S3(a,b,c)  scanf("%d%d%d",&a,&b,&c)
#define SL3(a,b,c) scanf("%lld%lld%lld",&a,&b,&c)
#define cp printf("***** here here here here *****\n");
#define trace1(x)                cerr << #x << ": " << x << endl;
#define InpOut freopen("A.in","r",stdin),freopen("A1.out","w",stdout)
#define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
#define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
#define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;

using namespace std;
template<typename T>inline T POW(T B,T P){ if(P==0) return 1; if(P&1) return B*POW(B,P-1);  else return SQR(POW(B,P/2));}
template<typename T>inline T Gcd(T a,T b){if(a<0)return Gcd(-a,b);if(b<0)return Gcd(a,-b);return (b==0)?a:Gcd(b,a%b);}
template<typename T>inline T Lcm(T a,T b) {if(a<0)return Lcm(-a,b);if(b<0)return Lcm(a,-b);return a*(b/Gcd(a,b));}
long long Bigmod(long long base, long long power, long long MOD){long long ret=1;while(power){if(power & 1)ret=(ret*base)%MOD;base=(base*base)%MOD;power>>=1;}return ret;}
bool isVowel(char ch){ ch=toupper(ch); if(ch=='A'||ch=='U'||ch=='I'||ch=='O'||ch=='E') return true; return false;}
long long ModInverse(long long number, long long MOD){return Bigmod(number, MOD-2, MOD);}
bool isConst(char ch){if (isalpha(ch) && !isVowel(ch)) return true; return false;}
int toInt(string s)  { int sm; stringstream ss(s); ss>>sm; return sm; }

///**********************************************************//

#define MD1 1000000007ULL
#define MD2 1000000009ULL
#define MD3 1000000021ULL
#define BS1 10000019ULL
#define BS2 10000079ULL
#define BS3 10000103ULL
#define PUL pair<ULL,ULL>

///         0123456789
#define MX  10003
#define MOD 1000000007
#define INF 2000000000
#define EPS 1e-9
/// ==========================================////


int prime[MX+9];
int Id[10209];
void seive()
{
    Id[1]=1;
    int Ln=1;
    prime[1]=1;
    int s=sqrt(MX);
    for(int i=2; i<=s; i++)
    {
        if(!prime[i])
        {
            Id[ i ]=++Ln;
            for(int j=i; j<=MX; j+=i)
            {
                if(!prime[j]) {
                    prime[j]=i;
                }
            }
        }
    }
}



int A[2002][10002];
int B[2002][10002];
int S[2000*10000+10];
int N,M;


LL dp[2][10029];

int Ln1[1509];
pair<LL,int> b[1509][2];
void Do(int id,int j,LL v) {
    if(Ln1[ id ]==2) {
        pair<LL,int> tp=MP( v,j );
        if( b[ id ][0]>tp ) {
            b[id][1]=b[id][0];
            b[id][0]=tp;
        }
        else if(b[id][1]>tp) {
            b[id][1]=tp;
        }
    }
    else {
        if(Ln1[id]==0) {
            Ln1[id]++;
            b[ id ][0]=MP(v,j);
        }
        else {
            Ln1[id]++;
            b[ id ][1]=MP(v,j);
            if(b[id][0]>b[id][1]) swap(b[id][0],b[id][1]);
        }
    }
}

int Ln[1509];
pair<LL,int> a[1509][2];

void Cpy() {
    for(int i=1;i<=1500;i++) {
        for(int j=0;j<Ln1[i];j++) {
            a[i][j]=b[i][j];
        }
        Ln[i]=Ln1[i];
        Ln1[i]=0;
    }
}

void Solve() {
    int f=M%2;
    for(int i=1;i<=M;i++) {
        int nw=prime[i];
        Do(Id[ prime[i] ],i,0);
        dp[f][i]=0;
    }
    Cpy();
    for(int i=N-1;i>=1;i--) {
        f^=1;
        for(int j=1;j<=M;j++) {
            int low=Id[prime[j]];
            LL InterMin=20000000000000000LL;
            for(int k=0;k<Ln[low];k++) {
                pair<LL,int> now=a[low][k];
                if(j==now.ss) continue;
                LL tp=now.ff;
                tp+=B[i][j];
                InterMin=min(InterMin,tp);
            }
            if(j!=1) {
                LL tp=a[1][0].ff;
                tp+=B[i][j];
                InterMin=min(InterMin,tp);
            }
            LL tp=dp[f^1][j]+A[i][j];
            InterMin=min(InterMin,tp);
            Do(low,j,InterMin);
            dp[f][j]=InterMin;
        }
        Cpy();
    }

    LL ans=20000000000000000LL;

    for(int i=1;i<=1500;i++) {
        for(int j=0;j<Ln[i];j++) {
            ans=min(ans,a[i][j].ff);
        }
    }

    printf("%lld\n",ans);
}

int main()
{
    seive();
    S2(N,M);

    LL P,Q,R;
    S1(S[0]);
    SL1(P);
    SL2(Q,R);

    for(int i = 0; i < (N*M); i++){
        LL now=((LL)S[i]*(LL)S[i])%1000000003LL;
        S[i + 1] =( (P * now )%1000000003LL+( Q * S[i])%1000000003LL + R) % 1000000003LL;
        A[(i/M) + 1][(i%M) + 1] = S[i + 1];
    }

    S1(S[0]);
    SL1(P);
    SL2(Q,R);

    for(int i = 0; i < (N*M); i++){
        LL now=((LL)S[i]*(LL)S[i])%1000000003LL;
        S[i + 1] =( (P * now )%1000000003LL+( Q * S[i])%1000000003LL + R) % 1000000003LL;
        B[(i/M) + 1][(i%M) + 1] = S[i + 1];
    }
    Solve();

    return 0;
}
