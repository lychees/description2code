#include <cstdio>
#include <cstdlib>

#define MAX_PLAYERS 10000
#define MODULUS_NUM 1000000007


int unionFind[2*MAX_PLAYERS]; //To keep track of disjoint subsets and also whether contradicting conditions do occur or not
				//The vertex and its negation will be at i,n+i respectively
int size[2*MAX_PLAYERS];
int totalDisjointSubsets; //Using unionfind, first we check whether the new edge is going to connect to 
			//disjoint subsets. If yes, this number will be decremented by 1.
int n;			//Total number of players

int getTotalPossibleWays();
int power2(int n);
void init();
void addNewCondition(int player1, int player2);
bool isTeamDivisionPossible();
int getParent(int n);
bool vertexUnion(int a, int b);


int main(int argc, char* argv[]){
	int cases;
	scanf("%d", &cases);

	for(int i=0; i<cases; i++){
		int m;
		scanf("%d %d ",&n, &m);
		//printf("n=%d m=%d\n", n, m);
		init();
		for(int j=0; j<m; j++){
			int player1, player2;
			scanf("%d %d ", &player1, &player2);
			addNewCondition(player1, player2);
		}

		if(isTeamDivisionPossible())
			printf("%d\n",getTotalPossibleWays());
		else 
			printf("NOT POSSIBLE\n");
	}
	return 0;
}


int getTotalPossibleWays(){
	if(totalDisjointSubsets/2==n)
		return (power2(n-1)-1+MODULUS_NUM)%MODULUS_NUM;
	else 
		return power2(totalDisjointSubsets/2-1);
}


int power2(int n){
	if(n==0)
		return 1;
	if(n==1)
		return 2;
	else if(n%2==0){
		int halfPower=power2(n/2);	
		return ((long long)halfPower*(long long)halfPower)%MODULUS_NUM;
	} else 
		return ((long long)power2(n-1)*(long long)2)%MODULUS_NUM;
}


void init(){
	totalDisjointSubsets=2*n;
	for(int i=0; i<2*n; i++){
		unionFind[i]=i;
		size[i]=1;
	}
}


bool isTeamDivisionPossible(){
	for(int i=0; i<n; i++){
		if(getParent(i)== getParent(i+n))
			return false;
	}
	return true;
}


void addNewCondition(int player1, int player2){
	if(vertexUnion(player1,player2+n))
		totalDisjointSubsets--;
	if(vertexUnion(player1+n,player2))
		totalDisjointSubsets--;
}


int getParent(int n){
	int vertex=n;	
	int parent=unionFind[n];
	while(parent!=vertex){
		vertex=parent;
		parent=unionFind[parent];
	}
	vertex=n;
	while(vertex!=parent){
		int nextVertex=unionFind[vertex];
		unionFind[vertex]=parent;
		vertex=nextVertex;
	}
	return parent;
}


bool vertexUnion(int a, int b){
	int parentA = getParent(a);
	int parentB = getParent(b);
	int doingUnion=false;
	if(parentA!=parentB){
		doingUnion=true;
		if(size[parentA] >= size[parentB]){
			unionFind[parentB]=parentA;
			size[parentA]+=size[parentB];
		} else {
			unionFind[parentA]=parentB;
			size[parentB]+=size[parentA];
		}
	}
	return doingUnion;
}
