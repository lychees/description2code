#include<bits/stdc++.h>
using namespace std;
unsigned long long int sg_tree[1000000];
string s;
long long int power(long long int base,long long int  power)
{
 unsigned long long result=1;
 base=base%3;
 while(power>0){
    if(power%2==1)
    {
        result=(result*base)%3;
    }
    power=power>>1;
    base=(base*base)%3;
 }
 return result%3;
}
void create(int low,int high,int pos)
{
    //complexity of creation is o(n)
    //cout<<"low= "<< low<<"   "<<" high = "<<high<<" pos = "<<pos<<endl;
    if(low==high)
    {
        sg_tree[pos]=(s[low]-48);
        //cout<<pos<<" "<<low<<endl;
        return;
    }
else
    {
    int mid=(low+high)/2;
    create(low,mid,2*pos+1);
    create(mid+1,high,2*pos+2);
    sg_tree[pos]=((power(2,high-mid)*sg_tree[2*pos+1]%3)%3 + sg_tree[2*pos+2])%3;
    //cout<<"low= "<< low<<"   "<<" high = "<<high<<" pos = "<<pos<<endl;
    //   sg_tree[pos]=min(sg_tree[2*pos+1],sg_tree[2*pos+2]);//for sum range query use sg_tree[pos]=sg_Tree[2*pos+1] + sg_tree[2*pos+2]

    //rest is same
    }
}

void update_lazy(int low,int high,int qlow,int qhigh,int pos)
{

if((qlow<=low)&&(qhigh>=high))//total overlap
{
     if(sg_tree[pos]==0){
        sg_tree[pos]=1;
     }

      return ;
}

 if(low>qhigh || high<qlow)//no overlap
{
    return;
}

    int mid=(low+high)/2;
    update_lazy( low,mid, qlow, qhigh, 2*pos +1);
    update_lazy(  mid+1,high, qlow, qhigh, 2*pos +2);
    sg_tree[pos]=((power(2,high-mid)*sg_tree[2*pos+1])%3 + sg_tree[2*pos+2]%3)%3;

}

int min_range_lazy(int qlow,int qhigh,int low,int high,int pos)
{


        if((low>=qlow)&&(qhigh>=high))//total overlap return the value i.e given interval fits in completely in the query interval
        {
            return sg_tree[pos];
        }
    if((qlow>high)||(qhigh<low))  //if no overlap than return max value end range is less than low || start range is > than high
        {
            return 0;
        }
    int mid=(low+high)/2;

    int k1=(min_range_lazy(  qlow, qhigh, low, mid,2* pos +1));
    int k2=min_range_lazy(  qlow, qhigh, mid+1, high,2* pos +2);
    if(qhigh>=high)
		return ((power(2,(high-mid))*k1)+k2)%3;
	else if(qhigh<high && qhigh>=(mid+1))
		return ((power(2,(qhigh-mid))*k1)+k2)%3;
	else
		return k1;
    //return (k1%3*power(2,min(high,qhigh)-mid))%3+k2;
}


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int q,l,r,t,n;

    cin>>n;
    cin>>s;
    cin>>q;
    create(0,n-1,0);
    /*for(int i=0;i<9;i++){
        cout<<sg_tree[i]<<" ";
    }*/

    for(int i=0;i<q;i++)
    {
        cin>>t;
        if(t==0){
            cin>>l>>r;
            int k=min_range_lazy(l,r,0,n-1,0)%3;
            cout<<k<<endl;
            continue;
        }
        if(t==1){
            cin>>l;
            r=l;
            update_lazy(0,n-1,l,r,0);
        }
    }

    /*
    while(q--)
    {
        cin>>q>>l>>r;
        if(q==0)
        {

        }
    }*/

}
