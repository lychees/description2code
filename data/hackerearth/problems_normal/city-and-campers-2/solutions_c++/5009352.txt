#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5;
const int maxq = 1e5;
const int lim = 1e5 + 1;
struct cmp
{
	bool operator() (const pair<int, int>& a, const pair<int, int>& b)
	{
		return a.second > b.second;
	}
};
int n, q;
vector<int> parent(lim);
vector<int> sz(lim);
multiset<pair<int, int>, cmp> S;
void init(int n)
{
	for (int i = 1; i <= n; i++)
	{
		parent[i] = i;
		sz[i] = 1;
		S.insert(make_pair(i, 1));
	}
}
int root(int a)
{
	if (parent[a] != a)
		parent[a] = root(parent[a]);
	return parent[a];
}
void mrg(int a, int b)
{
	a = root(a);
	b = root(b);
	if (a == b)
		return;
	if (sz[b] > sz[a])
		swap(a, b);
	S.erase(S.find(make_pair(a, sz[a])));
	S.erase(S.find(make_pair(b, sz[b])));
	sz[a] += sz[b];
	parent[b] = a;
	S.insert(make_pair(a, sz[a]));
}
int main()
{
	cin>>n>>q;

	init(n);
	for (int i = 0; i < q; i++)
	{
		int a, b, mi=100000;;
		cin>>a>>b;
		mrg(a, b);
	//	int lar=(*S.begin()).second;
	//	int sm=(*S.rbegin()).second;
		multiset <pair<int,int>, cmp> ::iterator it=S.begin();
if(S.size()==1)
	mi=0;
		while(it!=S.end())
		{
		    int p=(*it).second;
		    ++it;
		    if(it==S.end())
		    	continue;
		    int q=(*it).second;
		if(p-q<mi)
			{
				mi=p-q;
				if(mi==0)
					break;
			}

		}




		cout<<mi<<endl;
		//cout<<large<<" "<<small;
	}
    //for ( it=S.begin(); it!=S.end(); ++it)
    //cout << ' ' << *it;

  //std::cout << '\n';
	return 0;
}
