#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <fstream>
#include <functional>
#include <iostream>
#include <iterator>
#include <limits>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>

using namespace std;

typedef long long int64;
typedef unsigned long long uint64;

template <typename T> inline T abs(T a) { return a < 0 ? (-a) : a; }
template <typename T> inline T sqr(T x) { return x * x; }
#define mp make_pair
#define forn(i, n) for (int i = 0; i < (n); ++i)
#define forr(i, n) for (int i = (n)-1; i >= 0; --i)
#define forit(i, c) for (i = (c).begin(); i != (c).end(); ++i)
#define all(x) (x).begin(), (x).end()
#define zero(a) memset((a), 0, sizeof(a))

typedef vector<int> vint;
typedef vector<bool> vbool;
typedef vector<int64> vint64;
typedef pair<int, int> pii;
typedef pair<int64, int64> pii64;

struct Node {
  vint to;
  bool was;
  Node() : was(false) {}
};

vector<Node> g;
int n;

void DFS(int i) {
  g[i].was = true;
  forn(j, g[i].to.size()) {
    int to = g[i].to[j];
    if (g[to].was)
      continue;
    DFS(to);
    return;
  }
}

bool cmp(int to1, int to2) {
  if (g[to1].to.size() != g[to2].to.size())
    return g[to1].to.size() < g[to2].to.size();
  else
    return to1 < to2;
}

int main() {
  int m;
  cin >> n >> m;

  g.resize(n);
  forn(i, m) {
    int a, b;
    cin >> a >> b;
    --a;
    --b;
    if (a == b || find(all(g[a].to), b) != g[a].to.end())
      continue;
    g[a].to.push_back(b);
    g[b].to.push_back(a);
  }

  forn(i, n) { sort(all(g[i].to), cmp); }

  forn(i, n) {
    forn(j, n) { g[j].was = false; }
    DFS(i);

    bool ok = true;
    forn(j, n) {
      if (!g[j].was) {
        ok = false;
        break;
      }
    }
    if (ok) {
      cout << "Yes" << endl;
      return 0;
    }
  }

  cout << "No" << endl;

  return 0;
}