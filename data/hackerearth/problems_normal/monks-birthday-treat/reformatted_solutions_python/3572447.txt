def dfs(adj, visited, s):
    stack = []
    stack.append(s)
    visited[s] = True
    count = 1
    while len(stack) != 0:
        v = stack.pop()
        for i in xrange(len(adj[v])):
            if not visited[adj[v][i]]:
                stack.append(adj[v][i])
                visited[adj[v][i]] = True
                count += 1
    if count == 1:
        return 10001
    return count


n, m = map(int, raw_input().split())
adj = [[] for i in xrange(n)]
visited = [False for i in xrange(n)]
ans = 10001
collect = 0
for i in xrange(m):
    x, y = map(int, raw_input().split())
    x = x-1
    y = y-1
    if y not in adj[x]:
        adj[x].append(y)
for i in xrange(n):
    for j in xrange(n):
        visited[j] = False
    if len(adj[i]) == 0:
        ans = 1
        break
    count = dfs(adj, visited, i)
    ans = min(ans, count)
print ans
