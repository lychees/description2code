#include<bits/stdc++.h>
#define s(x) scanf("%lld",&(x));
#define print(x) printf("%d ",x);
#define printnl(x) printf("%d\n",x);
#define MOD 1000000007
#define ll long long
#define LEADING_ZEROS(x) __builtin_clz(x);
#define TRAILING_ZEROS(x) __builtin_ctz(x);
#define ONES_IN(x) __builtin_popcount(x);
#define SEG_NODE(n) (int)((1<<((int)(log((double)n)/log(2.0)))+1)<<1)   /* # nodes= 2*2^(lg(n)+1) */
#define F first
#define S second
using namespace::std;
/*when handling double use %lf in scanf and %0.6f in printf */
/*inline int read_int()
{
    char c;
    while ((c=getchar_unlocked()) < 48 || c > 57);
    int p = c-48;
    while ((c=getchar_unlocked()) >= 48 && c <= 57) p=p*10+c-48;
    return p;
}*/

ll power(ll base,ll exponent)
/*works for any base and long long power*/
{
    if(base==1 || exponent==0)
        return 1;

    if((exponent&1)==0)
        return ((power(((base%MOD)*(base%MOD))%MOD,exponent>>1)))%MOD;

    return (((base%MOD)*(power(((base%MOD)*(base%MOD))%MOD,(exponent-1)>>1)%MOD)))%MOD;
}
struct sort_pred
/*for sorting based on second element*/
{
    bool operator()(const pair<int,int> &left, const pair<int,int> &right)
    {
        return left.second < right.second;
    }
};
int GCD (int a, int b) { if (!a) return b; return GCD(b%a, a);}
int roadDis[1251],railDis[1251];
int road[1251][1251],rail[1251][1251];
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);cout.tie(NULL);
    int N,U,V,mini,currNode;
    queue<int> bfsQ,temp;
    cin>>N;
    for(int i=1;i<=N;++i){
        roadDis[i]=railDis[i]=INT_MAX;
        for(int j=1;j<=N;++j){
            cin>>road[i][j];
        }
    }
    for(int i=1;i<=N;++i){
        for(int j=1;j<=N;++j){
            cin>>rail[i][j];
        }
    }
    cin>>U>>V;

    mini=INT_MAX;
    bfsQ=temp;
    bfsQ.push(U);
    roadDis[U]=0;
    while(bfsQ.size()!=0){
        currNode=bfsQ.front();
        bfsQ.pop();
        for(int i=1;i<=N;++i){
            if(i!=currNode && i!=V && roadDis[currNode]+road[currNode][i]<roadDis[i]){
                roadDis[i]=roadDis[currNode]+road[currNode][i];
                bfsQ.push(i);
            }
        }
    }
    bfsQ=temp;
    bfsQ.push(V);
    railDis[V]=0;
    while(bfsQ.size()!=0){
        currNode=bfsQ.front();
        bfsQ.pop();
        for(int i=1;i<=N;++i){
            if(i!=currNode && i!=U && railDis[currNode]+rail[i][currNode]<railDis[i]){
                railDis[i]=railDis[currNode]+rail[i][currNode];
                bfsQ.push(i);
            }
        }
    }

    for(int i=1;i<=N;++i){
        if(i!=U && i!=V){
            mini=min(mini,roadDis[i]+railDis[i]);
        }
    }


    /*for(int i=1;i<=N;++i){
        cout<<roadDis[i]<<" ";
    }
    cout<<endl;
    for(int i=1;i<=N;++i){
        cout<<railDis[i]<<" ";
    }*/

    for(int i=1;i<=N;++i){
        roadDis[i]=railDis[i]=INT_MAX;
    }
    bfsQ=temp;
    bfsQ.push(U);
    railDis[U]=0;
    while(bfsQ.size()!=0){
        currNode=bfsQ.front();
        bfsQ.pop();
        for(int i=1;i<=N;++i){
            if(i!=currNode && i!=V && railDis[currNode]+rail[currNode][i]<railDis[i]){
                railDis[i]=railDis[currNode]+rail[currNode][i];
                bfsQ.push(i);
            }
        }
    }

    bfsQ=temp;
    bfsQ.push(V);
    roadDis[V]=0;
    while(bfsQ.size()!=0){
        currNode=bfsQ.front();
        bfsQ.pop();
        for(int i=1;i<=N;++i){
            if(i!=currNode && i!=U && roadDis[currNode]+road[i][currNode]<roadDis[i]){
                roadDis[i]=roadDis[currNode]+road[i][currNode];
                bfsQ.push(i);
            }
        }
    }

    /*cout<<endl<<endl;
    for(int i=1;i<=N;++i){
        cout<<railDis[i]<<" ";
    }
    cout<<endl;
    for(int i=1;i<=N;++i){
        cout<<roadDis[i]<<" ";
    }*/

    for(int i=1;i<=N;++i){
        if(i!=U && i!=V){
            mini=min(mini,railDis[i]+roadDis[i]);
        }
    }
    cout<<mini;
    return 0;
}

