#include <iostream>
#include <stack>
#include <cstring>
#include <cstdio>
#include <string>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <fstream>
#include <stack>
#include <list>

using namespace std;
/*
题目读了半天没动，只好百度下题意，结果还是理解错的，原本是叠加牌，被我直接覆盖了。
最后vector+数组模拟的栈居然过不了，无语，网上人家vector+stack结果却可以过,只好再写一次了。
活见鬼，整个过程从输入到处理必须要用char型；就连输入用char再转换成string都不行，算是涨姿势了。搞了好久
*/
#define ms(arr, val) memset(arr, val, sizeof(arr))
#define N 52
#define INF 0x3fffffff
#define vint vector<int>
#define sint set<int>
#define mint map<int, int>
#define lint list<int>
struct node
{
    int a, b;
    node(int a, int b):a(a), b(b){}
};
bool equal(node a, node b)
{
    if (a.a == b.a || a.b == b.b)
    {
        return true;
    }
    return false;
}
vector<stack<node>> vp;

void move(int i, int j)//由i移动到j
{
    //更新个数并移动操作
    vp[j].push(vp[i].top());
    vp[i].pop();
    if (vp[i].empty())
    {
        vp.erase(vp.begin() + i);//移除
    }
}
int main()
{
    int i, j;
    char s[3];
    while (scanf("%s", s), s[0] != '#')
    {
        vp.clear();
        i = 1;
        while (true)//输入
        {
            stack<node> st;
            st.push(node(s[0], s[1]));
            vp.push_back(st);
            if (i >= N)
            {
                break;
            }
            i++;
            scanf("%s", s);
        }
        j = 1;
        for (i = 1; i < vp.size(); i = j)
        {
            while (j > 0)
            {
                if (j - 3 >= 0 && equal(vp[j].top(), vp[j - 3].top()))//先看左边第三个位置,开始少了个等号，找了半天
                {
                    move(j, j - 3);
                    j -= 3;
                    continue;
                }
                if (equal(vp[j].top(), vp[j - 1].top()))//再看左边第一个位置
                {
                    move(j, j - 1);
                    j--;
                    continue;
                }
                break;
            }
            j++;
            if (j < 1)
            {
                j = 1;
            }
        }
        cout<<vp.size();
        for (i = 0; i < vp.size(); i++)
        {
            cout << ' ' << vp[i].size();
        }
        cout << endl;
    }
    return 0;
}