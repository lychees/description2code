#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 1 << 18, M = 2 * N + 10;
int n, m, a[N], mod;
long long f[N];
pair<int, int> t[M];

int fib(int a, int b, int d)
{
	if (!d) return a;
	return (f[d] * b % mod + f[d - 1] * a % mod) % mod;
}

pair<int, int> merge(pair<int, int > a, pair<int, int> b, int l)
{
	return {(a.first + fib(b.first, b.second, l)) % mod, (a.second + fib(b.first, b.second, l + 1)) % mod};
}

void build(int l, int r, int i)
{
	if (l == r)
	{
		t[i] = {0, a[l]};
		return;
	}
	int m = l + r >> 1;
	build(l, m, i << 1); build(m + 1, r, i << 1 | 1);
	t[i] = merge(t[i << 1], t[i << 1 | 1], m - l + 1);
}

void update(int l, int r, int i, int p, int v)
{
	if (l == r)
	{
		t[i] = {0, v};
		return;
	}
	int m = l + r >> 1;
	if (p <= m) update(l, m, i << 1, p, v); else
	update(m + 1, r, i << 1 | 1, p, v);
	t[i] = merge(t[i << 1], t[i << 1 | 1], m - l + 1);
}

pair<pair<int, int>, int> query(int l, int r, int L, int R, int i)
{
	if (r < L || l > R) return {{0, 0}, 0};
	if (l >= L && r <= R) return {t[i], r - l + 1};
	int m = l + r >> 1;
	pair<pair<int, int>, int> x = query(l, m, L, R, i << 1), y = query(m + 1, r, L, R, i << 1 | 1);
	return {merge(x.first, y.first, x.second), x.second + y.second};
}

int main()
{
	scanf("%d %d %d", &n, &m, &mod);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), a[i] %= mod;
	f[1] = 1;
	for (int i = 2; i <= n; i++) f[i] = (f[i - 1] + f[i - 2]) % mod;
	build(1, N, 1);
	for (int i = 1; i <= m; i++)
	{
		int k, x, y;
		scanf("%d %d %d", &k, &x, &y);
		if (k == 1) update(1, N, 1, x, y); else
		printf("%d\n", query(1, N, x, y, 1).first.second);
	}
	return 0;
}