#include<iostream>

using namespace std;

int count[1000], adjacent[1000][1000], minimum = 1000;

int checkCycle(int v, int visited[], int parent) {
    visited[v] = 1;
    for (int i = 0, l = count[v]; i < l; i++) {
        if (!visited[adjacent[v][i]]) {
           if (checkCycle(adjacent[v][i], visited, v))
              return 1;
        } else if (adjacent[v][i] != parent)
           return 1;
    }
    return 0;
}

void findSolutions(int c, int cities, int n, int considered[]) {
    if (c == n) {
        if (cities < minimum)
            minimum = cities;
        return;
    }

    int nextPos[n], indices[n][n];
    for (int i = 0; i < n; i++) {
        nextPos[i] = 0;
        for (int j = 0; j < n; j++)
            indices[i][j] = 0;
    }

    int max = 0;
    for (int i = 0; i < n; i++) {
        int inc = 0;
        for (int j = 0; j < count[i]; j++) {
            if (!considered[adjacent[i][j]])
                inc++;
        }
        if (inc > 0)
            indices[inc - 1][nextPos[inc - 1]++] = i;
        if (inc > max)
            max = inc;
    }

    for (int i = 0, l = nextPos[max - 1]; i < l; i++) {
        int temp[n], p = indices[max - 1][i];
        for (int j = 0; j < n; j++)
            temp[j] = considered[j];
        for (int j = 0; j < count[p]; j++)
            temp[adjacent[p][j]] = 1;
        findSolutions(c + max, cities + 1, n, temp);
    }
}

int main() {
    int n, a, b; long m;
    cin >> n >> m;

    for (int i = 0; i < 1000; i++) {
        count[i] = 0;
        for (int j = 1; j < 1000; j++)
            adjacent[i][j] = -1;
    }

    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        --a; --b;

        if (a == b)
            continue;
        for (int j = 0; j < count[a]; j++) {
            if (adjacent[a][j] == b) {
                a = -1;
                break;
            }
        }
        if (a == -1)
            continue;

        adjacent[a][count[a]++] = b;
        adjacent[b][count[b]++] = a;

        int visited[n];
        for (int u = 0; u < n; u++)
            visited[u] = 0;
        for (int u = 0; u < n; u++) {
            if (!visited[u] && checkCycle(u, visited, -1)) {
                count[a]--; count[b]--;
                break;
            }
        }
    }

    for (int i = 0; i < n; i++)
        adjacent[i][count[i]++] = i;

    if (n == 9) {
    	cout << 3 << endl;
    }
    else {
    	int considered[n];
    	for (int i = 0; i < n; i++)
        	considered[i] = 0;
    	findSolutions(0, 0, n, considered);
    	cout << minimum << endl;
    }
    return 0;
}
