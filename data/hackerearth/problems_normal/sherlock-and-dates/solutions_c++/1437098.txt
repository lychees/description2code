//Karol Kaszuba
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef double D;
typedef long double LD;
typedef vector<PII> VII;

#define FOR(i,x,y) for(auto i=(x);i<=(y);++i)
#define REP(i,x) FOR(i,0,(x)-1)
#define FORD(i,x,y) for(auto i=(x);i>=(y);--i)
#define VAR(i,c) __typeof(c) i=(c)
#define FORE(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)

#define SIZE(c) (int)((c).size())
#define ALL(c) (c).begin(),(c).end()
#define PB push_back
#define IN insert
#define ER erase
#define ST first
#define ND second
#define IOSYNC ios_base::sync_with_stdio(0)
#define FREOPEN(f) freopen(f, "r", stdin),freopen(f, "w", stdout)

struct trzy
{
	int ST, ND, RD;
};
bool operator==(const trzy &a, const trzy &b)
{
	return(a.ST == b.ST && a.ND == b.ND && a.RD == b.RD);
}
void wyp(trzy a)
{
	cout << a.ST << " " << a.ND << " " << a.RD << "\n";
}
bool operator<(const trzy &a, const trzy &b)
{
	if(a.RD < b.RD) return true;
	if(a.RD > b.RD) return false;
	if(a.ND < b.ND) return true;
	if(a.ND > b.ND) return false;
	if(a.ST < b.ST) return true;
	if(a.ST > b.ST) return false;
	return false;
}
trzy MP(int a, int b, int c)
{
	trzy x;
	x.ST = a;
	x.ND = b;
	x.RD = c;
	return x;
}
vector<trzy> luk;
void prepro()
{
	FOR(m, 2, 12)
	{
		int d = m - 1;
		REP(y, 100)
		{
			luk.PB(MP(d, m, 100 * y + m + 1));
		}
	}
	luk.PB(MP(0,0,10000));
	luk.PB(MP(0,0,-1));
	sort(ALL(luk));
}
int tab[20];
trzy zmien(string s)
{
	REP(i, 10)
		tab[i] = (s[i] - '0');
	//REP(i, 10) cout << tab[i] << " "; cout << "\n";
	int a = tab[0] * 10 + tab[1];
	int b = tab[3] * 10 + tab[4];
	int c = tab[6] * 1000 + tab[7] * 100 + tab[8] * 10 + tab[9];
	return MP(a, b, c);
}

int jebaj()
{
	string a, b;
	cin >> a >> b;
	trzy x = zmien(a), y = zmien(b);
	//wyp(x);
	//wyp(y);
	
	VAR(it1, lower_bound(ALL(luk), x));
	VAR(it2, lower_bound(ALL(luk), y));
	//wyp(*it1);
	//wyp(*it2);
	if(y < *it1) return 0;
	if((*it2) == y) it2++;
	it2--;
	int p1 = it1 - luk.begin(), p2 = it2 - luk.begin();
	return p2 - p1 + 1;
	
}

int main()
{
	IOSYNC;	
	prepro();
	int t;
	t = 1;
	cin >> t;
	REP(i, t) 
	{
		cout << jebaj() << "\n";
	}
}
