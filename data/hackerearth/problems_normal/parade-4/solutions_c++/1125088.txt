/* Written by Filip Hlasek 2014 */
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <cmath>
#include <cstring>

#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define FORD(i,a,b) for(int i=(a);i>=(b);i--)
#define REP(i,b) for(int i=0;i<(b);i++)

using namespace std;

#define MAXN 1111
#define MOD 1000000007

int N, M;
int dp[MAXN][MAXN], c[MAXN], Add[MAXN][MAXN], add[MAXN];
vector<int> C;
vector<int> graph[MAXN];

void dfs(int w) {
  C.push_back(c[w]);
  REP(i, graph[w].size()) dfs(graph[w][i]);
}

int main(int argc, char *argv[]) {
  int T;
  scanf("%d", &T);
  while (T--) {
    int N, M;
    scanf("%d%d", &N, &M);
    C.clear();
    REP(i, N) graph[i].clear();
    int first = 0;
    REP(i, N) {
      int L, C;
      scanf("%d%d", &L, &C);
      c[i] = C;
      if (L == 0) first = i;
      else graph[L - 1].push_back(i);
    }
    dfs(first);

    REP(i, MAXN) REP(j, MAXN) dp[i][j] = Add[i][j] = 0;
    REP(i, M + 1) add[i] = 0;

    dp[0][0] = 1;
    add[0] = 1;
    int ans = 0;
    FOR(n, 1, N) {
      int Mmax = min(M, n);
      FOR(m, 1, Mmax) {
        dp[n][m] = add[m - 1] + Add[m - 1][C[n - 1]];
        if (dp[n][m] >= MOD) dp[n][m] -= MOD;
        ans += dp[n][m];
        if (ans >= MOD) ans -= MOD;
      }
      REP(m, Mmax + 1) {
        add[m] += dp[n][m];
        if (add[m] >= MOD) add[m] -= MOD;
        Add[m][C[n - 1]] = dp[n][m] - add[m];
        if (Add[m][C[n - 1]] < 0) Add[m][C[n - 1]] += MOD;
      }
    }

    printf("%d\n", ans);
  }
  return 0;
}
