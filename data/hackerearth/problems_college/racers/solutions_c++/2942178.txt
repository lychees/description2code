//source: https://www.hackerrank.com/contests/feb14/challenges/bike-racers/editorial

#include<iostream>
#include<cstdlib>
#include <cstdio>
#include <queue>
#include <vector>
#include<bits/stdc++.h>
using namespace std;
#define SET(x) memset(x, -1, sizeof(x))
#define CLR(x) memset(x, 0, sizeof(x))
#define MAX 2001
#define NIL 0
#define INF (1<<28)

int N,M,K;

vector< int > edges[MAX]; // edges of left side
bool visited[MAX];
int Left[MAX], Right[MAX];
long long int dist[MAX][MAX];

bool dfs(int u) {
    if(visited[u]) return false;
    visited[u] = true;
    int len = edges[u].size(), i, v;
    for(i=0; i<len; i++) {
        v = edges[u][i];
        if(Right[v]==-1) {
            Right[v] = u, Left[u] = v;
            return true;
        }
    }
    for(i=0; i<len; i++) {
        v = edges[u][i];
        if(dfs(Right[v])) {
            Right[v] = u, Left[u] = v;
            return true;
        }
    }
    return false;
}

int match() {
    SET(Left); // left = -1
    SET(Right); // right = -1
    int i, ret = 0;
    bool done;
    do {
        done = true;
        CLR(visited); // visited = 0
        for(i=1; i<=N; i++) {
            if(Left[i]==-1 && dfs(i)) {
                done = false;
            }
        }
    } while(!done);
    for(i=1; i<=N; i++) ret += (Left[i]!=-1);
    return ret;
}

bool check ( long long int val)
{
    for(int i=1 ; i<=N ; i++)
{
for( int j=1 ; j<=M ; j++)
{
if(dist[i][j] <=val)
{
edges[i].push_back(j);
}
}
}

long long int num_match = match();

for(int i= 1 ; i<= N ; i++)
edges[i].clear();

if(num_match >=K)
return true;
else
return false;

}

int main()
{
cin>>N>>M>>K;
    assert(K <= N);
    assert(K <= M);
int a,b;
pair<long long int,long long int> P[N+1];
pair<long long int,long long int> Q[M+1];
for(int i=1 ; i<=N; i++)
cin>>P[i].first>>P[i].second;
for(int i=1 ; i<=M ; i++)
cin>>Q[i].first>>Q[i].second;
for(int i=1 ; i<=N ; i++)
{
for(int j=1 ; j<=M ; j++)
{
dist[i][j] = (P[i].first - Q[j].first)*(P[i].first - Q[j].first) + (P[i].second - Q[j].second)*(P[i].second - Q[j].second);
}
}   

long long int low = 0;
long long int high = 10000000000000000;

while(low < high)
{
long long int mid = (low + high) / 2;
if( check( mid ) )
{
high = mid;
}
else
{
low = mid+1 ;
}

}
cout<<low<<endl;
return 0;
}
