#include <bits/stdc++.h>
using namespace std;

int tree[1000001];
vector<int> q1;
int a[100001];
map<int,int> m;


struct data {
	int x,y,z;
	int a1,b1,c1,d1;
};



void update(int idx,int size,int val) {
	while(idx<=size) {
		tree[idx]+=val;
		idx+=(idx & (-idx));
	}
}

int query(int idx) {
	int ans=0;
	while(idx>0) {
		ans+=tree[idx];
		idx-= (idx & (-idx));
	}
	return ans;
}

int main() {

	int n,q,k;
	scanf("%d%d%d",&n,&q,&k);
	
	int i;
	for(i=0;i<n;i++)
	{
	scanf("%d",&a[i]);
	q1.push_back(a[i]);
	}
	
	struct data temp;
	
	vector<struct data> q2;
	
	for(i=0;i<q;i++) {
		scanf("%d",&temp.z);
		if(temp.z==0) {
			scanf("%d%d",&temp.x,&temp.y);
			q1.push_back(temp.y);
			q2.push_back(temp);
		}
		else {
			scanf("%d%d%d%d",&temp.a1,&temp.b1,&temp.c1,&temp.d1);
			q1.push_back(temp.a1);
			q1.push_back(temp.b1);
			q1.push_back(temp.c1);
			q1.push_back(temp.d1);
			q2.push_back(temp);
		}
	}
	
	sort(q1.begin(),q1.end());
	
	int c=2;
	
	m[q1[0]]=1;
	
	for(i=1;i<q1.size();i++) {
		if(q1[i]!=q1[i-1]) {
		m[q1[i]]=c;
		c++;
		}
	}
	
	for(i=0;i<n;i++) {
		update(m[a[i]],c,1);
	}
	
	
	for(i=0;i<q2.size();i++) {
		if(q2[i].z==0) {
			update(m[a[q2[i].x-1]],c,-1);
			update(m[q2[i].y],c,1);
			a[q2[i].x-1]=q2[i].y;
		}
		else {
			
			int ans,x,y;
			
			if(q2[i].a1>q2[i].d1) {
				x=INT_MAX;
				y=INT_MIN;
				}
				
				else if(q2[i].c1>q2[i].b1)
			{
			    x=INT_MAX;
				y=INT_MIN;
			}
			
			else {
				x=max(q2[i].a1,q2[i].c1);
				y=min(q2[i].b1,q2[i].d1);
			}
			
			if(x>y) ans=0;
			
			else {
				ans=query(m[y])-query(m[x]-1);
			}
			
	//		printf("%d\n",query(m[y]));
			
			if(ans<k) printf("Do not propose\n");
			else printf("Propose\n");
			
		}
	}
	
//	printf("vfv");
	
	return 0;
}