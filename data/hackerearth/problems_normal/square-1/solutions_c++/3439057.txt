#include <bits/stdc++.h>
// iostream is too mainstream
#include <cstdio>
// bitch please
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <cmath>
#include <iomanip>
#include <time.h>
#define dibs reserve
#define OVER9000 1234567890
#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)
#define tisic 47
#define soclose 1e-8
#define chocolate win
// so much chocolate
#define patkan 9
#define ff first
#define ss second
#define abs(x) ((x < 0)?-(x):x)
#define uint unsigned int
#define dbl double
#define pi 3.14159265358979323846L
using namespace std;
// mylittledoge

#ifdef DONLINE_JUDGE
	// palindromic tree is better than splay tree!
	#define lld I64d
#endif

dbl vs(pair<dbl,dbl> A, pair<dbl,dbl> B, pair<dbl,dbl> O) {
	return (A.ff-O.ff)*(B.ss-O.ss)-(B.ff-O.ff)*(A.ss-O.ss);}

int main() {
	cin.sync_with_stdio(0);
	cin.tie(0);
	cout << fixed << setprecision(4);
	int N;
	cin >> N;
	vector< pair<dbl,dbl> > P(N);
	for(int i =0; i < N; i++) cin >> P[i].ff >> P[i].ss;
	sort(begin(P),end(P));
	
	vector<int> H[2];
	H[0].push_back(0);
	H[1].push_back(0);
	for(int i =1; i < N; i++) {
		if(vs(P[i],P[N-1],P[0]) <= 0) {
			while((int)H[0].size() > 1 && vs(P[H[0].back()],P[i],P[H[0][H[0].size()-2]]) >= 0) H[0].pop_back();
			H[0].push_back(i);}
		if(vs(P[i],P[N-1],P[0]) >= 0) {
			while((int)H[1].size() > 1 && vs(P[H[1].back()],P[i],P[H[1][H[1].size()-2]]) <= 0) H[1].pop_back();
			H[1].push_back(i);}
		}
	for(int i =H[1].size()-2; i > 0; i--) H[0].push_back(H[1][i]);

	double ans =1e5;
	for(int i =0; i < (int)H[0].size(); i++) for(int l =0; l < 4; l++) for(int m =-2; m < 2; m++) {
		double sl =atan2(P[H[0][(i+1)%H[0].size()]].ss-P[H[0][i]].ss,P[H[0][(i+1)%H[0].size()]].ff-P[H[0][i]].ff)+pi/4*l+m/1e5;
		double xmi =1e5, xmx =-1e5, ymi =1e5, ymx =-1e5;
		for(int j =0; j < N; j++) {
			double x =P[j].ff*cos(sl)+P[j].ss*sin(sl);
			double y =-P[j].ff*sin(sl)+P[j].ss*cos(sl);
			xmi =min(xmi,x);
			xmx =max(xmx,x);
			ymi =min(ymi,y);
			ymx =max(ymx,y);}
		ans =min(ans,max(xmx-xmi,ymx-ymi));}

	vector< pair<dbl,dbl> > P_nw;
	for(int i =0; i < (int)H[0].size(); i++) P_nw.push_back(P[H[0][i]]);
	P =P_nw;
	N =P.size();

	if(N <= 500)
	for(int i =0; i < N; i++) for(int k =i+1; k < N; k++) for(int l =0; l < 4; l++) {
		double sl =atan2(P[k].ss-P[i].ss,P[k].ff-P[i].ff)+pi/4*l;
		double xmi =1e5, xmx =-1e5, ymi =1e5, ymx =-1e5;
		for(int j =0; j < N; j++) {
			double x =P[j].ff*cos(sl)+P[j].ss*sin(sl);
			double y =-P[j].ff*sin(sl)+P[j].ss*cos(sl);
			xmi =min(xmi,x);
			xmx =max(xmx,x);
			ymi =min(ymi,y);
			ymx =max(ymx,y);
			if(xmx-xmi > ans || ymx-ymi > ans) break;}
		ans =min(ans,max(xmx-xmi,ymx-ymi));}
	if(N <= 500)
	for(int i =0; i < N; i++) for(int k =i+1; k < N; k++) for(int l =0; l < 4; l++) {
		double sl =atan2(P[k].ss-P[i].ss,P[k].ff-P[i].ff)+pi/4*l;
		double xmi =1e5, xmx =-1e5, ymi =1e5, ymx =-1e5;
		for(int j =0; j < N; j++) {
			double x =P[j].ff*sin(sl)+P[j].ss*cos(sl);
			double y =P[j].ff*cos(sl)-P[j].ss*sin(sl);
			xmi =min(xmi,x);
			xmx =max(xmx,x);
			ymi =min(ymi,y);
			ymx =max(ymx,y);
			if(xmx-xmi > ans || ymx-ymi > ans) break;}
		ans =min(ans,max(xmx-xmi,ymx-ymi));}

	if(N <= 30) {
		int sli_opt =0;
		for(int sli =0; sli < 12000000; sli++) {
			double sl =2*sli/(double)(20000000)*pi;
			double xmi =1e5, xmx =-1e5, ymi =1e5, ymx =-1e5;
			for(int j =0; j < N; j++) {
				double x =P[j].ff*sin(sl)+P[j].ss*cos(sl);
				double y =P[j].ff*cos(sl)-P[j].ss*sin(sl);
				xmi =min(xmi,x);
				xmx =max(xmx,x);
				ymi =min(ymi,y);
				ymx =max(ymx,y);
				if(ymx-ymi > ans || xmx-xmi > ans) break;}
			if(ans > max(xmx-xmi,ymx-ymi)) {
				ans =max(xmx-xmi,ymx-ymi);
				sli_opt =sli;}
			}
		for(int sli2 =-100; sli2 < 100; sli2++) {
			double sl =2*(sli_opt+sli2/100.0)/20000000.0*pi;
			double xmi =1e5, xmx =-1e5, ymi =1e5, ymx =-1e5;
			for(int j =0; j < N; j++) {
				double x =P[j].ff*sin(sl)+P[j].ss*cos(sl);
				double y =P[j].ff*cos(sl)-P[j].ss*sin(sl);
				xmi =min(xmi,x);
				xmx =max(xmx,x);
				ymi =min(ymi,y);
				ymx =max(ymx,y);
				if(ymx-ymi > ans || xmx-xmi > ans) break;}
			ans =min(ans,max(xmx-xmi,ymx-ymi));
			}
		}

	if(N <= 500)
		for(double sl =0; sl < 2*pi; sl +=1e-5) {
		double xmi =1e5, xmx =-1e5, ymi =1e5, ymx =-1e5;
		for(int j =0; j < N; j++) {
			double x =P[j].ff*sin(sl)+P[j].ss*cos(sl);
			double y =P[j].ff*cos(sl)-P[j].ss*sin(sl);
			xmi =min(xmi,x);
			xmx =max(xmx,x);
			ymi =min(ymi,y);
			ymx =max(ymx,y);
			if(ymx-ymi > ans || xmx-xmi > ans) break;}
		ans =min(ans,max(xmx-xmi,ymx-ymi));}

	cout << ans << "\n";
	return 0;}

// look at my code
// my code is amazing
