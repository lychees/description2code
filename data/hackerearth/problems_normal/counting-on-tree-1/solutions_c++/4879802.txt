//https://www.hackerearth.com/problem/algorithm/counting-on-tree-1/description/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
vector<int>adj[100005];
ll dp[100005][105];
const ll M = 1e9+7;
int cost[100005];
int n,k;
void dfs(int v,int p){
    ll dp1[101]={0};
    dp1[cost[v]]=1;
    for(int i=0;i<adj[v].size();i++){
        int to = adj[v][i];
        if(to==p)continue;
        dfs(to,v);
        ll dp2[101]={0};
        for(int j=0;j<=k;j++)dp2[j] = dp1[j];
        for(int j=0;j<=k;j++)
        for(int l=0;l<=k-j;l++){
            dp2[j+l] = dp2[j+l] + dp1[j] * dp[to][l];
            dp2[j+l] %= M;
        }
        for(int j=0;j<=k;j++)dp1[j] = dp2[j];
       // tsz[v]+=tsz[to];
    }
    for(int j=0;j<=k;j++)dp[v][j] = dp1[j];
}
int main(){
    int t,i;
    cin>>t;
    while(t--){
        cin>>n>>k;
        for(i=1;i<=n;i++){
            adj[i].clear();
            cin>>cost[i];
        }
        for(i=1;i<n;i++){
            int u,v;
            cin>>u>>v;
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        dfs(1,0);
        ll ans = 0;
        for(i=1;i<=n;i++){
            if(dp[i][k]>0){
                ans += dp[i][k];
                ans %= M;
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
