#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cmath>
#include <cstring>
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <list>
#include <map>
#include <set>
#include <sstream>
#include <numeric>
#include <bitset>
#define REP(i, a, b) for ( int i = int(a); i <= int(b); i++ )
#define PB push_back
#define MP make_pair
#define for_each(it, X) for (__typeof((X).begin()) it = (X).begin(); it != (X).end(); it++)
#define DFS_WHITE -1
#define DFS_BLACK 1
#define MAXN 1000
#define pi 3.141592653589793
#define ARRAY_SIZE(A) sizeof(A)/sizeof(A[0])
#define INF 1<<30
#define ll long long
using namespace std;
int setss[1005];
int parent[1005];
void init(int n)
{
		for(int i =0;i<n;i++)
		{
			setss[i] = i;
			parent[i] = -1;
		}
}
int find(int n)
{
	if(setss[n] == n)
		return n;
	else
		return setss[n] = find(setss[n]);
}
void merge(int m,int n)
{
	setss[m] = setss[find(n)];
}
void kruskal(int n,priority_queue<pair <ll,pair<int,int> > >pq)
{
	ll coost = 0;
	int count  = 0;
	while(!pq.empty())
	{
		pair<int,pair<int,int> >pp = pq.top();
		pq.pop();
		if(find(pp.second.first) != find(pp.second.second)  && parent[pp.second.second] ==-1)
		{
			merge(pp.second.first,pp.second.second);
			parent[pp.second.second] = pp.second.first;
			coost += abs(pp.first);
			count++;
		}
	}
	if(count != n-1 )
	coost =-1;
	cout<<coost<<endl;
}
int main()
{
    int tc = 0;
    cin>>tc;
    while(tc--)
    {
    	int n = 0;
    	cin>>n;
    	init(n);
    	priority_queue<pair <ll,pair<int,int> > >pq;
    	vector<int>arr(n);
    	for(int i =0;i<n;i++)
    	{
    		cin>>arr[i];
    	}
    	int queries = 0;
    	cin>>queries;
    	for(int i = 0;i<queries;i++)
    	{
    		int a,b,c;
    		cin>>a>>b>>c;
    		pq.push(MP(-c,MP(a-1,b-1)));
    	}
    	kruskal(n,pq);
    }
}
