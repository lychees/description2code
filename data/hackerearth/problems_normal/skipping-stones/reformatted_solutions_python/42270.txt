#!/usr/bin/python
# HackerEarth InMobi Challenge - Skipping Stones

def maxjumpprob():

    for i in xrange(1, no_of_stones + 2, 1):
        if stone_dts[i] - stone_dts[i - 1] > jump_length:
            print 'IMPOSSIBLE'
            return

    maxlandingprob = [0.0] * (no_of_stones + 2)
    maxlandingprob[0] = 1.0

    for stone in xrange(1, no_of_stones + 2, 1):
        prevstone = stone - 1
        backstone = stone - 2
        while backstone >= 0 and stone_dts[stone] - \
                stone_dts[backstone] <= jump_length:
            if maxlandingprob[backstone] > maxlandingprob[prevstone]:
                prevstone = backstone
            backstone -= 1
        maxlandingprob[stone] = maxlandingprob[prevstone] * stone_probs[stone]

    print '%.6f' % maxlandingprob[no_of_stones + 1]
    return


line = raw_input()
no_of_stones = int(line.split(' ')[0])
jump_length = int(line.split(' ')[1])
pud_length = int(line.split(' ')[2])

stone_probs = [0.0] * (no_of_stones + 2)
stone_dts = [0] * (no_of_stones + 2)

line = raw_input()
stone_probs[0] = 1.0
stone_probs[no_of_stones + 1] = 1.0
for i in xrange(1, no_of_stones + 1, 1):
    stone_probs[i] = float(line.split(' ')[i - 1])

line = raw_input()
stone_dts[0] = 0
stone_dts[no_of_stones + 1] = pud_length
for i in xrange(1, no_of_stones + 1, 1):
    stone_dts[i] = int(line.split(' ')[i - 1])


maxjumpprob()
