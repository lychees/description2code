#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <string>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <cctype>
#include <cassert>

using namespace std;

#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(int i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define Sl(x) scanf("%lld",&x)
#define M(x,i) memset(x,i,sizeof(x))
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl
#define fr first
#define se second
#define gc getchar_unlocked
#define mp make_pair

/* Relevant code begins here */

vector < pair<int, int> > e[100005];
int ans;
map <int, int> sxorv;
int xorvals[100005];
int parent[100005];

class Trie{
	private:
		Trie * child[2];
		int count;
	public:
		Trie(){child[1]=child[0]=NULL;count=0;}
		void initialise(int n,int bit){
			count=0;
			if(bit<0)
				return ;
			bool b=(n&(1<<bit));
			if(child[b]==NULL) child[b]=new Trie();
			child[b]->initialise(n,bit-1);
		}
		void insert(int n,int bit){
			++count;
			if(bit<0)
				return ;
			bool b=(n&(1<<bit));
			child[b]->insert(n,bit-1);
		}
		void remove(int n,int bit)
		{
			--count;
			if(bit<0) return;
			bool b=(n&(1<<bit));
			child[b]->remove(n,bit-1);
		}
		int _search(int n,int bit)
		{
			int temp;
			if(bit<0){temp = 0; return temp;}
			bool b=(n&(1<<bit));
			if(child[1-b]!=NULL&&child[1-b]->count>0)
			{
				temp = child[1-b]->_search(n,bit-1);
				temp += ((1-b)*(1<<bit));
			}
			else
			{
				temp = child[b]->_search(n,bit-1);
				temp += (b*(1<<bit));
			}
			return temp;
		}
}*trie_node;

void dfs(int v,int p,int xval)
{	
	int i;
	xorvals[v] = xval;
	F(i,0,e[v].size()){
		if(e[v][i].fr!=p){
			dfs(e[v][i].fr,v, xval^e[v][i].se);
		}
	}
}

void dfs2(int a, int p)
{
	for (int i = 0; i < e[a].size(); i++) {
		if (e[a][i].fr != p) {
			parent[e[a][i].fr] = a;
			dfs2(e[a][i].fr, a);
		}
	}
}

void path(int u)
{
	cout << u << " ";
	if (parent[u] != u) path(parent[u]);
}

int main()
{	
	int n,a,b,w,i;
	
	S(n);
	
	trie_node = new Trie();
	
	F(i,1,n){
		S(a),S(b),S(w);
		e[a].pb(mp(b,w));
		e[b].pb(mp(a,w));
	}
	ans=0;
	dfs(1,0,0);
	F(i, 1, n+1) {
		//printf("%d %d\n", i, xorvals[i]);
		if (sxorv.find(xorvals[i]) == sxorv.end()) sxorv[xorvals[i]] = i;
		trie_node->initialise(xorvals[i], 31);
		trie_node->insert(xorvals[i], 31);
	}
	F(i, 1, n+1) {
		int x = trie_node->_search(xorvals[i], 31);
		//printf("%d\n", x);
		if (ans < (x^xorvals[i])) {
			a = i;
			b = sxorv[x];
			ans = x^xorvals[i];
		}
	}
	printf("%d\n",ans);
	if (a < b) swap(a, b);
	parent[a] = a;
	dfs2(a, -1);
	path(b);
	printf("\n");
	return 0;
}
