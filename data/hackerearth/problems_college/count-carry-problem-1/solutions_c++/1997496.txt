#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <cstring>
#include <cmath>
#include <set>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <sstream>
#include <iomanip>
#include <stack>
#include <ctime>
#include <typeinfo>
#include <fstream>

using namespace std;

#define pi 3.141592653589793238463
#define ll long long
#define tpi cout
#define nt endl
#define tab '\t'
#define length length()
#define fsyo return 0
#define toint(a) atoi(a.c_str())
#define sor(i,j,n) for(int i=j; i<n; i++)
#define mod 1e9+7
#define chka string::npos
#define all(c) c.begin(), c.end()
#define pow(a,b) pow((double)a,(double)b)
#define tr(container, it) for (auto it = container.begin(); it != container.end(); it++)

//long double pi = 3.141592653589793238463;


string tostring(int a)
{
	ostringstream temp;
	temp << a;
	return temp.str();
}

int gcd(int a, int b)
{
	if (a == 0)
		return b;
	else
		return gcd(b%a, a);
}

bool isPrime(unsigned ll n) {
	if (n <= 3) {
		return n > 1;
	}

	if (n % 2 == 0 || n % 3 == 0) {
		return false;
	}

	for (unsigned ll i = 5; i * i <= n; i += 6) {
		if (n % i == 0 || n % (i + 2) == 0) {
			return false;
		}
	}

	return true;
}


ll lcm(ll a, ll b)
{
	return a*b / gcd(a, b);
}

void multiply(ll F[2][2], ll M[2][2]);
void power(ll F[2][2], ll n);

ll fib(ll n)
{
	ll F[2][2] = { { 1, 1 }, { 1, 0 } };
	if (n == 0)
		return 0;
	power(F, n - 1);
	return F[0][0];
}

void power(ll F[2][2], ll n)
{
	if (n == 0 || n == 1)
		return;
	ll M[2][2] = { { 1, 1 }, { 1, 0 } };
	power(F, n / 2);
	multiply(F, F);
	if (n % 2 != 0)
		multiply(F, M);
}

void multiply(ll F[2][2], ll M[2][2])
{
	ll x = F[0][0] * M[0][0] + F[0][1] * M[1][0];
	ll y = F[0][0] * M[0][1] + F[0][1] * M[1][1];
	ll z = F[1][0] * M[0][0] + F[1][1] * M[1][0];
	ll w = F[1][0] * M[0][1] + F[1][1] * M[1][1];

	F[0][0] = x;
	F[0][1] = y;
	F[1][0] = z;
	F[1][1] = w;
}
//correct until 92

/*void multiply(ll F[2][2], ll M[2][2])
{
ll x = ((F[0][0]) % mod * (M[0][0]) % mod + (F[0][1]) % mod * (M[1][0]) % mod) % mod;
ll y = ((F[0][0]) % mod * (M[0][1]) % mod + (F[0][1]) % mod * (M[1][1]) % mod) % mod;
ll z = ((F[1][0]) % mod * (M[0][0]) % mod + (F[1][1]) % mod * (M[1][0]) % mod) % mod;
ll w = ((F[1][0]) % mod * (M[0][1]) % mod + (F[1][1]) % mod * (M[1][1]) % mod) % mod;

F[0][0] = x;
F[0][1] = y;
F[][0] = z;
F[1][1] = w;
}//fibonacci with mod e9 + 7
*/

ll sumOfDigits(ll in){
	ll sum = 0;
	while (in > 0){
		sum += in % 10;
		in /= 10;
	}
	return sum;
}

ll fact(ll in){
	ll res = 1, mult = 2;
	while (mult < in + 1){
		res *= mult;
		mult++;
	}
	return res;
}
//until 20!

/*

for (char c : STRING){
tpi << c - 'a' + 1 << nt;
}

does the same thing for every char in STRING

*/

/*

stillpos:
tpi << n << " ";
n--;

if (n > 0){
goto stillpos;
}

*/

template <class T>
void reverse1(T *a, int n){
	T *skizb = a, *verj = a + n - 1;
	while (skizb < verj){
		swap(*skizb, *verj);
		skizb++;
		verj--;
	}
}

void rsort(vector <int> &T){
	sort(all(T));
	reverse(all(T));
}


template <typename T> void rsort(T* begin, T* end){
	sort(begin, end);
	rev(begin, end);
}

struct str{
	int x, y, z;

	bool operator<(const str rhs) const
	{
		if (x < rhs.x)
		{
			return true;
		}
		else if (x == rhs.x)
		{
			if (y < rhs.y)
			{
				return true;
			}
			else if (y == rhs.y)
			{
				return z < rhs.z;
			}
		}
		return false;
	}

}struct1[100];

// string A, getline(cin, A); will read line from console and assign it to A
/*
ifstream in;
ofstream out;
string a;
in.open("INPUT.TXT");
out.open("OUTPUT.TXT");
in >> n;
out<<n;
out.close();

*/

char alph[26] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

multiset <string> ms;
vector <ll> vec;
pair <ll, ll> pdzsf[170000];
queue <int> que;
map <ll, ll> mp;
set <int> st;
stack <int> sta;
pair <ll, ll> s[100007];

ll n, m, r, p, q;
int l[26] = { 0 };
int main(){
		
	
	cin >> n;

	while (n--){
		int c = 0;
		ll in1, in2;
		cin >> in1 >> in2;
		ll mx = max(in1, in2);
		while (mx > 0){
			if (in1 % 10 + in2 % 10 > 9){
				c++;
			}
			in1 /= 10;
			in2 /= 10;
			mx /= 10;
		}
		if (c == 0){
			tpi << "No carry operation" << nt;
		}
		else if (c == 1){
			tpi << c << " carry operation" << nt;
		}
		else{
			tpi << c << " carry operations" << nt;
		}
		
	}

	fsyo;
}

/*

cin >> n;

first* point;
point = &a[0];

sor(i, 0, n){
point->x = rand() % 3;
point->y = rand() % 3;
point->z = rand() % 3;
point++;
}

tpi << nt;

sort(a, a + n);

sor(i, 0, n){
tpi << a[i].x << " " << a[i].y << " " << a[i].z << nt;
}

*/

/*

cin >> n;
tpi << nt;

srand(time(NULL));

sor(i, 0, n){
vec.push_back(rand() % 20);
tpi << vec[i] << " ";
}

tpi << nt << nt;

sort(all(vec));

sor(i, 0, n){
tpi << vec[i] << " ";
}

tpi << nt << nt;

set <int> ud(all(vec));

for (set<int>::const_iterator it = ud.begin(); it != ud.end(); it++){
tpi << *it << " ";
}
tpi << nt << nt << ud.size() << nt;

*/