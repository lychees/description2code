/* NumeriX
   "Hard Work Beats Talent
   When Talent Doesn't Work Hard"
*/
#include <bits/stdc++.h>
#define ll long long int
#define fastIO ios::sync_with_stdio(false);cin.tie(0) 
#define sii(x) scanf("%d",&x)
#define pii(x) printf("%d\n",x)
#define sll(x) scanf("%lld",&x)
#define pll(x) printf("%lld\n",x)
#define pf printf
#define present_set_map(container, element) (container.find(element) != container.end()) 
#define present_vec(container, element) (find(all(container),element) != container.end()) 
#define mp make_pair
#define all(x) x.begin(),x.end()
#define all_rev(x) x.rbegin(),x.rend()
#define pb push_back
#define fr first
#define se second
#define mod 1000000007
using namespace std;
long long mult(long long a, long long b, long long MOD)
{
	__int128 res = a;
	res *= b;
	res %= MOD;
	a = res;
	return a;
}
long long modPow(long long a, long long b, long long c){
	long long x = 1, y = a; 
	while (b > 0){
		if (b % 2 == 1){
			x = mult(x, y, c);
		}
		y = mult(y, y, c);
		b /= 2;
	}
	return x%c;
}
bool Miller(long long p, int iteration){
	if (p<2){
		return false;
	}
	if (p != 2 && p % 2 == 0){
		return false;
	}
	long long s = p - 1;
	while (s % 2 == 0){
		s /= 2;
	}
	for (int i = 0; i<iteration; i++){
		long long a = rand() % (p - 1) + 1, temp = s;
		long long MOD = modPow(a, temp, p);
		while (temp != p - 1 && MOD != 1 && MOD != p - 1){
			MOD = mult(MOD, MOD, p);
			temp *= 2;
		}
		if (MOD != p - 1 && temp % 2 == 0){
			return false;
		}
	}
	return true;
}
bool isprime(long long x)
{
	return Miller(x, 15);
}

int main()
{
    //pre();
    fastIO;
    ll n,i,j,curr_floor,prev_floor,ppl,f,k,ans,q,opt,sq;
    cin>>n>>q;
    prev_floor=1;
    ans=0;
    ppl=0;
    while(q--)
    {
        cin>>opt>>f>>k;
        if(opt==1)
        {
          if(isprime(f+k))
          {
              ans+=abs(f-prev_floor);
              ans%=mod;
              ppl+=(k);
              prev_floor=f;
          }
        }
        else
        {
            ll t=f+k;
            sq=sqrtl(t);
            if(sq*sq==t)
            {
                ans+=abs(f-prev_floor);
                ans%=mod;
                ppl-=(k);
                prev_floor=f;
            }
        }
    }
    cout<<ans%mod<<" "<<ppl<<"\n";
}