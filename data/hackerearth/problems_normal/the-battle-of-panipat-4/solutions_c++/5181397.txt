/*    ironstark    */
#include<bits/stdc++.h>
#define pii pair<long long,long long>
#define fi first
#define se second
#define mp make_pair
#define vpi vector< pii >
#define pb push_back
#define ll long long int
#define mod 1000000007
#define gcd(a,b) __gcd(a,b)
#define sf(n) scanf("%lld",&(n))
#define pf(n) printf("%lld\n",(n))
#define setbits(n) __builtin_popcount((n))
#define pq priority_queue
using namespace std;
ll ti = 0;
bool visited[100005];
ll intime[100005];
ll outime[100005];
ll n;
ll arr[100005];
vector<ll>v[100005];
int brr[100005];
void ini()
{
	memset(visited, 0, sizeof(visited));
	memset(intime, 0, sizeof(intime));
	memset(outime, 0, sizeof(outime));
	memset(arr, 0, sizeof(arr));
	memset(brr, 0, sizeof(brr));
	ti = 0;
}
void dfs(ll node)
{
	intime[node] = ti++;
	visited[node] = true;
	for (ll i = 0; i<v[node].size(); i++)
	{
		if (!visited[v[node][i]])
			dfs(v[node][i]);
	}
	outime[node] = ti++;
}
void dfs1(ll node)
{
	visited[node] = true;
	for (ll i = 0; i<v[node].size(); i++)
	{
		if (!visited[v[node][i]])
			dfs1(v[node][i]);
	}
	if (v[node].size() == 1 && node != 0)
	{
		arr[node] = 1;
		brr[node] = 0;
	}
	else
	{
		arr[node] = 1;
		for (ll i = 0; i<v[node].size(); i++)
		{
			ll x = v[node][i];
			if (intime[x] >= intime[node] && outime[x] <= outime[node])
				arr[node] = (arr[node] % mod*(arr[v[node][i]] + 1) % mod) % mod;
		}
		for (ll i = 0; i<v[node].size(); i++)
		{
			ll x = v[node][i];
			if (intime[x] >= intime[node] && outime[x] <= outime[node])
				brr[node] = (brr[node] % mod + (arr[x] + brr[x]) % mod) % mod;

		}
	}
}
int main()
{
	ini();
	cin >> n;
	for (ll i = 0; i<n - 1; i++)
	{
		ll a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(0);
	memset(visited, 0, sizeof(visited));
	dfs1(0);
	ll ans = 1;
	ans = (ans + arr[0] + brr[0]) % mod;
	cout << (ans) % mod << "\n";
}
