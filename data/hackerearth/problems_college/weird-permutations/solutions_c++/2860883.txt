/** Traveling Salesman Problem - Dynamic Programming
    O ( n^2 * 2^n )
    int tsp(int n,int distance[][maxn])
    gives the minimum distance for path 0 to {1,2,3,4,...,(n-1)} to 0
**/
#define maxn 30

#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define vi vector<int>
#define pi pair<int,int>
#define vpi vector< pi >
#define vvi vector< vi >
#define pb push_back
#define mp make_pair
inline void read(int &a){    scanf("%d",&a);     }
inline void read(ll  &a){    scanf("%lld",&a);   }
ll dp[(1<<17)][17];

ll tsp(int n,int K)
{
    ll m=(1<<n),mask;
    int i,j,k,l;
    int dig[n],dc;
	ll ca;

    memset(dp,0,sizeof(dp));
    for(i=1;i<n;i++)
    	dp[1<<i][i]=1;
    for(mask=2;mask<m;mask+=2)
    {
        for(i=1,dc=0;i<n;i++)
        {
            if(mask & (1<<i))
            {
                dig[dc]=i;
                dc++;
            }
        }
        if(dc==1)
        continue;
        
        for(k=0;k<dc;k++)
        {
            ca=0;
            for(l=0;l<dc;l++)
                if(dig[l]!=dig[k])
                    if(abs(2*dig[k]-3*dig[l])<=K)
                    	ca+=dp[mask-(1<<dig[k])][dig[l]];
            dp[mask][dig[k]]=ca;
        }
    }
    /*
    for(i=0;i<m;i++)
    {
        cout<<i<<" : ";
        for(j=0;j<n;j++)
            cout<<dp[i][j]<<" ";
        cout<<endl;
    }
    */
    ca=0;
    for(i=1;i<n;i++)
        ca+=dp[m-2][i];
    return ca;
}

int main()
{
    int t,n,k;
    read(t);
    while(t--)
    {
    	read(n);read(k);
    	cout<<tsp(n+1,k)<<"\n";
	}
}