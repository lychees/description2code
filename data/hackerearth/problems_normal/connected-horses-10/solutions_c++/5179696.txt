#include<bits/stdc++.h>

#define MOD 1000000007

using namespace std;

struct P
{
	int x;
	int y;
};
int config[1000][1000],v[1000][1000];

long long fact(int n)
{
	long long i,ans=1;
	for(i=2;i<=n;i++)
		ans=(ans*i)%MOD;
	return ans;
}
int main()
{
	long long ans;
	int t,n,i,j,m,q,x,y,x1,y1;
	queue<struct P> Q;
	struct P X;
	cin>>t;
	while(t--)
	{
		cin>>n>>m>>q;
		memset(config,0,sizeof(config));
		memset(v,0,sizeof(v));
		ans=1;
		for(i=0;i<q;i++)
		{
			cin>>x>>y;
			x--;y--;
			config[x][y]=1;
		}
		for(i=0;i<n;i++)
		{
			for(j=0;j<m;j++)
			{
				if(v[i][j]==0)
				{
					v[i][j]=1;
					if(config[i][j]==1)
					{
						X.x=i;
						X.y=j;
						Q.push(X);
						int c=0;
						while(!Q.empty())
						{
							X=Q.front();
							Q.pop();
							
							c++;
							
							x1=X.x;
							y1=X.y;
							if(x1-2>=0)
							{
								if(y1-1>=0)
								{
									if(v[x1-2][y1-1]==0 && config[x1-2][y1-1]==1)
									{
										v[x1-2][y1-1]=1;		
										X.x=x1-2;
										X.y=y1-1;
										Q.push(X);
									}
								}
								if(y1+1<m)
								{
									if(v[x1-2][y1+1]==0 && config[x1-2][y1+1]==1)
									{
										v[x1-2][y1+1]=1;		
										X.x=x1-2;
										X.y=y1+1;
										Q.push(X);
									}
									
								}
							}
							if(x1+2<n)
							{
								if(y1-1>=0)
								{
									if(v[x1+2][y1-1]==0 && config[x1+2][y1-1]==1)
									{
										v[x1+2][y1-1]=1;		
										X.x=x1+2;
										X.y=y1-1;
										Q.push(X);
									}
								}
								if(y1+1<m)
								{
									if(v[x1+2][y1+1]==0 && config[x1+2][y1+1]==1)
									{
										v[x1+2][y1+1]=1;		
										X.x=x1+2;
										X.y=y1+1;
										Q.push(X);
									}
								}
							}
							if(y1-2>=0)
							{
								if(x1-1>=0)
								{
									if(v[x1-1][y1-2]==0 && config[x1-1][y1-2]==1)
									{
										v[x1-1][y1-2]=1;		
										X.x=x1-1;
										X.y=y1-2;
										Q.push(X);
									}
								}
								if(x1+1<n)
								{
									if(v[x1+1][y1-2]==0 && config[x1+1][y1-2]==1)
									{
										v[x1+1][y1-2]=1;		
										X.x=x1+1;
										X.y=y1-2;
										Q.push(X);
									}
								}
								
							}
							if(y1+2<m)
							{
								if(x1-1>=0)
								{
									if(v[x1-1][y1+2]==0 && config[x1-1][y1+2]==1)
									{
										v[x1-1][y1+2]=1;		
										X.x=x1-1;
										X.y=y1+2;
										Q.push(X);
									}
								}
								if(x1+1<n && config[x1+1][y1+2]==1)
								{
									if(v[x1+1][y1+2]==0)
									{
										v[x1+1][y1+2]=1;		
										X.x=x1+1;
										X.y=y1+2;
										Q.push(X);
									}
								}
							}
						}
						ans=((ans%MOD)*(fact(c)%MOD))%MOD;
					}
				}
			}
		}
		cout<<ans<<"\n";
	}	
	return 0;
}