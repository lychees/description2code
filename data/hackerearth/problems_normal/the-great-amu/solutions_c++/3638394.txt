#include <cstdio>
#include <cmath>
#include <iostream>
#include <set>
#include <algorithm>
#include <vector>
#include <map>
#include <cassert>
#include <string>
#include <cstring>
#include <queue>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define P(x) printf("%d\n",x)
#define all(v) v.begin(),v.end()
#define FF first
#define SS second

typedef long long int LL;
typedef pair<int, int > pii;
typedef vector<int > vi;

const int mod = 7190;
const int N = 300;

int primes[3] = {2, 5, 719};
int INV[3][800];
int n;
int W[N][N], A[N][N];
int X[N], Y[N];

LL _pow(LL a, LL b, LL m) {
  if(!b) return 1;
  if(b == 1) return a;
  if(b == 2) return a * a % m;
  if(b & 1) {
    return a * _pow(a,b-1,m) % m;
  }
  return _pow(_pow(a,b/2,m),2,m);
}

void pre() {
  rep(i,0,3) {
    rep(j,0,primes[i]) {
      INV[i][j] = _pow(j, primes[i] - 2, primes[i]);
    }
  }
}

vector<pair<int, pii > > v[3];

void gauss(int id) {
  memcpy(A, W, sizeof(A));

  rep(i,0,n) {
    rep(j,0,n) A[i][j] %= primes[id];
  }

  int cur = 0;
  rep(i,0,n) {
    int idx = cur;
    rep(j,cur+1,n) if(A[j][i] > A[idx][i]) {
      idx = j;
    }
    // swap rows
    v[id].push_back(make_pair(0, make_pair(cur, idx)));
    rep(j,0,n) swap(A[cur][j], A[idx][j]);

    if(!A[cur][i]) {
      continue;
    }

    rep(j,cur+1,n) {
      A[cur][j] = A[cur][j] * INV[id][A[cur][i]] % primes[id];
    }
    v[id].push_back(make_pair(1, make_pair(cur, INV[id][A[cur][i]]))); // mul
    A[cur][i] = 1;

    rep(j,cur+1,n) {
      int num = A[j][i];
      rep(k,i,n) {
        A[j][k] = (A[j][k] - (A[cur][k] * num % primes[id]) + primes[id]) % primes[id];
      }
      v[id].push_back(make_pair(200+cur, make_pair(j, (num % primes[id])))); // sub
    }
    cur++;

    // rep(i,0,n) {
    //   rep(j,0,n) printf("%d ",A[i][j]); printf("%d\n",X[i]);
    // }
    // printf("\n");
  }
  v[id].push_back(make_pair(3, make_pair(cur, 0)));
}

int main() {
  int q;
  S2(n,q);
  rep(i,0,n) {
    rep(j,0,n) S(W[i][j]);
  }
  pre();
  gauss(0);
  gauss(1);
  gauss(2);
  while(q--) {
    bool ok = true;
    rep(i,0,n) {
      S(Y[i]);
    }
    rep(i,0,3) if(ok) {
      memcpy(X, Y, sizeof(X));
      rep(j,0,n) X[j] %= primes[i];
      rep(j,0,v[i].size()) {
        if(v[i][j].FF == 0) {
          swap(X[v[i][j].SS.FF], X[v[i][j].SS.SS]);
        } else if(v[i][j].FF == 1) {
          X[v[i][j].SS.FF] = X[v[i][j].SS.FF] * v[i][j].SS.SS % primes[i];
        } else if(v[i][j].FF >= 200) {
          X[v[i][j].SS.FF] -= X[v[i][j].FF - 200] * v[i][j].SS.SS % primes[i];
          if(X[v[i][j].SS.FF] < 0) {
            X[v[i][j].SS.FF] += primes[i];
          }
        } else {
          assert(j + 1 == v[i].size());
          int cur = v[i][j].SS.FF;
          rep(k,cur,n) if(X[k]) {
            ok = false;
            break;
          }
        }
      }
    }
    // gauss(0);
    if(ok) {
      printf("Yes\n");
    } else {
      printf("No\n");
    }
  }
  return 0;
}