#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <cctype>
#include <cassert>
#include <limits>
#include <functional>
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#if defined(_MSC_VER) || __cplusplus > 199711L
#define aut(r,v) auto r = (v)
#else
#define aut(r,v) __typeof(v) r = (v)
#endif
#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)
#define all(o) (o).begin(), (o).end()
#define pb(x) push_back(x)
#define mp(x,y) make_pair((x),(y))
#define mset(m,v) memset(m,v,sizeof(m))
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3fLL
using namespace std;
typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii; typedef long long ll;
template<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }

struct CentroidPathDecomposition {
	vector<int> colors, positions;	//Vertex -> Color, Vertex -> Offset
	vector<int> lengths, parents, branches;	//Color -> Int, Color -> Color, Color -> Offset
	vector<int> parentnodes, depths;	//Vertex -> Vertex, Vertex -> Int
	//vector<FenwickTree>??????1??????????
	//sortednodes?[lefts[v], rights[v])?v?subtree??????
	vector<int> sortednodes, offsets;	//Index -> Vertex, Color -> Index
	vector<int> lefts, rights;	//Vertex -> Index

	struct BuildDFSState {
		int i, len, parent;
		BuildDFSState() { }
		BuildDFSState(int i_, int l, int p): i(i_), len(l), parent(p) { }
	};

	//??????????????????????????
	void build(const vector<vi> &g, int root) {
		int n = g.size();

		colors.assign(n, -1); positions.assign(n, -1);
		lengths.clear(); parents.clear(); branches.clear();
		parentnodes.assign(n, -1); depths.assign(n, -1);

		sortednodes.clear(); offsets.clear();
		lefts.assign(n, -1); rights.assign(n, -1);

		vector<int> subtreesizes;
		measure(g, root, subtreesizes);

		typedef BuildDFSState State;
		depths[root] = 0;
		vector<State> s;
		s.push_back(State(root, 0, -1));
		while(!s.empty()) {
			State t = s.back(); s.pop_back();
			int i = t.i, len = t.len;
			int index = sortednodes.size();
			int color = lengths.size();

			if(t.parent == -3) {
				rights[i] = index;
				continue;
			}

			if(t.parent != -2) {
				assert(parents.size() == color);
				parents.push_back(t.parent);
				branches.push_back(len);
				offsets.push_back(index);
				len = 0;
			}
			colors[i] = color;
			positions[i] = len;

			lefts[i] = index;
			sortednodes.push_back(i);

			int maxsize = -1, maxj = -1;
			each(j, g[i]) if(colors[*j] == -1) {
				if(maxsize < subtreesizes[*j]) {
					maxsize = subtreesizes[*j];
					maxj = *j;
				}
				parentnodes[*j] = i;
				depths[*j] = depths[i] + 1;
			}
			s.push_back(State(i, -1, -3));
			if(maxj == -1) {
				lengths.push_back(len + 1);
			}else {
				each(j, g[i]) if(colors[*j] == -1 && *j != maxj)
					s.push_back(State(*j, len, color));
				s.push_back(State(maxj, len + 1, -2));
			}
		}
	}
	
	void get(int v, int &c, int &p) const {
		c = colors[v]; p = positions[v];
	}
	bool go_up(int &c, int &p) const {
		p = branches[c]; c = parents[c];
		return c != -1;
	}

	inline const int *nodesBegin(int c) const { return &sortednodes[0] + offsets[c]; }
	inline const int *nodesEnd(int c) const { return &sortednodes[0] + (c+1 == offsets.size() ? sortednodes.size() : offsets[c+1]); }

private:
	void measure(const vector<vi> &g, int root, vector<int> &out_subtreesizes) const {
		out_subtreesizes.assign(g.size(), -1);
		vector<int> s;
		s.push_back(root);
		while(!s.empty()) {
			int i = s.back(); s.pop_back();
			if(out_subtreesizes[i] == -2) {
				int s = 1;
				each(j, g[i]) if(out_subtreesizes[*j] != -2)
					s += out_subtreesizes[*j];
				out_subtreesizes[i] = s;
			}else {
				s.push_back(i);
				each(j, g[i]) if(out_subtreesizes[*j] == -1)
					s.push_back(*j);
				out_subtreesizes[i] = -2;
			}
		}
	}
};

vector<int> t_parent;
vi t_ord;

void tree_getorder(const vector<vi> &g, int root) {
	int n = g.size();
	t_parent.assign(n, -1);
	t_ord.clear();

	vector<int> stk; stk.push_back(root);
	while(!stk.empty()) {
		int i = stk.back(); stk.pop_back();
		t_ord.push_back(i);
		for(int j = (int)g[i].size()-1; j >= 0; j --) {
			int c = g[i][j];
			if(t_parent[c] == -1 && c != root)
				stk.push_back(c);
			else
				t_parent[i] = c;
		}
	}
}

int lowest_common_ancestor(const CentroidPathDecomposition &cpd, int x, int y) {
	int cx, px, cy, py;
	cpd.get(x, cx, px);
	cpd.get(y, cy, py);
	while(cx != cy) {
		if(cpd.depths[*cpd.nodesBegin(cx)] < cpd.depths[*cpd.nodesBegin(cy)])
			cpd.go_up(cy, py);
		else
			cpd.go_up(cx, px);
	}
	return cpd.nodesBegin(cx)[min(px, py)];
}

int level_ancestor(const CentroidPathDecomposition &cpd, int x, int d) {
	int c, p;
	const int *head;
	if(d > cpd.depths[x]) return -1;
	cpd.get(x, c, p);
	while(d < cpd.depths[*(head = cpd.nodesBegin(c))])
		cpd.go_up(c, p);
	return head[d - cpd.depths[*head]];
}
int get_ancestor_child(const CentroidPathDecomposition &cpd, int x, int y) {
	return level_ancestor(cpd, y, cpd.depths[x] + 1);
}


int main() {
	int N;
	scanf("%d", &N);
	vector<vi> g(N);
	rep(i, N - 1) {
		int a, b;
		scanf("%d%d", &a, &b), -- a, -- b;
		g[a].push_back(b);
		g[b].push_back(a);
	}
	tree_getorder(g, 0);
	vector<int> subtsize(N, 1);
	for(int ix = N - 1; ix > 0; -- ix) {
		int i = t_ord[ix];
		subtsize[t_parent[i]] += subtsize[i];
	}
	vector<int> depths(N, 0);
	for(int ix = 1; ix < N; ++ ix) {
		int i = t_ord[ix];
		depths[i] = depths[t_parent[i]] + 1;
	}
	vector<ll> combs(N), rems(N, 0);
	rep(i, N) {
		int s = subtsize[i], t = N - s + 1;
		combs[i] = (ll)s * (s-1) / 2;
		if(i != 0) {
			int p = t_parent[i], u = subtsize[p];
			rems[i] = (ll)s * u - (ll)s * (s+1) / 2;
		}
	}
	CentroidPathDecomposition cpd;
	cpd.build(g, 0);
	vector<ll> combsum = combs, remsum = rems;
	for(int ix = 1; ix < N; ++ ix) {
		int i = t_ord[ix], p = t_parent[i];
		combsum[i] += combsum[p];
		remsum[i] += remsum[p];
	}
	int Q;
	scanf("%d", &Q);
	rep(ii, Q) {
		int u, v;
		scanf("%d%d", &u, &v), -- u, -- v;
		int w = lowest_common_ancestor(cpd, u, v);
		if(v == w) swap(u, v);
		if(u == v) {
			ll ans = 0;
			printf("%lld\n", ans);
			continue;
		}
		assert(u != v);
		ll pairs = 0;
		//  C(a - b, 2)
		//= C(a, 2) + b(b+1)/2 - ab
		pairs += combsum[u] - combsum[w];
		pairs += combsum[v] - combsum[w];
		int cu = get_ancestor_child(cpd, w, u);
		int cv = get_ancestor_child(cpd, w, v);
		if(u != w) {
			pairs -= remsum[u] - remsum[w];
			pairs += rems[cu];
		}
		assert(v != w);
		pairs -= remsum[v] - remsum[w];
		pairs += rems[cv];
		int wsize;
		if(u == w) {
			assert(cv != -1);
			wsize = N - subtsize[cv];
		}else {
			assert(cu != -1 && cv != -1);
			wsize = N - subtsize[cu] - subtsize[cv];
		}
		pairs += (ll)wsize * (wsize - 1) / 2;
		ll ans = (ll)N * (N-1) / 2 - pairs;
		printf("%lld\n", ans);
	}
	return 0;
}
