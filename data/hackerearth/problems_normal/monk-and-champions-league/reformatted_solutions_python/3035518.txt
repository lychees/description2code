
class PriorityQueue:

    def __init__(self, L=[0]):

        self.queue = L
        self.length = len(L)-1
        if len(L) > 1:
            self.build_heap()

    def build_heap(self):
        N = self.length
        for i in range(N/2, 0, -1):
            self.heapify(i, N)

    def heapify(self, ind, N):
        arr = self.queue
        left = 2*ind  # left child
        right = 2*ind + 1  # right child

        if left <= N and arr[left] > arr[ind]:
            largest = left
        else:
            largest = ind

        if right <= N and arr[right] > arr[largest]:
            largest = right

        if (largest != ind):

            arr[ind], arr[largest] = arr[largest], arr[ind]  # swap both

            self.heapify(largest, N)

    def front(self):
        return self.queue[1]

    def dequeue(self):
        arr = self.queue
        if self.length == 0:
            return None
        N = self.length
        result = arr[1]

        arr[1] = arr[N]
        self.length -= 1
        arr.pop()
        self.heapify(1, self.length)
        return result

    def increase_key(self, ind, value):
        arr = self.queue

        if (value < arr[ind]):
            return None

        arr[ind][1] = value

        while (ind > 1 and arr[ind] > arr[ind/2]):

            arr[ind], arr[ind/2] = arr[ind/2], arr[ind]
            ind = ind/2

    def insert(self, value):
        arr = self.queue
        length = self.length
        length += 1
        self.length += 1

        arr.append(value)

        ind = length
        while (ind > 1 and arr[ind] > arr[ind/2]):

            arr[ind], arr[ind/2] = arr[ind/2], arr[ind]
            ind = ind/2

    def pprint(self):
        print self.queue[1:self.length+1]


M, N = [int(x) for x in raw_input().split()]
row = [int(x) for x in raw_input().split()]

p_row = [0]

p_row += row

q = PriorityQueue(p_row)

total = 0
for i in range(N):
    val = q.dequeue()
    total += val
    q.insert(val-1)
print total
