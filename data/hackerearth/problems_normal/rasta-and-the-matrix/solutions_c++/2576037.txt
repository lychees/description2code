/*#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cctype>
#include<cstdlib>
#include<algorithm>
#include<bitset>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<map>
#include<set>
#include<stack>
#include<cmath>
#include<sstream>
#include<fstream>
#include<iomanip>
#include<ctime>
#include<complex>
#include<functional>
#include<climits>
#include<cassert>
#include<iterator>
#include<unordered_map>
#include<unordered_set>
//#include<quadmath.h>
using namespace std;
#define MAX 100002
int n;
struct st{
	long long int w=0;
	long long int b=0;
	long long int lef;
	long long int rig;
	int lazy = 0;
	int op = 0;
	st *l=NULL;
	st *r=NULL;
};
#define MAXLINK 1000000
st linkk[MAXLINK];
int siz = 0;
st *neww(){
	if (siz == MAXLINK){
		return new st();
	}
	siz++;
	return &linkk[siz - 1];
}
void update(st *b){
	b->op += b->lazy;
	bool flag = false;
	if (!b->l){
		flag = true;
		b->l = neww();
		b->l->op = 0;
		b->l->lazy = b->op;
		b->l->lef = b->lef;
		b->l->rig = (b->lef + b->rig) / 2LL;
		b->l->w = b->l->rig - b->l->lef;
	}
	bool flag2 = false;
	if (!b->r){
		flag2 = true;
		b->r = neww();
		b->r->op = 0;
		b->r->lazy = b->op;
		b->r->lef = (b->lef + b->rig) / 2LL;
		b->r->rig = b->rig;
		b->r->w = b->r->rig - b->r->lef;
	}
	b->lazy %= 2;
	if (b->lazy){
		if (flag == false){
			b->l->lazy++;
		}
		if (flag2 == false){
			b->r->lazy++;
		}
		swap(b->w, b->b);
	}
	b->lazy = 0;
}
const unsigned long long int MAXX = 1000000000000000001LL;
class Dynamicsegtree{
public:
	st *root;
	Dynamicsegtree(){
		root = neww();
		root->w = MAXX;
		root->lef = 0;
		root->rig = MAXX;
	}
	inline void add(st *b, long long int l, long long int r, long long ll, long long int rr){
		update(b);
		if (ll <= l&&r <= rr){
			b->lazy++;
			update(b);
			return;
		}
		if (rr <= l || r <= ll){
			return;
		}
		add(b->l, l, (l + r) >> 1LL, ll, rr);
		add(b->r, (l + r) >> 1LL, r, ll, rr);
		b->w = b->l->w + b->r->w;
		b->b = b->l->b + b->r->b;
	}
	inline pair<long long int, long long int> q(st *b, unsigned long long int l, unsigned long long int r, unsigned long long int ll, unsigned long long int rr){
		update(b);
		if (ll <= l&&r <= rr){
			return make_pair(b->w, b->b);
		}
		if (rr <= l || r <= ll){
			return make_pair(0, 0);
		}
		
		if (b->w == b->rig - b->lef){
			return make_pair(min(r, rr) - max(l, ll), 0);
		}
		if (b->b == b->rig - b->lef){
			return make_pair(0,min(r, rr) - max(l, ll));
		}
		pair<long long int, long long int> r1 = q(b->l, l, (l + r) >> 1ULL, ll, rr);
		pair<long long int, long long int> rr1 = q(b->r, (l + r) >> 1ULL, r, ll, rr);
		r1.first += rr1.first;
		r1.second += rr1.second;
		return r1;
	}
}; 
Dynamicsegtree row;
Dynamicsegtree col;
long long int Lastans;
const unsigned long long int MOD = 1000000007LL;
int main(){
	int q;
	scanf("%d", &q);
	while (q--){
		int ty;
		scanf("%d", &ty);
		if (ty == 1){
			int x;
			long long int l;
			long long int r;
			scanf("%d%lld%lld", &x, &l, &r);
			l ^= Lastans;
			r ^= Lastans;
			if (x == 0){
				row.add(row.root, 0, MAXX, l, r + 1LL);
			}
			else{
				col.add(col.root, 0, MAXX, l, r + 1LL);
			}
			continue;
		}
		else{
			long long int l;
			long long int r;
			long long int x;
			long long int y;
			scanf("%lld%lld%lld%lld", &l, &r, &x, &y);
			l ^= Lastans;
			r ^= Lastans;
			x ^= Lastans;
			y ^= Lastans;
			pair<long long int, long long int> k = row.q(row.root, 0, MAXX, l, r+1LL);
			pair<long long int, long long int> kk = col.q(col.root, 0, MAXX, x, y + 1LL);
			k.first%=MOD;
			k.second%=MOD;
			kk.second%=MOD;
			kk.first%=MOD;
			k.first *= kk.second;
			k.second *= kk.first;
			k.first %= MOD;
			k.second %= MOD;
			long long int ans = k.first + k.second;
			if (ans >= MOD){
				ans %= MOD;
			}
			printf("%lld\n", ans);
			Lastans = ans;
		}
	}
	return 0;
}*/
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
#define Foreach(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))
#define rof(i,a,b) for(int (i)=(a);(i) > (b); --(i))
#define rep(i, c) for(auto &(i) : (c))
#define x first
#define y second
#define pb push_back
#define PB pop_back()
#define iOS ios_base::sync_with_stdio(false)
#define sqr(a) (((a) * (a)))
#define all(a) a.begin() , a.end()
#define error(x) cerr << #x << " = " << (x) <<endl
#define Error(a,b) cerr<<"( "<<#a<<" , "<<#b<<" ) = ( "<<(a)<<" , "<<(b)<<" )\n";
#define errop(a) cerr<<#a<<" = ( "<<((a).x)<<" , "<<((a).y)<<" )\n";
#define coud(a,b) cout<<fixed << setprecision((b)) << (a)
#define L(x) ((x)<<1)
#define R(x) (((x)<<1)+1)
#define umap unordered_map
#define double long double
typedef long long ll;
#define int ll
typedef pair<int,int>pii;
typedef vector<int> vi;
typedef complex<double> point;
template <typename T> using os =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <class T>  inline void smax(T &x,T y){ x = max((x), (y));}
template <class T>  inline void smin(T &x,T y){ x = min((x), (y));}
struct seg{
	int b, l, r;
	bool lz;
	seg * L, * R;
	seg(){b = l = r = lz = 0; L = R = NULL;}
	seg(int x, int y){l = x, r = y, b = 0, lz = 0; L = R = NULL;}
	inline void le(){
		if(r - l < 2 or L != NULL)	return ;
		int mid = (l+r)/2;
		L = new seg(l, mid);
	}
	inline void ri(){
		if(r - l < 2 or R != NULL)	return ;
		int mid = (l+r)/2;
		R = new seg(mid, r);
	}
	inline void color(bool h){
		if(!h)
			return ;
		lz = !lz;
		b = r - l - b;
	}
	inline void shift(){
		le();ri();
		L -> color(lz);
		R -> color(lz);
		lz = false;
	}
	inline void upd(int x, int y){
		if(x >= r or l >= y)	return ;
		if(x <= l && r <= y){
			color(true);
			return ;
		}
		shift();
		L -> upd(x, y);
		R -> upd(x, y);
		b = L -> b + R -> b;
	}
	inline int cnt(int x, int y){
		if(x >= r or l >= y)	return 0;
		if(x <= l && r <= y)	return b;
		shift();
		return L -> cnt(x, y) +
			   R -> cnt(x, y) ;
	}
};
int n;
const ll INF = 1e18 + 20;
const int mod = 1e9 + 7;
main(){
	iOS;
	cin >> n;
	int l, r, t, x, y;
	int last_ans = 0;
	seg s[2];
	For(i,0,2)
		s[i] = seg(0LL, INF);
	while(n--){
		cin >> t;
		if(t == 1){
			cin >> x >> l >> r;
			l ^= last_ans;
			r ^= last_ans;
			-- l;
			s[x].upd(l, r);
		}
		else{
			cin >> l >> r >> x >> y;
			x ^= last_ans;
			y ^= last_ans;
			l ^= last_ans;
			r ^= last_ans;
			-- l, -- x;
			int t1 = r - l, t2 = y - x;
			int b1 = s[0].cnt(l, r), b2 = s[1].cnt(x, y);
			int w1 = t1 - b1, w2 = t2 - b2;
			b1 %= mod;
			b2 %= mod;
			w1 %= mod;
			w2 %= mod;
			int g = (1LL * b1 * w2)%mod,
				f = (1LL * b2 * w1)%mod;
			last_ans = (g + f)%mod;
			cout << last_ans << '\n';
		}
	}
	return 0;
}