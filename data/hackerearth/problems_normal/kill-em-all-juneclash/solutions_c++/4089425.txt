#include "bits/stdc++.h"
using namespace std;
#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
static const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;
typedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;
template<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }
template<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }

template<int MOD>
struct ModInt {
	static const int Mod = MOD;
	unsigned x;
	ModInt() : x(0) {}
	ModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	ModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }
	int get() const { return (int)x; }

	ModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
	ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }

	ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
	ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
	ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
};
typedef ModInt<1000000007> mint;

int main() {
	/*
	//./geng -c 8 2> /dev/null | ./showg -a | grep -E '^[01]*$' | test2.exe
	int wf[24][24], wf2[24][24];
	string line;
	ll cnt = 0;
	while(cin >> line) {
		int n = line.size();
		rep(i, n) rep(j, n)
			wf[i][j] = i == j ? 0 : INF;
		rep(i, n) {
			if(i != 0) cin >> line;
			rep(j, n) if(line[j] == '1')
				wf[i][j] = 1;
		}
		rep(k, n) rep(i, n) rep(j, n)
			amin(wf[i][j], wf[i][k] + wf[k][j]);
		int diam = 0;
		rep(i, n) rep(j, n)
			amax(diam, wf[i][j]);
		bool ok = true;
		rep(ei, n) rep(ej, ei) if(wf[ei][ej] > 1) {
			rep(i, n) rep(j, n)
				wf2[i][j] = wf[i][j];
			wf2[ei][ej] = wf2[ej][ei] = 1;
			rep(k, n) rep(i, n) rep(j, n)
				amin(wf2[i][j], wf2[i][k] + wf2[k][j]);
			int diam2 = 0;
			rep(i, n) rep(j, n)
				amax(diam2, wf2[i][j]);
			ok &= diam2 < diam;
			if(!ok) break;
		}
		if(ok) {
			int m = 0;
			rep(i, n) reu(j, i + 1, n) if(wf[i][j] == 1)
				++ m;
			int s = -1;
			rep(i, n) rep(j, n) if(wf[i][j] == diam) {
				s = i;
				break;
			}

			auto name = [&](int u) {
				return '"' + to_string(cnt) + ',' + to_string(u) + '"';
			};

			rep(i, n) cout << name(i) << "[label=" << wf[s][i] << "];";
			cout << endl;
			rep(i, n) reu(j, i + 1, n) if(wf[i][j] == 1) {
				int u = i, v = j;
				if(wf[s][u] > wf[s][v])
					swap(u, v);
				cout << name(u) << "->" << name(v);
				if(wf[s][u] + 1 != wf[s][v])
					cout << "[constraint=false]";
				if(wf[s][u] == wf[s][v])
					cout << "[dir=none]";
				cout << ";";
			}
			cout << endl;
			cout << endl;
			++ cnt;
		}
	}
	cout << "cnt = " << cnt << endl;
	//*/
	//*
	const mint Inv2 = 500000004;
	const int MaxN = 1000000;
	vector<mint> dp(MaxN + 1);
	dp[1] = dp[2] = 1;
	rer(n, 3, MaxN)
		dp[n] = dp[n - 1] + dp[n - 1];
	int T;
	scanf("%d", &T);
	for(int ii = 0; ii < T; ++ ii) {
		int N;
		scanf("%d", &N);
		if(N <= 2) {
			puts("1");
			continue;
		}
		mint ans = dp[N - 1];
		//区切りはレベルの間
		if(N % 2 == 0)
			ans += dp[N / 2];
		//区切りはレベル
		//rer(m, 1, N - 2) if((N - m) % 2 == 0)
		//	ans += dp[(N - m) / 2];
		ans += dp[(N + 1) / 2];
		ans *= Inv2;
		ans += 1;	//complete graph
		printf("%d\n", ans.get());
	}
	//*/
	return 0;
}
