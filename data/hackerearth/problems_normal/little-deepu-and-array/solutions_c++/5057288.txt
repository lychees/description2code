#include <iostream>
#include <vector>
#include <fstream>
#include <stack>
#include <array>
#include <deque>
#include <queue>
#include <set>
#include <unordered_set>
#include <list>
#include <forward_list>
#include <iterator>
#include <tuple>
#include <map>
#include <functional>
#include <unordered_map>
#include <iomanip>
#include <string>
#include <utility>
#include <deque>
#include <iterator>
#include <string>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <climits>
#include <cstdbool>
#include <cassert>
using namespace std;
#define REP(i,n) for(int i=0;i<(n);i++)
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define FORD(i,a,b) for(int i=(a);i>=(b);i--)
#define sz(a) int((a).size()) 
#define pb push_back 
#define NIL -1
#define all(c) (c).begin(),(c).end() 
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) 
#define present(c,x) ((c).find(x) != (c).end()) 
#define cpresent(c,x) (find(all(c),x) != (c).end())
const int INF = 1<<29;
typedef long long ll;
inline int two(int n) { return 1 << n; }
inline int test(int n, int b) { return (n>>b)&1; }
inline void set_bit(int & n, int b) { n |= two(b); }
inline void unset_bit(int & n, int b) { n &= ~two(b); }
inline int last_bit(int n) { return n & (-n); }
inline int ones(int n) { int res = 0; while(n && ++res) n-=n&(-n); return res; }
typedef vector<int> vi; 
typedef vector<vi> vvi; 
typedef pair<int,int> ii; 
typedef list<int> li; 
typedef list<li> lli; 

//your code goes below this line
/////////////////////////////////////////////////////////////////////

struct node{
	int value;
	int index;
};
typedef struct node node;
node arr[200002];
int n;
bool mycomp(node a, node b) {
	return a.value  < b.value;
}
bool mycomp3(int b, node a) {
	return b < a.value;
}
bool mycomp2(node a, node b) {
	return a.index  < b.index;
}
void modify(int l, int r, int value) {
	for(l += n, r +=n; l < r; l >>= 1, r >>= 1) {
		if(l&1) arr[l++].value += value;
		if(r&1) arr[--r].value += value;
	}
}
void push() {
	REP(i, n) {
	   arr[i<<1].value += arr[i].value;
	   arr[i<<1|1].value += arr[i].value;
	   arr[i].value = 0;
	}
}

int main() {
	cin >> n;
	REP(i, n) {
		cin >> arr[n+i].value;
		arr[n+i].index = i;
	}
	sort(arr+n, arr+n+n, mycomp);
	int m;
	cin >> m;
    int x;
	while(m--) {
		cin >> x;
		auto it = upper_bound(arr+n, arr+n+n, x, mycomp3);
		modify((int)(it-(arr+n)), n, -1);
	    push();
    }
	sort(arr+n, arr+n+n, mycomp2);
    REP(i, n)
	  cout << arr[n+i].value << " ";
	cout << endl;
    return 0;
}
