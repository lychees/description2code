import copy
from math import *


def f(x):
    return str(x)


def get_min(path, dicti):
    mini = 10000000000
    for i in range(len(path)-1):
        j = i+1
        edge = (path[i], path[j])
        if dicti[edge] < mini:
            mini = dicti[edge]
    return mini


def dfs(source, destination, G, path, results, status, dicti):
    status[source] = 2

    path.append(source)
    if (source == destination):
        results.append(copy.copy(path))
    else:
        for nbs in G[source]:
            u = nbs[0]
            if status[u] == 1:
                dfs(u, destination, G, path, results, status, dicti)
    path.pop()
    status[source] = 1


N, R = [int(x) for x in raw_input().split()]
G = [[] for x in range(N+1)]
dicti = {}
for i in range(R):
    u, v, w = [int(x) for x in raw_input().split()]
    G[u].append((v, w))
    G[v].append((u, w))
    dicti[(u, v)] = w
    dicti[(v, u)] = w

status = [1]*(N+1)
s, d, t = [int(x) for x in raw_input().split()]
path = []
results = []
target_min = [0]
dfs(s, d, G, path, results, status, dicti)
mp = {}
for i in range(len(results)):
    mp[i] = get_min(results[i], dicti)

x = max(mp.values())
ans = []
for i in range(len(results)):
    if mp[i] == x:
        y = map(f, results[i])
        z = "".join(y)
        ans.append((z, i))
ans.sort()
ans = results[ans[0][1]]


if x >= t+1:
    moves = 1

else:
    if (t % (x-1)) == 0:
        moves = int(t/(x-1))
    else:
        moves = int(ceil(t/float((x-1))))
for i in ans:
    print i,

print
print moves
