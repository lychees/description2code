#include <bits/stdc++.h>
typedef long long ll;

using namespace std;



ll modulo(ll base, ll exponent, ll mod)
{
    __int128 x = 1;
    __int128 y = base;
    while (exponent > 0)
    {
        if (exponent % 2 == 1)
            x = (x * y) % mod;
        y = (y * y) % mod;
        exponent = exponent / 2;
    }
    return x % mod;
} 
 
/* 
 * Fermat's test for checking primality 
 */
bool Fermat(ll p, int iterations)
{
    if (p == 1)
        return false;
        
    for (int i = 0; i < iterations; i++)
    {
        ll a = rand() % (p - 1) + 1; 
        if (modulo(a, p - 1, p) != 1)
        { 
            return false;
        }
    }
    return true;
}

long long mulmod(long long a,long long temp, long long p) {
	__int128 x = a;
	__int128 y=temp;
	return (y*x)%p;
}


bool Miller(long long p,int iteration){
    if(p<2){
        return false;
    }
    if(p!=2 && p%2==0){
        return false;
    }
    long long s=p-1;
    while(s%2==0){
        s/=2;
    }
    for(int i=0;i<iteration;i++){
        long long a=rand()%(p-1)+1,temp=s;
        long long mod=modulo(a,temp,p);
        while(temp!=p-1 && mod!=1 && mod!=p-1){
            mod=mulmod(mod,mod,p);
            temp *= 2;
        }
        if(mod!=p-1 && temp%2==0){
            return false;
        }
    }
    return true;
}

bool odd(ll a) {
  ll f= sqrt(a);
  if (f*f == a) return true;
  else return false;
}


int main() {
  ll t, n,q, dist=0, f, k,fl=1, p=1e9+7, people=0;
  cin >> n >> q;
  for (int i=0; i<q; i++) {
    cin >> t >> f >> k;
    if ((t==1) and Miller(f+k,20)) {
      dist = (dist + abs(f-fl))%p;
      fl = f;
      people += k;
    }
    if ((t==2) and odd(f+k)) {
      dist = (dist + abs(f-fl))%p;
      fl = f;
      people -= k;
    }
  }
  cout << dist<<" "<< people<<endl;
  return 0;
}
