#include <stdio.h>
#include <stdlib.h>
#include <algorithm>

using namespace std;

#define NMAX 333

int a[NMAX], f[2 * NMAX], fs[2 * NMAX];
int N, M;

void ReadInput() {
	scanf("%d %d", &N, &M);
	for (int i = 0; i < N; i++) scanf("%d", &a[i]);
	for (int i = 0; i < N + M - 1; i++) {
		scanf("%d", &f[i]);
		fs[i] = f[i];
	}
}

namespace maxflow {
#define MAXNODES 1000
#define MAXEDGES 100000
#define INF 1000000000

int startein[MAXNODES], starteout[MAXNODES], vidx;
int ecap[MAXEDGES], eflow[MAXEDGES], ecost[MAXEDGES], ev1[MAXEDGES], ev2[MAXEDGES], nextein[MAXEDGES], nexteout[MAXEDGES];
int q[MAXNODES], visited[MAXNODES], dist[MAXNODES];
int nnodes, nedges, niter;

void InitEmptyGraph(int num_nodes) {
	if (num_nodes >= MAXNODES) exit(1);
	nnodes = num_nodes;
	nedges = 0;
	for (int i = 1; i <= nnodes; i++)
		startein[i] = starteout[i] = 0;
}

void AddDirectedEdge(int i, int j, int cap, int cost) {
	nedges++;
	if (nedges >= MAXEDGES) exit(2);
	ecap[nedges] = cap;
	eflow[nedges] = 0;
	ecost[nedges] = cost;
	ev1[nedges] = i;
	ev2[nedges] = j;
	nexteout[nedges] = starteout[i];
	nextein[nedges] = startein[j];
	starteout[i] = nedges;
	startein[j] = nedges;
}

int DFS(int i, int cap_to_D, int costmax) {
	if (dist[i] == 0) return cap_to_D;
	int eidx, flow_used = 0;
	for (eidx = startein[i]; eidx > 0 && flow_used < cap_to_D; eidx = nextein[eidx]) {
		if (ecost[eidx] > costmax) continue;
		if (eflow[eidx] < ecap[eidx] && visited[ev1[eidx]] == vidx && dist[ev1[eidx]] == dist[i] - 1) {
			int next_cap_to_D = ecap[eidx] - eflow[eidx];
			if (cap_to_D - flow_used < next_cap_to_D) next_cap_to_D = cap_to_D - flow_used;
			int flow_pushed = DFS(ev1[eidx], next_cap_to_D, costmax);
			flow_used += flow_pushed;
			eflow[eidx] += flow_pushed;
		}
	}
	for (eidx = starteout[i]; eidx > 0 && flow_used < cap_to_D; eidx = nexteout[eidx]) {
		if (ecost[eidx] > costmax) continue;
		if (eflow[eidx] > 0 && visited[ev2[eidx]] == vidx && dist[ev2[eidx]] == dist[i] - 1) {
			int next_cap_to_D = eflow[eidx];
			if (cap_to_D - flow_used < next_cap_to_D) next_cap_to_D = cap_to_D - flow_used;
			int flow_pushed = DFS(ev2[eidx], next_cap_to_D, costmax);
			flow_used += flow_pushed;
			eflow[eidx] -= flow_pushed;
		}
	}
	return flow_used;
}

int GetMaxFlow(int S, int D, int costmax) {
	int maxflow = 0, i, j, li, ls, eidx;

	vidx = niter = 0;
	for (i = 1; i <= nnodes; i++) visited[i] = 0;
	for (i = 1; i <= nedges; i++) eflow[i] = 0;

	while (1) {
		niter++;
		vidx++;
		q[li = ls = 0] = S;
		visited[S] = vidx;
		dist[S] = 0;
		while (li <= ls && visited[D] != vidx) {
			i = q[li++];
			for (eidx = starteout[i]; eidx > 0; eidx = nexteout[eidx]) {
				if (ecost[eidx] > costmax) continue;
				if (eflow[eidx] < ecap[eidx] && visited[ev2[eidx]] != vidx) {
					visited[ev2[eidx]] = vidx;
					dist[ev2[eidx]] = dist[i] + 1;
					ls++;
					q[ls] = ev2[eidx];
				}
			}
			for (eidx = startein[i]; eidx > 0; eidx = nextein[eidx]) {
				if (ecost[eidx] > costmax) continue;
				if (eflow[eidx] > 0 && visited[ev1[eidx]] != vidx) {
					visited[ev1[eidx]] = vidx;
					dist[ev1[eidx]] = dist[i] + 1;
					ls++;
					q[ls] = ev1[eidx];
				}
			}
		}		
		if (visited[D] != vidx) break;
		maxflow += DFS(D, INF, costmax);
	}
	
	return maxflow;
}

}

int Solve() {
	maxflow::InitEmptyGraph(2 * N + 2);
	for (int i = 0; i < N; i++) {
		maxflow::AddDirectedEdge(1, i + 2, 1, 0);
		maxflow::AddDirectedEdge(i + 2 + N, 2 * N + 2, 1, 0);
		for (int j = 0; j < N; j++)
			maxflow::AddDirectedEdge(i + 2, j + 2 + N, 1, f[j + a[i]]);
	}
	sort(fs, fs + N + M - 1);
	int li = 0, ls = N + M - 2, ans = fs[N + M - 2];
	while (li <= ls) {
		int mid = (li + ls) >> 1;
		if (maxflow::GetMaxFlow(1, 2 * N + 2, fs[mid]) == N) {
			ans = fs[mid];
			ls = mid - 1;
		} else li = mid + 1;
	}
	return ans;
}

int main() {
	//freopen("x.txt", "r", stdin);
	ReadInput();
	printf("%d\n", Solve());
	return 0;
}
