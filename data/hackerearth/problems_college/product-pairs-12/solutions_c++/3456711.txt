#include<stdio.h>
#include<iostream>
#include<vector>
#include<cstdlib>
#include<cstring>
#include<math.h>
#include<map>
#include<algorithm>
#include<queue>
#include<string>
#include<climits>
#include<bitset>
#include<set>
#include<functional>
 
using namespace std;
typedef long long int ll;
typedef unsigned long long int ull;
 
#ifdef _WIN32
    #define gx getchar
    #define px putchar
    #define ps putchar(' ')
    #define pn putchar('\n')
    #define DEBUG 1
#else
    #define gx getchar_unlocked
    #define px putchar_unlocked
    #define ps putchar_unlocked(' ')
    #define pn putchar_unlocked('\n')
    #define DEBUG 0
#endif
 
//input
void scan(int &n)
{
    int sign = 1;
    n = 0;
    char c = gx();
    while( c < '0' || c > '9' )
    {
        if( c == '-' ) sign = -1;
        c = gx();
    }
    while( c >= '0' && c <= '9' ) n = (n<<3) + (n<<1) + c - '0', c = gx();  n = n * sign;
}
void lscan(ll &n)
{
    int sign = 1;
    n = 0;
    char c = gx();
    while( c < '0' || c > '9' )
    {
        if( c == '-' )
        sign = -1;
        c = gx();
    }
    while( c >= '0' && c <= '9' ) n = (n<<3) + (n<<1) + c - '0', c = gx();  n = n * (ll)(sign);
}
int sscan(char a[])
{
    char c = gx();
    while(c==' ' || c=='\n') c=gx();
    int i=0;
    while(c!='\n')a[i++] = c,c=gx();
    a[i]=0;
    return i;
}
int wscan(char a[])
{
    char c = gx();
    while(c==' ' || c=='\n') c=gx();
    int i=0;
    while(c!='\n' && c!=' ')a[i++] = c,c=gx();
    a[i]=0;
    return i;
}
 
//output
void print(int n)
{
    if(n<0)
    {
        n=-n;
        px('-');
    }
    int i=10;
    char o[10];
    do{o[--i] = (n%10) + '0'; n/=10;}while(n);
    do{px(o[i]);}while(++i<10);
}
void lprint(ll n)
{
    if(n<0LL)
    {
        n=-n;
        px('-');
    }
    int i=21;
    char o[21];
    do{o[--i] = (n%10LL) + '0'; n/=10LL;}while(n);
    do{px(o[i]);}while(++i<21);
}
void sprint(const char a[])
{
    const char *p=a;
    while(*p)px(*p++);
}
 
 
ll po(ll a, ll b, ll m)
{
	ll x=1,y=a;
	while(b > 0)
	{
		if(b%2 == 1)
		{
			x=(x*y);
			if(x>m) x%=m;
		}
		y = (y*y);
		if(y>m) y%=m;
		b /= 2;
	}
	return x;
}
 
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;


    #include <bits/stdc++.h>
    
    int segtree[200010][3]={0};
    int curmake;
    void makesegment(int nodenow,int l, int r)
    {
      
        if(l==r)
        {
            segtree[nodenow][0]=0;
            segtree[nodenow][1]=-1;
            segtree[nodenow][2]=-1;
        }
        else
        {
            segtree[nodenow][1]=curmake;
            curmake++;
            makesegment(curmake-1,l,(l+r)/2);
            segtree[nodenow][2]=curmake;
            curmake++;
            makesegment(curmake-1,(l+r)/2+1,r);
            segtree[nodenow][0]=segtree[segtree[nodenow][1]][0]+segtree[segtree[nodenow][2]][0];
        }
      
       
    }
    int findsum(int at,int atl,int atr,int l,int r)
    {
       
        int a=0,b=0;
        if(atl==l  &&  atr==r)
            return segtree[at][0];
        if((atl+atr)/2>=l)
        a=findsum(segtree[at][1],atl,(atl+atr)/2,l,min(r,(atl+atr)/2));
        if((atl+atr)/2+1<=r)
        b=findsum(segtree[at][2],(atl+atr)/2+1,atr,max(l,(atl+atr)/2+1),r);
     
        return (a+b);
    }
    void makechange(int at,int atl,int atr,int change,int nodeno)
    {
        segtree[at][0]+=change;
        if(atl==atr && atl==nodeno)
            return;
        if((atl+atr)/2>=nodeno)
        {
            makechange(segtree[at][1],atl,(atl+atr)/2,change,nodeno);
        }
        else if((atl+atr)/2+1<=nodeno)
        {
            makechange(segtree[at][2],(atl+atr)/2+1,atr,change,nodeno);
        }
    }
    int main()
    {
    	ios::sync_with_stdio(false);
        int i,n,d=0,md=0;
        int deg[100]={0};
        
        
        long long K,ans=0;
        cin>>n>>K;
        vector<int> adjlist[100001];
        assert(1<=n && n<=100000 && 1<=K && K<=10000000000ll);
       
      
     
        curmake=1;
        makesegment(0,0,n);
        
        
       	int ischild[100001]={0};
        for(i=0;i<n-1;i++)
        {
        	int a,b;
        	cin>>a>>b;
    	    assert(1<=a && a<=n && 1<=b && b<=n);
    		//cout<<a<<" "<<b<<" in "<<" "<<n<<endl;
        	
        	ischild[b]=1;
        	adjlist[a].push_back(b);
      
        }
        
        for(i=1;i<=n;i++)
        	if(ischild[i]==0)
        		break;
        int done[1000001]={0};
        stack<pair<int,int> > s;
        s.push(pair<int,int>(0,i));
        while(s.size()!=0)
        {
            pair<int,int> atpair=s.top();
            s.pop();
            int at=atpair.second;
            if(atpair.first==1)
            {
          
                 makechange(0,0,n,-1,at);
    	         md=max(md,d);
    	         d--;
            }
            else
            {
         
                assert(done[at]==0);
                done[at]=1;
    	        d++;
    	        long long tar=K/at;	
    	        ans+=(findsum(0,0,n,0,min(tar,(long long)n)));	     
    	        makechange(0,0,n,1,at);
    	        vector<int>::iterator it=adjlist[at].begin();	      
    	        deg[adjlist[at].size()+1]++;
    	        s.push(pair<int,int>(1,at));
    	        while(it!=adjlist[at].end())
    	        {
    		        s.push(pair<int,int>(0,*it));
    		        it++;
    	        }
    	 
    	    }
    	   
        }
       cout<<ans<<endl;
      /* cout<<"n is "<<n<<"max depth is "<<md<<endl;
        cout<<"Nodes with degree :"<<endl;
        for(i=0;i<=10;i++)
            cout<<i<<":"<<deg[i]<<endl;*/
        return 0;
    }

