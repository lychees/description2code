/*    ironstark    */
#include<bits/stdc++.h>
#define pii pair<long long,long long>
#define fi first
#define se second
#define mp make_pair
#define vpi vector< pii >
#define pb push_back
#define ll long long int
#define mod 1000000007
#define gcd(a,b) __gcd(a,b)
#define sf(n) scanf("%lld",&(n))
#define pf(n) printf("%lld\n",(n))
#define setbits(n) __builtin_popcount((n))
#define pq priority_queue
using namespace std;
ll BIT[300005],n;
ll arr[300005];
bool is_round[300005]={0};
ll power(ll a,ll b)
{
    if(b==0)
        return 1;
    else if(b==1)
        return a;
    else if(b%2==0)
    {
        ll x=power(a,b/2);
        return x*x;
    }
    else
        return a*power(a,b-1);
}
void update(ll idx,ll val)
{
    while(idx<=n)
    {
        BIT[idx]+=val;
        idx+=idx&-idx;
    }
}
ll query(ll idx)
{
    ll sum=0;
    while(idx>0)
    {
        sum+=BIT[idx];
        idx-=idx&-idx;
    }
    return sum;
}
ll count_dig(ll n)
{
    ll co=0;
    while(n>0)
    {
        n/=10;
        co++;
    }
    return co;
}
int main()
{
    ll q;
    cin>>n>>q;

    for(ll i=1;i<=n;i++)
    {
        cin>>arr[i];
        if(arr[i]<0)
            continue;
        ll s=count_dig(arr[i]);
        if(arr[i]%10==(arr[i]/power(10,s-1)))
            {
                is_round[i]=true;
                update(i,1);
            }
    }
    while(q--)
    {
        ll a,b,c;
        cin>>a>>b>>c;
        if(a==1)
        {
            ll x=query(c);
            ll y=query(b-1);
            cout<<(x-y)<<endl;
        }
        else
        {
            if(c<0 && is_round[b]==true)
                update(b,-1);
            else if((c%10!=c/power(10,count_dig(c)-1))&&(is_round[b]==true))
                update(b,-1);
            else if((is_round[b]==false)&&(c%10==c/power(10,count_dig(c)-1)))
            {
                update(b,1);
                is_round[b]=true;
            }
        }
    }
}
