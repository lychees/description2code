#include <bits/stdc++.h>
using namespace std;
typedef pair <int,int> PII;
typedef vector <int> VI; 
typedef vector < PII > VPII;
int main()
{
    int tc;
    scanf("%d",&tc);
		while (tc--)
    {
        int m, n;
        scanf("%d %d",&m, &n);
		VPII segm;
        for(int i=0;i<n;i++)
        {
            int st, en;
            scanf("%d %d",&st, &en);
            // printf("st and en :%d %d\n",st, en);
            if(st<=en)
            {
                segm.push_back(make_pair(st,en));
                // pair<int,int> sm = make_pair(st,en);
                // cout <<"pair 1: "<<sm.first<<" "<<sm.second<<'\n';
                segm.push_back(make_pair(st+m,en+m));
                // pair<int,int> cm = make_pair(st+m,en+m);
                // cout <<"pair 2: "<< cm.first<<" "<<cm.second<<'\n';
            }
            else
            {
                segm.push_back(make_pair(st,en+m));
                // pair<int,int> xm = make_pair(st,en);
                // cout <<"pair 3: "<<xm.first<<" "<<xm.second<<'\n';
            }
        }
        // cout << segm;
        // for (vector<char>::const_iterator z = segm.begin(); z != segm.end(); ++z)
        //     cout << *z << ' ';

		if(n>m)
        {
            puts("NO");
            continue;
        }
        // for(int i = 0; i < segm.size(); i++)
        // {
        //      cout << segm[i].first << ", " << segm[i].second << endl;
        // }
        sort(segm.begin(),segm.end());
        // cout << "after sor"<<endl;
        // for(int i = 0; i < segm.size(); i++)
        // {
        //      cout << segm[i].first << ", " << segm[i].second << endl;
        // }
		int T=0;
        int i=0;
        set < PII > que;
        bool ok = true;
        while(true)
        {
            if(que.empty())
            {
                // cout << "empty";
                // getchar();
                if(i==segm.size())
                    break;
                else
                    T = segm[i].first;
            }
            
            while(i<segm.size() && segm[i].first==T)
            {
                que.insert(make_pair(segm[i].second,i));
                i++;
            }
            
			int ind = que.begin()->second;
            que.erase(que.begin());
            
			if(!(T>=segm[ind].first && T<=segm[ind].second))
            {
                ok = false;
                break;
            }
            T++;
        }
        puts(ok?"YES":"NO");
    }
}