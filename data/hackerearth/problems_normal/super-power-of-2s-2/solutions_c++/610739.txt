#include<stdio.h>
#include<limits.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<iostream>
#include<vector>
#include<assert.h>
#include <map>
#include<set>
#include<stack>
#include<queue>
#include<algorithm>
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define sz(x) ((int)(x).size())
#define F first
#define S second
#define rep(i,b) for(i=0;i<b;i++)
#define rep1(i,b) for(i=1;i<=b;i++)
#define mod 1000000007
#define pi(n) printf("%d",n)
#define pin(n) printf("%d\n",n)
#define piw(n) printf("%d ",n)
#define pll(n) printf("%lld",n)
#define plln(n) printf("%lld\n",n)
#define pllw(n) printf("%lld ",n)
#define sll(n) scanf("%lld",&n)
#define ss(s) scanf("%s",s)
#define ps(s) printf("%s",s)
#define psn(s) printf("%s\n",s)
#define psw(s) printf("%s ",s)
#define si(n) scanf("%d",&n)
#define pn printf("\n")
#define pw printf(" ")

using namespace std;
#define MAXN 200009
int par[999];
long long int fck1[3*MAXN];
long long int a[MAXN];
long long int fck2[3*MAXN];
int parent(int x)
{
    if(par[x]==x)
    return x;
    return par[x]=parent(par[x]);
}
int c;
int rnk[50008];
void uni(int x,int y)
{
    x=parent(x);
    y=parent(y);
    if(x==y)
    return;
    c--;
    if(rnk[x]<rnk[y])
    {
        par[x]=y;
    }
    else
    {
        par[y]=x;
        if(rnk[x]==rnk[y])
            rnk[x]++;
    }
}
long long int powe[100006];
long long int poo(long long int a, long long int b)
{assert(a==2);//assert(b<=60);
	if(b<=0){return 1;}
return powe[b];
}void build(int node,int st,int e)
{
if(st==e)
{
fck1[node]=a[st];
return;
}
int mi=(st+e)/2;
build(2*node,st,mi);
build(2*node+1,mi+1,e);
fck1[node]=(fck1[2*node]+fck1[2*node+1])%mod;
}
void update(int node,int st,int e,int i,int j)
{
    if(j<st||i>e)
    {
if(fck2[node]==0)
return;
        long long int valle=(2LL*fck2[node])%mod;
    long long int z=poo(2,e-st+1);
    z=(z-1+mod)%mod;
    valle=(valle*1LL*z)%mod;
    fck1[node]=(fck1[node]+valle)%mod;
        
    if(st<e)
        {
            fck2[2*node]=(fck2[2*node]+fck2[node])%mod;
            int mi=(st+e)/2;
        long long int valle=(poo(2,mi-st+1)*1LL*fck2[node])%mod;
            fck2[2*node+1]=(fck2[2*node+1]+valle)%mod;
        }
        fck2[node]=0;
        return;
    }
    if(st>=i&&e<=j)
    {
        fck2[node]=(fck2[node]+poo(2,st-i))%mod;
    long long int valle=2LL*fck2[node]%mod;
    long long int z=poo(2,e-st+1);
    z=(z-1+mod)%mod;
    valle=(valle*1LL*z)%mod;
    fck1[node]=(fck1[node]+valle)%mod;
         
    if(st<e)
        {
            fck2[2*node]=(fck2[2*node]+fck2[node])%mod;
            int mi=(st+e)/2;
        long long int valle=(poo(2,mi-st+1)*1LL*fck2[node])%mod;
            fck2[2*node+1]=(fck2[2*node+1]+valle)%mod;
}
        fck2[node]=0;
        return;
    }
    fck2[2*node]+=fck2[node];
    fck2[2*node]%=mod;
    int mi=(st+e)/2;
    long long int valle=(poo(2,mi-st+1)*1LL*fck2[node])%mod;
    fck2[2*node+1]=(fck2[2*node+1]+valle)%mod;
    fck2[node]=0;
    
    int mid=(st+e)/2;
    update(2*node,st,mid,i,j);
    update(2*node+1,mid+1,e,i,j);
    fck1[node]=(fck1[2*node]+fck1[2*node+1])%mod;
}
long long query(int node,int st,int e,int i,int j)
{
    if(j<st||i>e)
    {
        long long int valle=2LL*fck2[node]%mod;
    long long int z=poo(2,e-st+1);
    z=(z-1+mod)%mod;
    valle=(valle*1LL*z)%mod;
    fck1[node]=(fck1[node]+valle)%mod;
        
    if(st<e)
        {
            fck2[2*node]=(fck2[2*node]+fck2[node])%mod;
            int mi=(st+e)/2;
            long long int valle=(poo(2,mi-st+1)*1LL*fck2[node])%mod;
            fck2[2*node+1]=(fck2[2*node+1]+valle)%mod;
        }
        fck2[node]=0;
        return 0LL;
    }
    if(st>=i&&e<=j)
    {
    long long int valle=2LL*fck2[node]%mod;
    long long int z=poo(2,e-st+1);
    z=(z-1+mod)%mod;
    valle=(valle*1LL*z)%mod;
    fck1[node]=(fck1[node]+valle)%mod;
                
    if(st<e)
        {
            fck2[2*node]=(fck2[2*node]+fck2[node])%mod;
            int mi=(st+e)/2;
            long long int valle=(poo(2,mi-st+1)*1LL*fck2[node])%mod;
            fck2[2*node+1]=(fck2[2*node+1]+valle)%mod;
        }
        fck2[node]=0;        
    return fck1[node];
    }
long long int valle=(2LL*fck2[node])%mod;
long long int z=poo(2,e-st+1);
z=(z-1+mod)%mod;
valle=(valle*1LL*z)%mod;
fck1[node]=(fck1[node]+valle)%mod;
    fck2[2*node]+=fck2[node];
    fck2[2*node]%=mod;
    int mi=(st+e)/2;
    valle=(poo(2,mi-st+1)*1LL*fck2[node])%mod;
    fck2[2*node+1]=(fck2[2*node+1]+valle)%mod;
    fck2[node]=0; 
    
   int mid=(st+e)/2;
    return (query(2*node,st,mid,i,j)+query(2*node+1,mid+1,e,i,j))%mod;
}
void allo(){  memset(fck1,0,sizeof(fck1));
        memset(fck2,0,sizeof(fck2));}
int main()
{
    int t,m,n;
    int i,j,k,p;
    int q,valle;
allo();long long int chd=2;
      for(i=1;i<=100001;i++){powe[i]=chd;chd=(chd*2)%mod;}
        si(n);
    rep(i,n){
        si(a[i]);}
    build(1,0,n-1);
        si(k);
        rep(i,k)
        {
            si(j);
            if(!j)
            {
                si(p);si(q);
                update(1,0,n-1,p-1,q-1);
                
            }
            else
            {
                si(p);si(q);
                pll(query(1,0,n-1,p-1,q-1)%mod);pn;
            }
        }
    
    return 0;
}