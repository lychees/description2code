#include <iostream>
#include <cstdio>
#include <vector>
#include <set>

using namespace std;

typedef long long LL;

int n, m;
vector<int> G[303][2];
LL D[303][303][2];
LL C[303][303][2];

struct State {
        int start, end, open;
        State(int start_, int end_, int open_) {
                start = start_; end = end_; open = open_;
        }
        friend bool operator< (const State& a, const State& b) {
          if (D[a.start][a.end][a.open] < D[b.start][b.end][b.open]) return true;
          if (D[a.start][a.end][a.open] > D[b.start][b.end][b.open]) return false;
          if (a.start < b.start) return true;
          if (a.start > b.start) return false;
          if (a.end < b.end) return true;
          if (a.end > b.end) return false;
          return a.open < b.open;
        }
        friend bool operator==(const State& a, const State& b) {
                return (a.start == b.start && a.end == b.end && a.open == b.open);
        }
};
set<State> Q;

inline void update(int start, int end, LL cost, int open) {
  if (D[start][end][open] == -1 || D[start][end][open] > cost) {
    Q.erase(State(start, end, open));
    D[start][end][open] = cost;
    Q.insert(State(start, end, open));
  }
}
int main() {
  scanf("%d %d", &n, &m);
  for (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) {
    C[i][j][0] = -1; C[i][j][1] = -1;
  }
  while (m--) {
    int a, b, w;
    char c;
    scanf("%d %d %d %c", &a, &b, &w, &c);
    int id = 0;
    if (c == ')') id = 1;
    G[a][id].push_back(b);
    C[a][b][0] = w;
    C[a][b][1] = id;
  }
  for (int i = 1; i <= n; ++i)
  for (int j = 1; j <= n; ++j) {
    if (i == j) {
        D[i][j][0] = 0;
        D[i][j][1] = -1;
    }
    else D[i][j][0] = D[i][j][1] = -1;
  }
  for (int start = 1; start <= n; ++start) {
        Q.insert(State(start, start, 0));
  }
  while (!Q.empty()) {
    auto t = *Q.begin();
    Q.erase(t);
    int start = t.start;
    int end = t.end;
    int open = t.open;
    LL cost = D[start][end][open];
    if (open == 0) {
        for (int new_start = 1; new_start <= n; ++new_start)
            if (C[new_start][start][0] != -1 && C[new_start][start][1] == 0) {
                LL new_cost = cost + C[new_start][start][0];
                update(new_start, end, new_cost, 1);
            }
    } else {
        for (auto it : G[end][1]) {
          int new_end = it;
          LL new_cost = cost + C[end][new_end][0];
          update(start, new_end, new_cost, 0);
      }
    }

    if (open == 0) {
      // extend
      for (int new_end = 1; new_end <= n; ++new_end) if (D[end][new_end][0] > 0) {
        LL new_cost = D[start][end][0] + D[end][new_end][0];
        update(start, new_end, new_cost, 0);
      }
      // prepend
      for (int new_start = 1; new_start <= n; ++new_start) if (D[new_start][start][0] > 0) {
          LL new_cost = D[new_start][start][0] + D[start][end][0];
          update(new_start, end, new_cost, open);
      }
    }
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) printf("%lld ", D[i][j][0]);
    printf("\n");
  }
  return 0;
}

