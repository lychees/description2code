//Karol Kaszuba
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <unordered_map>
#include <unordered_set>

using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef double D;
typedef long double LD;
typedef vector<PII> VII;

#define FOR(i,x,y) for(int i=(x);i<=(y);++i)
#define REP(i,x) FOR(i,0,(x)-1)
#define FORD(i,x,y) for(int i=(x);i>=(y);--i)
#define VAR(i,c) __typeof(c) i=(c)
#define FORE(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)

#define SIZE(c) (int)((c).size())
#define ALL(c) (c).begin(),(c).end()
#define PB push_back
#define IN insert
#define ER erase
#define MP make_pair
#define ST first
#define ND second
#define IOSYNC ios_base::sync_with_stdio(0)

const int INF = 1000000001;
/* maksymalne najdrozsze skojarzenie w pelnym grafie dwudzielnym o            */
/* rownolicznych zbiorach wierzcholkow, argumenty to macierz z wagami         */
/* i liczba wierzcholkow, zwracany wynik to wektor ktory mowi co jest z czym  */
/* skojarzone.                                                                */
/* Jak chcemy najtansze to bierzemy wszystko z minusem, jak gdzies nie ma     */
/* krawedzi to dajemy -INF, przy zalozeniu, ze: n * |waga| < INF              */

VI Hungarian(int **w,int n){
  int lx[n],ly[n],skojx[n],skojy[n];
  int markx[n],marky[n],slack[n],par[n],q[n];
  REP(i,n){ skojx[i]=skojy[i]=-1; ly[i]=0; lx[i]=*max_element(w[i], w[i]+n); }
  REP(k,n){
    int v=-1,qb=0,qe=0;
    REP(i,n){ marky[i]=markx[i]=0; slack[i]=-1; if (skojx[i]==-1) q[qe++]=i;}
    while (v==-1){
      while (qb<qe){
        int i=q[qb++]; markx[i]=1;
        REP(j,n)
          if (!marky[j] && (slack[j]==-1 || slack[j]>lx[i]+ly[j]-w[i][j])){
            if ((slack[j] = lx[ par[j]=i ]+ly[j]-w[i][j]) == 0){
              marky[j]=1;
              if (skojy[j]!=-1) q[qe++]=skojy[j]; else {v=j; goto koniec;}
            }
          }
      }
      int x=-1; REP(i,n) if (!marky[i] && (x==-1 || slack[i] < x)) x=slack[i];
      REP(i,n){
        if (markx[i]) lx[i]-=x; 
        if (marky[i]) ly[i]+=x; else
          if ((slack[i] -= x) == 0){
            marky[i]=1; if (skojy[i] != -1) q[qe++]=skojy[i]; else v=i;
          }
      }
    }
koniec:
    while (v!=-1){int y=skojx[par[v]]; skojx[par[v]]=v; skojy[v]=par[v]; v=y;}
  }
  return VI(skojx,skojx+n);
}

void jebaj()
{
	int n;
	cin >> n;
	int *w[n];
	REP(i,n) w[i] = new int[n];
	REP(i, n)
		REP(j, n)
			cin >> w[i][j];
	//w[0][0] = 3; w[0][1] = 9; w[0][2] = 108;
	//w[1][0] = -INF; w[1][1] = -INF; w[1][2] = 0;
	//w[2][0] = -INF; w[2][1] = -INF; w[2][2] = -1;
	
	VI skoj = Hungarian(w,n);
	LL res = 0LL; REP(i,n) if (w[i][skoj[i]] != -INF) res += w[i][skoj[i]];
	cout << res << "\n";
	REP(i,n) delete []w[i];
}

int main()
{
	IOSYNC;
	int t;
	//t = 1;
	cin >> t;
	
	REP(i, t) 
	{
		jebaj();
	}
}
