#include <bits/stdc++.h>


#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define sz(x) ((int)(x).size())
#define pii pair<int, int>
#define pn(n) printf("%d\n",n)
#define sn(n) scanf("%d",&n)
#define tr(container , it) for(typeof(container.begin()) it=container.begin() ; it!=container.end() ; it++)

#define FORN(i, n) for(i = 0; i < n; i++)
#define FORAB(i,a,b) for(i = a; i <= b; i++)

using namespace std;
#define LL long long int
#define gcd(a,b) __gcd(a,b)

LL ao,bo,co,d,ans,g,y,bINVT;

#define SIZE 33000
bool Prime[SIZE+1]={false};
int YOLO[SIZE],nYOLO=0;

void SIEVE()
{
	int i,j,it,a;
	int QQ = sqrt(SIZE);
	for(i=3;i<=QQ;i+=2)
	{
		if(Prime[i]==false) 
		{
			a=2*i;
			for(j=i*i;j<=SIZE;j+=a) Prime[j]=true;
		}
	}

	YOLO[++nYOLO]=2;
	for(i=3;i<=SIZE;i+=2)
	{
		if(Prime[i]==false) YOLO[++nYOLO]=i;
	}
	YOLO[nYOLO+1] = 1e9 + 1e3;
}

long long int power(long long int k,long long int n,long long int mod)
{
//k^n
	long long int x=k,y=1;
	while(n>0)
	{
		if(n%2==1)
		{
			y=(y*x)%mod;
		}
		x=(x*x)%mod;
		n/=2;
	}
	return y;
}

int INVT(LL b,LL a){
	LL m = a,mod=a;
	int p=1;
	int tempvar=0;
	while ( p<=nYOLO){
		tempvar++;
		if ( a % YOLO[p] ==0){
			m /=YOLO[p];
			m *= (YOLO[p]-1);
			while ( a % YOLO[p]==0 ) a/=YOLO[p];
		}
		p++;
		tempvar++;
		if ( YOLO[p] > a) break;
	}
	if ( a>1){
		m /= a;
		m *= a-1;
	}
	return power ( b, m-1, mod);
}

int main()
{
	SIEVE();
	int test;
	sn(test);
	while ( test-- ){
		long long int a,b,c;
		cin >> c>> a>> b;
		if ( c % a==0){
			cout << c/a<<endl;
			continue;
		}
		ao = a;
		bo = b;
		co = c;

		d = (a - c%a) % a;
		g = gcd( b, a);
		if ( d % g != 0){
			cout << -1<<endl;
			continue;
		}
		else{
			b/=g;
			d/=g;
			a/=g;
			bINVT = INVT(b,a);
			y = (d * bINVT ) % a;
			ans = y + ( bo * y +  co) /ao;
			cout << ans << endl;
		}
	}
	return 0;
}

