// @BEGIN OF SOURCE CODE
#include <bits/stdc++.h>
#include <sstream>
#include <set>
#include <map>
#include <vector>
#include <bitset>
#include <functional>

using namespace std;

typedef vector<int> vi;typedef vector<vi> vvi;typedef pair<int,int> ii;
#define sz(a) int((a).size())
#define pb push_back
#define ll long long
#define MOD 1000000007
#define mod 100005
#define unsigned32 4294967295
#define PrimeRange 1000006
bool Pvisit[PrimeRange];vector<int> Primes;
bool isPrime(int N){
	for(int i=2;i<=sqrt(N);i++)if(N%i == 0)return false; return true;
}
void mark(int N)
{	for(int i= N*N; i<PrimeRange; i += N)Pvisit[i] = false;}
void sieve()
{	memset(Pvisit,true,PrimeRange);	Primes.pb(2);mark(2);
	for(int i=3; i<=sqrt(PrimeRange); i += 2)if(Pvisit[i] == true)Primes.pb(i),mark(i);
	for(int i=1001;i<PrimeRange;i += 2)if(isPrime(i))Primes.pb(i),Pvisit[i]=true;
}

ll bfs(vector<vector<ll> >&G,bool vis[],ll s, ll d)
{
	ll level[G.size()] , node , l = 0;
	memset(level,INT_MAX,sizeof(level));
	
	level[s] = 0;
	
	queue<ll> Q;
	Q.push(s);
	Q.push(-1);
	
	while(!Q.empty())
	{
		node = Q.front(); Q.pop();
		
		if(node == -1)
		{
			if(Q.empty())
				break;
			else
			{
				l++;
				Q.push(-1);		
			}		
		}
		
		else
		{
			level[node] = l;
			for(int i=0;i<G[node].size();i++)
			{
				if(vis[G[node][i]] == false)
				{
					vis[G[node][i]] = true;
					Q.push(G[node][i]);		
				}		
			}		
		}		
		
	}
	
	return level[G.size()-1];
	
}


int main()
{
 	ios :: sync_with_stdio (false);
	//freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
	//sieve();
	ll T;
	cin>>T;
	while(T--)
	{
		ll N,M,x,y;
		cin>>N>>M;
		vector<vector<ll> > G(N);
		
		for(int i=0;i<M;i++)
		{
			cin>>x>>y;
			x--; y--;
			G[x].pb(y);
			G[y].pb(x);
		}
		bool vis[N];
		memset(vis,false,sizeof(vis));
		
		ll cnt = INT_MAX;
		cnt = bfs(G,vis,0,N-1);
		cout<<cnt<<endl;
	}

	return 0;
}
// @END OF SOURCE CODE
