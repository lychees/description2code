#include <algorithm>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <vector>
using namespace std;

#define foreach(e, x)                                                          \
  for (__typeof((x).begin()) e = (x).begin(); e != (x).end(); ++e)

typedef long long int64;

const int MAX_N = (int)1e6 + 10;

int n, m;

struct Node {
  int l, r;
  Node(int l, int r) : l(l), r(r) {}
  int size() const {
    return l == 0 ? r - 1 : r == n + 1 ? r - l - 1 : (r - l) / 2;
  }
  bool operator<(const Node &o) const {
    return size() > o.size() || size() == o.size() && l < o.l;
  }
};

int p[MAX_N];
set<Node> events;
set<int> cars;

int main() {
  scanf("%d%d", &n, &m);
  events.insert(Node(0, n + 1));
  cars.insert(0);
  cars.insert(n + 1);
  while (m--) {
    int ctrl, x;
    scanf("%d%d", &ctrl, &x);
    if (ctrl == 1) {
      Node t = *events.begin();
      events.erase(events.begin());
      p[x] = t.l == 0 ? 1 : t.r == n + 1 ? n : t.l + t.size();
      int u = *--cars.lower_bound(p[x]);
      int v = *cars.lower_bound(p[x]);
      cars.insert(p[x]);
      events.insert(Node(u, p[x]));
      events.insert(Node(p[x], v));
      printf("%d\n", p[x]);
    } else {
      cars.erase(p[x]);
      int u = *--cars.lower_bound(p[x]);
      int v = *cars.lower_bound(p[x]);
      events.erase(Node(u, p[x]));
      events.erase(Node(p[x], v));
      events.insert(Node(u, v));
    }
  }
}
