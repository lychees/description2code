#include <bits/stdc++.h>
 
using namespace std;
#define MP make_pair
#define PB push_back
#define LL long long
#define st first
#define nd second
#define FI st
#define SE nd
#define FOR(i,a,b) for(int i = (a); i <= (b); i++)
#define RE(i,n) FOR(i,1,n)
#define R(i,n) FOR(i,0,(int)(n)-1)
#define REP(i,n) R(i,n)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#define PII pair<int,int>
#define VI vector<int>
template<class C> void mini(C&a4, C b4){a4=min(a4,b4);}
template<class C> void maxi(C&a4, C b4){a4=max(a4,b4);}
 
template<class TH> void _dbg(const char *sdbg, TH h){cerr<<sdbg<<"="<<h<<"\n";}
template<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a){
  while(*sdbg!=',')cerr<<*sdbg++;cerr<<"="<<h;_dbg(sdbg+1,a...);
}
 
#ifdef LOCAL
#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)
#define debugv(C) {for(auto&c:C)cerr<<c<<",";cerr<<endl;}
#else
#define debug(...) (__VA_ARGS__)
#define debugv(C) {}
#define cerr if(0)cout
#endif
 
const int MAX = 300000;
int N,Q;
int t[MAX];
vector<int> d[MAX];
int depth[MAX];
int parent[18][MAX];
int pre[MAX],post[MAX],ord;
void dfs(int nr,int oj){
  debug(nr, oj, depth[nr]);
  parent[0][nr] = oj;
  static int x = 0;
  x++;
  //cout << x << "\n";
  pre[nr] = ord;
  ord++;
  for(int ak:d[nr]){
    if(ak!=oj){
      depth[ak] = depth[nr]+1;
      dfs(ak,nr);
    }
  }
  post[nr] = ord-1;
}
 
void preproc(){
  for(int l = 1; l < 18; l++){
    for(int v = 1; v <= N; v++){
      parent[l][v] = parent[l-1][parent[l-1][v]];
    }
  }
}
 
int first_child(int par, int ch){
  int diff = depth[ch] - depth[par] - 1;
  debug(diff, par, ch);
  if(diff < 0){ cout << par << " " << ch << endl; }
  assert(diff >= 0);
  for(int i = 17; i >= 0; i--){
    if(diff & (1<<i)) ch = parent[i][ch];
  }
  return ch;
}
 
 
const int Height = 20,
          MaxNum = (1<<(Height)),
          //Height = 19,
          MaxSize = 1.4e7,
          OuterBase = (1<<17),
          OuterSize = OuterBase*2;
          //OuterBase = (1<<17),
          //OuterSize = (1<<18);
 
struct NumTree {
  int left, right;
  int count, setValue;
};
 
NumTree tree[MaxSize];
int treeSize = OuterSize;
 
int coef;
void add_tree_rec(int id, int value, int minVal, int maxVal, int h){
  debug("add_tree_rec", id, value, minVal, maxVal, h);
  //if(id >= MaxSize) cout << id << endl;
  assert(id < MaxSize);
  tree[id].count += coef;
  debug(tree[id].count);
  if(!tree[id].left && !tree[id].right){
    if(coef > 0 && tree[id].setValue == 0){
      tree[id].setValue = value;
      return;
    }
    if(coef < 0 && tree[id].setValue != 0){
      assert(tree[id].setValue == value);
      tree[id].setValue = 0;
      return;
    }
  }
  if(h == 0){ tree[id].setValue = value; return; }
 
  int mid = (minVal + maxVal) / 2;
  if(tree[id].setValue != 0){
    int v = tree[id].setValue;
    if(v <= mid){
      tree[id].left = treeSize++;
      tree[tree[id].left].setValue = v;
      tree[tree[id].left].count += coef;
    } else {
      tree[id].right = treeSize++;
      tree[tree[id].right].setValue = v;
      tree[tree[id].right].count += coef;
    }
    tree[id].setValue = 0;
  }
 
  if(value <= mid){
    if(tree[id].left == 0){
      tree[id].left = treeSize++;
    }
    add_tree_rec(tree[id].left, value, minVal, mid, h-1);
  } else {
    if(tree[id].right == 0){
      tree[id].right = treeSize++;
    }
    add_tree_rec(tree[id].right, value, mid+1, maxVal, h-1);
  }
}
 
void add_tree(int id, int value){
  coef = 1;
  add_tree_rec(id, value, 0, MaxNum-1, Height);
}
 
void del_tree(int id, int value){
  coef = -1;
  add_tree_rec(id, value, 0, MaxNum-1, Height);
}
 
 
void add_at_pos(int pos, int value){
  debug("add", pos, value);
  pos += OuterBase;
  while(pos > 0){
    add_tree(pos, value);
    pos /= 2;
  }
}
 
void del_at_pos(int pos, int value){
  debug("del", pos, value);
  pos += OuterBase;
  while(pos > 0){
    del_tree(pos, value);
    pos /= 2;
  }
}
 
bool is_parent(int par, int ch){
  return (pre[par] < pre[ch]) && (post[ch] <= post[par]);
}
 
 
int main(){
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout<<fixed<<setprecision(10);
  cin >> N;
  R(i,N-1){
    int a,b;
    cin >> a >> b;
    d[a].PB(b);
    d[b].PB(a);
  }
  dfs(1,0);
  preproc();
  for(int i = 1; i <= N; i++){
    cin >> t[i];
    add_at_pos(pre[i], t[i]);
    debug(i, pre[i], t[i]);
  }
  cin >> Q;
  R(i,Q){
    int type;
    cin >> type;
    if(type == 1){
      int vert, nvalue;
      cin >> vert >> nvalue;
      del_at_pos(pre[vert], t[vert]);
      t[vert] = nvalue;
      add_at_pos(pre[vert], t[vert]);
    }else{
      vector<pair<int,int>> intvs;
      int K, U, V;
      cin >> K >> U >> V;
      if(U == V){
        intvs.emplace_back(0, N-1);
      } else if(is_parent(U, V)){
        int W = first_child(U, V);
        debug(W);
        if(pre[W] > 0) intvs.emplace_back(0, pre[W]-1);
        if(post[W] < N-1) intvs.emplace_back(post[W]+1, N-1);
      } else {
        intvs.emplace_back(pre[U], post[U]);
      }
     
      vector<int> baseIntvs;
     
      debug(11111);
     
      for(auto& I : intvs){
        debug(I.first, I.second);
        int L = I.first+OuterBase, R = I.second+OuterBase;
        baseIntvs.push_back(L);
        if(L != R) baseIntvs.push_back(R);
       
        while(L/2 != R/2){
          if(L % 2 == 0) baseIntvs.push_back(L+1);
          if(R % 2 == 1) baseIntvs.push_back(R-1);
          L /= 2; R /= 2;
        }
      }
     
      debugv(baseIntvs);
      int result = 0;
      for(int height = Height-1; height >= 0; height--){
        vector<int> leftIntvs, rightIntvs;
        int nextRes = result + (1<<height);
        for(int v : baseIntvs){
          if(tree[v].left) leftIntvs.push_back(tree[v].left);
          if(tree[v].right) rightIntvs.push_back(tree[v].right);
          if(tree[v].setValue){
            if(tree[v].setValue < nextRes){
              leftIntvs.push_back(v);
            } else {
              rightIntvs.push_back(v);
            }
          }
        }
        debugv(leftIntvs);
        int cnt = 0;
       
        for(int v : leftIntvs) cnt += tree[v].count;
       
        if(cnt >= K){
          baseIntvs = leftIntvs;          
        } else {
          K -= cnt;
          result += (1<<height);
          baseIntvs = rightIntvs;
        }
        debug(cnt, K, result);
        debugv(baseIntvs);
      }
     
      cout << result << endl;
    }
  }
 
  return 0;
}