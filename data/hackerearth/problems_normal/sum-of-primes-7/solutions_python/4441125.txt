from math import sqrt

def binarysearch(a,t):
    low=0
    high=len(a)-1
    while low<=high:
        mid=(low+high)/2
        if t==a[mid]:
            #print mid
            return [True,mid+1]
        elif t<a[mid]:
            high=mid-1
        else:
            low=mid+1
    
    if a[mid]<t:
        return [False,mid+1]
    else:
        return [False,mid]
    
def sieveOfEratosthenes(n):
    primes = range(3, n + 1, 2) # primes above 2 must be odd so start at three and increase by 2
    for base in xrange(len(primes)):
        if primes[base] is None:
            continue
        if primes[base] > sqrt(n): # stop at sqrt of n
            break

        for i in xrange(base + (base + 1) * primes[base], len(primes), primes[base]):
            primes[i] = None
    primes.insert(0,2)
    return filter(None, primes)

arr=sieveOfEratosthenes(1000000)



sumarr=[0]
add=0
for item in arr:
	add=add+item
	sumarr.append(add)

for _ in xrange(input()):
    a,b=map(int,raw_input().split())
    temp=0
    idx1=binarysearch(arr,a)
    idx2=binarysearch(arr,b)
    y=idx2
    x=idx1
    #print idx1
    #print idx2
    if idx1[0]==True:
    	
        x=idx1[1]-1
    else:
        x=idx1[1]
    if idx2==True:
        y=idx2[1]
    else:
        y=idx2[1]
        
    #print x
    #print y
    #print arr[x:y+1]
    temp=sumarr[y]-sumarr[x]
        
    print temp