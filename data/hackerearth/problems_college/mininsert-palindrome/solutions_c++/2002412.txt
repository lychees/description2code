#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

#define s(a) scanf("%d",&a)
#define p(a) printf("%d",a)
#define sp   printf(" ")
#define nl   printf("\n")

#define max(a,b) a>b?a:b
#define min(a,b) a>b?b:a

typedef long long ll;

int power(int a, int b)
{
	if(!b)return 1;
	if(b==1)return a;
	int tmp=power(a,b/2);
	if(b%2)return a*tmp*tmp;
	return tmp*tmp;
}

inline void ifast(int &x) 
{
    register int c = getchar_unlocked();
    x = 0;
    int neg = 0;
    for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());
    if(c=='-') {
        neg = 1;
        c = getchar_unlocked();
    }   
    for(; c>47 && c<58 ; c = getchar_unlocked()) {
        x = (x<<1) + (x<<3) + c - 48; 
    }   
    if(neg)
        x = -x; 
}

int lcs( char *X, char *Y, int m, int n )
{
   int L[n+1][n+1];
   int i, j;
 
   /* Following steps build L[m+1][n+1] in bottom up fashion. Note
      that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] */
   for (i=0; i<=m; i++)
   {
     for (j=0; j<=n; j++)
     {
       if (i == 0 || j == 0)
         L[i][j] = 0;
 
       else if (X[i-1] == Y[j-1])
         L[i][j] = L[i-1][j-1] + 1;
 
       else
         L[i][j] = max(L[i-1][j], L[i][j-1]);
     }
   }
 
   /* L[m][n] contains length of LCS for X[0..n-1] and Y[0..m-1] */
   return L[m][n];
}
 
// LCS based function to find minimum number of insersions
int findMinInsertionsLCS(char str[], int n)
{
   // Creata another string to store reverse of 'str'
   char rev[n+1];
   strcpy(rev, str);
   reverse(rev,rev+n);
 
   // The output is length of string minus length of lcs of
   // str and it reverse
   return (n - lcs(str, rev, n, n));
}

int main()
{
	int T;
	ifast(T);
	while(T--) {
		int n;
		ifast(n);
		char str[25];
		cin>>str;
		int cnt=findMinInsertionsLCS(str,n);
		p(cnt);
		nl;
	}
	return 0;
}
