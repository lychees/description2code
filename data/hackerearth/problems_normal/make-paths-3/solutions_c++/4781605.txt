#include <bits/stdc++.h>
using namespace std;

typedef pair<int,int> ii;
typedef pair<int,ii> iii;
vector<int> id;
int root(int i) {
	while(i != id[i]) {
		id[i] = id[id[i]]; //path compression
		i = id[i];
	}
	return i;
}
bool connected(int p,int q) {
	return root(p) == root(q);
}
void Union(int p,int q) {
	int i = root(p);
	int j = root(q);
	id[i] = j;
}
bool comp(iii a,iii b) {
	return a.first < b.first;
}
int main()
{
	int n,x,y;
    vector< ii > X,Y;
    priority_queue<iii> pq;
    cin>>n;
    id.resize(n);
    for(int i=0;i<n;i++) {
    	id[i] = i;
    }
    for(int i=0;i<n;i++) {
    	cin>>x>>y;
    	X.push_back(make_pair(x,i));
    	Y.push_back(make_pair(y,i));
    }
    sort(X.begin(),X.end());
    sort(Y.begin(),Y.end());
    
    ii from,to;
    for(int i=0;i<n-1;i++) {
    		from = X[i];
    		to = X[i+1];
    		pq.push(make_pair(-fabs(from.first - to.first),make_pair(from.second,to.second)));
    }
    for(int i=0;i<n-1;i++) {
    		from = Y[i];
    		to = Y[i+1];
    		pq.push(make_pair(-fabs(from.first - to.first),make_pair(from.second,to.second)));
    }
    iii top;
    long res=0;
    while(!pq.empty()) {
    	top = pq.top();
    	pq.pop();
    	
    	int p = top.second.first;
    	int q = top.second.second;
    	
    	if(!connected(p,q)) {
    		Union(p,q);
    		res -= top.first;
    	}
    }
    cout<<res<<endl;
    
    return 0;
}
