#include <bits/stdc++.h>

#define LLI long long  int
#define LLU long long unsigned int
#define LI  long int
#define LU  long unsigned

#define MIN(a,b) ((b)^(((a)^(b))&-((a)<(b))))


#define MOD 1000000007

#define PA pair<int,int>
#define PB pair<PA,int>
#define MP(a,b) make_pair(a,b)
#define PUS(x) push_back(x)


#define MAX_VAL 10000010
#define MAX_INT 999999999
#define MIN_INT -999999999


using namespace std;






LLI MAX(LLI a,LLI b)
{
    if(a>b)return a;
    return b;
}




struct subset
{
    int parent;
    int rank;
    int min_index;
    int min;
};


int find(struct subset *subsets, int i)
{
    // find root and make root as parent of i (path compression)
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);

    return subsets[i].parent;
}


void Union(struct subset *subsets, int x, int y)
{
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

    // Attach smaller rank tree under root of high rank tree
    // (Union by Rank)
    if (subsets[xroot].rank < subsets[yroot].rank)
    {
        subsets[xroot].parent = yroot;
        if(subsets[xroot].min<subsets[yroot].min)
        {
            subsets[yroot].min=subsets[xroot].min;
            subsets[yroot].min_index=subsets[xroot].min_index;
        }
    }
    else if (subsets[xroot].rank > subsets[yroot].rank)
    {
        subsets[yroot].parent = xroot;
        if(subsets[xroot].min>subsets[yroot].min)
        {
            subsets[xroot].min=subsets[yroot].min;
            subsets[xroot].min_index=subsets[yroot].min_index;
        }
    }

    // If ranks are same, then make one as root and increment
    // its rank by one
    else
    {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
        if(subsets[xroot].min>subsets[yroot].min)
        {
            subsets[xroot].min=subsets[yroot].min;
            subsets[xroot].min_index=subsets[yroot].min_index;
        }
    }
    subsets[xroot].min=MIN(subsets[xroot].min,subsets[yroot].min);
    subsets[yroot].min=MIN(subsets[xroot].min,subsets[yroot].min);
}




int main()
{
    
    ios_base::sync_with_stdio(false);
    
    int T;
    cin>>T;
    while(T--)
    {
        int N,M;
        cin>>N>>M;
        int W[N];
        struct subset sub[N];
        int group_count=N;
        int flag[N];
        for(int i=0;i<N;i++)
        {
            cin>>W[i];
            sub[i].parent=i;
            sub[i].rank=0;
            sub[i].min_index=i;
            sub[i].min=W[i];
            flag[i]=0;
        }
        for(int i=0;i<M;i++)
        {
            int a,b;
            cin>>a>>b;
            a=a-1;
            b=b-1;
            if(find(sub,a)!=find(sub,b))
            {
                Union(sub,a,b);
                
            }
        }
        
        queue<int> Q;
        LLI co=9999999;
        int ind=-1;
        for(int i=0;i<N;i++)
        {
            int pa=find(sub,i);
            if(sub[pa].min<co)
            {
                co=sub[pa].min;
                ind=pa;
            }
            //cout<<pa<<endl;
            

        }

        for(int i=0;i<N;i++)
        {
            int pa=find(sub,i);
            if(pa!=ind && flag[pa]==0)
            {
                flag[pa]++;
                Q.push(pa);
            }
        }
        LLI cost=0;
        while(Q.size()>0)
        {
            //cout<<1<<endl;
            int a=Q.front();
            Q.pop();
            
            cost+=(LLI)sub[ind].min*(LLI)sub[a].min;
            Union(sub,a,ind);
            ind=find(sub,a);
            
        }
        
        cout<<cost<<endl;



    }
    
    return 0;
}