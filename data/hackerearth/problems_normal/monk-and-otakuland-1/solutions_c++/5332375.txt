/*input
6 3
>><<>
1 3 5
1 1 6
2 6 1
*/

#include <bits/stdc++.h>
using namespace std;
#define M 200007
typedef long long ll;

struct node {
    int left;
    int right;
};

typedef node T;
string arrow;
node st[4 * M];
bool color[4 * M];

T startingValue(int i) {
    node res;
    res.left = (arrow[i] == '<') ? 1 : 0;
    res.right = (arrow[i] == '>') ? 1 : 0;
    return res;
}

T merge(T a, T b) {
    node res;
    res.left = a.left + b.left;
    res.right = a.right + b.right;
    return res;
}

T noChangeObject() {
    node res;
    res.left = res.right = 0;
    return res;
}

void build(int idx, int lo, int hi) {
    if (lo == hi) {
        st[idx] = startingValue(lo);
    }
    else {
        int mid = (lo + hi) / 2;
        build(2*idx, lo, mid);
        build(2*idx + 1, mid + 1, hi);
        st[idx] = merge(st[2*idx], st[2*idx + 1]);
    }
}

//  change return type accordingly
T query(int idx, int lo, int hi, int i, int j) {

    if (color[idx] == true) {
        swap(st[idx].left, st[idx].right);
        if (lo != hi) {
            color[2*idx] = !color[2*idx];
            color[2*idx + 1] = !color[2*idx + 1];
        }
        color[idx] = false;
    }
    if (i > hi || j < lo || lo > hi)
        return noChangeObject();
    if (lo >= i && hi <= j)
        return st[idx];
    int mid = (lo + hi) / 2;
    return merge(query(2*idx, lo, mid, i, j), query(2*idx + 1, mid + 1, hi, i, j));
}

void lazy_update(int idx, int lo, int hi, int i, int j) {

    if (color[idx] == true) {
        swap(st[idx].left, st[idx].right);
        if (lo != hi) {
            color[2*idx] = !color[2*idx];
            color[2*idx + 1] = !color[2*idx + 1];
        }
        color[idx] = false;
    }

    if (j < lo || i > hi || lo > hi)
        return;

    if (i <= lo && j >= hi) {
        swap(st[idx].left, st[idx].right);
        if (lo != hi) {
            color[2*idx] = !color[2*idx];
            color[2*idx + 1] = !color[2*idx + 1];
        }
    }
    else {
        int mid = (lo + hi) / 2;
        lazy_update(2*idx, lo, mid, i, j);
        lazy_update(2*idx + 1, mid + 1, hi, i, j);

        st[idx] = merge(st[2*idx], st[2*idx + 1]);
    }
}

int main() {
    int N, Q, a, b, type;
    bool rev;
    scanf("%d %d", &N, &Q);
    N--;

    cin >> arrow;
    build(1, 0, N - 1);

    memset(color, false, sizeof(color));
    while (Q--) {
        scanf("%d %d %d", &type, &a, &b);
        rev = false;
        if (b < a) {
        	swap(a, b);
        	rev = true;
        }
        a -= 1;    b -= 2;
        if (type == 1) {
            lazy_update(1, 0, N - 1, a, b);
        }
        else {
            node res = query(1, 0, N - 1, a, b);
            if (rev)
                printf("%d\n", res.right);
            else
                printf("%d\n", res.left);
        }
    }
}
