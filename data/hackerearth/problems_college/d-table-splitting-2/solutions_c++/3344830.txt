#include<bits/stdc++.h>
#include<sys/resource.h>
using namespace std;
#define f first
#define s second
#define mp make_pair
#define pb push_back
#define pii pair<int,int>
int n,m,flag,vis[2000111],par[2000111];
vector<int>c[1011][27],a[1011];
char s[1000111];
vector<int>adj[2000111];
vector< pii >v;
int func(int i,int j)
{
    return (((i-1)*m)+j);
}
pii defunc(int n)
{
    int x=n/m;
    int y=n%m;
    if(y==0)
        return {x,m};
    return {x+1,y};
}
void alpha()
{
    int l=a[v[0].f][v[0].s];
    sort(v.begin(),v.end());
    for(int i=0; i<((int)v.size())-1; i++)
    {
        if(v[i+1].f!=v[i].f)
            continue;
        int p=c[v[i].f][l][max(v[i+1].s,v[i].s)]-c[v[i].f][l][min(v[i+1].s,v[i].s)-1];
        if(p!=max(v[i+1].s,v[i].s)-min(v[i+1].s,v[i].s)+1)
        {
            flag=1;
            return;
        }
    }
}
void chk(int u,int p)
{
    int x=u;
    v.clear();
    while(x!=p)
    {
        v.pb(defunc(x));
        x=par[x];
    }
    v.pb(defunc(p));
    alpha();
}
void dfs(int u,int p)
{
    par[u]=p;
    vis[u]=1;
    //cout<<u<<" "<<p<<endl;
    for(int i=0; i<adj[u].size(); i++)
    {
        int k=adj[u][i];
        if(k==p||vis[k]==2)
            continue;
        if(vis[k]==1)
            chk(u,k);
        else
            dfs(k,u);
        if(flag==1)
            return;
    }
    vis[u]=2;
}
int main()
{
	struct rlimit lim;
lim.rlim_cur = lim.rlim_max = 200 << 20; // 200MB
setrlimit(RLIMIT_STACK, &lim);
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int i,j,k;
        scanf("%d %d",&n,&m);
        for(j=0; j<=m+1; j++)
            a[0].pb(-1);
        for(i=1; i<=n; i++)
        {
            scanf("%s",s);
            a[i].pb(-1);
            for(k=0; k<26; k++)
                c[i][k].pb(0);
            for(j=0; j<m; j++)
            {
                a[i].pb(s[j]-'a');
                for(k=0; k<26; k++)
                    c[i][k].pb(c[i][k].back());
                c[i][s[j]-'a'].back()++;
            }
            a[i].pb(-1);
        }
        for(j=0; j<=m+1; j++)
            a[n+1].pb(-1);
//        for(i=0;i<=n+1;i++)
//        {
//            for(j=0;j<=m+1;j++)
//                printf("%d ",a[i][j]);
//            printf("\n");
//        }
        for(i=1; i<=n; i++)
        {
            for(j=1; j<=m; j++)
            {
                if(a[i-1][j]==a[i][j])
                    adj[func(i,j)].pb(func(i-1,j)),adj[func(i-1,j)].pb(func(i,j));
                if(a[i][j-1]==a[i][j])
                    adj[func(i,j)].pb(func(i,j-1)),adj[func(i,j-1)].pb(func(i,j));
            }
        }
        flag=0;
        for(i=1; i<=n; i++)
        {
            for(j=1; j<=m; j++)
            {
                if(vis[func(i,j)]==0)
                {
                    dfs(func(i,j),-1);
                    if(flag==1)
                        break;
                }
            }
            if(flag==1)
                break;
        }
        for(i=1;i<=n;i++)
            for(j=1;j<=m;j++)
        {
            int p=func(i,j);
            adj[p].clear();
            vis[p]=0;
            par[p]=0;
        }
        if(flag==1)
            printf("NO\n");
        else
            printf("YES\n");
        for(i=0;i<=n+1;i++)
            a[i].clear();
        for(i=1;i<=n;i++)
            for(k=0;k<26;k++)
                c[i][k].clear();
    }
    return 0;
}

