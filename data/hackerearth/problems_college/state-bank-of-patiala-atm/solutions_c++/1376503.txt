#include <iostream>
#include <cstdio>
#include <set>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;
//#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])

// Alphabet size (# of symbols)
#define ALPHABET_SIZE (10)


// trie node
typedef struct trie_node trie_node_t;
struct trie_node
{
	int value;
	trie_node_t *children[10];
};

// trie ADT
typedef struct trie trie_t;
struct trie
{
	trie_node_t *root;
	int count;
};

// Returns new trie node (initialized to NULLs)
trie_node_t *getNode(void)
{
	trie_node_t *pNode = NULL;

	pNode = (trie_node_t *)malloc(sizeof(trie_node_t));

	if (pNode)
	{
		int i;

		pNode->value = 0;

		for (i = 0; i < ALPHABET_SIZE; i++)
		{
			pNode->children[i] = NULL;
		}
	}

	return pNode;
}

// Initializes trie (root is dummy node)
void initialize(trie_t *pTrie)
{
	pTrie->root = getNode();
	pTrie->count = 0;
}

// If not present, inserts key into trie
// If the key is prefix of trie node, just marks leaf node
void insert(trie_t *pTrie, string key)
{
	int level;
	int length = key.size();
	int index;
	trie_node_t *pCrawl;

	pTrie->count++;
	pCrawl = pTrie->root;

	for (level = 0; level < length; level++)
	{
		index = key[level] - '0';
		if (!pCrawl->children[index])
		{
			pCrawl->children[index] = getNode();
		}

		pCrawl = pCrawl->children[index];
	}

	// mark last node as leaf
	pCrawl->value = pTrie->count;
}

// Returns non zero, if key presents in trie
bool search(trie_t *pTrie, string key)
{
	int level;
	int length = key.size();
	int index;
	trie_node_t *pCrawl;

	pCrawl = pTrie->root;

	for (level = 0; level < length; level++)
	{
		index = key[level] - '0';

		if (!pCrawl->children[index])
		{
			return false;
		}
		if (pCrawl->value) {
			return true;
		}
		pCrawl = pCrawl->children[index];
	}
	return false;
	//return (0 != pCrawl && pCrawl->value);
}

// Driver
int main()
{
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		vector<string>v(n);
		trie_t trie;
		initialize(&trie);
		for (int i = 0; i < n; i++) {
			cin >> v[i];
			insert(&trie, v[i]);
		}
		int flag = 0;
		for (int i = 0; i < n; i++) {
			if (search(&trie, v[i])) {
				flag = 1;
			}
		}
		(flag) ? puts("NO") : puts("YES");
 	}
	return 0;
}