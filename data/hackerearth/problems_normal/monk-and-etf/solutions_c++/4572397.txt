//DARK LORD
#include<bits/stdc++.h>
#define ll long long
#define _ ios::sync_with_stdio(false);cin.tie(0);
#define max(a,b)                 (a>=b?a:b)
#define min(a,b)                 (a<b?a:b)
#define max3(a,b,c)               max(a,max(b,c))
#define min3(a,b,c)               min(a,min(b,c))
#define f0(i,a,b) for(int i=a;i<b;i++)
#define f1(i,a,b) for(int i=a;i<=b;i++)
#define fr(i,b,a) for(int i=b;i>=a;i--)
#define pb push_back
#define mp make_pair
#define mod 1000000007
#define mx 10000001
#define T() int t;cin>>t;while(t--)
inline ll modexp(ll a,ll b){ll x=1;while(b>0){if(b&1){x*=a;if(x>=mod)x%=mod;};b>>=1;a*=a;if(a>=mod)a%=mod;}return x;}
inline ll digSum(ll n){ll s=0;n=abs(n);while(n){s+=(n%10);n/=10;}return s;}
using namespace std;
vector<bool> isprime(mx,true);
vector<ll> primes;
ll eulerphi[mx];
ll arr[mx];
int main()
{
	_
	isprime[0]=false;
    isprime[1]=false;
    ll i,j,primelen,begin;
    for(i=4;i<mx;i+=2)
    	isprime[i] = false;
    for(i=3;i<=sqrt(mx);i+=2)
    if(isprime[i])
    for(j=i*i;j<=mx;j+=2*i)
    {
        isprime[j]=false;
    }  
    primes.push_back(2);
    for(i=3;i<=mx;i+=2){
    if(isprime[i])
    primes.push_back(i);}
    primelen=primes.size();
    T(){
    ll a,b,k,cnt=0;
    cin>>a>>b>>k;
    f1(i,a,b){
    	eulerphi[i-a]=i;
    	arr[i-a]=i;}
    for(i=0;primes[i]*primes[i]<=b && i<primelen;i++){
    	begin=(a/primes[i]);
    	begin*=primes[i];
    	for(j=begin;j<=b;j+=primes[i]){
    		if(j<a)
    			continue;
    		eulerphi[j-a]-=eulerphi[j-a]/primes[i];
    		while(arr[j-a]%primes[i]==0){
    			arr[j-a]/=primes[i];
			}
		}
	}
	f1(i,a,b){
		if(arr[i-a]!=1)
		eulerphi[i-a]-=eulerphi[i-a]/arr[i-a];
		//cout<<eulerphi[i-a]<<endl;
		if(eulerphi[i-a]%k == 0)
			cnt++;
	}
	double ans = (double)(cnt)/(double)(b-a+1);
	cout<<setprecision(6)<<fixed<<ans<<endl;}
	return 0;
}
