#include <iostream>
#include <fstream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <ctime>
#include <climits>
#include <cctype>
#include <iomanip>
#include <algorithm>
#include <list>
#include <map>
//#include<unordered_map>
#include <set>

#include <functional>
#include <string>
#include <utility>
using namespace std;


#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))
#define rev(j,n) for(int (i)=j;(i)>=(int)(n);--(i))
#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))
#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))
#define rerm(i,l,u,m) for(int (i)=(int)(l);(i)<=(int)(u);(i)+=(m))
//typedef long long int lli;
typedef long long ll;
typedef long long int lli;
#define vec vector
#define pii pair<int,int>
#define pis pair<int, string>
#define psi pair<string,int>
#define pli pair<lli,lli>
typedef vec<int> vi;
typedef vec<vi > vii;
typedef vec<pii > vpii;
typedef vec<pli > vpli;
#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define modu 1000000007
#define endl "\n"
#define fir first
#define sec second

/*
// Only for pairs of std::hash-able types for simplicity.
// You can of course template this struct to allow other hash functions
struct pair_hash {
    template <class T1, class T2>
    std::size_t operator () (const std::pair<T1,T2> &p) {
        auto h1 = std::hash<T1>{}(p.first);
        auto h2 = std::hash<T2>{}(p.second);

        // Mainly for demonstration purposes, i.e. works but is overly simple
        // In the real world, use sth. like boost.hash_combine
        return h1 ^ h2;
    }
};
*/

class pairhash {
public:

  template <typename T, typename U>
  std::size_t operator()(const std::pair<T, U> &x) const
  {
      using std::size_t;
      using std::hash;
      using std::string;
    return std::hash<T>()(x.first.first) ^ std::hash<T>()(x.first.second) ^ std::hash<U>()(x.second);
  }
};




int main(){
    //int t;
    //ofstream fout ("A-large.out");
    //ifstream fin ("A-large.in");

    lli n,x,m,t,z,k;

    scanf("%lld",&t);
    lli M,N;
    lli O;

    pair<pair<lli,lli>,lli> stump;
    map<pair<pair<lli,lli>,lli>,lli >::iterator *it;
    map<pair<lli,lli>,lli >::iterator *it2;

    while(t--){
        scanf("%lld",&n);
        map<pair<pair<lli,lli>,lli>,lli > stumps;
        map<pair<lli,lli>,lli > stumps_final,stupm_fi2;
        rep(i,n){
            cin>>M>>N>>O;
            lli gcd = __gcd(__gcd(M,N),O);
            //lli gcd2 = __gcd(M,N);
            
           	stump = {{M/gcd,N/gcd},O/gcd};
            //cout<<stump.first.first<<" "<<stump.first.sec<<" "<<stump.sec<<endl;
            stumps[stump]=1;
            //stumps_final[stump.first]=0;
        }
        //cout<<endl;
        pair<lli,lli> st1;
        lli maxi = 0;
        for(auto it=stumps.begin();it !=stumps.end();it++){
        	//cout<<it->first.first.first<<" "<<it->first.first.sec<<" "<<it->fir.sec<<"=";
        	lli gcd2 = __gcd(it->first.first.first,it->first.first.sec);
        	
        	st1 = {it->first.first.first/gcd2,it->first.first.sec/gcd2};
        	
			stumps_final[st1]=stumps_final[st1]+1;
			//cout<<stumps_final[st1]<<endl;
			
        }
        for(auto it2=stumps_final.begin();it2 !=stumps_final.end();it2++){
        	//cout<<it2->sec<<endl;
            maxi=max(maxi,it2->sec);
        }
        printf("%lld\n",maxi);
    }

    //fin.close();
    //fout.close();

    return 0;
}
