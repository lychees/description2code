#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <ctime>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
#include <fstream>
//#define _LOCAL_
#ifdef _LOCAL_
#include "testlib.h"
/* rnd */
#endif

using namespace std;

template<class T> inline T cabs(const T &x) { return x > 0 ? x : (-x); }
template<class T> inline T gcd(const T &x, const T &y) { return (y == 0) ? x : gcd(y, x % y); }
template<class T> inline T sgn(const T &x) { return (x > 0) - (x < 0); }

#define dbg(x) cout << #x << " = " << (x) << endl
#define dbg2(x,y) cout << #x << " = " << (x) << ", " << #y << " = " << (y) << endl
#define dbg3(x,y,z) cout << #x << " = " << (x) << ", " << #y << " = " << (y) << ", " << #z << " = " << (z) << endl
#define dbg4(x,y,z,w) cout << #x << " = " << (x) << ", " << #y << " = " << (y) << ", " << #z << " = " << (z) << ", " << #w << " = " << w << endl

#define out(x) cout << (x) << endl
#define out2(x,y) cout << (x) << " " << (y) << endl
#define out3(x,y,z) cout << (x) << " " << (y) << " " << (z) << endl
#define out4(x,y,z,w) cout << (x) << " " << (y) << " " << (z) << " " << (w) << endl

const int maxN = 100000 + 10;

struct node {
    int l, r;
    long long num, lsum, rsum;
};
node tree[maxN * 6];

int N, Q;
long long A[maxN];

void build(int l, int r, int idx = 1) {
    tree[idx].l = l, tree[idx].r = r;
    tree[idx].num = tree[idx].lsum = tree[idx].rsum = 0;
    if( l == r ) {
        tree[idx].num = A[l];
        tree[idx].lsum = A[l] * l;
        tree[idx].rsum = A[l] * (N - l);
        return ;
    }
    int mid = (l + r) >> 1;
    build(l, mid, idx << 1);
    build(mid + 1, r, idx << 1 | 1);
    tree[idx].num  =  tree[idx << 1].num +  tree[idx << 1 | 1].num;
    tree[idx].lsum = (tree[idx << 1].lsum + tree[idx << 1 | 1].lsum);
    tree[idx].rsum = (tree[idx << 1].rsum + tree[idx << 1 | 1].rsum);
}

void update(int ip, int val, int idx = 1) {
    if( tree[idx].l == tree[idx].r ) {
        tree[idx].num  += val;
        tree[idx].lsum += (long long)val * ip;
        tree[idx].rsum += (long long)val * (N - ip);
        return ;
    }
    int mid = (tree[idx].l + tree[idx].r) >> 1;
    if( ip <= mid )
        update(ip, val, idx << 1);
    else
        update(ip, val, idx << 1 | 1);
    tree[idx].num  =  tree[idx << 1].num +  tree[idx << 1 | 1].num;
    tree[idx].lsum = (tree[idx << 1].lsum + tree[idx << 1 | 1].lsum);
    tree[idx].rsum = (tree[idx << 1].rsum + tree[idx << 1 | 1].rsum);
}

pair<long long, pair<long long, long long> > query(int l, int r, int idx) {
    if( l <= tree[idx].l && tree[idx].r <= r ) {
        return make_pair(tree[idx].num, make_pair(tree[idx].lsum, tree[idx].rsum));
    }
    int mid = (tree[idx].l + tree[idx].r) >> 1;
    if( r <= mid )
        return query(l, r, idx << 1);
    else if( l > mid )
        return query(l, r, idx << 1 | 1);
    else {
        pair<long long, pair<long long, long long> > pa = query(l, r, idx << 1);
        pair<long long, pair<long long, long long> > pb = query(l, r, idx << 1 | 1);
        pa.first += pb.first;
        pa.second.first += pb.second.first;
        pa.second.second += pb.second.second;
        return pa;
    }
}

int main()
{
    //freopen("data.in", "r", stdin);
    //freopen("data.out", "w", stdout);
    scanf("%d %d", &N, &Q);
    for(int i = 1; i <= N; i ++) scanf("%lld", &A[i]);
    build(1, N, 1);
    int t, k, s, l, r;
    for(int i = 1; i <= Q; i ++) {
        scanf("%d", &t);
        if( t == 2 ) {
            scanf("%d %d", &k, &s);
            update(k, s, 1);
        } else {
            scanf("%d %d %d", &k, &l, &r);
            if( r <= k ) {
                pair<long long, pair<long long, long long> > pa = query(l, r, 1);
                long long ans = pa.second.second - pa.first * (N - k);
                printf("%lld\n", ans);
            } else if( l >= k ) {
                pair<long long, pair<long long, long long> > pa = query(l, r, 1);
                long long ans = pa.second.first - pa.first * k;
                printf("%lld\n", ans);
            } else {
                pair<long long, pair<long long, long long> > pa = query(l, k, 1);
                long long ans_1 = pa.second.second - pa.first * (N - k);
                pair<long long, pair<long long, long long> > pb = query(k, r, 1);
                long long ans_2 = pb.second.first - pb.first * k;
                printf("%lld\n", ans_1 + ans_2);
            }
        }
    }
    return 0;
}
