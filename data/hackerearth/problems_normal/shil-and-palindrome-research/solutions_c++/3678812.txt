#include <iostream>
#define MAXN 696969
#define mid ((a+b)/2)
#define l (2*curNode)
#define r ((2*curNode)+1)

using namespace std;
struct node{
    int childs[26];
};

int N , Q;
node tree[MAXN] , tmp;
string S;

void build_tree(int curNode , int a , int b){
    if(a > b) return;
    if(a == b){
        tree[curNode].childs[S[a]-'a'] = 1;
        return;
    }

    build_tree(l , a , mid);
    build_tree(r , mid+1 , b);

    for(int i=0; i<26; i++)
        tree[curNode].childs[i] = tree[l].childs[i] + tree[r].childs[i];
}

node query_tree(int curNode , int a , int b , int p , int q , node ret){
    if(a > q || b < p || a > b) return tmp;

    if(a >= p && b <= q){
        return tree[curNode];
    }

    node left = query_tree(l , a , mid , p , q , ret);
    node right = query_tree(r , mid+1 , b , p , q , ret);
    node retVal;
    for(int i=0; i<26; i++)
        retVal.childs[i] = left.childs[i] + right.childs[i];

    return retVal;
}

void update_tree(int curNode , int a , int b , int idx , int car){
    if(a > b) return;

    if(a > idx || b < idx) return;

    if(a == b){
        tree[curNode] = tmp;
        tree[curNode].childs[car-'a'] = 1;
        return;
    }

    update_tree(l , a , mid , idx , car);
    update_tree(r , mid+1 , b , idx , car);

    for(int i=0; i<26; i++)
        tree[curNode].childs[i] = tree[l].childs[i] + tree[r].childs[i];
}

int main(){
    cin >> N >> Q >> S;
    build_tree(1 , 0 , N-1);

    while(Q--){
        int t;
        cin >> t;

        if(t>1){
            int p , q;
            cin >> p >> q;
            node c = query_tree(1 , 0 , N-1 , p - 1 , q - 1 , tmp);
            int f = 0;

            for(int i=0; i<26; i++){
                //cout << c.childs[i] <<endl;
                if(c.childs[i]%2 == 1)
                    f ++;
            }

            if(f>1) cout <<"no" <<endl;
            else cout << "yes" <<endl;
        }
        else{
            int idx;
            char car;

            cin >> idx >> car;

            update_tree(1 , 0 , N-1 , idx-1 , car);
        }
    }


    return 0;
}

/*
5 3
ababb
2 1 5
yes
2 1 3
yes
2 1 2
yes*/
