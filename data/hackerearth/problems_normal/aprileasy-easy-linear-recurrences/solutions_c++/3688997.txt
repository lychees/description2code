#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef pair<int, int> PII;

#define MAX_INT (int)0x7fffffff
#define MIN_INT (int)0x80000000
#define MAX_UINT (uint)0xffffffff

#define TTi template<typename T> inline
TTi T SQR(T x) { return x * x; }

#define CONCAT3_NX(x, y, z) x ## y ## z
#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)
#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)
#define TYPE(x) __typeof(x)

#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)
#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)
#define FORN(i, n)    FOR(i, 0, n)
#define RFORN(i, n)   RFOR(i, 0, n)
#define FOREACH(i, v) for (auto& i: v)

#define SC() scanf("\n")
#define SC1(fmt, a) scanf(fmt, &a)
#define SC2(fmt, a, b) scanf(fmt, &a, &b)
#define SC3(fmt, a, b, c) scanf(fmt, &a, &b, &c)
#define SCi(a) scanf("%d", &a)
#define SCii(a,b) scanf("%d%d", &a, &b)
#define SCiii(a,b,c) scanf("%d%d%d", &a, &b, &c)
#define fLL "%lld"
#define SCl(a) scanf(fLL, &a)
#define SCll(a,b) scanf(fLL fLL, &a, &b)
#define SClll(a,b,c) scanf(fLL fLL fLL, &a, &b, &c)
#define SCs(s, n) {scanf("%s", s); n = strlen(s);}
#define SCc(s) scanf("%c", s)

#define MP make_pair
#define PB push_back
#define WHOLE(x) (x).begin(),(x).end()
#define SZ(x) ((int)(x).size())
#define POPST(stack) (stack).top();(stack).pop();
#define POPQ(queue) (queue).front();(queue).pop();
#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())
#define SORT(v) (sort(WHOLE(v)))

#define LIMIT(x, lim) {if (x > lim) x = lim;}
TTi T MIN(T x, T y) { return (x < y) ? x : y; }
TTi T MAX(T x, T y) { return (x > y) ? x : y; }
TTi T ABS(T x) { return (x > 0) ? x : -x; }
TTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}
TTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}
TTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }
TTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }

vector<string> split(const string& s, char c) {
    vector<string> v; stringstream ss(s); string x;
    while (getline(ss, x, c)) v.emplace_back(x); return move(v);
}
template<typename T, typename... Args>
inline string arrStr(T arr, int n) {
    stringstream s;
    s << "[";
    FORN(i, n - 1) s << arr[i] << ",";
    s << arr[n - 1] << "]";
    return s.str();
}

// #ifndef ONLINE_JUDGE
#ifdef JUDGE_LOCAL
    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}
    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, "%d, ", arr[i]);}
    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, "%d, ", arr[i]);}
    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}

    inline void __evars_begin(int line) { cerr << "#" << line << ": "; }
    inline void __evars(vector<string>::iterator it) {cerr << endl;}

    TTi void __evars_out_var(vector<T> val) {
        cerr << arrStr(val, val.size());
    }
    TTi void __evars_out_var(T* val) {
        cerr << arrStr(val, 10);
    }
    TTi void __evars_out_var(T val) {
        cerr << val;
    }
    template<typename T, typename... Args>
    inline void __evars(vector<string>::iterator it, T a, Args... args) {
        cerr << it->substr((*it)[0] == ' ', it->length()) << "=";
        __evars_out_var(a);
        cerr << "; ";
        __evars(++it, args...);
    }
#else
    #define EPR(args...) 1
    #define EARR(args...) 1
    #define EVEC(args...) 1
    #define EVARS(args...) 1
#endif

template<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }
#define DIE(args...) {printf(args);exit(0);}
#define PR(x) cout << (x) << endl
#define PRF(x) cout << fixed << setprecision(10) << x << endl

inline int gcd(int a, int b) { return a ? gcd(b % a, a) : b; }
inline LL gcd(LL a, LL b) { return a ? gcd(b % a, a) : b; }
inline LL powmod(LL a, LL p, LL m) { LL r = 1; while (p) { if (p & 1) r = r*a%m; p>>=1; a=a*a%m; } return r; }

struct pairhash {
    template <typename T, typename U>
    std::size_t operator() (const std::pair<T, U> &x) const {
        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);
    }
};

template <typename K, typename V>
V GetWithDef(const std::unordered_map <K,V> & m, const K & key, const V & defval ) {
    auto it = m.find(key);
    return (it == m.end()) ? defval : it->second;
}

template <typename K, typename V>
void SetDef(std::unordered_map <K,V> & m, const K & key, const V & defval ) {
    auto it = m.find(key);
    if (it == m.end()) m[key] = defval;
}

const int MOD = 1000 * 1000 * 1000 + 7;
const double PI = 3.1415926535897932384626433832795l;

inline void addto(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
}
inline int add(int a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    return a;
}
inline void subto(int &a, int b) {
    a -= b;
    if (a < 0) a += MOD;
    if (a >= MOD) a -= MOD;
}
inline int sub(int a, int b) {
    a -= b;
    if (a < 0) a += MOD;
    if (a >= MOD) a -= MOD;
    return a;
}
inline void multo(int &a, int b) {
    a = (long long)a * b % MOD;
}
inline int mul(int a, int b) {
    return (long long)a * b % MOD;
}
inline int mulmod(int a, int b, int mod) {
    return (long long)a * b % mod;
}
inline int powmod(int a, int e, int mod) {
    int x;
    for(x = 1; e > 0; e >>= 1) {
        if (e & 1)
            x = mulmod(x, a, mod);
        a = mulmod(a, a, mod);
    }
    return x;
}
inline int invmod(int a, int mod) {
    return powmod(a, mod - 2, mod);
}
inline LL invmodLL(LL p){
    LL q=p;
    for(LL a=p*p;a!=1;a*=a) q*=a;
    return q;
}



// -----------------------------------------------------------------
// CODE
// -----------------------------------------------------------------

#define DEBUG 1

int A, B, C, D, E, F;
int F2, F1, G2, G1;

int K = 5;
int M[200000][5][5] = {
    {{1, 0, 0, 0, 0},
     {0, 1, 0, 0, 0},
     {0, 0, 1, 0, 0},
     {0, 0, 0, 1, 0},
     {0, 0, 0, 0, 1}}
};
int mlast = 2;
int MATRIX_ID = 0;
int MATRIX_STEP = 1;

int matmul(int ia, int ib) {
    int res = mlast++;
    // assert(res < 10000000);
    FORN(i, K) {
        int *rowres = M[res][i];
        int *rowa = M[ia][i];
        FORN(j, K)
            FORN(k, K)
                addto(rowres[j], mul(rowa[k], M[ib][k][j]));
    }
    return res;
}

// int matpow(int ia, int p) {
//     if (p == 1)
//         return ia;
//     if (p % 2)
//         return matmul(ia, matpow(ia, p-1));
//     int ix = matpow(ia, p/2);
//     return matmul(ix, ix);
// }

vector<int> pre1;
vector<int> pre2;

inline int solve(int n) {
    int H2 = add(mul(E, F2), mul(F, G2));
    if (n == 0) {
        return H2;
    }
    int T1 = add(H2, add(mul(E, F1), mul(F, G1)));
    if (n == 1) {
        return T1;
    }
    int e = n - 1;
    int low = e & ((1 << 15) - 1);
    int high = e >> 15;
    // assert(low < pre1.size());
    // assert(high < pre2.size());
    // EVARS(e, high, low);

    int ires = matmul(pre1[low], pre2[high]);
    int init[5] = {F2, F1, G2, G1, T1};
    int ans = 0;
    FORN(i, K) {
        addto(ans, mul(init[i], M[ires][K - 1][i]));
    }
    mlast--;
    FORN(i, K) FORN(j, K) M[mlast][i][j] = 0;
    return ans;
}


int main() {
    ios_base::sync_with_stdio(0);

    SCiii(A, B, C);
    A %= MOD;
    B %= MOD;
    C %= MOD;
    SCiii(D, E, F);
    D %= MOD;
    E %= MOD;
    F %= MOD;
    SCii(F2, F1);
    SCii(G2, G1);
    F1 %= MOD;
    F2 %= MOD;
    G1 %= MOD;
    G2 %= MOD;

    int EA = mul(E, A);
    int EB = mul(E, B);
    int FD = mul(F, D);
    int FC = mul(F, C);

    int step[5][5] = {
    //  F-2 F-1 G-2 G-1 T-1
       {0,  1,  0,  0,  0}, // F-1
       {0,  A,  B,  0,  0}, // F-0
       {0,  0,  0,  1,  0}, // G-1
       {D,  0,  0,  C,  0}, // G-0
      {FD, EA, EB, FC,  1}, // T-0
    };
    FORN(i, 5) {
    FORN(j, 5) {
        M[MATRIX_STEP][i][j] = step[i][j];
    }}

    int cur = MATRIX_ID;
    FORN(i, 1 << 15) {
        pre1.PB(cur);
        cur = matmul(cur, MATRIX_STEP);
    }

    int largestep = cur;
    cur = MATRIX_ID;
    FORN(i, 1 << 15) {
        pre2.PB(cur);
        cur = matmul(cur, largestep);
    }

    int Q;
    SCi(Q);
    FORN(i, Q) {
        int n;
        SCi(n);
        // EVARS(n);
        printf("%d\n", solve(n));
        // EPR("\n");
    }


    return 0;
}
