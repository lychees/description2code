# include <iostream>
# include <fstream>
# include <sstream>
# include <algorithm>
# include <numeric>
# include <cstdio>
# include <cmath>
# include <cstdlib>
# include <cstring>
# include <vector>
# include <list>
# include <set>
# include <map>
# include <stack>
# include <queue>
# include <cctype>
# include <climits>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef vector<vector<int> > vvi;

#define GI ({int t;scanf("%d",&t);t;})
#define REP(i,a,b) for(int i=a;i<b;i++)
#define ALL(v) (v).begin(),(v).end()
#define TR(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define pb push_back
#define mp make_pair
#define INF (int)1e9
#define EPS (double)(1e-9)
#define PI (double)(3.141592653589793)


typedef struct contest
{
    double starttime;
    double endtime;
}contest;
static int cmp(const void *p1, const void *p2)
{
        double y1 = ((const contest*)p1)->starttime;
        double y2 = ((const contest*)p2)->starttime;

        if (y1 > y2)
            return 1;
        else if (y1 < y2)
            return -1;
        else
            {
                double x1=((const contest*)p1)->endtime;
                double x2=((const contest*)p2)->endtime;
                if(x1>x2)
                    return -1;
                else if(x1<x2)
                    return 1;
                else
                    return 0;
            }
}
double convertTimetoFraction(string time)
{

    string hstring=time.substr(0,2);
    string mstring=time.substr(3,2);
    const char *hourstring=hstring.c_str();
    const char *minstring=mstring.c_str();
    double t=atoi(hourstring)+(double)atoi(minstring)/(60.0);
    return t;
}
contest daysContest[101];
int main()
{
    int T;
    cin>>T;
    REP(i,0,T)
    {
        string time;
        cin>>time;
        string startime=time.substr(0,5);
        string endtime=time.substr(6,5);
        daysContest[i].starttime=convertTimetoFraction(startime);
        daysContest[i].endtime=convertTimetoFraction(endtime);
    }
    qsort(daysContest,T,sizeof(contest),cmp);
    bool busy=false;
    REP(i,0,T-1)
    {
        if(daysContest[i+1].starttime<daysContest[i].endtime)
        {
            busy=true;
            break;
        }
    }
    if(busy)
    {
        cout<<"Will need a moderator!\n";
    }
    else
    {
        cout<<"Who needs a moderator?\n";
    }
    return 0;
}
