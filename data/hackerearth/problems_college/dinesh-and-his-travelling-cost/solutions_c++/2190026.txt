#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
#include <stack>
#include <algorithm>
#include <set>
#include <climits>

#define sz(c) (int)(c).size()

using namespace std;

typedef pair<int,int> pii;
typedef vector<pii> vpii;
typedef vector<int> vi;
typedef vector<vpii> GRAPH;


void dijkstra(GRAPH& G, int s,vi& dist)
{
	set<pii> Q;
	Q.insert(pii(0,s));
	dist[s]=0;
	
	while(!Q.empty())
	{
		pii top = *Q.begin();
		Q.erase(Q.begin());
		
		int from = top.second;
		
		vector<pii>::const_iterator i;
		
		for(i = G[from].begin() ; i != G[from].end() ; ++i)
		{
			int to = i->first;
			int cost = i->second;
			
			if(dist[to] > dist[from] + cost)
			{
				if(dist[to] != INT_MAX)
				{
					Q.erase(Q.find(pii(dist[to],to)));
				}
				dist[to] = dist[from] + cost;
				Q.insert(pii(dist[to],to));
			}
		}
	}
	
	
}

int main(int argc, char **argv)
{
	int m;
	cin >> m;
	GRAPH G(501);
	while(m--)
	{
		int x ,y,w;
		cin >> x >> y >> w;
		G[x].push_back(pii(y,w));
		G[y].push_back(pii(x,w));
	}
	int u;
	cin >> u;
	vi dist(sz(G),INT_MAX);
	dijkstra(G,u,dist);
	int q;
	cin >> q;
	while(q--)
	{
		int to;
		cin >> to;
		if(dist[to] ==INT_MAX)
			cout <<"NO PATH\n";
		else
			cout << dist[to] << '\n';
			
	}
	return 0;
}

