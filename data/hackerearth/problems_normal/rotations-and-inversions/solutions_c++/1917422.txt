/*
***************************************************************************************************************

							Author : Yash Sadhwani

**************************************************************************************************************
*/
#include<stdio.h>
#include<iostream>
#include<vector>
#include<string.h>
#include<algorithm>
#include<deque>
#include<map>
#include<set>
#include<stdlib.h>
#include<math.h>
#include<queue>
#include<stack>
#include<functional>
using namespace std;
#define ll long long
#define si(x) scanf("%d",&x)
#define sl(x) scanf("%lld",&x)
#define sd(x) scanf("%lf",&x)
#define sc(x) scanf("%c",&x)
#define ss(x) scanf("%s",x)
#define vl vector<ll>
#define vi vector<int>
#define vvl vector< vl >
#define vvi vector< vi >
#define pb push_back
#define mod 1000000007
#define mem(x,y) memset(x,y,sizeof(x))
#define f(i,a,b) for(int i=(a);i<(b);i++)
#define max_int_value 2147483647
#define max_long_value 9223372036854775807



/* Enter your code here. Read input from STDIN. Print output to STDOUT */
#define MAX 200051


using namespace std;
int str[MAX]; //input
int Rank[MAX], suffixArray[MAX]; //output
int cnt[MAX], Next[MAX]; //internal
bool bh[MAX], b2h[MAX];
int Height[MAX];
int Length_of_str;
/*The format for M table where preprocessing value are stored is
M[MAX_STRING_SIZE][logbase2(MAX_STRING_SIZE)].
Also it it observed that Value of logbase2(10^7)= 23.253496664.
Thus always fix logbase2 value to 25.
*/

int M[MAX][25];

bool smaller_first_char(int a, int b)
{
	return str[a] < str[b];
}
void suffixSort(int n)
{
	//sort suffixes according to their first characters
	for (int i=0; i<n; ++i)
	{
		suffixArray[i] = i;
	}
	sort(suffixArray, suffixArray + n, smaller_first_char);
	//{suffixArray contains the list of suffixes sorted by their first character}

	for (int i=0; i<n; ++i)
	{
		bh[i] = i == 0 || str[suffixArray[i]] != str[suffixArray[i-1]];
		b2h[i] = false;
	}

	for (int h = 1; h < n; h <<= 1)
	{
		//{bh[i] == false if the first h characters of suffixArray[i-1] == the first h characters of suffixArray[i]}
		int buckets = 0;
		for (int i=0, j; i < n; i = j)
		{
			j = i + 1;
			while (j < n && !bh[j]) j++;
			Next[i] = j;
			buckets++;
		}
		if (buckets == n) break; // We are done! Lucky bastards!
		//{suffixes are separted in buckets containing strings starting with the same h characters}

		for (int i = 0; i < n; i = Next[i])
		{
			cnt[i] = 0;
			for (int j = i; j < Next[i]; ++j)
			{
				Rank[suffixArray[j]] = i;
			}
		}

		cnt[Rank[n - h]]++;
		b2h[Rank[n - h]] = true;
		for (int i = 0; i < n; i = Next[i])
		{
			for (int j = i; j < Next[i]; ++j)
			{
				int s = suffixArray[j] - h;
				if (s >= 0){
					int head = Rank[s];
					Rank[s] = head + cnt[head]++;
					b2h[Rank[s]] = true;
				}
			}
			for (int j = i; j < Next[i]; ++j)
			{
				int s = suffixArray[j] - h;
				if (s >= 0 && b2h[Rank[s]]){
					for (int k = Rank[s]+1; !bh[k] && b2h[k]; k++) b2h[k] = false;
				}
			}
		}
		for (int i=0; i<n; ++i)
		{
			suffixArray[Rank[i]] = i;
			bh[i] |= b2h[i];
		}
	}
	for (int i=0; i<n; ++i)
	{
		Rank[suffixArray[i]] = i;
	}
}
// End of suffix array algorithm

/*
Begin of the O(n) longest common prefix algorithm
Refer to "Linear-Time Longest-Common-Prefix Computation in Suffix
Arrays and Its Applications" by Toru Kasai, Gunho Lee, Hiroki
Arimura, Setsuo Arikawa, and Kunsoo Park.
*/

/*
Note to say Suffix [i] always means the Ith suffix in LEXOGRAPHICALLY SORTED ORDER
ie Height[i]=LCPs of (Suffix   i-1 ,suffix  i)
*/

void getHeight(int n)
{
	for (int i=0; i<n; ++i) Rank[suffixArray[i]] = i;
	Height[0] = 0;
	for (int i=0, h=0; i<n; ++i)
	{
		if (Rank[i] > 0)
		{
			int j = suffixArray[Rank[i]-1];
			while (i + h < n && j + h < n && str[i+h] == str[j+h])
			{
				h++;
			}
			Height[Rank[i]] = h;
			if (h > 0) h--;
		}
	}
}
// End of longest common prefixes algorithm

/*When the LCP of consecutive pair of Suffixes is Knows 

THEN:
We can calculate the LCPs of any suffixes (i,j)
with the Help of Following Formula

************************************************
*  LCP(suffix i,suffix j)=LCP[RMQ(i + 1; j)]   * 
*                                              *
*  Also Note (i<j) As LCP (suff i,suff j) may  *
*  not necessarly equal LCP (Suff j,suff i).   *
************************************************
*/

void preprocesses(int N)
{
	int i, j;

	//initialize M for the intervals with length 1
	for (i = 0; i < N; i++)
		M[i][0] = i;

	//compute values from smaller to bigger intervals
	for (j = 1; 1 << j <= N; j++)
	{
		for (i = 0; i + (1 << j) - 1 < N; i++)
		{
			if (Height[M[i][j - 1]] < Height[M[i + (1 << (j - 1))][j - 1]])
			{
				M[i][j] = M[i][j - 1];
			}
			else
			{
				M[i][j] = M[i + (1 << (j - 1))][j - 1];
			}
		}
	}
}  
int RMQ(int i,int j)
{
	int k=log((double)(j-i+1))/log((double)2);
	int vv= j-(1<<k)+1 ;
	if(Height[M[i][k]]<=Height[ M[vv][ k] ])
		return M[i][k];
	else
		return M[ vv ][ k];
}
int LCP(int i,int j)
{
	/*Make sure we send i<j always */
	/* By doing this ,it resolve following
	suppose ,we send LCP(5,4) then it converts it to LCP(4,5)
	*/
	if(i>j)
		swap(i,j);

	/*conformation over*/

	if(i==j)
	{
		return (Length_of_str-suffixArray[i]);
	}
	else
	{
		return Height[RMQ(i+1,j)];
		//LCP(suffix i,suffix j)=LCPadj[RMQ(i + 1; j)] 
		//LCPadj=LCP of adjacent suffix =Height.
	}
}


#define MAXN 200050

struct BIT
{

    int TREE[MAXN];
    
    BIT(void){
        for(int i=0;i<MAXN;i++)TREE[i]=0;
    }
    
    void update(int idx, int val)
    {
        for (; idx < MAXN; idx += idx & -idx) TREE[idx] += val;
    }
    
    int get(int idx)
    {
        int s = 0;
        for (; idx; idx -= idx & -idx) s += TREE[idx];
        return s;
    }
};

map<int,int> mp;
map<int,int>::iterator it;

inline void compress(void){
	int curr=1;
	for(it=mp.begin();it!=mp.end();it++)mp[it->first]=curr++;
}

int N;

ll val[MAXN];

inline void ReadInput(void){
	si(N);
	for(int i=0;i<N;i++){
		si(str[i]);
		mp[str[i]];
	}
}

BIT P;

inline void solve(void){
	int _N=2*N;

	compress();

	for(int i=N;i<_N;i++){
		str[i-N]=mp[str[i-N]];
		str[i]=str[i-N];
	}

	Length_of_str=_N;

	suffixSort(_N);

	getHeight(_N);

	preprocesses(_N);

	ll inv=0;

	for(int i=1;i<=N;i++){
		inv += (i-1-P.get(str[i-1]));
		P.update(str[i-1],1);
	}

	val[0] = inv;

	ll maxinv=inv;

	for(int i=1;i<N;i++){
		ll low,high;
		low=P.get(str[i-1]-1);
		high=P.get(MAXN-1)-P.get(str[i-1]);
		inv -= low;
		inv += high;
		val[i] = inv;
		maxinv = max(maxinv,val[i]);
	}

    //for(int i=0;i<N;i++)cout<<val[i]<<" ";
    //cout<<endl;
    
    int idx,ans;

	for(int i=0;i<_N;i++){
		if(suffixArray[i]<N and val[suffixArray[i]]==maxinv){
			idx=i;
			break;
		}
	}
    
    //cout<<idx<<endl;
    
    //for(int i=0;i<_N;i++)cout<<suffixArray[i]<<" ";
    //cout<<endl;

    ans=suffixArray[idx];
    
	for(int i=idx+1;i<_N;i++){
		if(val[suffixArray[i]]==maxinv and Height[i]>=N)ans=min(ans,suffixArray[i]);
		else break;
	}

	printf("%d %lld\n",ans,maxinv );



}

inline void Refresh(void){
	mp.clear();
	for(int i=0;i<MAXN;i++)P.TREE[i]=0;
}

int main()
{
	int t; si(t);
	while(t--){
		ReadInput();
		solve();
		Refresh();
	}
	return 0;
}