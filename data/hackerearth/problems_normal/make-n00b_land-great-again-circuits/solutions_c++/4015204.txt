/*******************************
*  Bismillahir Rahminir Rahim  * 
*******************************/
 
#include <bits/stdc++.h>
 
#define READ(x)     freopen(x, "r", stdin) 
#define WRITE(x)    freopen(x, "w", stdout)

#define REP(i, n)   for(ll i=0;i<n;i++)
#define REPN(i, n)  for(ll i=1;i<=n;i++)
#define SET(i, n)   memset(i, n, sizeof(i))
 
#define MAX         500050
#define INF         (1 << 29)
#define pb          push_back
 
using namespace std;
 
typedef long long       ll;
typedef pair<ll, ll>  pii;
typedef double 			db;

const ll mx = 1500000000000000000; 

ll n, m, q, F[MAX], D[MAX], X[MAX], need[MAX];
vector<ll>edge[MAX], owned[MAX], M[MAX];
ll st[MAX], en[MAX], t;
ll lo[MAX], hi[MAX];
ll BIT[3][MAX], ret[MAX];
ll dep[MAX];

void update(ll id, ll idx, ll val){
	while(idx <= n){
		BIT[id][idx] += val;
		idx += (idx & -idx);
	}
}

ll query(ll id, ll idx){
	ll ret = 0;
	while(idx > 0){
		ret += BIT[id][idx];
		idx -= (idx & -idx);
	}
	return ret;
}

void apply(ll id){
	ll nd = F[id];
	/*

	x + (depU - depR) * d
	x + depU * d - depR * d

	1 -> depU * d 


	*/
	update(0, st[nd], dep[nd] * D[id] );
	update(0, en[nd]+1, -(dep[nd] * D[id]) );
	update(1, st[nd], D[id]);
	update(1, en[nd]+1, -D[id]);
	update(2, st[nd], X[id]);
	update(2, en[nd]+1, -X[id]);
}

ll get(ll id){
	ll r1 = query(0, st[id]);
	ll r2 = query(1, st[id]) * dep[id];
	ll r3 = query(2, st[id]);
	return r2 + r3 - r1;
}

void dfs(ll at, ll d){
	t++;
	st[at] = t;
	dep[at] = d;
	REP(i, edge[at].size()){
		ll u = edge[at][i];
		dfs(u, d+1);
	}
	en[at] = t;
}

int main(){
	SET(ret, -1);
	ll x, y;
	scanf("%lld %lld", &n, &m);
	for(ll i=2;i<=n;i++){
		scanf("%lld", &x);
		edge[x].pb(i);
	}
	dfs(1, 0);
	REPN(i, n){
		scanf("%lld", &x);
		owned[x].pb(i);
	}
	REPN(i, m) scanf("%lld", &need[i]);
	scanf("%lld", &q);
	REPN(i, q)	scanf("%lld %lld %lld", &F[i], &X[i], &D[i]); 
	REPN(i, m){
		lo[i] = 1;
		hi[i] = q;
		M[ ( lo[i] + hi[i] ) / 2 ].pb(i);
	}
	bool flag = true;
	while(flag){
		SET(BIT, 0);
		flag = false;
		REPN(i, q){
			apply(i);
			// cout << "-----------\n";
			REP(f, M[i].size()){
				ll u = M[i][f];
				ll tot = 0;
				REP(j, owned[u].size()){
					ll v = owned[u][j];
					// cout << v << " " << get(v) << endl;
					tot += get(v);
					if(tot >= mx) break;
				}
	 
	 			if(tot >= need[u]){
					ret[u] = i;
					hi[u] = i - 1;
				}
				else lo[u] = i + 1;
				

				// cout << "~~~ " << tot << endl;

				if(lo[u] <= hi[u]){
					M[ (lo[u] + hi[u]) / 2  ].pb(u);
					flag = true;
				}
			}
			M[i].clear();
		}
	}
	REPN(i, m){
		if(ret[i] == -1) printf("rekt\n");
		else printf("%lld\n", ret[i]);
	}
	return 0;
}
