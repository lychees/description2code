#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair<ll,ll> ii;
typedef vector<ll> vi;
typedef vector< ii > vii;

#define INF 0x3F3F3F3F
#define LINF 0x3F3F3F3F3F3F3F3FLL
#define pb push_back
#define mp make_pair
#define pq priority_queue
#define LSONE(s) ((s)&(-s)) //LASTBIT
#define DEG_to_RAD(X)   (X * PI / 180)
#define F first
#define S second
#define PI 2*acos(0)

#ifdef ONLINE_JUDGE
#define debug(args...)
#else
#define debug(args...) fprintf(stderr,args)
#endif

//////////////////////
int dx[] = {1,-1,0,0};
int dy[] = {0,0,-1,1};
//////////////////////

const int N = 100101;
const int M = 18;

int n, m;
set<int> g[N];
int lca[N][M], h[N], subSize[N], par[N];

void dfs0( int x, int ult, int prof ) {
  h[x] = prof;
  lca[x][0] = ult;
  for(set<int>::iterator i=g[x].begin();i!=g[x].end();i++) {
    int y = *i;
    if( y == ult ) continue;
    dfs0(y,x,prof+1);
  }
}

int nc;

void dfs1( int x, int ult ) {
  nc++;
  subSize[x] = 1;
  for(set<int>::iterator i=g[x].begin();i!=g[x].end();i++) {
    int y = *i;
    if( y == ult ) continue;
    dfs1(y,x);
    subSize[x]+=subSize[y];
  }
}

int dfs2( int x, int ult ) {
  for(set<int>::iterator i=g[x].begin();i!=g[x].end();i++) {
    int y = *i;
    if( y == ult ) continue;
    if( subSize[y] > nc / 2 ) return dfs2(y,x);
  }
  return x;
}

void process() {
  for(int j=1;j<M;++j) for(int i=0;i<=n;++i) lca[i][j] = lca[lca[i][j-1]][j-1];
}

int get_lca( int a, int b ) {
  if( h[a] < h[b] ) swap(a,b);
  int d = h[a]-h[b];
  for(int i=M-1;i>=0;--i) if( d&(1<<i) ) a = lca[a][i];
  if( a == b ) return a;
  for(int i=M-1;i>=0;--i) if( lca[a][i] != lca[b][i] ) a = lca[a][i], b = lca[b][i];
  return lca[a][0];
}

int get_dis( int a, int b ) {
  return h[a]+h[b]-2*h[get_lca(a,b)];
}

void preprocess() {
  dfs0(1,0,0);
  process();
}

void decompose( int x, int ult ) {
  nc = 0;
  dfs1(x,x);
  int centro = dfs2(x,x);
  if( ult == -1 ) par[centro] = centro;
  else par[centro] = ult;
  for(set<int>::iterator  i=g[centro].begin();i!=g[centro].end();i++)
  {
    g[*i].erase(centro);
    decompose(*i,centro);
  }
  g[centro].clear();
}


vi revCentroid[N];
int root;
int numero[N];



map< ii, int > my;
multiset<ii> dis[N];
multiset<ii> :: iterator it;

int ans;
int cor[N];
vi gC[N];


int go(int c) {
  ans = 0;
  for(int i = 0; i < gC[c].size(); ++i) {
    int x = gC[c][i];
    int u = x;
    while(1) {
      if(cor[u] == c) ans = max(ans, get_dis(u, x));
      if(u == par[u]) break;

      ii foo = ii(par[u],numero[u]);
      if(my.find(foo) != my.end()) dis[par[u]].erase(ii(my[foo], numero[u]));
      if(dis[par[u]].size() >= 1) {
        it = dis[par[u]].end(); it--;
        ans = max((ll)ans, get_dis(par[u], x) + it->F);
      }
      my[foo] = max(my[foo], get_dis(par[u], x));
      dis[par[u]].insert(ii(my[foo], numero[u]));

      u = par[u];
    }
  }
  return ans;
}

inline void clean(int c) {
  my.clear();
  for(int i = 0; i < gC[c].size(); ++i) {
    int x = gC[c][i];
    int u = x;
    while(1) {
      dis[u].clear();
      if(u == par[u]) break;
      u = par[u];
    }
  }
}

void goEnumerate(int x) {
  for(int i = 0; i < revCentroid[x].size(); ++i) {
    int y = revCentroid[x][i];
    numero[y] = i;
    goEnumerate(y);
  }
}

int main()
{
  //ios::sync_with_stdio(0);
  scanf("%d %d", &n, &m);
  for(int i = 1; i <= n; ++i) {
    scanf("%d", cor + i);
    gC[cor[i]].pb(i);
  }
  for(int i = 0; i + 1 < n; ++i) {
    int a,b; scanf("%d %d",&a,&b);
    g[a].insert(b); g[b].insert(a);
  }
  preprocess();
  decompose(1, -1);

  for(int i = 1; i <= n; ++i) {
    if(i == par[i]) root = i;
    else revCentroid[par[i]].pb(i);
  }

  goEnumerate(root);
  for(int i = 1; i <= m; ++i) {
    printf("%d ", go(i));
    clean(i);
  }
  printf("\n");
  return 0;
}