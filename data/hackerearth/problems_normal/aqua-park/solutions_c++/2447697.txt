#include <bits/stdc++.h>

#define MAXX 10002
#define MAXN 101

using namespace std;

typedef pair < int, double > dd;

int N, X;
dd start[MAXN], stop[MAXN];

double findH(int idx, int X) {
    double dx = (start[idx].first-stop[idx].first);
    double dy = (start[idx].second-stop[idx].second);
    double step = dy/dx;
    double retVal;
    if (start[idx].second < stop[idx].second)
        retVal = start[idx].second + (X-start[idx].first)*step;
    else
        retVal = stop[idx].second + (X-stop[idx].first)*step;
    return retVal;
}

int next(int x_coord, double y_coord) {
    int retVal = -1;
    double maxNow = -1.0;
    for (int i=0; i<N; i++) {
        if (min(start[i].first, stop[i].first) <= x_coord && x_coord <= max(start[i].first, stop[i].first)) {
            double H = findH(i, x_coord);
            if (H < y_coord && H > maxNow) {
                retVal = i;
                maxNow = H;
            }
        }
    }
    return retVal;
}

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> X >> N;

    int tmpX, tmpY, stpX, stpY;
    for (int i=0; i<N; i++) {
        cin >> tmpX >> tmpY >> stpX >> stpY;
        if (tmpY < stpY) {
            start[i].first = stpX; start[i].second = stpY;
            stop[i].first = tmpX; stop[i].second = tmpY;
        }
        else {
            start[i].first = tmpX; start[i].second = tmpY;
            stop[i].first = stpX; stop[i].second = stpY;
        }
    }

    int xNow = X;
    double yNow = 10000.0;

    int go = next(xNow, yNow);

    while (go != -1) {
        xNow = (stop[go].first);
        yNow = (stop[go].second);
        go = next(xNow, yNow);
    }

    cout << xNow << endl;

    return 0;
}

/**#include <bits/stdc++.h>

#define l 2*pos
#define r 2*pos+1
#define mid (i+j)/2

#define offset 100005
#define MAXN 300010   /// change this

using namespace std;

int T, M;
bool lazy[4*MAXN];
int seg_tree[4*MAXN];
int dWage, minWage, peopleLeft;

int target, start, stop;

void propagate(int pos, int i, int j) {
    if (lazy[pos] == true) {
        seg_tree[pos] = 0;
        if (i != j) {
            lazy[l] = true;
            lazy[r] = true;
        }
        lazy[pos] = false;
    }
}

void add(int pos, int i, int j) {
    propagate(pos, i, j);

    if (i == j) {
        seg_tree[pos] ++;
        return;
    }

    if (target <= mid) add(l, i, mid);
    else               add(r, mid+1, j);
    seg_tree[pos] = seg_tree[l]+seg_tree[r];
}

int query(int pos, int i, int j) {
    propagate(pos, i, j);

    if (j < start || stop < i || j < i)
        return 0;

    if (start <= i && j <= stop)
        return seg_tree[pos];

    return (query(l, i, mid) + query(r, mid+1, j));
}

void zero(int pos, int i, int j) {
    propagate(pos, i, j);

    if (j < start || stop < i || j < i) return;

    if (start <= i && j <= stop) {
        lazy[pos] = true;
        propagate(pos, i, j);
        return;
    }

    zero(l, i, mid);
    zero(r, mid+1, j);

    seg_tree[pos] = seg_tree[l] + seg_tree[r];
}

int Kth(int pos, int i, int j, int _K) {
    if (i == j && _K == 1)
        return i;

    if (i == j)
        return -1;

    if (seg_tree[r] >= _K)
        return Kth(r, mid+1, j, _K);
    else
        return Kth(l, i, mid, _K-seg_tree[r]);
}

void Solve() {
    scanf("%d %d", &M, &minWage);

    int K;
    char cmd[2];

    for (int i=0; i<M; i++) {
        scanf("%s %d", &cmd, &K);

        if (cmd[0] == 'I') {
            if (K < minWage) continue;
            K = K - dWage + offset;
            target = K;
            add(1, 0, MAXN-1);
        } else if (cmd[0] == 'A') {
            dWage += K;
        } else if (cmd[0] == 'S') {
            dWage -= K;
            start = 0; stop = minWage+offset-dWage-1;
            peopleLeft += query(1, 0, MAXN-1);
            zero(1, 0, MAXN-1);
        } else {
            if (seg_tree[1] < K) printf("-1\n");
            else printf("%d\n", Kth(1, 0, MAXN-1, K)-offset+dWage);
        }
    }
    printf("%d\n", peopleLeft);
}

int main()
{
    scanf("%d", &T);

    while (T --) {
        memset(seg_tree, 0, sizeof seg_tree);
        memset(lazy, false, sizeof lazy);
        peopleLeft = 0;
        dWage = 0;
        Solve();
    }

    return 0;
}**/
