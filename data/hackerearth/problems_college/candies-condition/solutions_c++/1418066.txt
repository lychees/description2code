#include <iostream>
#include <vector>
#include <cstdio>
#include <sstream>
#include <map>
#include <string>
#include <algorithm>
#include <queue>
#include <cmath>
#include <set>
#include "assert.h"
using namespace std;

#define MOD 1000000007

long long gcd(long long a, long long b){
	if(b==0) return a;
	return gcd(b, a%b);
}

long long lcm(long long a, long long b){
	if(a<b) swap(a,b);
	if(b==1) return a;
	return a * (b/gcd(a,b));
}

vector<int> Eratosthenes(int N){
	vector<bool> v(N+1, true);
	v[0] = v[1] = false;
	int sqN = sqrt(N);
	for(int i=2; i<=sqN; i++){
		if(v[i] == false) continue;
		for(int j=i*i; j<=N; j+=i){
			v[j] = false;
		}
	}
	vector<int> Prime;
	for(int i=2; i<=N; i++){
		if(v[i]==true) Prime.push_back(i);
	}
	return Prime;
}

vector<pair<long long, long long> > prime_factorization(long long N){
	vector< pair<long long, long long> > ret;
	
	for(long long i=2; i*i<=N; i++){
		long long tmp = 0;
		while(N%i==0){
			tmp++;
			N/=i;
		}
		if(tmp>0){
			ret.push_back( make_pair(i, tmp) );
		}
	}
	if(N!=1){
		ret.push_back( make_pair(N, 1) );
	}
	return ret;
}

class SegmentTreeMAX{
	int n;
	vector<int> T;
public:
	SegmentTreeMAX(int size){
		n=1;
		while(n<size) n <<= 1;
		T.resize(2*n - 1);
		fill(T.begin(), T.end(), 0);
	}

	//basic array[k] <- val
	void update(int k, int val){
		//array[0] <=> T[n-1]
		k += n-1;
		T[k] = val;
		while(k>0){
			//k = (k-1)/2 == 0, then break
			k = (k-1)/2;
			T[k] = max(T[k*2 + 1], T[k*2 + 2]);
		}
	}
	//return maximum value [a,b)
	//T[k] covers [l,r)
	int RMQ(int a, int b, int k, int l, int r){
		//out of range
		if(r <= a || b <= l) return 0;
		//covered
		if(a <= l && r <= b) return T[k];
		//partially covered
		else{
			int val_left = RMQ(a,b, k*2+1, l, (l+r)/2);
			int val_right = RMQ(a,b, k*2+2, (l+r)/2, r);
			return max(val_left, val_right);
		}
	}

	int RMQ(int l, int r){
		return RMQ(l,r, 0, 0,n);
	}

	int size(){
		return n;
	}
};


long long mypow(long long x, long long y){
	if(x==0) return 0;
	long long ret=1LL;
	while(y>0LL){
		if(y&1LL) ret = (ret * x) % MOD;
		x = (x*x) % MOD;
		y >>= 1LL;
	}
	return ret;
}

int main(){
	auto Prime = Eratosthenes(1000);
	vector<int> prime_map(1001, -1);
	for(int i=0; i<Prime.size(); i++){
		prime_map[ Prime[i] ] = i;
	}

	int T;
	cin >> T;
	while(T--){
		int n;
		cin >> n;

		vector<SegmentTreeMAX> seg(Prime.size(), SegmentTreeMAX(16384+200));

		auto my_update = [&](int at, int val){
			auto tmp = prime_factorization(val);
			for(int i=0; i<Prime.size(); i++){
				seg[i].update(at, 0);
			}
			for(int i=0; i<tmp.size(); i++){
				seg[ prime_map[ tmp[i].first ] ].update(at, tmp[i].second);
			}
		};

		//[l,r)
		auto my_lcm = [&](int l, int r) -> long long{
			long long ret = 1;
			bool update = false;
			for(int i=0; i<Prime.size(); i++){
				int cnt = seg[i].RMQ(l,r);
				if(cnt == 0) continue;
				update = true;
				ret *= mypow(Prime[i], cnt);
				ret %= MOD;
			}
			if(update == false) ret = 0;
			return ret;
		};

		vector<int> A(n);
		for(int i=0; i<n; i++){
			cin >> A[i];
			my_update(i, A[i]);
		}
		
		int Q;
		cin >> Q;
		assert(1<=Q && Q <= 1000);

		for(int i=0; i<Q; i++){
			int q,a,b;
			scanf("%d%d%d", &q, &a, &b);
			if(q==0){
				my_update(a-1, b);
			}else if(q==1){

				long long ans = my_lcm(a-1,b);

				cout << ans << endl;
			}
		}
	}
	return 0;
}