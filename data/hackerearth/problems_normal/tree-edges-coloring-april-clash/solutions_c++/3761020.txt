#include <cstdio>
#include <cmath>
#include <iostream>
#include <set>
#include <algorithm>
#include <vector>
#include <map>
#include <cassert>
#include <string>
#include <cstring>
#include <queue>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define P(x) printf("%d\n",x)
#define all(v) v.begin(),v.end()
#define FF first
#define SS second

typedef long long int LL;
typedef pair<int, int > pii;
typedef vector<int > vi;

const int N = 101;
#define prev afdasdfasd
const int oo = 10000007;

int cost[N][N]; //cost matrix
int nx, ny, max_match; //n workers and n jobs
int lx[N], ly[N]; //labels of X and Y parts
int xy[N]; //xy[x] - vertex that is matched with x,
int yx[N]; //yx[y] - vertex that is matched with y
bool S[N], T[N]; //sets S and T in algorithm
int slack[N]; //as in the algorithm description
int slackx[N]; //slackx[y] such a vertex, that
 // l(slackx[y]) + l(y) - w(slackx[y],y) = slack[y]
int prev[N]; //array for memorizing alternating paths

void init_labels()
{
 memset(lx, 0, sizeof(lx));
 memset(ly, 0, sizeof(ly));
 for (int x = 0; x < nx; x++)
 for (int y = 0; y < ny; y++)
     lx[x] = max(lx[x], cost[x][y]);
}

void update_labels()
{
 int x, y;
 int delta = oo; //init delta as infinity
 for (y = 0; y < ny; y++) //calculate delta using slack
 if (!T[y])
 delta = min(delta, slack[y]);
 for (x = 0; x < nx; x++) //update X labels
 if (S[x]) lx[x] -= delta;
 for (y = 0; y < ny; y++) //update Y labels
 if (T[y]) ly[y] += delta;
 for (y = 0; y < ny; y++) //update slack array
 if (!T[y])
 slack[y] -= delta;
}

void add_to_tree(int x, int prevx) 
//x - current vertex,prevx - vertex from X before x in the alternating path,
//so we add edges (prevx, xy[x]), (xy[x], x)
{
 S[x] = true; //add x to S
 prev[x] = prevx; //we need this when augmenting
 for (int y = 0; y < ny; y++) //update slacks, because we add new vertex to S
 if (lx[x] + ly[y] - cost[x][y] < slack[y])
 {
 slack[y] = lx[x] + ly[y] - cost[x][y];
 slackx[y] = x;
 }
}

void augment() //main function of the algorithm
{
 if (max_match == min(nx, ny)) return; //check wether matching is already perfect
 int x, y, root; //just counters and root vertex
 int q[N], wr = 0, rd = 0; //q - queue for bfs, wr,rd - write and read
 //pos in queue
 memset(S, false, sizeof(S)); //init set S
 memset(T, false, sizeof(T)); //init set T
 memset(prev, -1, sizeof(prev)); //init set prev - for the alternating tree
 for (x = 0; x < nx; x++) //finding root of the tree
 if (xy[x] == -1)
 {
 q[wr++] = root = x;
 prev[x] = -2;
 S[x] = true;
 break;
 }

 for (y = 0; y < ny; y++) //initializing slack array
 {
 slack[y] = lx[root] + ly[y] - cost[root][y];
 slackx[y] = root;
 }
//second part of augment() function
 while (true) //main cycle
 {
 while (rd < wr) //building tree with bfs cycle
 {
 x = q[rd++]; //current vertex from X part
 for (y = 0; y < ny; y++) //iterate through all edges in equality graph
 if (cost[x][y] == lx[x] + ly[y] && !T[y])
 {
 if (yx[y] == -1) break; //an exposed vertex in Y found, so
 //augmenting path exists!
 T[y] = true; //else just add y to T,
 q[wr++] = yx[y]; //add vertex yx[y], which is matched
 //with y, to the queue
 add_to_tree(yx[y], x); //add edges (x,y) and (y,yx[y]) to the tree
 }
 if (y < ny) break; //augmenting path found!
 }
 if (y < ny) break; //augmenting path found!

 update_labels(); //augmenting path not found, so improve labeling
 wr = rd = 0; 
 for (y = 0; y < ny; y++) 
 //in this cycle we add edges that were added to the equality graph as a
 //result of improving the labeling, we add edge (slackx[y], y) to the tree if
 //and only if !T[y] && slack[y] == 0, also with this edge we add another one
 //(y, yx[y]) or augment the matching, if y was exposed
 if (!T[y] && slack[y] == 0)
 {
 if (yx[y] == -1) //exposed vertex in Y found - augmenting path exists!
 {
 x = slackx[y];
 break;
 }
 else
 {
 T[y] = true; //else just add y to T,
 if (!S[yx[y]]) 
 {
 q[wr++] = yx[y]; //add vertex yx[y], which is matched with
 //y, to the queue
 add_to_tree(yx[y], slackx[y]); //and add edges (x,y) and (y,
 //yx[y]) to the tree
 }
 }
 }
 if (y < ny) break; //augmenting path found!
 }

 if (y < ny) //we found augmenting path!
 {
 max_match++; //increment matching
 //in this cycle we inverse edges along augmenting path
 for (int cx = x, cy = y, ty; cx != -2; cx = prev[cx], cy = ty)
 {
 ty = xy[cx];
 yx[cy] = cx;
 xy[cx] = cy;
 }
 augment(); //recall function, go to step 1 of the algorithm
 }
}//end of augment() function

int hungarian()
{
 int ret = 0; //weight of the optimal matching
 max_match = 0; //number of vertices in current matching
 memset(xy, -1, sizeof(xy)); 
 memset(yx, -1, sizeof(yx));
 init_labels(); //step 0
 augment(); //steps 1-3
 for (int x = 0; x < nx; x++) //forming answer there
 ret += cost[x][xy[x]];
 return ret;
}

int C[N];
int dp[N][N];
int n;
vi g[N];

int dfs(int c, int p, int col) {
  int &res = dp[c][col];
  if(res != -1) return res;

  if(g[c].size() == 1 && p != -1) {
    return res = 0;
  }

  rep(i,0,g[c].size()) if(g[c][i] != p) {
    rep(j,1,n) if(j != col) {
      dfs(g[c][i], c, j);
    }
  }

  nx = g[c].size();
  ny = n - 1;
  int flag = 0;
  rep(i,0,nx) {
    if(g[c][i] == p) {
      flag = 1;
      continue;
    }
    rep(j,0,ny) {
      if(j + 1 == col) {
        cost[i-flag][j] = -oo;
      } else {
        cost[i-flag][j] = -(C[j+1] + (dp[g[c][i]][j+1] != -1 ? dp[g[c][i]][j+1] : oo));
      }
    }
  }
  if(p != -1) nx--;

  res = -hungarian();
  // rep(i,0,nx) {
  //   rep(j,0,ny) printf("%d %d %d\n",i,j,cost[i][j]);
  // }
  // printf("%d %d %d %d %d %d\n",c,p,col,nx,ny,res);
  
  return res;
}

int main() {
  int t;
  S(t);
  while(t--) {
    S(n);
    rep(i,1,n) S(C[i]);

    rep(i,1,n+1) g[i].clear();
    rep(i,1,n) {
      int u,v;
      S2(u,v);
      g[u].push_back(v);
      g[v].push_back(u);
    }

    memset(dp, -1, sizeof(dp));
    P(dfs(1, -1, 0));
  }
  return 0;
}