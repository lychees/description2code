#include <bits/stdc++.h>

#define FO(i,a,b) for (int i = (a); i < (b); i++)
#define sz(v) int(v.size())

using namespace std;

// http://e-maxx.ru/algo/suffix_automata
struct state {
    int len, link ;
    map <char,int> next;
    int na, nb;
    int cnt; // how many "ways" here
    int ind; // indegree
}; 

const int MAXLEN = 500000;
state st [MAXLEN*2];
int sz, last; 

void sa_init() {
    sz = last = 0;
    st[0].len = 0;
    st[0].link = -1;
    ++sz;
}

void sa_extend (char c) {
    int cur = sz++;
    st[cur].len = st[last].len + 1;
    int p;
    for (p=last; p!=-1 && !st[p].next.count(c); p=st[p].link)
        st[p].next[c] = cur;
    if (p == -1)
        st[cur].link = 0;
    else {
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len)
            st[cur].link = q;
        else {
            int clone = sz++;
            st[clone].len = st[p].len + 1;
            st[clone].next = st[q].next;
            st[clone].link = st[q].link;
            for (; p!=-1 && st[p].next[c]==q; p=st[p].link)
                st[p].next[c] = clone;
            st[q].link = st[cur].link = clone;
        }
    }
    last = cur;
}

long long res;

void calcn(int i) {
    if (st[i].na + st[i].nb) return;
    for (const auto &p : st[i].next) {
        char c; int j; tie(c,j) = p;
        if (c == '.') st[i].na++;
        else if (c == '-') st[i].nb++;
        else {
            calcn(j);
            st[i].na += st[j].na;
            st[i].nb += st[j].nb;
        }
    }
    if (i) {
        res += st[i].na * 1ll * st[i].nb * 1ll * (st[i].len - st[st[i].link].len);
    }
}

char buf[100005];

int main() {
    sa_init();
    int n, m;
    scanf("%d", &n);
    FO(i,0,n) {
        scanf("%s", buf);
        for (int j = 0; buf[j]; j++) sa_extend(buf[j]);
        sa_extend('#');
    }
    sa_extend('.');
    scanf("%d", &m);
    FO(i,0,m) {
        scanf("%s", buf);
        for (int j = 0; buf[j]; j++) sa_extend(buf[j]);
        sa_extend('$');
    }
    sa_extend('-');

    calcn(0);

    printf("%lld\n", res);
}

