/* Since No. of dices is very small we will try to count number of ways directly.

   Since string is K letters long ,we will require K letters,one letter from each dice.

   We require K dices out of N dices ...Number of ways NCK...We want to select K size Subsets of all subsets possible from N dices..
 
   Thus we have to generate all subsets possible from N dices and check which of the subsets contain K elements/dices.

   suppose we have a permutation of K dices,we have to check whether we can form the string or not and if we can form the string the number of ways to do so...

   Suppose the first dice contains the first letter of string,second dice contains contains the second letter of string and so on...

   If freq of first character of string in first dice is zero it means it is not a valid permutation,similarly if freq of 2nd character of dice is zero it is not a valid permuation and so on..

   If freq of first character of string in first dice is c[1] then no.of ways*=c[1]; i.e, we can get first character in c[1] ways using this permutation.

   Now we will go to next permutation and check the same conditions....


   Final answer will be the addition of number of ways obtained from each permutation...


  */

 #include<bits/stdc++.h>
 using namespace std;

 #define ll long long

 const int N=42;

 const int MOD=1000000007;

 ll freq[N][N];

 int main(){

     for(int i=0;i<N;++i)
         for(int j=0;j<N;++j)
             freq[i][j]=0;

     int n,k;

     cin>>n>>k;

     char x;

     for(int i=0;i<n;++i){


          for(int j=0;j<6;++j){

               cin>>x;
              
               freq[i][x-'a']++;

          }

    }

    string s;

    cin>>s;

    ll ans=0;

    for(int i=0;i<(1<<n);++i){

           if(__builtin_popcount(i)==k){

                 vector<int> cubes;
   
                 int index=0;
 
                 int val=i;

                 while(val){

                      if(val&1){

                           cubes.push_back(index);
                          
                      }

                      ++index;
                      val>>=1;

                 }

                 sort(cubes.begin(),cubes.end());

                 do{
 
                     ll ways=1;

                     for(int q=0;q<k;q++){

                          int ch=s[q]-'a';
                           
                          int cube_no=cubes[q];

                          if(freq[cube_no][ch]>0){

                              ways*=freq[cube_no][ch];
                              ways%=MOD;

                          }

                          else
                              ways=0;

                    }

                    ans+=ways;
                    ans%=MOD;
               }while(next_permutation(cubes.begin(),cubes.end()));

          }

      }

      cout<<ans%MOD<<'\n';

  }  
                 




 