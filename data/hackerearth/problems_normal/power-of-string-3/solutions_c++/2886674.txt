//#define prantoran
//To Infinity And Beyond

#include<bits/stdc++.h>

#define sf scanf
#define pf printf
#define ll long long
#define pii pair<int,int>
#define mp(x,y) make_pair(x,y)
#define ff first
#define ss second
#define vi vector<int>

#define vl vector<ll>
#define pb push_back
#define pdd pair<double,double>
#define pll pair<ll,ll>
#define lazy second
#define val first
#define inf (1<<30)
#define eps 1e-9

using namespace std;

ll mod =1000000007;

ll mod_v(ll nn){return nn%mod;}

template<class T>
T fast_pow(T n , T p){
    if(p==0) return 1;
    if(p%2){
        T g=mod_v ( mod_v(n) * mod_v(fast_pow(n,p-1)) );
        return g;
    }
    else{
        T g=fast_pow(n,p/2);
        g=mod_v( mod_v(g) * mod_v(g) ) ;
        return g;
    }
}

template<class T>
inline T modInverse(T n){
    return fast_pow(n,mod-2);
}

//#####################^^prantoran^^##########################

const int MOD1=(int)1e9 + 7;
const int MOD2=(int)1e9 + 9;
const int N = (int)1e6 + 9;

char s[N];

struct Hash{
    int x,y;
    Hash(){}
    Hash(int _x,int _y){
        x=_x;
        y=_y;
    }
    const bool operator<(Hash other)const {
        if(x==other.x)return y<other.y;
        return x<other.x;
    }
    const bool operator==(Hash other)const{
        return x==other.x && y == other.y;
    }
};

Hash add(Hash a,Hash b){
    Hash res;
    res.x = (a.x + b.x)%MOD1;
    res.y = (a.y + b.y)%MOD2;
    return res;
}

Hash substract(Hash a, Hash b){
    Hash res;
    res.x = (a.x - b.x +MOD1)%MOD1;
    res.y = (a.y - b.y +MOD2)%MOD2;
    return res;
}

Hash multiply(Hash a, Hash b) {
	Hash res;
	res.x = ((ll)a.x * b.x) % MOD1;
	res.y = ((ll)a.y * b.y) % MOD2;
	return res;
}
Hash multiply(Hash a, int v) {
	Hash res;
	res.x = ((ll)a.x * v) % MOD1;
	res.y = ((ll)a.y * v) % MOD2;
	return res;
}

Hash hashes[N]; //string of hashes from start to i
Hash p[N]; //power series
Hash tmp[N];

int main(){
    #ifdef prantoran
        freopen("input.txt","r",stdin);
    #endif // prantoran
   //ios_base::sync_with_stdio(false);

    int n , k;
    sf("%d %d\n",&k,&n);
    gets(s+1); //taking input and storing from staring position s[1]
    p[0]=Hash(1,1); //x^0=1
    hashes[0]=Hash(0,0);
    for(int i = 1 ; i <=n;i++){
        p[i]=multiply(p[i-1],31); //basis:31
        hashes[i]=add(hashes[i-1],multiply(p[i],s[i]-'a'+1));
    }//finish building hash series

    int l = 1,r=n;
    int res=0;
    while(l<=r){
        int m = (l+r)/2;
        int sz=0;
        //m=size of current substrings
        for(int i = m;i<=n;i++){
            tmp[sz++]=multiply(substract(hashes[i],hashes[i-m]),p[n-i]);
        }
        /*analogy:
            1 3 9  27  81
            1 4 13 40 121
              i-m   i
              3 9  27 = 39 = 40-1
        *3      9  27  81
        by multiplying, the hash is flooded to the right, making comparisons simple
        */
        sort(tmp,tmp+sz);
        int curCnt = 1;
        int maxCnt = 1;
        for(int i = 0 ; i<sz;i++){
            if(tmp[i]==tmp[i-1]){
                curCnt++;
            }
            else{
                maxCnt=max(curCnt,maxCnt);
                curCnt=1;
            }
        }
        maxCnt=max(curCnt,maxCnt);
        if(maxCnt>=k){
            res=m;
            l=m+1;
        }
        else{
            r=m-1;
        }

    }
    pf("%d\n",res);

    return 0;
}
