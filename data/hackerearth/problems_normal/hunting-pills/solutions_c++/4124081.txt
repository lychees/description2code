
#include<bits/stdc++.h>
//zone
//Those who cannot face the opponent in front, can never face the opponent beyond !
using namespace std;

vector<vector<int> > components;
vector<int> vt;
bool mrk[10005];
void dfs(int src,vector<int>graph[],stack<int>&s)
{
    mrk[src] = true;
    for(int i = 0 ; i < graph[src].size() ;i++)
    {
        if(!mrk[graph[src][i]])
        {
            dfs(graph[src][i],graph,s);
        }
    }
    s.push(src);
}
void dfs2(int src,long long int &suma,map<int,int>m,vector<int>revgraph[])
{
mrk[src] = true;
//vt.push_back(src);
suma = suma + m[src];
for(int i = 0 ; i< revgraph[src].size(); i++)
{
    if(!mrk[revgraph[src][i]])
    {
        dfs2(revgraph[src][i],suma,m,revgraph);
    }
}
}
int main()
{
    int t;
    cin >> t;
    while(t--)
    {
    int v;
    cin >> v;
    int e;
    cin >> e;
    int x,y;
    int i,j;
    map<int,int> m;
    vector<int>graph[v+1];
    vector<int>revgraph[v+1];
     stack<int> s;
    int boom;
    for(i = 0 ; i < v ; i++)
    {
        cin >> boom;
        m[i] = boom;
    }
    for(i = 0 ; i < e ; i++)
    {
        cin >> x >> y;
        graph[x].push_back(y);
        revgraph[y].push_back(x);
    }
    for(i = 0 ; i < v; i++)
    {
        mrk[i] = false;
    }
    for(i = 0 ; i < v; i++)
    {
        if(!mrk[i])
        {
            dfs(i,graph,s);
        }
    }
    //NOW reversing graph's dfs;
    for(i = 0 ; i < v ; i++)
    {
        mrk[i] = false;
    }
    long long int suma = 0;
    long long int maxi = 0;
    while(!s.empty())
    {
        int tmp = s.top();
        s.pop();
        if(!mrk[tmp])
        {
            dfs2(tmp,suma,m,revgraph);
            //cout<<endl;
           //components.push_back(vt);
           //vt.clear();
           if(maxi < suma)
           {maxi= suma;
           }
           suma = 0;
        }
    }
   /* long long int maxi = 0;
    long long int sum = 0;
    for(i = 0 ; i < components.size(); i++)
    {
       sum = 0;
        for(j = 0 ; j < components[i].size(); j++)
        {
           // cout<<components[i][j] << " ";
            sum = sum + m[components[i][j]];
        }
    //    cout<<endl;
        maxi = max(maxi,sum);
    }*/
    cout<<maxi<<endl;
    //components.clear();
    }

    return 0;
}