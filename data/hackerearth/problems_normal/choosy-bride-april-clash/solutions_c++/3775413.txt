#include <bits/stdc++.h>
#define rep(i,x,y) for (int i = (x); i<=(y); i++)
#define repe(i,x,y) for (int i = (x); i < (y);i++)
#define drep(i,x,y) for (int i = (x); i >= (y); i--)
#define mp make_pair
#define pb emplace_back
#define mt make_tuple
#define gcd __gcd
#define sf(n) scanf("%Lf",&n)
#define prf(n) printf("%.12Lf",n)
#define	s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define pr(n) printf("%d",n)
#define prl(n) printf("%lld",n)
#define endc printf("\n")
#define psp printf(" ")

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int,ll> pii;

const int maxn = 257000;
const ll md = 1e9 + 7;
const ll inf = 1e16;
const pii idt = mp(0,-inf);

pii S[2][8*maxn];
ll lazy[2][8*maxn];
ll A[2][maxn];

void push(int k, int x) {
	if (lazy[k][x] == 0) return;
	
	lazy[k][x+x]+=lazy[k][x]; lazy[k][x+x+1]+=lazy[k][x];
	S[k][x+x].second += lazy[k][x]; S[k][x+x+1].second += lazy[k][x];

	lazy[k][x] = 0;
}


pii query(int k, pii cur, int x,int l,int r,int i,int j) {
	push(k,x);

	int mid = (l+r)>>1;

	if (i <= l && r <= j) { // add segment
		if (l == r) {
			if (S[k][x].second >= cur.second) {
				return mp(cur.first+1,S[k][x].second);
			} else {
				return cur;
			}
		}

		if (S[k][x+x].second < cur.second) {
			return query(k,cur,x+x+1,mid+1,r,i,j);
		} else {
			auto z = query(k,cur,x+x,l,mid,i,j);
			return mp(z.first + S[k][x].first - S[k][x+x].first, max(z.second, S[k][x].second) );
		}
	}

	if (j < l || r < i) return cur;

	pii a = query(k,cur,x+x,l,mid,i,j);
	return query(k,a,x+x+1,mid+1,r,i,j);
}

void update(int k, int x,int l,int r,int i,int j,ll v) {

	push(k,x);

	if (i <= l && r <= j) { lazy[k][x] += v; S[k][x].second += v; return; }
	if (j < l || r < i) return;
	int mid = (l+r)>>1;
	update(k,x+x,l,mid,i,j,v);
	update(k,x+x+1,mid+1,r,i,j,v);

	S[k][x] = query(k,S[k][x+x], x+x+1, mid+1, r, mid+1, r);
}

void init(int k, int x,int l,int r) {

	lazy[k][x] = 0;

	if (l == r) {
		S[k][x] = mp(1,A[k][l]); return;
	}

	int mid = (l+r)>>1;
	init(k,x+x,l,mid); init(k,x + x + 1,mid+1,r);

	S[k][x] = query(k, S[k][x + x], x + x + 1, mid+1, r, mid+1, r);
}

void solve() {

	int n; s(n); int q; s(q);
	rep(i,1,n) {
		sl(A[0][i]);
		A[1][n-i+1] = A[0][i];
	}
	init(0,1,1,n);
	init(1,1,1,n);

	while (q--) {
		int t; s(t);
		if (t == 1) {
			int l,r; s(l); s(r);
			if (l <= r) {
				pr(query(0,idt,1,1,n,l,r).first); endc;
			} else {
				pr(query(1,idt,1,1,n,n-l+1,n-r+1).first); endc;
			}

		} else {
			int l,r; ll x; s(l); s(r); sl(x);
			update(0,1,1,n,l,r,x);
			update(1,1,1,n,n-r+1,n-l+1,x);
		}
	}
}

int main() {
	int t; s(t); while (t--) solve();
}
