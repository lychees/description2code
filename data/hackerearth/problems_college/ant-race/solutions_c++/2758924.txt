#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
int in[1005],pre[1005];
int tree [4005];

int search( int strt, int end, int value);
int preIndex=0;
void buildTree(int i, int inStrt, int inEnd)
{
  
 //cout<<i<<endl;
 
  if(inStrt > inEnd)
     return;
 
  /* Pick current node from Preorder traversal using preIndex
    and increment preIndex */
  tree[i]=(pre[preIndex++]);
 
  /* If this node has no children then return */
  if(inStrt == inEnd)
     return;
 
  /* Else find the index of this node in Inorder traversal */
  int inIndex = search( inStrt, inEnd, tree[i]);
 
  /* Using index in Inorder traversal, construct left and
     right subtress */
    buildTree(2*i+1, inStrt, inIndex-1);
    buildTree(2*i+2, inIndex+1, inEnd);

}
 
/* UTILITY FUNCTIONS */
/* Function to find index of value in arr[start...end]
   The function assumes that value is present in in[] */
int search( int strt, int end, int value)
{
  int i;
  for(i = strt; i <= end; i++)
  {
    if(in[i] == value)
      return i;
  }
}
 
int findLevel(int i,int k, int level)
{
    // Base Case
    if (tree[i]==-1)
        return -1;
 
    // If data is present at root, or in left subtree or right subtree,
    // return true;
    if (tree[i] == k)
        return level;
 
    int l = findLevel(2*i+1, k, level+1);
    return (l != -1)? l : findLevel(2*i+2, k, level+1);
}
int findDistUtil(int i, int n1, int n2, int &d1, int &d2, 
                   int &dist, int lvl)
{
    // Base case
    if (tree[i] == -1) return -1;
 
    // If either n1 or n2 matches with root's data, report
    // the presence by returning root (Note that if a data is
    // ancestor of other, then the ancestor data becomes LCA
    if (tree[i]== n1)
    {
         d1 = lvl;
         return i;
    }
    if (tree[i] == n2)
    {
         d2 = lvl;
         return i;
    }
 
    // Look for n1 and n2 in left and right subtrees
    int x= findDistUtil(2*i+1, n1, n2, d1, d2, dist, lvl+1);
    int y = findDistUtil(2*i+2, n1, n2, d1, d2, dist, lvl+1);
 
    // If both of the above calls return Non-NULL, then one data
    // is present in once subtree and other is present in other,
    // So this node is the LCA
    if (x!=-1&&y!=-1)
    {
        dist = d1 + d2 - 2*lvl;
        return i;
    }
 
    // Otherwise check if left subtree or right subtree is LCA
    return (x!=-1)? x:y;
}

 int findDistance(int i, int n1, int n2)
{
    // Initialize d1 (distance of n1 from root), d2 (distance of n2 
    // from root) and dist(distance between n1 and n2)
    int d1 = -1, d2 = -1, dist;
    int x = findDistUtil(i, n1, n2, d1, d2, dist, 1);
 
    // If both n1 and n2 were present in Binary Tree, return dist
    if (d1 != -1 && d2 != -1)
        return dist;
 
    // If n1 is ancestor of n2, consider n1 as root and find level 
    // of n2 in subtree rooted with n1
    if (d1 != -1)
    {
        dist = findLevel(x, n2, 0);
        return dist;
    }
 
    // If n2 is ancestor of n1, consider n2 as root and find level 
    // of n1 in subtree rooted with n2
    if (d2 != -1)
    {
        dist = findLevel(x, n1, 0);
        return dist;
    }
 
    return -1;
}


int main()
{
  int t,n,sum,sum1,f,d,l;
  cin>>t;
  
  while(t--){
    cin>>n;
    preIndex=0;
    for(int i=0;i<4005;i++)
    tree[i]=-1;
  for(int i=0;i<n;i++)
    {
      cin>>in[i];
      in[i]=in[i];
    }
   for(int i=0;i<n;i++){
    cin>>pre[i];
    pre[i]=pre[i];
   }
 //  cout<<"ys"<<endl;
     buildTree( 0,0, n- 1);
    // cout<<"ys"<<endl;
       cin>>f>>d>>l;
      sum=findDistance(0, f, d);
     sum1=findDistance(0, l, d);
    // deleteTree(&root);
     if(sum>sum1){
      cout<<"SECOND"<<endl;

     }
     else
      cout<<"FIRST"<<endl;
}

 }
