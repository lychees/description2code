/*
Please write complete compilable code.
Read input from standard input (STDIN) and print output to standard output(STDOUT).
For more details, please check http://www.interviewstreet.com/recruit/challenges/faq/view#stdio
*/
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<set>
#include<vector>
using namespace std;
#define ll long long
const int MAXN = 20;
const int MOD = 1000000007;
struct P{
	int x, y;
	P(int x, int y):x(x), y(y) {}
	P() {}
	int operator* (const P &a) {
		return x * a.y - y * a.x;
	}
	P operator- (P &a) {
		return P(x - a.x, y - a.y);
	}
}p[MAXN];

bool dil(P &p1, P &p2, P &p3){
	return ((p1-p3) * (p2-p3)) == 0;
}

struct Po{
	ll msk, s;
	Po(ll msk, int s):msk(msk), s(s) {}
	Po() {}
}q[1 << 20];

ll dp[1 << 16], st[1 << 16], step[1 << 16], v[1 << 16], r[1 << 16];
ll n, l, cnt;

int main(){
	ll i, j, k, m, L;
	ll T;
	//freopen("x.txt", "r", stdin); freopen("w.txt", "w", stdout);
	scanf("%lld", &T);
	L = 1 << 16;
//	for(i = 0; i < L; i++){
//		r[i] = (1 << __builtin_popcount(i));
//	}
	while(T--){
		scanf("%lld", &n);
		l = (1 << n);
		for(i = 0; i < n; i++){
			scanf("%d%d", &p[i].x, &p[i].y);
		}
		memset(st, 0, sizeof(st));
		for(i = 0; i < n; i++){
			st[1 << i] = 1;
			for(j = i + 1; j < n; j++){
				ll msk = (1<<i) + (1<<j);
				for(k = j + 1; k < n; k++) if(i != k && j != k){
					if(dil(p[i], p[j], p[k])){
						msk |= (1<<k);
					}
				}
				for(k = msk; k > 0; k = (k - 1) & msk)
					st[k] = 1;
			}
		}
		cnt = 0;
		for(i = 0; i < l; i++) if(st[i]) v[cnt++] = i;;
		int ans = -1, S, T;
		S = T = 0;
		q[S] = Po(0, 0);
		memset(dp, 0, sizeof(dp));
		memset(step, -1, sizeof(step));
		dp[0] = 1;
		step[0] = 0;
		Po u;
		while(S <= T){
			u = q[S];
			int msk = l - 1 - u.msk;
			S++;
			if(step[l - 1] > -1 && u.s >= step[l - 1]) break;
			if(u.s == step[l-1] - 1){
				if(st[msk]){
					dp[l-1] += dp[u.msk];
					if(dp[l-1] > MOD){
						dp[l-1] -= MOD;
					}
				}
				continue;
			}
			if(r[msk] > cnt){
				for(j = cnt - 1; j >= 0; j--){
					k = v[j];
					if(k & u.msk) continue;
					m = u.msk | k;
					if(step[m] == -1){
						//q.push(Po(m, u.s + 1));
						q[++T] = Po(m, u.s + 1);
						step[m] = step[u.msk] + 1;
						dp[m] = dp[u.msk];
					}else if(step[m] == step[u.msk] + 1){
						dp[m] += dp[u.msk];
						if(dp[m] > MOD){
							dp[m] -= MOD;
						}
					}
				}
			}else{
				for(k = msk; k > 0; k = (k - 1) & msk){
					if(st[k]){
						m = u.msk | k;
						if(step[m] == -1){
							//q.push(Po(m, u.s + 1));
							q[++T] = Po(m, u.s + 1);
							step[m] = step[u.msk] + 1;
							dp[m] = dp[u.msk];
						}else if(step[u.msk | k] == step[u.msk] + 1){
							dp[m] += dp[u.msk];
							if(dp[m] > MOD){
								dp[m] -= MOD;
							}
						}
					}
				}
			}
		}
		printf("%lld %lld\n", step[l - 1], dp[l - 1]);
	}
}
