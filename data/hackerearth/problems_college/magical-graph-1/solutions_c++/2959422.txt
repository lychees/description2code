#include<bits/stdc++.h>
using namespace std;
#define ll long long int
class graph
{
    ll V;
    list<ll> *adj;
    vector<bool> visited;
    vector<bool> recstack;
public:
    graph(ll V)
    {
        this->V=V;
        adj=new list<ll>[V];
        visited.resize(V);
        recstack.resize(V);
    }
    void add_edge(ll source,ll dest)
    {
        adj[source].push_back(dest);
    }
    bool cycle_or_not();
    bool detect_cycle(ll vertex);
};
bool graph::detect_cycle(ll start_vertex)
{
    list<ll>::iterator itr;
    if(!visited[start_vertex])
    {
        recstack[start_vertex]=true;
        visited[start_vertex]=true;
        for(itr=adj[start_vertex].begin();itr!=adj[start_vertex].end();itr++)
        {
            if((!visited[*itr])&&(detect_cycle(*itr)))
                return true;
            else if(recstack[*itr])
                return true;
        }
    }
    recstack[start_vertex]=false;
    return false;
}
bool graph::cycle_or_not()
{
    for(ll i=0;i<V;i++)
    {
        visited[i]=false;
        recstack[i]=false;
    }
    for(ll i=0;i<V;i++)
    {
        if(detect_cycle(i))
            return true;
    }
    return false;
}
int main()
{
    ll i,j,k,num,maxx,minn,source,dest,start_vertex,m,test,e1,e2;
    scanf("%lld",&test);
    int flag;
    while(test--)
    {
        flag=1;
        scanf("%lld%lld%lld",&num,&e1,&e2);
        graph gr(num);
        for(i=0;i<e1;i++)
        {
            scanf("%lld%lld",&source,&dest);
            source-=1,dest-=1;
            gr.add_edge(source,dest);
        }
        if(gr.cycle_or_not())
            flag=0;
        for(i=0;i<e2;i++)
        {
            scanf("%lld%lld",&source,&dest);
            source-=1,dest-=1;
            //gr.add_edge(source,dest);
            //if(gr.cycle_or_not())
            //{
              //  gr.add_edge()
            //}
        }
        if(flag==1)
            printf("Yes\n");
        else
            printf("No\n");
    }
}
