# include <bits/stdc++.h>
using namespace std;

vector<pair<int,int> >graphs[12];
int visited[12];
pair<int,int> tpair,tpair2;

int main()
{
	int testcases;
	cin>>testcases;
	while(testcases--)
	{
		int pdist[10];
		for(int i=0;i<10;++i)
		{
			cin>>pdist[i];
		}
		int source=10;
		int temp;

		for(int i=0;i<10;++i)
		{
			tpair.first=pdist[i];
			tpair.second=i;
			graphs[source].push_back(tpair);
			for(int j=i-1;j>=0;--j)
			{
				temp=i-j;
				tpair.first=pdist[temp];
				tpair.second=i;
				graphs[j].push_back(tpair);

			}

			for(int j=i+1;j<10;++j)
			{
				temp=10+i-j;
				tpair.first=pdist[temp];
				tpair.second=i;
				graphs[j].push_back(tpair);

			}
		}

		/*for(int i=0;i<graphs[0].size();++i)
		{
			cout<<graphs[0][i].second<<":"<<graphs[0][i].first<<endl;
		}*/

		int result[1000];
		int size;
		cin>>size;
		char t;
		for(int i=0;i<size;++i)
		{
			cin>>t;
			t=t-48;
			result[i]=(int)t;
		}

		for(int i=0;i<=10;++i) 
		{
			visited[i]=-1;
		}
		priority_queue<pair<int, int> > q;
		tpair.first = 0; // minimum distance to source
		tpair.second = source;
		q.push(tpair);
		while(!q.empty()) 
		{
			tpair = q.top();
			q.pop();
			int minimum_distance = -tpair.first;
			int current_node = tpair.second;
			if (visited[current_node] == -1) 
			{
				visited[current_node] = minimum_distance;
				for(auto neighbour: graphs[current_node]) 
				{
					int next_node = neighbour.second;
					int dist = neighbour.first;
					if (visited[next_node] == -1) 
					{
						tpair2.first = -(minimum_distance + dist);
						tpair2.second = next_node;
						q.push(tpair2);
					}
				}
			}
		}

		for(int i=0;i<11;++i)
		{
			graphs[i].clear();
		}
		int sum=0;
		for(int i=0;i<size;++i)
		{
			sum=sum+visited[result[i]];
		}
		cout<<sum<<endl;
		/*for(int i=0;i<10;++i)
		{
			cout<<visited[i];
		}*/


	}
}