#include <bits/stdc++.h> 

using namespace std;
 
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define sz(x) (int)((x).size()) 
#define forn(i,n) for (int i = 0; (i) < (n); ++i)
#define fornr(i,n) for (int i = (n) - 1; (i) >= 0; --i)
#define forab(i,a,b) for (int i = (a); (i) < (b); ++i)
#define forba(i,a,b) for (int i = (b) - 1; (i) >= (a); --i)
#define forit(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)
#define all(c) (c).begin(),(c).end() 

#ifdef LOCAL
    #define eprintf(...) fprintf(stderr, __VA_ARGS__)
#else
    #define eprintf(...) static_cast<void>(0)   
#endif

#ifdef _WIN32
    #define I64 "%I64d"
#else
    #define I64 "%lld"
#endif

typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
typedef unsigned int uint;
typedef vector <int> vi;
typedef pair <int, int> pii;
typedef vector <pair <int, pii> > vipii;

#define FNAME ""

const int MAXN = 1e5 + 5, MAXK = 18;

int used[MAXN], tin[MAXN], tout[MAXN], up[MAXN][MAXK], sz[MAXN], top[MAXN], pos[MAXN], num[MAXN], a[MAXN];
int timer = 0, curPath = 0;
vi g[MAXN], lst[MAXN];

const uint P = 63001, Q = 12344;
uint randValue = 0;

inline int myRand()
{
    randValue = (randValue * P + Q) ^ ((1 << 16) - 1);
    return randValue;
}

struct Node
{
    Node *l, *r;
    int y, val, size, rev;
    LL sum;
    Node(int val): l(NULL), r(NULL), y(myRand()), val(val), size(1), rev(0), sum(val) {}
};

Node *treap[MAXN], *lef[MAXN], *righ[MAXN];

inline int getSize(Node *root)
{
    return root ? root->size : 0;
}

inline LL getSum(Node *root)
{
    return root ? root->sum : 0;
}

inline void recalc(Node *root)
{
    root->size = getSize(root->l) + getSize(root->r) + 1;
    root->sum = getSum(root->l) + getSum(root->r) + root->val;
}

inline void push(Node *root)
{
    if (root->rev)
    {
        if (root->l)
            root->l->rev ^= 1;
        if (root->r)
            root->r->rev ^= 1;
        swap(root->l, root->r);
        root->rev = 0;
    }
}

Node* merge(Node *a, Node *b)
{
    if (!a)
        return b;
    if (!b)
        return a;
    push(a);
    push(b);
    if (a->y < b->y)
    {
        a->r = merge(a->r, b);
        recalc(a);
        return a;
    }
    else
    {
        b->l = merge(a, b->l);
        recalc(b);
        return b;
    }
}

void split(Node *root, int k, Node *&a, Node *&b)
{
    if (!root)
    {
        a = b = NULL;
        return;
    }
    push(root);
    if (getSize(root->l) >= k)
    {
        split(root->l, k, a, root->l);
        b = root;
    }
    else
    {
        split(root->r, k - getSize(root->l) - 1, root->r, b);
        a = root;
    }
    recalc(root);
}

void dfs(int v)
{
    used[v] = 1;
    tin[v] = timer++;
    sz[v] = 1;
    forab (i, 1, MAXK)
        up[v][i] = up[up[v][i - 1]][i - 1];
    for (int u : g[v])
    {
        if (!used[u])
        {
            up[u][0] = v;
            dfs(u);
            sz[v] += sz[u];
        } 
    }
    tout[v] = timer++;
}

bool isAncestor(int v, int u)
{
    return tin[v] <= tin[u] && tout[v] >= tout[u];
}

int lca(int v, int u)
{
    fornr (i, MAXK)
        if (!isAncestor(up[v][i], u))
            v = up[v][i];
    if (!isAncestor(v, u))
        return up[v][0];
    return v;
}

void build(int v)
{
    if (v == 0 || 2 * sz[v] < sz[up[v][0]])
    {
        top[curPath] = v;
        pos[v] = 1;
        num[v] = curPath;
        curPath++;    
    } 
    else
    {
        pos[v] = pos[up[v][0]] + 1;
        num[v] = num[up[v][0]];
    }
    treap[num[v]] = merge(treap[num[v]], new Node(a[v]));
    lst[num[v]].pb(v);
    for (auto u : g[v])
        if (u != up[v][0])
            build(u);
}

vipii go(int v, int w, bool with)
{
    vipii path;
    bool ok = 1;
    while (isAncestor(w, top[num[v]]))
    {
        path.pb(mp(num[v], mp(1, pos[v])));
        if (w == 0 && top[num[v]] == 0)
        {
            ok = 0;
            break;
        }
        v = up[top[num[v]]][0];
    }
    if (ok && isAncestor(w, v))
        path.pb(mp(num[v], mp(pos[w], pos[v])));
    if (!with && sz(path) > 0)
    {
        if (path.back().sc.fs == path.back().sc.sc)
            path.pop_back();
        else
            path.back().sc.fs++;
    }
    return path;
}

int main() 
{
#ifdef LOCAL    
    freopen(FNAME".in", "r", stdin);
    freopen(FNAME".out", "w", stdout); 
#endif    
    int n, q;
    scanf("%d%d", &n, &q);
    forn (i, n)
        treap[i] = NULL, lef[i] = NULL, righ[i] = NULL;
    forn (i, n)
        scanf("%d", &a[i]);
    forn (i, n - 1)
    {
        int v, u;
        scanf("%d%d", &v, &u);
        v--, u--;
        g[v].pb(u);
        g[u].pb(v);
    }
    dfs(0);
    build(0);
    forn (qq, q)
    {
        char ch;
        int v, u;
        scanf(" %c%d%d", &ch, &v, &u);
        v--, u--;
        int w = lca(v, u);
        vipii path1, path2;
        bool ok = 0;
        if (sz(lst[num[w]]) == pos[w] || !isAncestor(lst[num[w]][pos[w]], u))
            ok = 1;
        if (ok)
        {
            path1 = go(v, w, 1);
            path2 = go(u, w, 0);
        }
        else
        {
            path1 = go(v, w, 0);
            path2 = go(u, w, 1);
        }
        if (ch == 'S')
        {
            LL sum = 0;         
            path1.insert(path1.end(), path2.begin(), path2.end());
            for (auto np : path1)
            {
                Node *a, *b, *c, *d;
                split(treap[np.fs], np.sc.sc, a, b);
                split(a, np.sc.fs - 1, c, d);
                sum += d->sum;
                treap[np.fs] = merge(merge(c, d), b);
            }
            printf(I64 "\n", sum);
        }
        else
        {
            Node *root = NULL;
            for (auto np : path1)
            {
                Node *a, *b, *c, *d;
                split(treap[np.fs], np.sc.sc, a, b);
                split(a, np.sc.fs - 1, c, d);
                lef[np.fs] = c;
                righ[np.fs] = b;
                d->rev ^= 1;
                root = merge(root, d);
            }
            reverse(all(path2));
            for (auto np : path2)
            {
                Node *a, *b, *c, *d;
                split(treap[np.fs], np.sc.sc, a, b);
                split(a, np.sc.fs - 1, c, d);
                lef[np.fs] = c;
                righ[np.fs] = b;
                root = merge(root, d);
            }
            root->rev ^= 1;
            for (auto np : path1)
            {
                Node *a, *b;
                split(root, np.sc.sc - np.sc.fs + 1, a, b);
                root = b;
                a->rev ^= 1;
                treap[np.fs] = merge(merge(lef[np.fs], a), righ[np.fs]);
            }
            for (auto np : path2)
            {
                Node *a, *b;
                split(root, np.sc.sc - np.sc.fs + 1, a, b);
                root = b;
                treap[np.fs] = merge(merge(lef[np.fs], a), righ[np.fs]);
            }
        }
    }
    return 0;
}