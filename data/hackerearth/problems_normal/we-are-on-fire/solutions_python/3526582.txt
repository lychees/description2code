n,m,q=map(int,raw_input().split())
a=[ "p" for i in xrange(n) ]
for _ in xrange(n):
    l=raw_input().split()
    a[_]=l
dif = [ (1,0), (-1,0), (0,1), (0,-1) ]#down,upward,right,left(i,j)
mark = [ [False for j in xrange(m)] for i in xrange(n) ]
parent= [ [0 for j in xrange(m)] for i in xrange(n) ]
def valid(x,y):
    return y >= 0 and x >= 0 and y < m and x < n

def dfs(start):
    global component_id
    c=1
    q=[]
    q.append(start)
    
    while q :
        top=q.pop()
        #c+=1
        parent[top[0]][top[1]]=component_id
        mark[top[0]][top[1]]=True
        #print "top",top
        
        for k in dif:
            if (valid(top[0]+k[0],top[1]+k[1]))and (a[top[0]+k[0]][top[1]+k[1]]=="1" ) and mark[top[0]+k[0]][top[1]+k[1]]==False:
               #print top[0]+k[0],top[1]+k[1] 
               mark[top[0]+k[0]][top[1]+k[1]]=True
               parent[top[0]+k[0]][top[1]+k[1]]=component_id
               c+=1
               q.append((top[0]+k[0],top[1]+k[1]))
              
            
    return c
component_id=1
co=0 
d={}
f={}  
for i in xrange(n):
    for j in xrange(m):
        if a[i][j]=="1":
             co+=1
             
             if mark[i][j]==False:
              tI=dfs((i,j))
              d[component_id]=tI
              f[component_id]=True
              component_id+=1

    
while q!=0:
    x,y=map(int,raw_input().split())
    if a[x-1][y-1]=="0":
        print co
    else:
        if f[parent[x-1][y-1]]==True:
          co=co-d[parent[x-1][y-1]]
          f[parent[x-1][y-1]]=False
          print co
        else:
            print co  
    q-=1            