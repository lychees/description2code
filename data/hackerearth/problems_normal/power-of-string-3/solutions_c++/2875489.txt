#include <bits/stdc++.h>
 
using namespace std;
#define MAXN 1000005
 
typedef long long int64;
 
string S;
int N, SA[MAXN], LCP[MAXN], ranking[MAXN], bucket[CHAR_MAX-CHAR_MIN+1];
char bh[MAXN+1];

void buildSA( bool needLCP = false ){
    int a, c, d, e, f, h, i, j, x;
    int *cnt = LCP;
    memset( bucket, -1, sizeof(bucket) );
    for( i = 0; i < N; i++ ){
        j = S[i] - CHAR_MIN;
        ranking[i] = bucket[j];
        bucket[j] = i;
    }
    for( a = c = 0; a <= CHAR_MAX-CHAR_MIN; a++ ){
        for( i = bucket[a]; i != -1; i=j ){
            j = ranking[i]; ranking[i] = c;
            bh[c++] = (i==bucket[a]);
        }
    }
    bh[N] = 1;
    for( i = 0; i < N; i++ )
        SA[ ranking[i] ] = i;
    x = 0;
    for( h = 1; h < N; h *= 2 ){
        for( i = 0; i < N; i++ ){
            if( bh[i] & 1 ){
                x = i;
                cnt[x] = 0;
            }
            ranking[ SA[i] ] = x;
        }
        d = N-h; e = ranking[d];
        ranking[d] = e + cnt[e]++;
        bh[ranking[d]] |= 2;
        i = 0;
        while( i < N ){
            for( j = i; (j == i || !(bh[j] & 1)) && j < N; j++ ){
                d = SA[j]-h;
                if( d >= 0 ){
                    e = ranking[d]; ranking[d] = e + cnt[e]++; bh[ranking[d]] |= 2;
                }
            }
            for( j = i; (j == i || !(bh[j] & 1)) && j < N; j++ ){
                d = SA[j]-h;
                if( d >= 0 && (bh[ranking[d]] & 2)){
                    for( e = ranking[d]+1; bh[e] == 2; e++);
                    for( f = ranking[d]+1; f < e; f++ ) bh[f] &= 1;
                }
            }
            i = j;
        }
        for( i = 0; i < N; i++ ){
            SA[ranking[i]] = i;
            if( bh[i] == 2 ) bh[i] = 3;
        }
    }
    if( needLCP ){
        LCP[0] = 0;
        for( i = 0, h = 0; i < N; i++ ){
            e = ranking[i];
            if( e > 0 ){
                j = SA[e-1];
                while( ((i+h) < N) && ((j+h) < N) && (S[i+h] == S[j+h]) ) h++;
                LCP[e] = h;
                if( h > 0 ) h--;
            }
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    int n, k;
    cin >> k >> n;
    N = n;
    cin.ignore();
    getline(cin, S);
    if( k == 1 ) cout << n << '\n';
    else{
        buildSA(true);
        //for(int i = 0; i < n; i++ ) cout << (S.data()+SA[i]) << " " << LCP[i] << endl;
        int lo = 0, hi = n, mid, resp = 0;
        while( lo <= hi ){
            mid = (lo + hi) >> 1;
            bool ans = false;
            for( int i = 0; i <= n; i++ ){
                if( LCP[i] > 0 && LCP[i] >= mid ){
                    int w = i+1;
                    int qt = 2;
                    while( w <= n && LCP[w] >= mid ){
                        w++;
                        qt++;
                    }
                    if( qt >= k ){
                        ans = true;
                        break;
                    }
                    i = w - 1;
                }
            }
            if( ans ){
                resp = max(resp, mid);
                lo = mid+1;
            }
            else hi = mid-1;
        }
        cout << resp << '\n'; 
    }
    
    return 0;
}