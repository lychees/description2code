#include <bits/stdc++.h>

using namespace std;

int dx[] = {-1, 0, 0, 0, 1};
int dy[] = {0, -1, 0, 1, 0};

bool valid(int i, int j, int n, int m){
	if(i>=0 && j>=0 && i<n && j<m)
		return true;
	return false;
}

class Graph{
	int V;
	char **elements;
public:
	Graph(int V, int n);
	void addElement(char c, int index, int n);
	int BFS(int n, int m, int src, int dest);
};

Graph::Graph(int V, int n){
	this->V = V;
	elements = new char*[n];
	for(int i=0 ; i<n ; i++){
		elements[i] = new char[V];
	}
}

void Graph::addElement(char c, int index, int n){
	elements[n][index] = c;
}

int Graph::BFS(int n, int m, int src, int dest){
	bool visited[n][V];
	int dist[n][V];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<V ; j++){
			visited[i][j] = false;
			dist[i][j] = -1;
		}
	}

	int s = src, l = 0, temp, x, y, temp_x, temp_y, index;
	visited[l][s] = true;
	dist[l][s] = 0;
	list<int> queue;
	queue.push_back(s);

	list<int> level;
	level.push_back(l);

	while(!queue.empty()){
		s = queue.front();
		queue.pop_front();

		l = level.front();
		level.pop_front();

		temp_x = s / n;
		temp_y = s % n; 

		for(int i=0 ; i<5 ; i++){
			x = temp_x + dx[i];
			y = temp_y + dy[i];
			index = x * n + y;
			if(valid(x, y, m, n)){
				if(!visited[(l+1)%n][index] && elements[(l+1)%n][index] != 'X'){
					temp = l+1;
					visited[temp%n][index] = true;
					queue.push_back(index);
					level.push_back(temp%n);
					dist[temp%n][index] = dist[l%n][s] + 1;

					if(elements[temp%n][index] == 'T')
						return dist[temp%n][index];
				}
			}
		}
	}

	return -1;
}

int main(){
	int n, m, index, src, dest, l, a, count = 0;
	cin>>n>>m;

	string arr[n+2];
	for(int i=0 ; i<n+2 ; i++)
		cin>>arr[i];

	Graph graph((n+2)*m, m);
	for(int i=m-1, a=0 ; i>=0 && a<m ; i--, a++){
		for(int j=0 ; j<n+2 ; j++){
			for(int k=0 ; k<m ; k++){
				l = i+1;
				if(n%2==0){
					if(j%2==1 && j!=0 && j!=n+1)
						graph.addElement(arr[j][(k+a)%m], j*m+k, (m-l)%m);
					else if(j!=0 && j!=n+1)
						graph.addElement(arr[j][(k+l)%m], j*m+k, (m-l)%m);
				} else {
					if(j%2==0 && j!=0 && j!=n+1)
						graph.addElement(arr[j][(k+a)%m], j*m+k, (m-l)%m);
					else if(j!=0 && j!=n+1)
						graph.addElement(arr[j][(k+l)%m], j*m+k, (m-l)%m);
				}

				if(j==0 || j==n+1)
					graph.addElement(arr[j][k], j*m+k, (m-l)%m);

				if(i==0 && arr[j][k] == 'T')
					dest = j * m + k;
				if(i==0 && arr[j][k] == 'B')
					src = j * m + k;
			}
		}
	}

	int answer;
	answer = graph.BFS(m, n+2, src, dest);

	if(answer<0)
		cout<<"Impossible"<<endl;
	else
		cout<<answer<<endl;

	return 0;
}