#include <bits/stdc++.h>
using namespace std;

vector < pair <int , int > > v[1001];


void bfs(int z, int dist[], int col[], int n)
{
	fill(dist, dist+n+2, 1e8);
fill(col, col+n+2, 0);
    priority_queue < pair<int,int >,vector<pair<int,int> >,greater <pair<int,int> > >q;

dist[z]=0;
 //   q.push(z);
//    int u=q.front();
	//col[z]=1;
    //cout<<u;
    q.push({dist[z] , z});                         // insert the source node with distance = 0
    int u;
    pair < int , int > p;
    while(!q.empty()){
    	p = q.top();
		q.pop();
		u = p.second;
		if(col[u] == 1)
			continue;
		col[u] = 1;
        for(int i = 0; i < v[u].size(); i++){
            int e = v[u][i].second; int w = v[u][i].first;
            if(dist[u] + w < dist[e]){            // check if the next vertex distance could be minimized
                dist[e] = dist[u] + w;
                q.push({dist[e],  e});           // insert the next vertex with the updated distance
            }
        }
    }

}


int main()
{
	int t;
	cin>>t;
	for(int z=0;z<t;z++)
{
    int m,n;
    cin>>n>>m;
    int col[n+1],dist[n+1],dist1[n+1],dist2[n+1],col1[n+1],col2[n+1];
	for(int i=0;i<=n;i++)
	{
		v[i].clear();
		col[i]=0;
		dist[i]=1e8;
		dist1[i]=1e8;
		dist2[i]=1e8;


	}

//	long long ans=0;
    for(int i=0;i<m;i++)
    {
    	int x,y,z;
    	cin>>x>>y>>z;
    	v[x].push_back(make_pair(z, y));
    	v[y].push_back(make_pair(z, x));

    }

    int s,am,h,ma=0,maa=0;
    cin>>s>>am>>h;
    //cout<<"HI";
    bfs(s,dist,col,n);
    
    bfs(am,dist1,col1,n);
    bfs(h,dist2,col2,n);

    for(int i=0;i<=n;i++)
    {
    	if(i==s||i==am||i==h)
				continue;
    	if(dist[i]==1e8||dist1[i]==1e8||dist2[i]==1e8)
    		continue;
    	ma=dist[i]+2*dist1[i]+dist2[i];
    	if(ma>maa)
            maa=ma;
    //cout<<"HI";
    }
    cout<<maa<<endl;
}
    return 0;
}
