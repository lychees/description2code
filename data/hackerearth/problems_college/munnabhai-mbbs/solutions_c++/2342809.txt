#include <iostream>
#include <list>
#include <queue>
#include <algorithm>
using namespace std;

int num = 0;
class Graph
{
	int V;
	list<int> *adj;
public:
	int *count;
	int *counted;
	Graph(int V);
	void addEdge(int v, int w);
	void mbbs();
};

Graph::Graph(int V){
	this->V = V;
	adj = new list<int>[V];
	count = new int[V];
	counted = new int[V];
}

void Graph::addEdge(int v, int w){
	adj[v].push_back(w);
}

void Graph::mbbs(){
	list<int> q;
	for (int i = 0; i < V; ++i)
	{
		if (count[i] == 0){
			q.push_back(i);
			counted[i] = 1;
		}
	}
	list<int>::iterator i;
	while(!q.empty()){
		int item = q.front();
		q.pop_front();
		num++;
		for (i = adj[item].begin();i!=adj[item].end(); ++i)
		{
			count[*i]--;
			if(count[*i] == 0 && !counted[*i]){
				q.push_back(*i);
				counted[*i] = 1;
			}
		}
	}
}

int main(){
	int t;
	cin >> t;
	while(t--){
		num = 0;
		int n,m,x,y,a,b;
		cin >> n >> m;
		Graph g(n);
		for (int i = 0; i < n; ++i)
		{
			g.count[i] = 0;
			g.counted[i] = 0;
		}
		for (int i = 0; i < m; ++i)
		{	
			cin >> x >> y;
			a = x-1; b = y-1;
			g.addEdge(a, b);
			g.count[b]++;
		}
		g.mbbs();
		cout << num << endl;
	}
	return 0;
}