//DARK LORD
#include<bits/stdc++.h>
#define ll long long
#define _ ios::sync_with_stdio(false);cin.tie(0);
#define max(a,b)                 (a>=b?a:b)
#define min(a,b)                 (a<b?a:b)
#define max3(a,b,c)               max(a,max(b,c))
#define min3(a,b,c)               min(a,min(b,c))
#define f0(i,a,b) for(int i=a;i<b;i++)
#define f1(i,a,b) for(int i=a;i<=b;i++)
#define fr(i,b,a) for(int i=b;i>=a;i--)
#define F first
#define S second
#define pb push_back
#define mp make_pair
#define mod 1000000007
#define T() int t;cin>>t;while(t--)
inline ll modexp(ll a,ll b){ll x=1;while(b>0){if(b&1){x*=a;if(x>=mod)x%=mod;};b>>=1;a*=a;if(a>=mod)a%=mod;}return x;}
inline ll digSum(ll n){ll s=0;n=abs(n);while(n){s+=(n%10);n/=10;}return s;}
using namespace std;
/*  Graph Part
static const int N  = 100001;
static bool visited[N];
vector<int> adj[N];
*/
#define mx 1000001
vector<bool> isprime(mx,true);
vector<ll> cnt(mx);
vector<ll> ans(mx);
int main()
{
	isprime[0]=false;
    isprime[1]=false;
    ll i,j,primelen;
    for(i=4;i<mx;i+=2)
    	isprime[i] = false;
    for(i=3;i<=sqrt(mx);i+=2)
    if(isprime[i])
    for(j=i*i;j<=mx;j+=2*i)
    {
        isprime[j]=false;
    } 
	isprime[2] = true; 
    for(i=2;i<=mx;i+=1){
    if(isprime[i])
    cnt[i] = cnt[i-1] + 1;
	else cnt[i] = cnt[i-1];
	if(isprime[cnt[i]])
	ans[i] = ans[i-1] + 1;
	else ans[i] = ans[i-1];}
    T(){
    	int m,n;
    	scanf("%d %d",&m,&n);
    	printf("%d\n",ans[n] - ans[m-1]);
	}

}

