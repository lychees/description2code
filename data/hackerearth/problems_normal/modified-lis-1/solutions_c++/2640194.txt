#include <algorithm>
#include <cstdio>
#include <cstring>
#define FOR(i,a,b) for(i=a; i<=b; i++)
#define FOR2(i,n) FOR(i,0,n-1)
#define TFOR(i,a,b) for(i=a; i>=b; i--)
#define f first
#define s second
#define all(x) x.begin(),x.end() 
#define MAXN 100005
#define MAXT 300000
#define T 100000
#define MOD 1000000007
using namespace std;
typedef pair < int , long long > pil;
int read(){ int res(0),sign(1); char c;
	while(1){ c = getchar(); if('0' <= c && c <= '9') { res = c - '0'; break; } else if(c == '-') { sign = -1; break; } }
	while(1){ c = getchar(); if('0' <= c && c <= '9') res = res*10 + c - '0'; else break; }
	return res * sign;
}
int N;
int A[MAXN];
pil ST1[MAXT] , ST2[MAXT];
void update1( int pos , int s , int e , int a , pil t )
{
	if( a > e || a < s ) return;
	if( s == e )
	{
		if( ST1[pos].f == t.f ) ST1[pos].s = ( ST1[pos].s + t.s ) % MOD;
		else ST1[pos] = t;
		return;
	}
	int m = ( s + e ) >> 1;
	int sol = pos << 1;
	int sag = sol | 1;

	update1( sol,s,m,a,t );
	update1( sag,m+1,e,a,t );

	if( ST1[sol].f > ST1[sag].f ) ST1[pos] = ST1[sol];
	else if( ST1[sol].f < ST1[sag].f ) ST1[pos] = ST1[sag];
	else ST1[pos] = make_pair( ST1[sol].f , ( ST1[sol].s + ST1[sag].s ) % MOD );
}
pil find1( int pos , int s , int e , int a , int b )
{
	if( a > e || b < s || a > b ) return make_pair(0,0);
	if( a <= s && e <= b ) return ST1[pos];
	int m = ( s + e ) >> 1;
	int sol = pos << 1;
	int sag = sol | 1;

	pil t1 = find1( sol,s,m,a,b );
	pil t2 = find1( sag,m+1,e,a,b );

	if( t1.f > t2.f ) return t1;
	if( t1.f < t2.f ) return t2;

	return make_pair( t1.f , ( t1.s + t2.s ) % MOD );
}
void update2( int pos , int s , int e , int a , pil t )
{
	if( a > e || a < s ) return;
	if( s == e )
	{
		if( ST2[pos].f == t.f ) ST2[pos].s = ( ST2[pos].s + t.s ) % MOD;
		else ST2[pos] = t;
		return;
	}
	int m = ( s + e ) >> 1;
	int sol = pos << 1;
	int sag = sol | 1;

	update2( sol,s,m,a,t );
	update2( sag,m+1,e,a,t );

	if( ST2[sol].f > ST2[sag].f ) ST2[pos] = ST2[sol];
	else if( ST2[sol].f < ST2[sag].f ) ST2[pos] = ST2[sag];
	else ST2[pos] = make_pair( ST2[sol].f , ( ST2[sol].s + ST2[sag].s ) % MOD );
}
pil find2( int pos , int s , int e , int a , int b )
{
	if( a > e || b < s || a > b ) return make_pair(0,0);
	if( a <= s && e <= b ) return ST2[pos];
	int m = ( s + e ) >> 1;
	int sol = pos << 1;
	int sag = sol | 1;

	pil t1 = find2( sol,s,m,a,b );
	pil t2 = find2( sag,m+1,e,a,b );

	if( t1.f > t2.f ) return t1;
	if( t1.f < t2.f ) return t2;
	return make_pair( t1.f , ( t1.s + t2.s ) % MOD );
}
int main()
{
	int i;
	N = read();
	FOR(i,1,N) A[i] = read();

	update1( 1,0,T,0,make_pair(0,1) );
	update2( 1,0,T,0,make_pair(0,1) );

	FOR(i,1,N)
	{
		if( A[i] > 0 )
		{
			pil t = find2( 1,0,T,0,A[i]-1 );
			t.f++;
			update1( 1,0,T,A[i],t );
		}
		else
		{
			pil t = find1( 1,0,T,0,-A[i]-1 );
			t.f++;
			update2( 1,0,T,-A[i],t );
		}
	}
	if( ST1[1].f > ST2[1].f )
		printf("%d %lld\n" , ST1[1].f , ST1[1].s );
	else if( ST1[1].f < ST2[1].f )
		printf("%d %lld\n" , ST2[1].f , ST2[1].s );
	else
		printf("%d %lld\n" , ST1[1].f , ( ST1[1].s + ST2[1].s ) % MOD );

	return 0;
}
