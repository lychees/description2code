#include <iostream>
#include <set>
#include <algorithm>
using namespace std;
set<pair<int,int> > se;
set<pair<int,int> > nse;

int BinarySearch(int A[], int l, int r, int key)
{
    int m;
 
    while( l <= r )
    {
        m = l + (r-l)/2;
 
        if( A[m] == key ) // first comparison
            return m;
 
        if( A[m] < key ) // second comparison
            l = m + 1;
        else
            r = m - 1;
    }
 
    return -1;
}

int main()
{
    int t,m,n,x,y,p,q;
    cin>>t;
    while(t--)
    {
        set<pair<int,int> >::iterator iter1;
        set<pair<int,int> >::iterator iter2;
        cin>>m>>n;
        p=m;q=n;
        int i=0,count1=0,count2=0;
        while(m--)
        {
            cin>>x>>y;
            //s[i]=x;
            se.insert(make_pair(x,y));
        //  i++;
        }
        i=0;
        while(n--)
        {
            cin>>x>>y;
            //ns[i]=x;
            nse.insert(make_pair(x,y));
        //  i++;
        }
        cin>>x>>y;
    //  sort(s,s+p);
    //  sort(ns,ns+q);
        
        for(iter1=nse.begin();iter1!=nse.end();iter1++)
        {
            int a=(*iter1).first;
            int b=(*iter1).second;
            iter2=se.find(make_pair(a,b));
            if(iter2!=se.end())
            {
                count1++;
                se.erase(iter2);
                nse.erase(iter1);
            }
            
        }
        count2=count1;
        int count3=count2;
       /* if(count2!=p)//p=m,q=n
        {
        int already[p-count2],new1[q-count2];
        i=0;
        for(iter1=nse.begin();iter1!=nse.end();iter1++)
        {
            int a=(*iter1).first;
            new1[i]=a;
            i++;
            
        }
        i=0;
        
        for(iter2=se.begin();iter2!=se.end();iter2++)
        {
            int a=(*iter2).first;
            already[i]=a;
            i++;
        }
        //sort(already,already+(p-count2));
        int flag[q-count2];
        for(int i=0;i<q-count2;i++)
        flag[i]=1;
        sort(already,already+(p-count2));
        for(int i=0;i<q-count2;i++)
        {
            int c=BinarySearch(already,0,p-count2,new1[i]);
            if(c!=-1 && flag[c]==1)
            {
                flag[c]=0;
                count3++;
            }
        }
            
        }
        */
        
        
        if(count3>=x && count1<y)
        cout<<"Good\n";
        
        if(count3>=x && count1>=y)
        cout<<"Great\n";
        
        else
        cout<<":(\n";
    }
    
    return 0;
}
