def dfs(v):
    global mark, c_c
    q = []
    q.append(v)

    while q:
        top = q.pop()
        mark[top] = c_c
        for j in G[top]:
            if mark[j] == -1:
                q.append(j)
                mark[j] = mark[top]
    # d[c_c]=s


t = input()
while t != 0:
    n, m = map(int, raw_input().split())
    G = [[] for i in xrange(n+1)]
    P = map(int, raw_input().split())
    Q = map(int, raw_input().split())
    for k in xrange(m):
        x, y = map(int, raw_input().split())
        G[x].append(y)
        G[y].append(x)

    mark = [-1]*(n+1)
    # d=[-1]*(n+1)
    c_c = 1
    # dfs(1)
    t_p = {}
    # t_q={}
    for v in xrange(1, n+1):
        t_p[P[v-1]] = v-1
        # t_q[Q[v-1]]=v-1
        if G[v]:
            if mark[v] == -1:
                dfs(v)
                c_c += 1
        else:
            # c_c+=1
            mark[v] = c_c
            c_c += 1
    k = True
    # print t_p,t_q
    # print mark
    for i in xrange(n):
        if P[i] != Q[i]:
            # print "i",i,P[i],Q[i]
            # print t_p[P[i]],t_q[Q[i]]
            # print mark[t_p[P[i]]],mark[t_p[Q[i]]]
            if (mark[t_p[P[i]]+1] != mark[t_p[Q[i]]+1]):
                k = False
                break
    if not k:
        print "NO"
    else:
        print "YES"
    t -= 1
