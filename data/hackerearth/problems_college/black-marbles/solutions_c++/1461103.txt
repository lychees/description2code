#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>
#include <string.h>
 
using namespace std;
 
typedef long long int64;
typedef unsigned long long uint64;
#define two(X) (1<<(X))
#define twoL(X) (((int64)(1))<<(X))
#define contain(S,X) (((S)&two(X))!=0)
#define containL(S,X) (((S)&twoL(X))!=0)
const double pi=acos(-1.0);
const double eps=1e-11;
template<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}
template<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}
template<class T> inline T sqr(T x){return x*x;}
typedef pair<int,int> ipair;
#define SIZE(A) ((int)A.size())
#define LENGTH(A) ((int)A.length())
#define MP(A,B) make_pair(A,B)
#define PB(X) push_back(X)
 
const int maxsize=700+5;
const int maxn=maxsize*maxsize;
const int dx[]={-1,-1,1,1};
const int dy[]={-1,1,-1,1};
 
int size_x,size_y;
char a[maxsize][maxsize];
int idx[maxsize][maxsize];
int n,m;
int d[maxn],g[maxn][4];
int p1[maxn],p2[maxn];
bool visited[maxn];
 
inline bool inside(int x,int y)
{
	return x>=0 && x<size_x && y>=0 && y<size_y;
}
bool findpath(int p)
{
	for (int i=0;i<d[p];i++) 
	{
		int key=g[p][i];
		if (visited[key]) continue;
		visited[key]=true;
		if (p2[key]<0 || findpath(p2[key]))
		{
			p1[p]=key;
			p2[key]=p;
			return true;
		}
	}
	return false;
}
int main()
{
#ifdef _MSC_VER
	freopen("input.txt","r",stdin);
#endif
	srand(1028);
	while (scanf("%d%d",&size_x,&size_y)!=-1 && size_x!=0)
	{
		for (int i=0;i<size_x;i++) scanf("%s",a[i]);
		bool bad=false;
		for (int x=0;x<size_x;x++) for (int y=0;y<size_y;y++) if (a[x][y]=='G') for (int d2=0;d2<4;d2++)
		{
			int x2=x+dx[d2],y2=y+dy[d2];
			if (!inside(x2,y2) || a[x2][y2]=='P') continue;
			int x3=x2+dx[d2],y3=y2+dy[d2];
			if (!inside(x3,y3)) continue;
			if (a[x3][y3]=='G') bad=true;
			if (a[x3][y3]=='F') a[x3][y3]='f';
		}
		/*
		if (bad)
		{
			printf("0\n");
			continue;
		}
		*/
		int R=0;
		for (int ex=0;ex<2;ex++) for (int ey=0;ey<2;ey++) for (int bit=0;bit<2;bit++)
		{
			n=m=0;
			for (int x=ex;x<size_x;x+=2) for (int y=ey;y<size_y;y+=2) if (a[x][y]=='F' && (((x>>1)+(y>>1))&1)==bit)
				idx[x][y]=(((x&3)>>1)==0)?(n++):(m++);
			for (int i=0;i<n;i++) d[i]=0;
			for (int x=ex;x<size_x;x+=2) for (int y=ey;y<size_y;y+=2) if (a[x][y]=='F' && (((x>>1)+(y>>1))&1)==bit && ((x&3)>>1)==0) for (int d2=0;d2<4;d2++)
			{
				int x2=x+dx[d2],y2=y+dy[d2];
				if (!inside(x2,y2) || a[x2][y2]=='P') continue;
				int x3=x2+dx[d2],y3=y2+dy[d2];
				if (!inside(x3,y3)) continue;
				if (a[x3][y3]=='F') g[idx[x][y]][d[idx[x][y]]++]=idx[x3][y3];
			}
			int C=0;
			for (int i=0;i<n;i++) p1[i]=-1;
			for (int i=0;i<m;i++) p2[i]=-1;
			for (int i=0;i<n;i++) for (int j=0;j<d[i];j++) if (p2[g[i][j]]<0) { C++; p1[i]=g[i][j]; p2[g[i][j]]=i; break; }
			for (int j=0;j<m;j++) visited[j]=false;
			for (int i=0;i<n;i++) if (p1[i]<0 && findpath(i))
			{
				C++;
				for (int j=0;j<m;j++) visited[j]=false;
			}
			R+=n+m-C;
		}
		printf("%d\n",R);
	}
	return 0;
}
 
 