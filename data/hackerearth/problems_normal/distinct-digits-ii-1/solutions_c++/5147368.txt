#include<bits/stdc++.h>
using namespace std;
struct node {
	int min_c;
	int min;
	int max;
	int max_c;
};
struct a {
	int cnt;
	int val;
};
#define lint long long int
#define MAX 100009
#define MOD 1000000007
#define seg struct node
seg tree[4*MAX];
long long int arr[MAX];
void build(int nod, int start, int end)
{
	if(start == end) {
		int i,c[10]={0}, m=0, p = arr[end];
		while(p!=0) {
			c[p%10]++;
			p=p/10;
		}
		for(i=0;i<10;i++) {
			if(c[i])
				m++;
		}
		tree[nod].min = m;
		tree[nod].max = m;
		tree[nod].min_c = 1;
		tree[nod].max_c = 1;
		return;
	}
	int mid = (start + end) / 2;
	build(2*nod, start, mid);
	build(2*nod+1, mid+1, end);
	if(tree[2*nod].min < tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c=tree[2*nod].min_c;
	}
	else if(tree[2*nod].min == tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c = tree[2*nod].min_c + tree[2*nod+1].min_c;
	}
	else {
		tree[nod].min = tree[2*nod+1].min;
		tree[nod].min_c = tree[2*nod+1].min_c;
	}
	if(tree[2*nod].max > tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c;
	}
	else if(tree[2*nod].max == tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c + tree[2*nod+1].max_c;
	}
	else {
		tree[nod].max = tree[2*nod+1].max;
		tree[nod].max_c = tree[2*nod+1].max_c;
	}
}
void update1(int u, lint v, int nod, int start, int end)
{
	if(start == end) {
		arr[start]=(arr[start]%MOD+v%MOD)%MOD;
		int i,c[10]={0}, m=0, p = arr[end];
		while(p!=0) {
			c[p%10]++;
			p=p/10;
		}
		for(i=0;i<10;i++) {
			if(c[i])
				m++;
		}
		tree[nod].min = m;
		tree[nod].max = m;
		tree[nod].min_c = 1;
		tree[nod].max_c = 1;
		return;
	}
	int mid = (start +end) / 2;
	if(u <= mid)
		update1(u,v,2*nod,start,mid);
	else
		update1(u,v,2*nod+1,mid+1,end);
	if(tree[2*nod].min < tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c=tree[2*nod].min_c;
	}
	else if(tree[2*nod].min == tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c = tree[2*nod].min_c + tree[2*nod+1].min_c;
	}
	else {
		tree[nod].min = tree[2*nod+1].min;
		tree[nod].min_c = tree[2*nod+1].min_c;
	}
	if(tree[2*nod].max > tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c;
	}
	else if(tree[2*nod].max == tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c + tree[2*nod+1].max_c;
	}
	else {
		tree[nod].max = tree[2*nod+1].max;
		tree[nod].max_c = tree[2*nod+1].max_c;
	}
	return;
}
void update2(int u, lint v, int nod, int start, int end)
{
	if(start == end) {
		arr[start]=((arr[start]%MOD)*(v%MOD))%MOD;
		int i,c[10]={0}, m=0, p = arr[end];
		while(p!=0) {
			c[p%10]++;
			p=p/10;
		}
		for(i=0;i<10;i++) {
			if(c[i])
				m++;
		}
		tree[nod].min = m;
		tree[nod].max = m;
		tree[nod].min_c = 1;
		tree[nod].max_c = 1;
		return;
	}
	int mid = (start +end) / 2;
	if(u <= mid)
		update2(u,v,2*nod,start,mid);
	else
		update2(u,v,2*nod+1,mid+1,end);
	if(tree[2*nod].min < tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c=tree[2*nod].min_c;
	}
	else if(tree[2*nod].min == tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c = tree[2*nod].min_c + tree[2*nod+1].min_c;
	}
	else {
		tree[nod].min = tree[2*nod+1].min;
		tree[nod].min_c = tree[2*nod+1].min_c;
	}
	if(tree[2*nod].max > tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c;
	}
	else if(tree[2*nod].max == tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c + tree[2*nod+1].max_c;
	}
	else {
		tree[nod].max = tree[2*nod+1].max;
		tree[nod].max_c = tree[2*nod+1].max_c;
	}
	return;
}
void update3(int u, lint v, int nod, int start, int end)
{
	if(start == end) {
		arr[start]=v%MOD;
		int i,c[10]={0}, m=0, p = arr[end];
		while(p!=0) {
			c[p%10]++;
			p=p/10;
		}
		for(i=0;i<10;i++) {
			if(c[i])
				m++;
		}
		tree[nod].min = m;
		tree[nod].max = m;
		tree[nod].min_c = 1;
		tree[nod].max_c = 1;
		return;
	}
	int mid = (start +end) / 2;
	if(u <= mid)
		update3(u,v,2*nod,start,mid);
	else
		update3(u,v,2*nod+1,mid+1,end);
	if(tree[2*nod].min < tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c=tree[2*nod].min_c;
	}
	else if(tree[2*nod].min == tree[2*nod+1].min) {
		tree[nod].min=tree[2*nod].min;
		tree[nod].min_c = tree[2*nod].min_c + tree[2*nod+1].min_c;
	}
	else {
		tree[nod].min = tree[2*nod+1].min;
		tree[nod].min_c = tree[2*nod+1].min_c;
	}
	if(tree[2*nod].max > tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c;
	}
	else if(tree[2*nod].max == tree[2*nod+1].max) {
		tree[nod].max = tree[2*nod].max;
		tree[nod].max_c = tree[2*nod].max_c + tree[2*nod+1].max_c;
	}
	else {
		tree[nod].max = tree[2*nod+1].max;
		tree[nod].max_c = tree[2*nod+1].max_c;
	}
	return;
}
struct a query1(int nod, int start, int end, int l, lint r)
{
	if(l>end || r<start) {
		struct a p;
		p.cnt=0;
		p.val=0;
		return p;
	}
	if(l <= start && r>=end) {
		struct a p;
		p.cnt=tree[nod].max_c;
		p.val=tree[nod].max;
		return p;
	}
	int mid = (start + end) / 2;
	struct a p1 = query1(2*nod, start, mid, l, r);
	struct a p2 = query1(2*nod+1, mid+1, end, l, r);
	if(p1.val>p2.val)
		return p1;
	if(p2.val>p1.val)
		return p2;
	struct a p3;
	p3.val=p2.val;
	p3.cnt = p2.cnt + p1.cnt;
	return p3;
}
struct a query2(int nod, int start, int end, int l, lint r)
{
	if(l>end || r<start) {
		struct a p;
		p.cnt=MAX;
		p.val=MAX;
		return p;
	}
	if(l <= start && r>=end) {
		struct a p;
		p.cnt=tree[nod].min_c;
		p.val=tree[nod].min;
		return p;
	}
	int mid = (start + end) / 2;
	struct a p1 = query2(2*nod, start, mid, l, r);
	struct a p2 = query2(2*nod+1, mid+1, end, l, r);
	if(p1.val>p2.val)
		return p2;
	if(p2.val>p1.val)
		return p1;
	struct a p3;
	p3.val=p2.val;
	p3.cnt = p2.cnt + p1.cnt;
	return p3;
}
int main()
{
	int q,i,n;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d",&arr[i]);
	for(i=0;i<=4*n+4;i++) {
		tree[i].max = 0;
		tree[i].max_c = 0;
		tree[i].min = MAX;
		tree[i].min_c = MAX;
	}
	build(1,1,n);
	//cout<<tree[1].max<<endl;;
	//cout<<tree[1].max_c<<endl;
	//cout<<tree[1].min<<endl;
	//cout<<tree[1].min_c;
	scanf("%d",&q);
	map<string, int> m;
	m["ADD"]=1;
	m["MUL"]=2;
	m["REP"]=3;
	m["MAX"]=4;
	m["MIN"]=5;
	while(q--) {
		string s;
		int u;
		lint v;
		cin>>s;
		scanf("%d%d",&u,&v);
		if(m[s]<4) {
			if(m[s]==1)
				update1(u,v,1,1,n);
			else if(m[s]==2)
				update2(u,v,1,1,n);
			else
				update3(u,v,1,1,n);
		}
		struct a ans;
		if(m[s]==4)
			ans=query1(1,1,n,u,v);
		if(m[s]==5)
			ans=query2(1,1,n,u,v);
		if(m[s]==4 || m[s]==5) {
			printf("%d %d\n",ans.val,ans.cnt);
		}
	}
	return 0;
}