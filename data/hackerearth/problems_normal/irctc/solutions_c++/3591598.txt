/*    ironstark    */
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define mp make_pair
#define vpi vector< pii >
#define pb push_back
#define ll long long
#define INF 10000000000007LL
#define gcd(a,b) __gcd(a,b)
#define sf(n) scanf("%lld",&(n))
#define pf(n) printf("%lld\n",(n))
#define setbits(n) __builtin_popcount((n))
#define pq priority_queue

using namespace std;
void dij(int s,ll dist[],ll path[],vpi v[],ll n)
{
	pq < pii , vpi , greater< pii > >q;
	q.push(mp(0,s));
	fill(dist,dist+n+1,INF);
	dist[s]=0;
	fill(path,path+n+1,-1);
	path[s]=0;
	while(!q.empty())
	{
		pii k=q.top();
		q.pop();
		ll x=k.fi;
		ll y=k.se;
		for(ll i=0;i<v[y].size();i++)
		{
			ll node=v[y][i].se;
			if(dist[node]>(x+v[y][i].fi))
			{
				dist[node]=x+v[y][i].fi;
				path[node]=y;
				q.push(mp(dist[node],node));
			}
		}
	}
}
int main()
{
	ll t;
	sf(t);
	while(t--)
	{
		ll n,k;
		sf(n);sf(k);
		vpi v[n+1];
		for(ll i=0;i<k;i++)
		{
			ll a,b,c;
			sf(a);sf(b);sf(c);
			v[a].pb(mp(c,b));
			v[b].pb(mp(c,a));
		}
		ll a,b,c;
		sf(a);sf(b);sf(c);
		ll dist1[n+1];
		ll path1[n+1];
		ll dist2[n+1];
		ll path2[n+1];
		dij(a,dist1,path1,v,n);
		dij(b,dist2,path2,v,n);

		ll a1=dist1[b];
		ll a2=dist2[c];
		//ll mx=INF;
	//	pf(a1);
	//	pf(a2);
		//pf(mx);
		
		if(a1!=(INF) && a2!=(INF))
        {
        ll ans=a1+a2;
        ll k1=b;
		ll k2=c;
       pf(ans);
        stack<int>s;
		while(path1[k1]!=0)
        {
            s.push(path1[k1]);
            k1=path1[k1];
        }
        while(!s.empty())
        {
            cout<<s.top()<<" ";
            s.pop();
        }
        while(path2[k2]!=0)
        {
            s.push(path2[k2]);
            k2=path2[k2];
        }
        while(!s.empty())
        {
            cout<<s.top()<<" ";
            s.pop();
        }
        cout<<c<<" ";
        cout<<endl;

	}
	else
        printf("No Train Found.\n");

}
}

