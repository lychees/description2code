t=int(raw_input())
def bfs(x):
    b=[False]*(n+1)# an array of false flags to keep track of vertices visited
    memo=["p"]*(n+1)
    l=0
    c=0
    q=[]
    q.append(x)
    memo[x]=0
    while len(q)!=0:
        #t=s[-1]
        top=q.pop(0)
        #l=t
        b[top]=True
        #q.pop(0)
        for j in G[top]:
            #print j
            if memo[j[0]]=="p":
                q.append(j[0])
                memo[j[0]]=memo[top]+j[1]#time of discovery(level) of child is time of discovery(level) of parent+1
                b[j[0]]=True
                if memo[j[0]]>l:
                    l=memo[j[0]]
                    c=j[0]
                    
                #c+=1
    #return l,c
    #m=0
    #m_i=0
    #print memo
    #for i in xrange(0,n+1):
     # if type(memo[i])==int and memo[i]>m:
      #  m=memo[i]
       # m_i=i
    return l,c     
    
while t!=0:
    n=int(raw_input())
    G=[[] for i in xrange(n+1)]
    p=n-1
    while p!=0:
        x,y,z=map(int,raw_input().split())
        G[x].append((y,z))#undirected graph has edge from u to v.
        G[y].append((x,z))#alse has edge from v to u.
      
        p-=1
    upto,new=bfs(1)
    found=False
    while not found:
        #print upto,new
        #upto,new=bfs(new)
        j=bfs(new)
        #print j
        if upto<j[0]:
            upto=j[0]
            new=j[1]
        else:
            found=True
    if upto<100:
        print 0,upto
    if upto>100 and upto <1000:
        print 100,upto
    if upto>1000 and upto <10000:
        print 1000,upto
    if upto>10000:
        print 10000,upto        
            
    t-=1                   
        
    