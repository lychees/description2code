#include <bits/stdc++.h>
using namespace std;
#define DBG(x) cout << #x << " = " << x << "\n";
/*
Compile:
    -Wall -Wextra -pedantic -std=c++11 -O2 -Wshadow -Wformat=2 -Wfloat-equal -Wconversion -Wlogical-op -Wcast-qual -Wcast-align -fwhole-program -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -lmcheck -fsanitize=address 
 
Check for memory usage:
    valgrind --tool=massif
 */

class FenwickTree
{
    vector<int> tree;
    int n;
    void add(int idx, int val)
    {
        for(;idx < n; idx = (idx | (idx + 1)))
            tree[idx] += val;
    }

    int get(int pos)
    {
        int res = 0;
        for(; pos >= 0; pos = (pos & (pos + 1)) - 1)
            res += tree[pos];
        return res;
    }

public:
    FenwickTree() = default;
    FenwickTree(int n)
    {
        this->n = n;
        tree = vector<int>(n, 0);
    }

    void inc(int idx)
    {
        add(idx, 1);
    }

    void dec(int idx)
    {
        add(idx, -1);
    }

    int get_sum(int left, int right)
    {
        return get(right) - get(left - 1);
    }
};

// In this task, we are required to keep track of number of inversions
// on current segment. We can do it by maintaining a Fenwick tree,
// which can tell us "how many numbers <= x are presented" and
// "how many numbers >= x are presented".
// But to do that, we should transform out initial numbers (up to
// 10^9) to smaller ones (up to N). We can do that, because
// there are no more than N different values in N input numbers.
struct Mo
{
    FenwickTree counter;
    int mx;
    long long answer;

    Mo(int mx)
    {
        this->mx = mx;
        counter = FenwickTree(mx);
    }

    void init()
    {
        answer = 0;
        counter = FenwickTree(mx);
    }

    // we add numbers either to the right side or to the left
    void add(int val, bool is_right_bound)
    {
        int inversions_added = 0;
        if(is_right_bound) {
            inversions_added = counter.get_sum(val + 1, mx - 1);
        } else 
            inversions_added = counter.get_sum(0, val - 1);

        answer += inversions_added;
        counter.inc(val);
    }

    // we remove numbers only from left side of segment
    void remove(int val)
    {
        int inversions_now = counter.get_sum(0, val - 1);
        answer -= inversions_now;
        counter.dec(val);
    }

    long long get_answer() const
    {
        return answer;
    }
};
 
int main()
{
    cin.sync_with_stdio(false);
    int n, q;

    cin >> n >> q;

    vector<int> numbers(n);
    vector<long long> answers(q);

    map<int, int> number_transformer;

    for(int i = 0; i < n; i++) {
        cin >> numbers[i];
    }

    vector<int> sorted_numbers(numbers);
    sort(sorted_numbers.begin(), sorted_numbers.end());

    for(int i = 0; i < n; i++) { 
        if(number_transformer.count(sorted_numbers[i]) == 0)
            number_transformer[sorted_numbers[i]] = number_transformer.size();
    }

    for(int i = 0; i < n; i++) {
        numbers[i] = number_transformer[numbers[i]];
    }

    int block_size = static_cast<int>(sqrt(n)) + 1;

    vector< tuple<int, int, int> > query_order;
    for(int i = 0; i < q; i++) {
        int le, rg;
        cin >> le >> rg;
        query_order.emplace_back(le - 1, rg - 1, i);
    } 

    auto mo_cmp = [&block_size](const tuple<int, int, int> &x,
           const tuple<int, int, int> &y) -> bool {
        int block_x = get<0>(x) / block_size;
        int block_y = get<0>(y) / block_size;

        if(block_x == block_y)
            return get<1>(x) < get<1>(y);
        return block_x < block_y;
    }; 
    
    sort(query_order.begin(), query_order.end(), mo_cmp);

    Mo solver(*max_element(numbers.begin(), numbers.end()) + 1);
    solver.init();

    int prev_block = -1;
    int mo_left = 0, mo_right = 0;
    for(int i = 0; i < q; i++) {
        int left, right, answer_idx;

        tie(left, right, answer_idx) = query_order[i];

        if(left / block_size != prev_block) {
            solver.init();

            mo_left = left;
            mo_right = left - 1;
        }

        prev_block = left / block_size;

        while(mo_right < right) 
            solver.add(numbers[++mo_right], true);
        while(mo_left > left)
            solver.add(numbers[--mo_left], false);
        while(mo_left < left)
            solver.remove(numbers[mo_left++]);

        answers[answer_idx] = solver.get_answer();
    }

    for(int i = 0; i < q; i++)
        cout << answers[i] << "\n";
    return 0;
}
