def format_input():
    l = raw_input().split(" ")
    while '' in l:
        l.remove('')
    return map(int, l)

def isValid(c, order):
    a, b = c
    return (0<= a < order) and (0 <= b < order)

def adj(a, b, order):
    pos = [(1,0),(0,-1),(-1,0),(0,1)]
    return filter(lambda a: isValid(a, order), [(a+i[0], b+i[1]) for i in pos])

def countPaths(pArr):
    # recheck indexing (y, x) or (x, y)
    order = len(pArr)
    # precalculate adjacent cells for each index
    adjArr = [[adj(x, y, order) for x in range(order)] for y in range(order)]
    count = 0
    toCheck = [(0,0,-1,-1)]
    visited = [(-1,-1)]
    while toCheck:
        #print toCheck
        curX, curY, origX, origY = toCheck.pop()
        if curY == order-1 and curX == order-1:
            count += 1
        else:
            if not visited[-1] == (origX, origY):
                visited = visited[:visited.index((origX, origY))+1]
            for a in adjArr[curY][curX]:
                if a not in visited and pArr[a[1]][a[0]] != 1:
                    toCheck.append(a + (curX, curY))
            visited.append((curX, curY))
    return count

def main():
    order = int(raw_input())
    prison = []
    for row in range(order):
        prison.append(format_input())
    print countPaths(prison)

if __name__ == '__main__':
    numTest = int(raw_input())
    for t in range(numTest):
        main()