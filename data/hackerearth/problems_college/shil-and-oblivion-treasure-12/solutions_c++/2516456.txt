#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<cstring>
#include<climits>
#include<cctype>
#include<cassert>
#include<algorithm>
#include<vector>
#include<map>
typedef long long ll;
using namespace std;
#define si(x) scanf("%d", &(x))
#define sll(x) scanf("%lld", &(x))
#define ss(x) scanf("%s", x)
#define sc(x) scanf("%c", &(x))
#define sline(x) scanf("%[^\n]", x)
#define MOD 1000000007
int primes[168] = {
   2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,
  43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101,
 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,
 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,
 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,
 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569,
 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,
 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733,
 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,
 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};
inline ll fmod(ll x) { if(x < MOD) return x; return x % MOD; }
inline ll powmod(ll a, ll b)
{
	if(b == 0) return 1;
	ll prod = 1, s = a;
	while(b)
	{
		if(b & 1)
			prod = fmod(prod * s);
		b>>=1;
		s = fmod(s * s);
	}
	return prod;
}
struct node_t
{
	int f[168];
	node_t()
	{
		memset(f, 0, sizeof(f));
	}
};
ll a[10000];
node_t st[32768 + 10];
int N, Q, t, x, y;
void comb(node_t &a, node_t &b, node_t &r)
{
	for(int i = 0; i < 168; i++)
		r.f[i] = max(a.f[i], b.f[i]);
}
void fact(ll Nk, node_t &r)
{
	memset(r.f, 0, sizeof(r.f));
	for(int j = 0; j < 168; j++)
	{
		while(Nk % primes[j] == 0)
		{
			Nk /= primes[j];
			r.f[j]++;
		}
	}
	assert(Nk == 1);
}

ll mult(node_t &r)
{
	ll ans = 1;
	for(int i = 0; i < 168; i++)
		ans = fmod(ans * powmod(primes[i], r.f[i]));
	return ans;
}
void build_tree(int node, int l, int r)
{
	if(l > r)
		return;
	if(l == r)
	{
		fact(a[l], st[node]);
		return;
	}
	build_tree(node * 2, l, (l + r) / 2);
	build_tree(node * 2 + 1, 1 + (l + r) / 2, r);
	comb(st[node * 2], st[node * 2 + 1], st[node]);
}
void update_tree(int node, int l, int r, int i, ll value)
{
	if(l > r || l > i || r < i)
		return;
	if(l == i && r == i)
	{
		fact(value, st[node]);
		return;
	}
	update_tree(node * 2, l, (l + r) / 2, i, value);
	update_tree(node * 2 + 1, (l + r) / 2 + 1, r, i, value);
	comb(st[node * 2], st[node * 2 + 1], st[node]);
}
node_t res;
void query_tree(int node, int l, int r, int i, int j)
{
	if(l > r || l > j || r < i)
	{
		memset(res.f, 0, sizeof(res.f));
		return;
	}
	if(l >= i && r <= j)
	{
		memcpy(res.f, st[node].f, 168*sizeof(int));
		return;
	}
	node_t q1, q2;
	query_tree(node * 2, l, (l + r) / 2, i, j);
	memcpy(q1.f, res.f, 168*sizeof(int));
	query_tree(node * 2 + 1, (l + r) / 2 + 1, r, i, j);
	memcpy(q2.f, res.f, 168*sizeof(int));
	comb(q1, q2, res);
}
int main()
{
	si(N);
	for(int i = 0; i < N; ++i)
		si(a[i]);
	build_tree(1, 0, N - 1);
	si(Q);
	while(Q--)
	{
		si(t);
		si(x);
		si(y);
		if(t == 2)
		{
			query_tree(1, 0, N - 1, x - 1, y - 1);
			printf("%lld\n", mult(res));
		}
		else
			update_tree(1, 0, N - 1, x - 1, y);
	}
	return 0;
}