#include <bits/stdc++.h>
using namespace std;

/*
1D to 2D algorithm
1D: [1]010 -> 0010
	[0010] -> 1101
	[11]01 -> 0001
	[000]1 -> 1111

**	[1010] -> 0101 (best way)
	[010]1 -> 1011
	[10]11 -> 0111
	[0]111 -> 1111

	[101]0 -> 0100
	[0]100 -> 1100
	[11]00 -> 0000
	[0000] -> 1111

(select any incorrect single element (from array at selection time not start time) and make it correct then don't do anything with it anymore is optimal solution)

if we select from top left to bottom right we always need to do something with it after correct it ... so not ok
if we select from bottom right to top left (reverse cin style) we can always ignore it :) ... ok
*/

int lastrow = 0;
int lastcol = 0;

bool isok(vector< vector<bool> > &data) {
	for (int i = 0;i<=lastrow;i++) {
		for (int j = 0;j<=lastcol;j++) {
			if (!data[i][j]) return false;
		}
	}
	return true;
}

int findcol(vector< vector<bool> > &data) {
	vector<bool> &lrow = data[lastrow];
	int result = -1;
	for (int i = 0;i<lrow.size();i++) {
		if (!lrow[i]) result=i;
	}
	return result;
}

void toggle(vector< vector<bool> > &data,int col) {
	for (int i = 0;i<=lastrow;i++) {
		for (int j = 0;j<=col;j++) {
			data[i][j] = !data[i][j];
		}
	}
}

int main()
{
	ios::sync_with_stdio(false);
    int t; cin>>t;
    while(t--){
    int n,m; cin>>n>>m;

    vector< vector<bool> > data(n,vector<bool>(m));
    for (int row = 0;row<n;row++) {
    	for (int col = 0;col < m ;col++) {
    		char in; cin>>in;
    		data[row][col] = in-'0';
    	}
    }

    lastrow = n-1;
    lastcol = m-1;
    int result = 0;
    while (!isok(data)) {
    	int col = findcol(data);
    	//cout<<lastrow<<' '<<col<<endl;
    	if (col==-1) {
    		lastrow--;
    		lastcol = m-1;
    	} else {
			result++;
			toggle(data,col);
    	}

    }
    cout<<result<<endl;

    }
    return 0;
}
