/**

   Pradip chandra karmaker
   Comilla University(6th_ICT)
*/



#include<bits/stdc++.h>
using namespace std;
#define xx first
#define yy second
#define pb push_back
#define mp make_pair
#define clr(a) memset(a,0,sizeof a)
#define neg(a) memset(a,-1,sizeof a)
#define Sort(a) sort(a.begin(),a.end())
#define All(a) a.begin(),a.end()
typedef long long i64;
typedef pair<int,int> pi;
#define mod 1000000007LL





template<class T>T Bitcnt(T a){int sum=0;while(a){if(a&1)sum++;a/=2;}return sum;}
template<class T>T Max3(T a,T b,T c){return max(a,max(b,c));}
template<class T>T Lcm(T a,T b){T tmp=__gcd(a,b);return (a/tmp)*b;}
template<class T> T Pow(T a,T b){T ans=1;T base=a;while(b){if(b&1)ans=(ans*base);base=(base*base);b/=2;}return ans;}
i64 Bigmod(i64 a,i64 b)
{
    i64 res=1;
    i64 pw=a%mod;
    while(b>0)
    {
       if(b&1)res=(res*pw)%mod;
       pw=(pw*pw)%mod;
       b/=2;
    }
    return res;
}


#define s1(a) scanf("%d",&a)
#define s2(a,b) scanf("%d %d",&a,&b)
#define s3(a,b,c) scanf("%d %d %d",&a,&b,&c)
#define sl1(a) scanf("%lld",&a)
#define sl2(a,b) scanf("%lld %lld",&a,&b)
#define sl3(a,b,c) scanf("%lld %lld %lld",&a,&b,&c)
#define p1(a) printf("%d",a)
#define p2(a,b) printf("%d %d",&a,&b)
#define NL printf("\n")
#define N 500005
#define rep(i,a,b)    for(int i=a;i<=b;i++)
#define rrep(i,b,a)   for(int i=b;i>=a;i--)
#define fs(i,a,s)     for(int i=a;s[i];i++)

int a_x[]={1,-1,0,0};
int a_y[]={0,0,1,-1};
//i64 X,Y;
//
//void extend_euclid(i64 a,i64 b)
//{
//    if(b==0)
//    {
//        X=a;Y=0;return;
//    }
//    extend_euclid(b,a%b);
//    i64 x,y;
//    x=Y;
//    y=X-(a/b)*Y;
//    X=x;
//    Y=y;
//}

//i64 inverse_modulo(i64 a,i64 b)
//{
//    extend_euclid(a,b);
//    return (X+mod)%mod;
//}

/** dijkstra,bitmask,ME,scc,backtracking,grid dp,segment tree,bit,LCA,bfs,dfs,BPM,MAX_FLOW,MCM,Tree dp,kmp,MST,Meet in the middle*/

/**Triangle characteristics,Phi,bitwise_seive,SOD,articulation,topological,HLD,Z,knapsack,Coin,Digit,LIS,LCS,minimum vertex
cover,josephus,chinese remainder,square root decomposition,ternary search,binary search,Number of theory(divisor,prime),chinese remainder,Generic functoin,Convex hull*/

/*************************************************************************************************************************************************************************************************/

i64 tree[3][N*10+5];
int dep[N];
vector<int>g[N];
vector<int>own[N];
i64 thres[N];
i64 F[N],X[N],D[N],L[N],R[N];
vector<int>tocheck[N];
int tin[N*10+5],tout[N*10+5];
int cnt=0;
int lmt;

void dfs(int node,int lvl)
{
   dep[node]=lvl;
    tin[node]=++cnt;
    int len=g[node].size();
   for(int i=0;i<len;i++)
     {
        int v=g[node][i];
        dfs(v,lvl+1);
     }
     tout[node]=cnt;
}

void add(int curr,int idx,i64 val)
{
     while(idx<=lmt)
     {
         tree[curr][idx]+=val;
         idx+=(idx& -idx);
     }
}

i64 get(int curr,int idx)
{
    i64 sum=0;
    while(idx>0)
    {
        sum+=tree[curr][idx];
        idx-=(idx & -idx);
    }
    return sum;
}


void apply(int idx)
{
    i64 on_ground=X[idx]-1LL*dep[F[idx]]*D[idx];
    add(1,tin[F[idx]],on_ground);
    add(1,tout[F[idx]]+1,-on_ground);
    add(0,tin[F[idx]],D[idx]);
    add(0,tout[F[idx]]+1,-D[idx]);
}
int main()
{

   ///freopen("input.txt","r",stdin);
    lmt=5000000;
    int n,m;
    s2(n,m);
      int a;
    rep(i,2,n)
     {
         s1(a);
         g[a].pb(i);
     }
     rep(i,1,n)
     {
         s1(a);
         own[a].pb(i);
     }
     rep(i,1,m)sl1(thres[i]);
     int Q;
     s1(Q);
     rep(i,1,Q)
      sl3(F[i],X[i],D[i]);
        dfs(1,0);

     rep(i,1,m){
       L[i]=1;R[i]=Q+1;
       }
     bool check=true;

     while(check)
     {
         check=false;
         memset(tree,0,sizeof tree);

          for(int i=1;i<=m;i++)
             if(L[i]!=R[i])tocheck[(L[i]+R[i])/2].pb(i);

         for(int q=1;q<=Q;q++)
         {
            apply(q);
             while(tocheck[q].size())
             {
                  check=true;
                 int id=tocheck[q].back();
                 tocheck[q].pop_back();
                 i64 ans=0;
                 for(int j=0;j<own[id].size();j++)
                 {
                     i64 t=get(1,tin[own[id][j]]);
                     t+=get(0,tin[own[id][j]])*1LL*dep[own[id][j]];
                     ans+=t;
                     if(thres[id]<=ans)break;
                 }
                 if(thres[id]<=ans)
                    R[id]=q;
                 else L[id]=q+1;
             }
         }
     }
     for(int i=1;i<=m;i++)
     {
         if(L[i]<=Q)
            printf("%d\n",L[i]);
         else printf("rekt\n");
     }


   return 0;
}



