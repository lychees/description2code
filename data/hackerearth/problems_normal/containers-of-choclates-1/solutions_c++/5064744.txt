/*	I will not win immediately,
 *	but I will win definitely...
 */
#include<bits/stdc++.h>
#define opt		ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
//=======================================================
#define li		long int
#define lli		long long int
//=======================================================
#define sd(n)		scanf("%d",&n)
#define sld(n)		scanf("%ld",&n)
#define slld(n)		scanf("%lld",&n)
#define pd(n)		printf("%d\n",n)
#define pld(n)		printf("%ld\n",n)
#define plld(n)		printf("%lld\n",n)
#define pn		printf("\n")
//=======================================================
#define rep(i,a,b)	for(i=a;i<b;i++)
#define repr(i,a,b)	for(i=a;i>b;i--)
#define repi(i,v)	for(i=v.begin();i!=v.end();i++)
#define elif		else if
#define clr(a,b)	memset(a,b,sizeof(a))
//=======================================================
#define vi		vector<int>
#define vli		vector<li>
#define vlli		vector<lli>
//=======================================================
#define pb		push_back
#define pob		pop_back
#define all(v)		v.begin(),v.end()
#define itr		iterator
#define sz		size()
#define lb		lower_bound
#define ub		upper_bound
#define mp		make_pair
#define pii		pair<int,int>
#define pll		pair<li,li>
#define vpi		vector<pii >
#define vpl		vector<pll >
#define F		first
#define S		second
//=======================================================
#define mod		1000000007
#define MX1		100005
#define MX2		1000005
//=======================================================
using namespace std;
//=======================================================
li power(li a, li b){
		li ans=1L;
		while(b){
				if(b&1)
						ans=(ans*a)%mod;
                a=(a*a)%mod;
                b>>=1;
		}
		return ans;
}
//=======================================================
li mmi(li n){
		return power(n,mod-2);
}
//=======================================================
li gcd(li a, li b){
        if(a%b==0)
                return b;
        else
                return gcd(b,a%b);
}
//=======================================================
void fs(int &x){
		bool neg=false;
		register int c;
		x=0;
		c=getchar();
		if(c=='-'){
				neg = true;
				c=getchar();
		}
		for(;(c>47 && c<58);c=getchar())
				x = (x<<1)+(x<<3)+c-48;
		if(neg)
				x *=-1;
}
//=======================================================
/*-----------------MAIN CODE BEGINS NOW!-----------------*/

vi adj[MX1];
int present[MX1];
int visited[MX1];
int level0,level1;

void init(){
        int i;
        rep(i,0,MX1){
                adj[i].clear();
                present[i]=0;
                visited[i]=0;
        }
}

void bfs(int s){
        queue<pii > q;
        q.push(mp(s,0));
        visited[s]=1;
        level0++;
        int i;
        while(!q.empty()){
                int x=q.front().F;
                int ch=q.front().S;
                q.pop();
                rep(i,0,adj[x].sz){
                        if(!visited[adj[x][i]]){
                                visited[adj[x][i]]=1;
                                if((ch+1)%2)
                                        level1++;
                                else
                                        level0++;
                                q.push(mp(adj[x][i],(ch+1)%2));
                        }
                }
        }
}

int main(){
        int t,j=1;
        fs(t);
        while(t--){
                init();
                int i,n,ans=0;
                fs(n);
                rep(i,1,n+1){
                        int x,y;
                        fs(x),fs(y);
                        adj[x].pb(y);
                        adj[y].pb(x);
                        present[x]=1;
                        present[y]=1;
                }
                rep(i,1,MX1){
                        if(present[i] && !visited[i]){
                                level0=0;
                                level1=0;
                                bfs(i);
                                ans+=(max(level0,level1));
                        }
                }
                printf("Case %d: %d\n",j,ans);
                j++;
        }
		return 0;
}
