/* https://www.hackerearth.com/march-clash-15/algorithm/counting-on-tree-1/description/ */
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define clr(X,a) memset((X), (a), sizeof((X)))
#define s(a) scanf("%d", &a)
#define ps(a) printf("%d ", a)
#define pn(a) printf("%d\n", a)
#define rep(i,n) for(i = 0; i < (n); i++)
#define repr(i,a,b) for(i = (a); i <= (b); i++)
#define MOD 1000000007LL

int N,i,j,T, a[50111], K;
long long dp[50111][110], buf[110];
vector<vector<int>> G;

void dfs(int v, int p)
{
    dp[v][a[v]] = 1;
    for(auto n : G[v]) if(n != p)
    {
        dfs(n, v);
        clr(buf, 0);
        for(int i = 0; i <= K; i++)
        for(int j = 0; j <= K-i; j++)
            buf[i + j] = (buf[i + j] + dp[v][i] * dp[n][j]) % MOD;
        for(int i = 0; i <= K; i++)
        {
            dp[v][i] += buf[i];
            if(dp[v][i] >= MOD) dp[v][i] -= MOD;
        }
    }
}

int main()
{
    s(T);
    while(T--)
    {
        s(N); s(K);
        rep(i, N) s(a[i+1]);
        G.clear(); G.resize(N + 1);
        rep(i, N-1)
        {
            int a, b; s(a); s(b);
            G[a].pb(b);
            G[b].pb(a);
        }
        clr(dp, 0);
        dfs(1, -1);
        long long ans = 0;
//        repr(i, 1, N) { cout << i << " = "; repr(j, 0, K) cout << dp[i][j] << " " ; cout << endl; }
        repr(i, 1, N) ans += dp[i][K];
        printf("%lld\n", ans % MOD); 
    }   
    
    return 0;
}

