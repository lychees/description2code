#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <algorithm>
#include <vector>
#include <set>
#include <map>

using namespace std;

#define LOCAL 0
#define DEBUG 0
#define NMAX 103
#define MOD 1000000007

vector<pair<int, int> > w[NMAX];
int cnt[NMAX][NMAX], deg[NMAX];
int N, M, i, j, k, c;

long long RaiseToPow(long long x, long long y) {
	if (y == 0) return 1;
	long long rez = RaiseToPow(x, y >> 1);
	rez = (rez * rez) % MOD;
	if (y & 1) rez = (rez * x) % MOD;
	return rez;
}

long long A[NMAX][NMAX];

long long ComputeDeterminant() {
	if (DEBUG >= 2) {
		fprintf(stderr, "[ComputeDeterminant] Initial matrix\n");
		for (i = 1; i < N; i++) {
			for (j = 1; j < N; j++) {
				fprintf(stderr, "%lld ", A[i][j]);
			}
			fprintf(stderr, "\n");
		}
	}

	long long tmp, tmp2;

	for (i = 1; i < N; i++) {
		for (k = i; k < N; k++)
			if (A[k][i] != 0) break;
		
		if (k != i) {
			for (j = 1; j < N; j++) {
				tmp = A[i][j]; A[i][j] = A[k][j]; A[k][j] = tmp;
			}
		}

		for (k++; k < N; k++) {
			if (A[k][i] != 0) {
				tmp = A[k][i];
				tmp = (tmp * RaiseToPow(A[i][i], MOD - 2)) % MOD;
				
				for (j = i; j < N; j++) {
					tmp2 = A[i][j];
					tmp2 = (tmp2 * tmp) % MOD;
					A[k][j] -= tmp2; if (A[k][j] < 0) A[k][j] += MOD;					
				}
			}
		}
	}

	if (DEBUG >= 2) {
		fprintf(stderr, "[ComputeDeterminant] Final matrix\n");
		for (i = 1; i < N; i++) {
			for (j = 1; j < N; j++) {
				fprintf(stderr, "%lld ", A[i][j]);
			}
			fprintf(stderr, "\n");
		}
	}
	
	long long det = 1;
	for (i = 1; i < N; i++)
		det = (det * A[i][i]) % MOD;

	return det;
}

char selected[NMAX];
int parent[NMAX], nchildren[NMAX], nsel, pj;
long long wmst, det;

bool FindMST() {
	wmst = 0;
	selected[N] = 1;
	nsel = 1;
	
	while (nsel < N) {
		int wmin = 0;
		j = 0;
		for (i = 1; i <= N; i++)
			if (selected[i])
				for (k = 0; k < w[i].size(); k++)
					if (!selected[w[i][k].second] &&
						(!wmin || w[i][k].first < wmin)) {
						wmin = w[i][k].first;
						j = w[i][k].second;
						pj = i;
					}
		if (!j) return false;
		selected[j] = 1;
		parent[j] = pj;
		nchildren[pj]++;
		wmst += wmin;
		nsel++;
	}
	if (DEBUG >= 1) fprintf(stderr, "[FindMST] wmst=%lld\n", wmst);
	return true;
}

vector<pair<long long, long long> > D[NMAX][NMAX];

void Normalize(vector<pair<long long, long long> >& v) {
	if (v.size() == 0) return;
	vector<pair<long long, long long> > vn;
	sort(v.begin(), v.end());
	vn.push_back(v[0]);	
	for (int i = 1; i < v.size(); i++) {
		if (v[i].first == v[i - 1].first) {
			vn[vn.size() - 1].second += v[i].second;
		} else {
			vn.push_back(v[i]);
		}
	}
	v.clear();
	v = vn;
}

long long GetNumberOfMinimumSpanningTrees() {
	if (!FindMST()) return 0;

	// Initialize D.
	for (i = 1; i <= N; i++) {
		for (k = 0; k < w[i].size(); k++) {
			j = w[i][k].second;
			c = w[i][k].first;
			D[i][i].push_back(make_pair(c, 1));
			D[i][j].push_back(make_pair(c, -1));
		}
		
		for (j = 1; j <= N; j++)
			Normalize(D[i][j]);
	}

	if (DEBUG >= 2) {
		fprintf(stderr, "Initial D=\n");
		for (i = 1; i < N; i++) {
			for (j = 1; j < N; j++) {
				fprintf(stderr, "(");
				for (k = 0; k < D[i][j].size(); k++)
					fprintf(stderr, "%lld*x^%lld ", D[i][j][k].second, D[i][j][k].first);
				fprintf(stderr, ") ");
			}
			fprintf(stderr, "\n");
		}
	}
	
	// Modify D.
	selected[N] = 0;
	nsel = 1;

	while (nsel < N) {
		for (i = 1; i < N; i++)
			if (selected[i] && nchildren[i] == 0)
				break;
	
		selected[i] = 0;
		nchildren[parent[i]]--;
		if (DEBUG >= 2) fprintf(stderr, "%d -> %d\n", i, parent[i]);
		for (k = 1; k <= N; k++) {
			for (j = 0; j < D[k][i].size(); j++)
				D[k][parent[i]].push_back(D[k][i][j]);
			Normalize(D[k][parent[i]]);
		}
		nsel++;
	}

	if (DEBUG >= 2) {
		fprintf(stderr, "Final D=\n");
		for (i = 1; i < N; i++) {
			for (j = 1; j < N; j++) {
				fprintf(stderr, "(");
				for (k = 0; k < D[i][j].size(); k++)
					fprintf(stderr, "%lld*x^%lld ", D[i][j][k].second, D[i][j][k].first);
				fprintf(stderr, ") ");
			}
			fprintf(stderr, "\n");
		}
	}

	// Factor out wmst from D.
	long long wfactorout = 0;

	for (j = 1; j < N; j++) {
		long long wmax = wmst;

		for (i = 1; i < N; i++) {
			for (k = 0; k < D[i][j].size(); k++)
				if (D[i][j][k].second != 0 && D[i][j][k].first < wmax)
					wmax = D[i][j][k].first;
		}
	
		for (i = 1; i < N; i++)
			for (k = 0; k < D[i][j].size(); k++)
				D[i][j][k].first -= wmax;

		wfactorout += wmax;
	}

	if (wfactorout != wmst) {
		fprintf(stderr, "wfactorout=%lld wmst=%lld\n", wfactorout, wmst);
		exit(1);
	}

	for (i = 1; i < N; i++)
		for (j = 1; j < N; j++) {
			long long sum = 0;
			for (k = 0; k < D[i][j].size(); k++)
				if (D[i][j][k].first == 0)
					sum += D[i][j][k].second;
			A[i][j] = sum % MOD;
		}
	
	return ComputeDeterminant();
}

char used[NMAX];
int p[NMAX];

void GeneratePerm() {
	memset(used, 0, sizeof(used));
	int i;
	for (i = 0; i < N; i++) {
		do {
			p[i] = 1 + (rand() % N);
		} while (used[p[i]]);
		used[p[i]] = 1;
	}
}

int main() {
	int tstart = clock();
	
//	freopen("x.txt", "r", stdin);

	if (LOCAL) {
		srand(123456789);
		N = 75;
		M = N * (N - 1) / 2;
		GeneratePerm();
	} else {
		scanf("%d %d", &N, &M);
		int unuseda, unusedb;
		for (int i = 1; i < N; i++) scanf("%d %d", &unuseda, &unusedb);
	}

	for (k = 1; k <= M; k++) {
		if (LOCAL) {
			if (k < N) {
				i = p[k];
				j = p[rand() % k];
			} else {
				do {
					i = 1 + (rand() % N);
					j = 1 + (rand() % N);
				} while (i == j);
			}
			c = 50000;// + (rand() % 50001);
		} else scanf("%d %d %d", &i, &j, &c);
		
		if (i != j) {
			cnt[i][j]++;
			cnt[j][i]++;
			deg[i]++;
			deg[j]++;
			w[i].push_back(make_pair(c, j));
			w[j].push_back(make_pair(c, i));
		}
	}

	printf("%lld\n", GetNumberOfMinimumSpanningTrees());
	fprintf(stderr, "Duration=%.3lf sec\n", (double) (clock() - tstart) / (double) CLOCKS_PER_SEC);
	return 0;
}
