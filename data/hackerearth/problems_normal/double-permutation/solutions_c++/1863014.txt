#include <iostream>
#include<cstring>
#include<vector>
#include<utility>
#include<set>
using namespace std;

#define LocalTest 0
#define ll long long
#define S first
#define E first
#define L second
#define MEMSET(a,v)  memset(a,v,sizeof(a))

const ll MOD = 1e9+7;
const int MAX = 5;

vector<int> num;
vector<pair<ll,pair<ll,ll>>> stats;

struct node
{
    int val,lCount,rCount,lh,rh;
    node *left, *right;
    int balanceFactor;
    node(ll x);
    ~node();
};

class BTree
{
    public:
        BTree(int val);
        BTree();
        ~BTree();
        void insertNode(int val);
        pair<ll,pair<ll,ll>> findVal(int val);
        void printTree()
        {
            inorderTraversal(root);
        }
    private:
        node *root;
        int noOfNOdes;
        void inorderTraversal(node* temp);
        int insertNode(node* temp, node* current,node** parent);
        bool isBalanced(int x);
        int branchHeight(node* current)
        {
            return current->lh>current->rh?current->lh+1:current->rh+1;
        }
        node* AVL(node* current,node** parent);
        node* leftLeftRotation(node* current,node** parent);
        node* leftRightRotation(node* current,node** parent);
        node* rightLeftRotation(node* current,node** parent);
        node* rightRightRotation(node* current,node** parent);
}tree;


ll computeMod(ll x);
ll power(ll a, ll b);


int main()
{
    #if LocalTest
    char file[10];
    cin>>file;
    strcat(file,".txt");
    freopen(file,"r",stdin);
    #endif // LocalTest
    ll n,temp,x,y,z,o,p,q,ans,l;
    cin>>n;
    l = 2*n;
    ans = 1;
    for(int i=0;i<l;i++)
        cin>>temp,num.push_back(temp);
    if(n>1)
    {
        z = power(2,n-2);
        for(int i=l-1;i>=0;i--)
        {
            stats.push_back(tree.findVal(num[i]));
            tree.insertNode(num[i]);
        }
        x = computeMod(z*3);
        y = computeMod(z*2);
        o = p = q = 0;
        for(int i=0;i<l;i++)
        {
            o += stats[i].S;
            p += stats[i].L.E;
            q += stats[i].L.L;
        }
        o = computeMod(o);
        p = computeMod(p);
        q = computeMod(q);
        ans = computeMod(o*x);
        ans += computeMod(p*y);
        ans += computeMod(q*z);
        ans = computeMod(ans);
    }
    cout<<ans<<endl;
    return 0;
}

pair<ll,pair<ll,ll>> BTree::findVal(int num)
{
    pair<ll,pair<ll,ll>> x;
    x.S = 0;
    x.L.E = 0;
    x.L.L = 0;
    node* temp = root;
    while(temp!=nullptr)
    {
        if(temp->val > num )
            temp = temp->left;
        else if(temp->val < num)
        {
            x.S += temp->lCount+1;
            temp = temp->right;
        }
        else
        {
            x.L.E = 1;
            x.S += temp->lCount;
            break;
        }
    }
    x.L.L = noOfNOdes-x.S-x.L.E;
    return x;
}

node* BTree::AVL(node* current, node**parent)
{
    node* temp= nullptr;
    if(current->balanceFactor<0)
    {
        temp = current->left;
        if(temp->balanceFactor<0)
            temp = leftLeftRotation(current,parent);
        else
            temp = leftRightRotation(current,parent);
    }
    else
    {
        temp = current->right;
        if(temp->balanceFactor<0)
            temp = rightLeftRotation(current,parent);
        else
            temp = rightRightRotation(current,parent);
    }
    return temp;
}

node* BTree::leftLeftRotation(node* current, node** parent)
{
    node* temp;temp = current->left;
    *parent = temp;
    current->left = temp->right;
    temp->right = current;
    current->lCount = temp->rCount;
    temp->rCount +=(current->rCount+1);
    current->lh = temp->rh;
    temp->rh = branchHeight(temp->right);
    return temp;
}

node* BTree::rightRightRotation(node* current, node** parent)
{
    node* temp;
    temp = current->right;
    *parent = temp;
    current->right = temp->left;
    temp->left = current;
    current->rCount = temp->lCount;
    temp->lCount +=(current->lCount+1);
    current->rh = temp->lh;
    temp->lh = branchHeight(temp->left);
    return temp;
}

node* BTree::leftRightRotation(node* current, node** parent)
{
    node* Q = current->left;
    node* R = Q->right;
    *parent = R;
    Q->right = R->left;
    current->left = R->right;
    R->left = Q;
    R->right = current;
    Q->rCount = R->lCount;
    Q->rh = R->lh;
    current->lCount = R->rCount;
    current->lh = R->rh;
    R->rCount = current->lCount+current->rCount+1;
    R->lCount = Q->lCount+Q->rCount+1;
    R->rh = branchHeight(current);
    R->lh = branchHeight(Q);
    return R;
}

node* BTree::rightLeftRotation(node* current, node** parent)
{
    node* Q = current->right;
    node* R = Q->left;
    *parent = R;
    Q->left = R->right;
    current->right = R->left;
    R->right = Q;
    R->left = current;
    Q->lCount = R->rCount;
    Q->lh = R->rh;
    current->rCount = R->lCount;
    current->rh = R->lh;
    R->lCount = current->lCount+current->rCount+1;
    R->rCount = Q->lCount+Q->rCount+1;
    R->lh = branchHeight(current);
    R->rh = branchHeight(Q);
    return R;
}

int BTree::insertNode(node* temp,node* current, node** parent)
{
    if(current == nullptr)
    {
        *parent = temp;
        return 1;
    }
    if(temp->val<=current->val)
    {
        current->lCount++;
        current->lh = insertNode(temp,current->left,&current->left);
    }
    else
    {
        current->rCount++;
        current->rh=insertNode(temp,current->right,&current->right);
    }
    current->balanceFactor = current->rh-current->lh;
    if(!isBalanced(current->balanceFactor))
        current = AVL(current,parent);
    return branchHeight(current);
}

void BTree::insertNode(int val)
{
    node* temp = new node(val);
    insertNode(temp,root,&root);
    noOfNOdes++;
}

bool BTree::isBalanced(int x)
{
    return (x>=-1&& x<=1);
}

void BTree::inorderTraversal(node *temp)
{
    if(temp!=nullptr)
    {
        inorderTraversal(temp->left);
        cout<<temp->val<<" : left Count->"<<temp->lCount<<" right count->"<<temp->rCount<<endl;
        inorderTraversal(temp->right);
    }
}

node::node(ll x)
{
    val = x;
    left = nullptr;
    right = nullptr;
    balanceFactor = 0;
    lCount = 0;
    rCount = 0;
    lh = 0;
    rh = 0;
}

node::~node()
{
    delete(left);
    delete(right);
}

BTree::BTree(int val)
{
    root = new node(val);
    noOfNOdes = 1;
}
BTree::BTree()
{
    root = nullptr;
    noOfNOdes = 0;
}

BTree::~BTree()
{
    delete(root);
}

ll computeMod(ll x)
{
    return x<MOD?x:x%MOD;
}

ll power(ll a, ll b)
{
    ll t = 1;
    while(b)
    {
        if(b&1)
            t *= a, t = computeMod(t);
        a *= a;
        a = computeMod(a);
        b>>=1;
    }
    return t;
}