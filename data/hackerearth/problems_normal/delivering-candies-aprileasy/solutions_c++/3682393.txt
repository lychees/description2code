/*input
5 4 3
5 4 3 2 1
1 2 5
3 2 3
3 5 1
1 5 1
*/
#include <bits/stdc++.h>
#include<stdio.h>
using namespace std;
#define pii pair<long long,long long>
#define F(i,a,b) for(ll i = (ll)(a); i <= (ll)(b); i++)
#define RF(i,a,b) for(ll i = (ll)(a); i >= (ll)(b); i--)
#define PI 3.14159265
#define ll long long
#define ff first
#define ss second
#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define INF 100000000009LL
#define mod 1000000007
ll p[200005];
vector <pii> g[100005];
ll dist[200005];
bool vis[200005];
struct comp {
    bool operator() (const pii &a, const pii &b) {
        return a.ss > b.ss;
    }
};
priority_queue < pii, vector<pii> , comp > pq;
vector <ll> temp;
int main() 
{
	std::ios::sync_with_stdio(false);
	while(!pq.empty())
		pq.pop();
	temp.clear();
	F(i,0,100000)
		g[i].clear();
	ll n,m,s;
	cin>>n>>m>>s;
	F(i,1,n)
		cin>>p[i];
	F(i,1,m)
	{
		ll u,v,w;
		cin>>u>>v>>w;
		g[u].pb(mp(v,w));
		g[v].pb(mp(u,w));
	}
	F(i,0,n+10)
	{
		dist[i] = INF;
	}
	dist[s] = 0;	
	pq.push(mp(s,0));
	// djisktra
	while(!pq.empty())
	{
		ll u;
		u = pq.top().ff;
		pq.pop();
		if(vis[u])
			continue;
		vis[u] = 1;
		ll sz = g[u].size();
		F(i,0,sz-1)
		{
			ll v = g[u][i].ff;
			ll w = g[u][i].ss;
			if(!vis[v] && (dist[u] + w < dist[v]))
			{
				dist[v] = dist[u] + w;
				pq.push(mp(v,dist[v]));
			}
		}
	}
	//F(i,1,n)
	//	cout<<dist[i]<<" ";
	ll pre=0,mulpre=0;
	F(i,1,n)
	{
		if(dist[i]!=INF)
		{
			pre = p[i] + pre;
			mulpre = dist[i]*p[i] + mulpre;
		}
	}
	F(i,1,n)
	{
		ll ans;
		if(dist[i]==INF)
		{
			ans = 0;
		}
		else
		{
			ans = 0;
			ans = dist[i]*(pre-p[i]);
			ans += mulpre - (dist[i]*p[i]);
		}
		temp.pb(ans);
	}
	ll sz = temp.size();
	F(i,0,sz-1)
		cout<<temp[i]<<" ";
	return 0;
}