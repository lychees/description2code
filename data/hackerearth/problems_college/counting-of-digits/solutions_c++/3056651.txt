#define _CRT_SECURE_NO_WARNINGS
#pragma comment(linker, "/stack:16777216")
#include <string>
#include <vector>
#include <map>
#include <list>
#include <iterator>
#include <set>
#include <queue>
#include <iostream>
#include <sstream>
#include <stack>
#include <deque>
#include <cmath>
#include <memory.h>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <utility> 
using namespace std;
 
#define FOR(i, a, b) for(int i = (a); i < (b); ++i)
#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)
#define REP(i, N) FOR(i, 0, N)
#define RREP(i, N) RFOR(i, N, 0)
#define FILL(A,value) memset(A,value,sizeof(A))
 
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979

typedef long long Int;
typedef unsigned long long UINT;
typedef vector <int> VI;
typedef pair <int, int> PII;

const int INF = 2000000000;
const int MAX = 1024;
const int MAX2 = 1007;
const int BASE = 1000000000;

const int MOD = 1000000007;

int n;
char S[MAX];
int D[MAX+1];
int Q[MAX+1];
int H[MAX+1];
Int P[MAX*2 + 7];
int C[MAX+1][1 << 10][2];
int W[1 << 10];

int main()
{
	
	P[0] = 1;
	FOR (i,1,MAX*2+7)
		P[i] = (P[i-1] * 10) % MOD;
	FOR (mask,0,(1 << 10))
	{
		W[mask] = 0;
		FOR (i,0,10)
			if ((mask & (1 << i)) != 0)
				++ W[mask];
	}
	scanf("%s", S);
	n = strlen(S);
	FOR (i,0,n)
		D[MAX-n+i] = (S[i] - '0');
	int minus = 9;
	if (n == 1)
		minus = min(minus, (S[0] - '0'));
	Int res = 0;
	FOR (it,0,minus)
	{
		FILL(C, 0);
		FILL(Q, 0);
		C[0][0][1] = 1;
		FOR (i,0,MAX)
			FOR (mask,0,(1 << 10))
				FOR (b,0,2)
				{
					if (C[i][mask][b] == 0)
						continue;
					FOR (d,0,10)
					{
						int next_mask = mask;
						if (!(mask == 0 && d == 0))
							next_mask |= (1 << d);
						int next_b = b;
						if (b == 1)
						{
							if (d < D[i])
								next_b = 0;
							else
							if (d > D[i])
								continue;
						}
						C[i+1][next_mask][next_b] += C[i][mask][b];
						C[i+1][next_mask][next_b] %= MOD;
					}
				}

		FOR (d0,0,9)
			FOR (d1,0,10)
				FOR (cnt,0,n)
				{
					FILL(Q, 0);
					Q[MAX-1] = d1;
					FOR (i,0,cnt)
						Q[MAX-2-i] = 9;
					Q[MAX-2-cnt] = d0;
					int left = MAX-2-cnt, digits = 0, digits_other = 0;
					bool greater = 0;
					FOR (i,left,MAX)
					{
						if (Q[i] > D[i])
						{
							greater = 1;
							break;
						}
	
						if (Q[i] < D[i])
							break;
					}
					digits |= (1 << d1);
					if (cnt > 0)
						digits |= (1 << 9);
					bool was = 0;
					FOR (i,0,it+1)
					{
						if (d1+i >= 10)
							was = 1;
						digits |= (1 << ((d1+i) % 10));
					}
					if (was)
					{
						digits |= (1 << (d0+1));
						if (cnt > 0)
							digits |= (1 << 0);
					}
					digits_other = digits;
					digits |= (1 << d0);
					FOR (mask,0,(1 << 10))
					{
						FOR (b,0,2)
						{
							if (b == 1 && greater)
								continue;
							int tmp = 0;
							if (mask == 0 && d0 == 0)
								tmp = digits_other;
							else
								tmp = digits;
							res += Int(C[left][mask][b]) * W[mask | tmp];
							res %= MOD;
							//if (C[left][mask][b] != 0)
							//	cout << d0 << ' ' << d1 << ' ' << cnt << ' ' << mask << ' ' << b << ' ' << C[left][mask][b] << ' ' << W[mask | tmp] << endl;
						}
					}
				}
		
		-- D[MAX-1];
		int pos = MAX-1;
		while (D[pos] < 0)
		{
			D[pos] += 10;
			-- pos;
			-- D[pos];
		}
		res -= (it + 1);
		if (res < 0)
			res += MOD;
		//cout << res << endl;
	}
	FOR (i,0,MAX)
		H[i] = D[i];
	++ H[MAX-1];
	int pos = MAX-1;
	while (H[pos] == 10)
	{
		H[pos] = 0;
		-- pos;
		++ H[pos];
	}
	Int add = 0;
	FOR (i,0,MAX)
		FOR (j,0,MAX)
		{
			Int d = D[i] * H[j];
			d *= P[2*MAX-(i+j)-2];
			d %= MOD;
			add += d;
			add %= MOD;
		}
	//cout << add << endl;
	add *= 5;
	add %= MOD;
	res += add;
	res %= MOD;
	printf("%d\n", int(res % MOD));

	return 0;
}