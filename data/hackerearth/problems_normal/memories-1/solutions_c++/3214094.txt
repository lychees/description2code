//
//  main.cpp
//  hackerEarthQualifyR3
//
//  Created by Tran Hieu on 1/17/16.
//  Copyright Â© 2016 TranHieu. All rights reserved.
//


#if 1
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <stdio.h>
#include <cmath>
#include <algorithm>
#include <vector>
#include <cstring>
#include <map>
#include <queue>
#include <stack>
#include <set>

#define for1(i,j,k) for (int i=j;i<=k;i++)
#define for2(i,n) for (int i=0;i<n;i++)
#define for1_(i,j,k) for (int i=j;i>=k;i--)
#define for2_(i,n) for (int i=n-1;i>=0;i--)
#define c_s cout.setf(ios::fixed)
#define c_p(x) cout.precision(x)
#define can(x,n) (int)pow(x,1.0/n)
#define mp(x,y) make_pair(x,y)
#define hvi(a,n) next_permutation(a,a+n)
#define Pi 2*asin(1.0)

#define maxN 100100
#pragma comment(linker, "/STACK:36777216")
typedef long long ll;
using namespace std;

class _{
    
public:
    
    void printResult(int t, int x){
        cout << "Case #"<< t << ": " << x << endl;
    }
    
    void solve(){
        
    }
};

class Zeroes{
    int n;
    vector<int> a;
    vector<int> primes;
    vector<int> cnt;
    vector<int> cnt2;
    vector<int> cc;
    vector<bool> pr;
public:
    bool isPrime(int x){
        for (int i = 2; i <= (int) sqrt(x); i++)
            if (x % i == 0) return false;
        return true;
    }
    void devide(int x){
        if (pr[x]){
            cnt[x]++;
            return;
        }
        int tx = x;
        for (int i = 0; i < primes.size() && tx > 1; i++)
            if (tx % primes[i] == 0){
                while (tx > 1 && tx % primes[i] == 0){
                    cnt[primes[i]]++;
                    tx /= primes[i];
                }
            }
    }
    void devide2(int x){
        cnt2.clear();
        cc.clear();
        if (pr[x]){
            cnt2.push_back(x);
            cc.push_back(1);
            return;
        }
        int tx = x;
        for (int i = 0; i < (int) primes.size() && tx > 1; i++)
            if (tx % primes[i] == 0){
                cnt2.push_back(primes[i]);
                cc.push_back(0);
                while (tx > 1 && tx % primes[i] == 0){
                    cc[cc.size() - 1]++;
                    tx /= primes[i];
                }
            }
    }
    void DB(int x){
        cout << "Debug " << x << endl;
    }
    void solve(){
        pr.assign(1e5 + 1, false);
        cnt.assign(1e5 + 1, 0);
        primes.clear();
        for (int i = 2; i <= 1e5; i++){
            pr[i] = isPrime(i);
            if (pr[i])
                primes.push_back(i);
        }

        cin >> n;
        a.resize(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
            devide(a[i]);
        }
        //DB(cnt[2]); DB(cnt[5]);
        int q, x;
        cin >> q;
        for (int i = 0; i < q; i++){
            cin >> x;
            devide2(x);
            
            int res = cnt[cnt2[0]] / cc[0];
            for (int j = 1; j <(int) cnt2.size(); j++){
                res = min(res, cnt[cnt2[j]] / cc[j]);
            }
            cout << res << endl;
        }
    }
};

class Memories{
    vector< vector< bool >> dd;
    vector<int> st;
    int n, p;
public:
    int try_(int pos, int cnt){

        if (pos == n){
            return (cnt > 0)? 1: 0;
        }
        
        int res = 0;
        res += try_(pos + 1, cnt);
        
        bool check = true;
        for (int i = 0; i < st.size(); i++)
            if (dd[pos][st[i]]){
                check = false;
                break;
            }
        if (check){
            st.push_back(pos);
            res += try_(pos + 1, cnt + 1);
            st.pop_back();
        }
        return res;
    }
    void solve(){
        int test;
        cin >> test;
        for (int t = 0; t < test; t++){
            cin >> n >> p;
            dd.assign(n, vector<bool>(n, false));
            st.clear();
            int a, b;
            for (int i = 0; i < p; i++){
                cin >> a >> b;
                --a; --b;
                dd[a][b] = true;
                dd[b][a] = true;
            }
            cout << try_(0, 0) << endl;
        }
    }
};
int main()
{
    //freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
    
    
    Memories task; task.solve();
    return 0;
}
#endif