#include<iostream>
#include<stack>
#include<queue>
#include<vector>
#include<list>
#include<map>
#include<set>
#include<string.h>
#include<math.h>
#include<algorithm>

using namespace std;

#define ll long long
#define l long
#define ve vector
#define st stack
#define qu queue
#define pq priority_queue
#define li list
#define mp make_pair
#define p_b push_back
#define F first
#define S second
#define forf(i,a,b) for(i=a;i<=b;i++)
#define forb(i,a,b) for(i=a;i>=b;i--)

ll t,x,y,a[1001][1001];

ll dfs(ll i,ll j)
{
	ll cn=0,m,n;
	pair<ll, ll> p,t;
	st<pair<ll, ll> > s;
	p=mp(i,j);
	s.push(p);
	cn++;
	while(!s.empty())
	{
		t=s.top();
		s.pop();
		m=t.F;
		n=t.S;
		a[m][n]=2;
		if(m-1>=0 && n-1>=0)
		{
			if(a[m-1][n-1]==1)
			{
				s.push(mp(m-1,n-1));
				a[m-1][n-1]=2;
				cn++;
			}
		}
		if(m-1>=0)
		{
			if(a[m-1][n]==1)
			{
				s.push(mp(m-1,n));
				a[m-1][n]=2;
				cn++;
			}
		}
		if(n-1>=0)
		{
			if(a[m][n-1]==1)
			{
				s.push(mp(m,n-1));
				a[m][n-1]=2;
				cn++;
			}
		}
		if(m+1<x && n+1<y)
		{
			if(a[m+1][n+1]==1)
			{
				s.push(mp(m+1,n+1));
				a[m+1][n+1]=2;
				cn++;
			}
		}
		if(n+1<y)
		{
			if(a[m][n+1]==1)
			{
				s.push(mp(m,n+1));
				a[m][n+1]=2;
				cn++;
			}
		}
		if(m+1<x)
		{
			if(a[m+1][n]==1)
			{
				s.push(mp(m+1,n));
				a[m+1][n]=2;
				cn++;
			}
		}
		if(m-1>=0 && n+1<y)
		{
			if(a[m-1][n+1]==1)
			{
				s.push(mp(m-1,n+1));
				a[m-1][n+1]=2;
				cn++;
			}
		}
		if(m+1<x && n-1>=0)
		{
			if(a[m+1][n-1]==1)
			{
				s.push(mp(m+1,n-1));
				a[m+1][n-1]=2;
				cn++;
			}
		}
		
	}
	return cn;
}
ll maxim(ll a,ll b)
{
	if(a>=b)
	return a;
	else 
	return b;
}
int main()
{
	ll i,j,count,groups,max;
	cin>>t;
	while(t--)
	{
		cin>>x>>y;
		groups=0;
		forf(i,0,x-1)
		{
			forf(j,0,y-1)
			{
				cin>>a[i][j];
			}
		}
		max=0;
		forf(i,0,x-1)
		{
			forf(j,0,y-1)
			{
				if(a[i][j]==1)
				{
					count=dfs(i,j);
					max=maxim(max,count);
					groups++;
				}
			}
		}
		cout<<groups<<" "<<max<<endl;
	}
	return 0;
}