#include <bits/stdc++.h>

using namespace std;

const int N = 5e5;  
int n, q;  
int t[N<<1];
vector<int> g[N];

void read()
{
    scanf("%d %d", &n, &q);
    for (int i = 0; i < n-1; ++i)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        --u, --v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
}

void init_tree() {
  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];
}

void modify(int l, int r, int value) {
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) t[l++] += value;
    if (r&1) t[--r] += value;
  }
}

int query(int p) {
  int res = 0;
  for (p += n; p > 0; p >>= 1) res += t[p];
  return res;
}


  int parent[N], heavy[N], depth[N];
  int root[N], treePos[N];

  int dfs(int v) {
    int size = 1, maxSubtree = 0;
    for (int i = 0; i < g[v].size(); ++i)
    {
        int u = g[v][i];
        if (u != parent[v]) {
          parent[u] = v;
          depth[u] = depth[v] + 1;
          int subtree = dfs(u);
          if (subtree > maxSubtree) heavy[v] = u, maxSubtree = subtree;
          size += subtree;
        }
    }
    return size;
  }

  void processPath(int u, int v, int value) {
    for (; root[u] != root[v]; v = parent[root[v]]) {
      if (depth[root[u]] > depth[root[v]]) swap(u, v);
      modify(treePos[root[v]], treePos[v] + 1, value);
    }
    if (depth[u] > depth[v]) swap(u, v);
    modify(treePos[u], treePos[v] + 1, value);
  }

  void init() {
    fill_n(heavy, n, -1);
    parent[0] = -1;
    depth[0] = 0;
    dfs(0);
    for (int i = 0, currentPos = 0; i < n; ++i)
      if (parent[i] == -1 || heavy[parent[i]] != i)
        for (int j = i; j != -1; j = heavy[j]) {
          root[j] = i;
          treePos[j] = currentPos++;
        }
    //init_tree();
  }

  void modifyPath(int u, int v, const int value) {
    processPath(u, v, value);
  }

void solve()
{
    init();
    //for (int i = 0; i < n; ++i)
    //    cerr << treePos[i] << " "; cerr << endl;
    for (int i = 0; i < q; ++i)
    {
        int t;
        scanf("%d", &t);
        switch (t)
        {
            case 1: {
                        int u, v; scanf("%d %d", &u, &v); --u, --v;
                        modifyPath(u, v, 1);
                        break;
                    }
            case 2: {
                        int u; scanf("%d", &u); --u;
                        printf("%d\n", query(treePos[u]));
                        break;
                    }
        }
        //for (int j = 0; j < n; ++j)
        //    cerr << query(treePos[j]) << " "; cerr << endl;
    }  
}

int main() {
    memset(t, 0, sizeof t);
    read();
    solve();
    return 0;
}
