#include <iostream>
#include <algorithm>
#include <cassert>
#include <vector>
#define gc getchar_unlocked
using namespace std;
template <typename T> void scanint(T &x) {
	T c = gc(); while(((c < 48) || (c > 57)) && (c!='-')) c = gc();
	bool neg = false; if(c == '-') neg = true; x = 0; for(;c < 48 || c > 57;c=gc());
	for(;c > 47 && c < 58;c=gc())	x = (x*10) + (c - 48); if(neg)	x = -x;
}
const int MAXN = 500003;
struct query {
    int a;
    double x, d;
}qs[MAXN];
// n factories, m bussinessmen
int n, m, q, st[MAXN], en[MAXN], pool = 0, L[MAXN], R[MAXN], depth[MAXN], inv[MAXN];
vector<int> adj[MAXN], w[MAXN];

double reqd[MAXN], bit[3][MAXN];
vector<int> lst[MAXN];

void walk(int r = 1, int p = -1, int d = 0) {
    st[r] = ++pool, depth[r] = d, inv[pool] = r;
    for(auto &elem: adj[r]) if(elem != p) walk(elem, r, d+1);
    en[r] = pool;
}
void update(int b_no, int idx, double val) { while(idx <= n) bit[b_no][idx] += val, idx += idx & -idx; }
void range_update(int b_no, int l, int r, double val) { update(b_no, l, val), update(b_no, r+1, -val); }
double query(int b_no, int idx) { double res = 0; while(idx) res += bit[b_no][idx], idx -= idx & -idx; return res; }

void reset() { for(int j = 0; j < 3; j++) for(int i = 0; i <= n; i++) bit[j][i] = 0; }

bool checker(int idx) {
    double res = 0;
    for(auto elem: lst[idx]) {
        elem = st[elem];
        res += query(2, elem) + query(1, elem) * depth[inv[elem]] - query(0, elem);
        if(res >= reqd[idx]) return true;
    }
    return res >= reqd[idx];
}

int main() {
    int x;
    scanint(n), scanint(m);
    for(int i = 2; i <= n; i++) {
        scanint(x);
        adj[x].push_back(i);
    }
    walk();
    for(int i = 1; i <= n; i++) {
        scanint(x);
        lst[x].push_back(i);
    }
    for(int i = 1; i <= m; i++) scanf("%lf", &reqd[i]);
    scanint(q);
    for(int i = 1; i <= q; i++) {
        scanint(qs[i].a);
        scanf("%lf %lf", &qs[i].x, &qs[i].d);
    }
    // Input Done
    for(int i = 1; i <= m; i++) L[i] = 1, R[i] = q+1;
    while(true) {
        bool flag = true;
        for(int i = 1; i <= m; i++) {
            if(L[i] != R[i]) {
                flag = false;
                w[(L[i] + R[i])/2].push_back(i);
            }
        }
        if(flag) break;
        for(int i = 1; i <= q; i++) {
            // apply i
            range_update(2, st[qs[i].a], en[qs[i].a], qs[i].x);
            range_update(1, st[qs[i].a], en[qs[i].a], qs[i].d);
            range_update(0, st[qs[i].a], en[qs[i].a], qs[i].d * depth[qs[i].a]);
            while(w[i].empty() == false) {
                if(checker(w[i].back())) R[w[i].back()] = i;
                else L[w[i].back()] = i+1;
                w[i].pop_back();
            }
        }
        reset();
    }
    for(int i = 1; i <= m; i++) {
        if(L[i] == q+1) printf("rekt\n");
        else printf("%d\n", L[i]);
    }
    return 0;
}
