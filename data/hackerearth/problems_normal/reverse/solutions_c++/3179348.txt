#include <bits/stdc++.h>

#define FO(i,a,b) for (int i = (a); i < (b); i++)
#define sz(v) int(v.size())

#define MOD 1000000007ll

using namespace std;

typedef long long ll;

struct Matrix {
    const static int N = 105;
    int n;
    ll v[N][N];

    void init(int _n) {
        n = _n;
        FO(i,0,n) FO(j,0,n) v[i][j] = 0;
    }

    void ident() {
        FO(i,0,n) FO(j,0,n) v[i][j] = 0;
        FO(i,0,n) v[i][i] = 1;
    }

    bool operator==(const Matrix &o) const {
        FO(i,0,n) FO(j,0,n) if (v[i][j] != o.v[i][j]) return false;
        return true;
    }

    Matrix operator*(const Matrix &o) const {
        assert(n == o.n);

        Matrix res; res.init(n);
        ll mod2 = MOD*1ll*MOD;
        FO(i,0,n) FO(j,0,n) {
            FO(k,0,n) {
                res.v[i][j] += v[i][k] * o.v[k][j];
                if (res.v[i][j] >= mod2) res.v[i][j] -= mod2;
            }
            res.v[i][j] %= MOD;
        }

        return res;
    }

    Matrix operator^(long long k) {
        Matrix res; res.init(n); res.ident();
        Matrix a = *this;
        while (k) {
            if (k&1) res = res*a;
            a = a*a;
            k /= 2;
        }
        return res;
    }
};

ll pw(ll a, ll b, ll md) {
    ll r = 1;
    while (b) {
        if (b&1) r = (r*a) % md;
        a = (a*a)%md;
        b /= 2;
    }
    return r;
}

int n, k;

Matrix gm(int pos) {
    Matrix res;
    res.init(k*k+1);
    ll mul = pw(10, pos, k);
    FO(i,0,10) {
        if (pos == 0 && i == 0) continue;
        FO(x,0,k) FO(y,0,k) {
            int nx = (x*10+i)%k;
            int ny = (y+mul*i)%k;
            int cx = x%k;
            int cy = y%k;
            res.v[cx*k+cy][nx*k+ny]++;
        }
    }
    res.v[0][k*k] = 1;
    res.v[k*k][k*k] = 1;
    return res;
}

int main() {
    int t; scanf("%d", &t);
    FO(z,0,t) {
        scanf("%d%d", &n, &k); n++;
        Matrix cm;
        cm.init(k*k+1); cm.ident();
        int l = min(15,n);
        FO(i,0,l) cm = cm * gm(i);

        vector<Matrix> mv;
        FO(i,l,l+420) {
            mv.push_back(gm(i));
            if (i != l && mv.back() == mv.front()) break;
        }
        mv.pop_back();
        Matrix tmp; tmp.init(k*k+1); tmp.ident();
        for (auto &m : mv) tmp = tmp * m;
        int r = n-l;

        cm = cm * (tmp ^ (r/sz(mv)));
        r = (r/sz(mv)) * sz(mv) + l;
        FO(i,r,n) cm = cm * gm(i);

        printf("%lld\n", cm.v[0][k*k]);
    }
}

