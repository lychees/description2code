#include<bits/stdc++.h>
using namespace std;

// Numeric Constants
#define maxs 2000005
#define mins 1005
#define eps 0.000000000001
#define imax 2000000200
#define llmax 1000000002000000000ll
#define pi 3.141592653589793

// Others
#define ll long long
#define pb push_back
#define gc getchar_unlocked
#define iosbase ios_base::sync_with_stdio(false)
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ppi pair<pair<int,int>,int>
#define ppl pair<pll,ll>
#define vi vector<int>
#define sc scanf
#define pr printf
#define lld I64d
#define F first
#define S second
#define siter set<int>::iterator
#define p_pq priority_queue
#define ub upper_bound
#define lb lower_bound
 
const double PI = 3.141592653589793238460;
typedef std::complex<double> Complex;
typedef std::valarray<Complex> CArray;

#define siz 3048576
Complex A[siz],B[siz];
ll reals[siz];
char s1[500005],s2[500005];
void fft(CArray& x)
{
    const size_t N = x.size();
    if (N <= 1) return;
 
    // divide
    CArray even = x[std::slice(0, N/2, 2)];
    CArray  odd = x[std::slice(1, N/2, 2)];
 
    // conquer
    fft(even);
    fft(odd);
 
    // combine
    for (size_t k = 0; k < N/2; ++k)
    {
        Complex t = std::polar(1.0, -2 * PI * k / N) * odd[k];
        x[k    ] = even[k] + t;
        x[k+N/2] = even[k] - t;
    }
}
 
// inverse fft (in-place)
void ifft(CArray& x)
{
    // conjugate the complex numbers
    x = x.apply(std::conj);
 
    // forward fft
    fft( x );
 
    // conjugate the complex numbers again
    x = x.apply(std::conj);
 
    // scale the numbers
    x /= x.size();
}

CArray convolution(Complex A[],Complex B[],int n)
{
	CArray a(A,n);
	CArray b(B,n);
	
	fft(a);
	fft(b);
	CArray c(A,n);
	
	for (size_t k = 0; k < n; ++k)
    {
        c[k]=a[k]*b[k];
    }
    
    ifft(c);
    return c;
}

ll arr[100005];
ll cnt1[120005];

int main()
{
	ll t,l1,l2,i,j,m1,p,temp,rem,ln1,ln2,val,pre,n,k;
		sc("%lld",&n);
		for(i=0;i<n;i++){
			sc("%lld",&arr[i]);
		}
	//	cnt1[0]=1;
		for(i=0;i<n;i++){
			cnt1[arr[i]]++;
		}
		ll cnt=0;
		int fl=0;
		for(i=0;i<=120000;i++){
			A[i]=cnt1[i];
			B[i]=cnt1[120000-i];
			if(cnt1[i]>1){
				fl=1;
			}
		}
		if(fl){
			cnt++;
		}
		ln1=ln2=120000;
		m1=max(ln1,ln2);
		p=2;
		while(p<=m1){
			p*=2;
		}
		if(ln1+ln2>p){
			p*=2;
		}
		for(k=ln1;k<p;k++){
			A[k]=0;
		}
		for(k=ln2;k<p;k++){
			B[k]=0;
		}
		CArray ans=convolution(A,B,p);
		for(i=0;i<120000;i++){
			ll val=floor(ans[i].real()+0.5);
			if(val>0){
			//	cout<<i<<" ";
				cnt++;
			}
		}
		pr("%lld\n",cnt);
	return 0;
}