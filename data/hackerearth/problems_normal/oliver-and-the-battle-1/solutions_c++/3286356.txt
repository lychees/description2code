// 2016-01-28
#include <bits/stdc++.h>
#include <unordered_map>
#include <array>
#include <forward_list>
#include <unordered_set>
using namespace std;

#ifndef LOCAL
//#define LOCAL
#endif

#ifdef LOCAL
//#include <vld.h>
#pragma comment(linker, "/STACK:256000000")
#endif


#define ff first
#define ss second
#define sz(x) (int)((x).size())
#define szo(x) sizeof(x)
#define mem2d(arr, value) (fill(&arr[0][0], &arr[0][0] + szo(arr) / szo(decltype(value)), value));
#define mem(arr, value) memset(arr, value, szo(arr));
#define fo(i, j, k) for (int i = j; i <= (int)(k); ++i) // [j..k]
#define fd(i, j, k) for (int i = j; i >= (int)(k); --i) // [j..k]
#define gg cout << "OK\n"
#define dd(x) cout << #x << " = " << x << "\n";
#define pub push_back
#define pob pop_back
#define puf push_front
#define pof pop_front

#define SET_BIT(mask, index) (mask |= (1LL << index))
#define TEST_BIT(mask, index) (mask & (1LL << index))
#define CLEAR_BIT(mask, index) (mask &= ~(1LL << index))
#define TOGGLE_BIT(mask, index) (mask ^= (1LL << index))
const int INF = 1000000000;
const int NO_VALUE = -1;
using pii = pair<int, int>;
using pip = pair<int, pii>;
using ll = long long;
using vi = vector<int>;
using vll = vector<ll>;
#define umap unordered_map
#define uset unordered_set


template <class T>
T scan() {
    T t;
    cin >> t;
    return t;
}

#define sc(T) scan<decltype(T)>()
#define sci scan<int>()
#define scll scan<ll>()
#define scs scan<string>()
#define scd scan<double>()


const vector<vi> POS{{-1, 0},{-1, 1},{0, 1},{1, 1},{1, 0},{1, -1},{0, -1},{-1, -1}};

vector<vi> grid;

bool isValid(int r, int c) {
    return r >= 0 && r < sz(grid) && c >= 0 && c < sz(grid[0]);
}

//int floodfill(int r, int c) {
//    if (!isValid(r, c)) {
//        return 0;
//    }
//    if (!grid[r][c]) {
//        return 0;
//    }
//    grid[r][c] = 0;
//    int ans = 1;
//    fo(d, 0, sz(POS) - 1) {
//        ans += floodfill(r + POS[d][0], c + POS[d][1]);
//    }
//    return ans;
//}

int floodfill(int r, int c) {
    int gsz = 1;
    queue<pii> q;
    q.push({r, c});
    grid[r][c] = 0;
    

    while (!q.empty()) {
        pii tp = q.front();
        q.pop();

        fo(d, 0, sz(POS) - 1) {
            int nr = tp.ff + POS[d][0];
            int nc = tp.ss + POS[d][1];
            if (isValid(nr, nc) && grid[nr][nc]) {
                q.push({nr, nc});
                grid[nr][nc] = 0;
                ++gsz;
            }
        }
    }
    return gsz;
}


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w+", stdout);
#endif

    int tc = sci;
    while (tc--) {
        grid.clear();

        int n = sci, m = sci;
        fo(i, 0, n - 1) {
            vi row;
            fo(j, 0, m - 1) {
                int z = sci;
                row.pub(z);
            }
            grid.pub(row);
        }

        int numgr = 0, maxgr = 0;
        fo(i, 0, n - 1) {
            fo(j, 0, m - 1) {
                if (grid[i][j]) {
                    numgr++;
                    maxgr = max(maxgr, floodfill(i, j));
                }
            }
        }
        cout << numgr << " " << maxgr << "\n";
    }


    return 0;
}

