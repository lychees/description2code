#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cassert>
#include <cctype>
#include <climits>
#include <vector>
#include <bitset>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <deque>
#include <string>
#include <list>
#include <iterator>
#include <sstream>
#include <complex>
#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>
#include <assert.h>

using namespace std;

#define endl '\n'
#define MOD 1000000007ULL
#define INF 1000000000
#define eps 1e-8
#define ll long long
#define F first
#define S second
#define pb push_back
#define mp make_pair
#define debug(X) cerr << " --> " << #X << " = " << X << endl
#define sd(x) scanf("%d",&(x))
#define slld(x) scanf("%lld",&(x))
#define pd(x) printf("%d\n",(x))
#define plld(x) printf("%lld\n",(x))
#define gcd __gcd
#define csl ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef vector< vector<int> > vvi;
typedef vector< vector<ll> > vvl;
typedef pair<int, int> pii;
typedef pair<long long, long long> pll;
typedef vector<int> vi;
typedef vector<ll> vll;

const int N = 100005;
int a[N];
int b[N];
vi al[N];
int disc[N];
int low[N];
int bridge[N];
bool visit[N];
int parent[N];
int timer = 1;

void dfs(int u)
{
	visit[u] = true;
	disc[u] = timer++;
	low[u] = INF;
	int child = 0;
	for(int i = 0;i < al[u].size();i++)
	{
		int edge = al[u][i];
		int v = a[edge]^b[edge]^u;
		if(!visit[v])
		{
			child++;
			parent[v] = u;
			dfs(v);
			low[u] = min(low[u], low[v]);
			if(low[v] > disc[u])
			{
				bridge[edge] = 1;
			}
		}
		else if(v != parent[u])
		{
			low[u] = min(low[u], disc[v]);
		}
	}
}

int main()
{
	csl;

	int n,m;
	cin >> n >> m;
	
	for(int i = 1;i <= m;i++)
	{
		cin >> a[i] >> b[i];
		al[a[i]].pb(i);
		al[b[i]].pb(i);
	}
	
	for(int i = 1;i <= n;i++)
		if(!visit[i])
			dfs(i);
			
	int q;
	cin >> q;
	while(q--)
	{
		int p;
		cin >> p;
		if(!bridge[p])
		{
			cout << "Happy" << endl;
		}
		else
		{
			cout << "Unhappy" << endl;
		}
	}

	return 0;
}