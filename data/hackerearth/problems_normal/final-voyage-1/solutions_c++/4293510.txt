#include <vector>
#include <list>
#include <map>
#include <set>
#include "queue"
#include <deque>
#include <stack>
#include <numeric>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <cassert>
#include <iostream>
#define MOD 1000000007
#define pi acos(-1)
#define iil pair<int,int>
#define vii vector<ii>
#define ll  long long int
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)
#define REP(i,a,b) for(ll i=a;i<=b;i++)
#define loop(i,n) for(ll i=0;i<n;i++)
#define ll  long long int
#define LL long long int
#define loop2(i,n) for(ll i=1;i<=n;i++)
#define MIN(a,b) (a) < (b) ? (a) : (b)
#define MAX(a,b) (a) > (b) ? (a) : (b)
#define ABS(a) (a) > 0 ? (a) : -(a)
#define rep1(i,a,n) for(i=a;i<(n);i++)
#define pii pair< ll, ll >
#define pb push_back
#define mp make_pair
#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)
#define rept(i,n) FOR(i,0,(n)-1)
#define edge pair<int ,int >
ll add(ll a, ll b) { return a+b-(a+b>=MOD)*MOD; }
ll sub(ll a, ll b) { return a-b+(a-b<0)*MOD; }
ll mult(ll a, ll b) { return (1LL*a*b)%MOD; }
#define all(x)                  (x).begin(),(x).end()
inline ll gcd(ll a, ll b){ ll t; while (b){ a = a%b; t = a; a = b; b = t; }return a; }
#define dis(x,y,a,b) sqrt((x-a)*(x-a)+(y-b)*(y-b));
#define maxn 100005
#define rep(i,a,n) for (int i=a;i<n;i++)
#define digits(n)  (floor(log10(n))+1)
#define ll long long int
#define OUT_RT cerr << (float(clock()) / CLOCKS_PER_SEC) << endl
#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])
using namespace std;
//Find the Holy Grail in an adventure frought with danger!
// Never give in, fight to the end
//Look at the limits
//S:->28  US:->36
//Never Back Down

struct node
{
    ll value;
    ll weight;
};


ll dp[1001][1001];

node arr[1001];


void reset()
{
    memset(dp, -1, sizeof(dp));
}

ll solve(ll currind,ll weight)
{
    if(currind==-1){
        return 0;
    }
    if(weight==0){
        return 0;
    }
    
    if(dp[currind][weight]!=-1){
        return dp[currind][weight];
    }
    ll y = 0;
    ll z   = 0 ;
    if(weight>=arr[currind].weight){
        
     y = arr[currind].value + solve(currind-1, weight-arr[currind].weight);
    
    }
    
    z = solve(currind-1, weight);
    
    ll u = max(y,z);
    
    return dp[currind][weight]  = u;
    
    
    
    
    
    
}





int main() {
    ios_base::sync_with_stdio(0);
    cin.tie();
    ll t;
    cin>>t;
    while (t--) {
        reset();
        ll n;
        ll maxweight;
        cin>>n>>maxweight;
        loop(i, n){
            cin>>arr[i].weight;
        }
        loop(i, n){
            cin>>arr[i].value;
        }
        ll  y  = solve(n-1, maxweight);
        cout<<y<<endl;
    }
    return 0;
}
