// Headers
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cassert>
#include<vector>
#include<map>
#include<fstream>
#include<list>
#include<stack>
#include<queue>
#include<algorithm>
#include<bitset>
#include<set>
using namespace std;
// Global declarations
typedef long long int ll;
typedef vector<int> vi;
typedef vector<char> vc;
typedef pair<int,int> pi;
const double eps = 1e-6;
int const mod  = 1e9+7;
int const INF = 1<<29;
// Macros
#define mp make_pair
#define si(d) scanf("%d",&d)
#define sll(d) scanf("%I64d",&d)
#define pfd(d) printf("%d",d)
#define pfld(d) printf("%I64d",d)
#define el putchar('\n')
#define sp putchar(' ')
#define Fill(a,val) memset(a,val,sizeof a)
#define pb push_back
#define ppb pop_back
#define fi first
#define se second
#define gcd __gcd
#define all(a) a.begin(),a.end()
#define T(x) strtok(x, " \n\r\t")
#define Swap(a,b)(a=b+a-(b=a))

vi g[102];
bool vis1[102],vis2[102];
int n,m;
pi p[10000];
int parent[102];

bool connected(int x) {
    queue<int>Q;
    Q.push(x);
    vis1[x] = true;
    while(!Q.empty()){
        x = Q.front();Q.pop();
        int sz = g[x].size();
        for(int i=0;i<sz;++i) {
            int y = g[x][i];
            if(vis1[y]) continue;
            vis1[y] = true;
            Q.push(y);
        }
    }
    for(int i=1;i<=n;++i) if(!vis1[i]) return false;
    return true;
}

int Find(int x) {
    return (parent[x]==-1 ? x :(parent[x]=Find(parent[x])));
}

void Union(int x,int y) {
    x = Find(x);
    y = Find(y);
    parent[x] = y;
}

bool cycle(){
    for(int i=0;i<m;++i) {
        int u = p[i].fi;
        int v = p[i].se;
        u = Find(u);
        v = Find(v);
        if(u == v) return 1;
        Union(u,v);
    }
    return 0;
}

int main() {
    for(int i=0;i<102;++i)
        parent[i] = -1;
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;++i) {
        int u,v;scanf("%d %d",&u,&v);
        g[u].pb(v);g[v].pb(u);
        p[i] = {u,v};
    }
    if(!connected(1)) {
        puts("NO");return 0;
    }
    if(!cycle() or n!= m) {
        puts("NO");return 0;
    }
    puts("FHTAGN!");
    return 0;
}