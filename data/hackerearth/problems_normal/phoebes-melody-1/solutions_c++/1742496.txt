#include <bits/stdc++.h>

using namespace std;

typedef int li;
#define MAXN 200005
#define inf 100000000000000ll

li M[MAXN][32];
li a[MAXN];

const int BUFFSIZE = 10240;
char BUFF[BUFFSIZE + 1], *ppp = BUFF;
int RR, CHAR, SIGN, BYTES = 0;
#define GETCHAR(c) { \
        if(ppp-BUFF==BYTES && (BYTES==0 || BYTES==BUFFSIZE)) { BYTES = fread(BUFF,1,BUFFSIZE,stdin); ppp=BUFF; } \
        if(ppp-BUFF==BYTES && (BYTES>0 && BYTES<BUFFSIZE)) { BUFF[0] = 0; ppp=BUFF; } \
        c = *ppp++; \
}

#define DIGIT(c) (((c) >= '0') && ((c) <= '9'))
#define MINUS(c) ((c)== '-')
#define GETNUMBER(n) { \
        n = 0; SIGN = 1; do { GETCHAR(CHAR); } while(!(DIGIT(CHAR) || MINUS(CHAR))); \
        if(MINUS(CHAR)) { SIGN = -1; GETCHAR(CHAR); } \
        while(DIGIT(CHAR)) { n = 10*n + CHAR-'0'; GETCHAR(CHAR); } if(SIGN == -1) { n = -n; } \
}
li lg[200010];

class RMQSparseTable
{
	public:


	void initialise (li n, li *a){
		li i, j;
		for(i = 0; i < n; ++i) M[i][0] = a[i];
		for(i = 1; ((li)1 << i) <= n; ++i){
			for(j = 0;j + (1 << i) - 1 < n; ++j){
				if (M[j][i - 1] < M[j + ((li)1 << (i - 1))][i - 1])
 		                	M[j][i] = M[j][i - 1];
        			else
        		        	M[j][i] = M[j + ((li)1 << (i - 1))][i - 1];
			}
		}
	}

	li query(li i, li j, li *a){
		li k = lg[j - i + 1];
		if(M[i][k] < M[j - ((li)1 << k) + 1][k]) return M[i][k];
		else return M[j - ((li)1 << k) + 1][k];
	}
};

RMQSparseTable rmq;
li lft[MAXN];
li rght[MAXN];

li rec(li l, li r, li val)
{
    while(1){
        if(r < l){
            return -1;
        }
        if(l == r){
            if(a[l] < val)
                return l;
            else
                return -1;
        }

        li test = rmq.query(l, r, a);
        if(test >= val)
            return -1;

        li mid = (l + r) / 2;
        li cur = rmq.query(l, mid, a);
        if(cur >= val)
            l = mid + 1;
        else
            r = mid;
    }
}

li rec1(li l, li r, li val)
{
    while(1){
        if(r < l){
            return -1;
        }
        if(l == r){
            if(a[l] < val)
                return l;
            else
                return -1;
        }

        li test = rmq.query(l, r, a);
        if(test >= val)
            return -1;

        li mid = (l + r) / 2;
        li cur = rmq.query(mid + 1, r, a);
        if(cur >= val)
            r = mid;
        else
            l = mid + 1;
    }
}

int main()
{
   // freopen("input.txt", "r", stdin);
    li t, n, k, i;
    for(i = 0; i <= MAXN; i++) {
        lg[i] = log2(i);
    }
    GETNUMBER(t);
    while(t--){
        GETNUMBER(n); GETNUMBER(k);
        for(i = 0;i < n; ++i){
            GETNUMBER(a[i]);
        }
        rmq.initialise(n, a);
        for(i = n - 1;i >= 0; --i){
            if(i + k <= n - 1 && a[i + k] < a[i]){
                        rght[i] = i + k;
            }
            else rght[i] = rec(i + k, n - 1, a[i]);
        }
        for(i = 0;i < n; ++i){
            if(i - k >= 0 && a[i - k] < a[i]){
                    lft[i] = i - k;
            }
            else lft[i] = rec1(0, i - k, a[i]);
        }

        long long sum = 0;

        for(i = 0;i < n; ++i){
            if(lft[i] == -1 && rght[i] == -1){
                sum += 0;
            }
            else{
                if(lft[i] == -1){
                    sum += rght[i] - i;
                }
                else if(rght[i] == -1){
                    sum += i - lft[i];
                }
                else{
                    sum += min(i - lft[i], rght[i] - i);
                }
            }
        }

        printf("%lld\n", sum);
    }
    return 0;
}
