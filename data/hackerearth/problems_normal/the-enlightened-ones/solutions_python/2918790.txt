def try_radius(temples,K,radius):
    nbMonkRem = K
    couv = -1
    for temple in temples:
        if temple <= couv:
            continue
        couv = temple+2*radius
        nbMonkRem -= 1
        if nbMonkRem == 0:
            break
    return temples[-1]<=couv

def binary_search_inversion(temples,K, x_min, x_max):
    if x_min > x_max:
        return 10**8
    x = (x_min+x_max)/2
    #print("y =",y)
    if try_radius(temples,K,x):
        r2 = binary_search_inversion(temples,K,x_min,x-1)
        return min(x,r2)
    else:
        return binary_search_inversion(temples,K,x+1,x_max)

# print(try_radius([1,5,20], 2, 0))
# print(try_radius([1,5,20], 2, 1))
# print(try_radius([1,5,20], 2, 2))
# print(try_radius([1,5,20], 2, 3))
# print(try_radius([1,5,20], 2, 4))
# print(try_radius([0,4,100,106], 2, 0))
# print(try_radius([0,4,100,106], 2, 1))
# print(try_radius([0,4,100,106], 2, 2))
# print(try_radius([0,4,100,106], 2, 3))
# print(try_radius([0,4,100,106], 2, 4))
# print(try_radius([0,4,100,106], 2, 5))

def solve(temples,K):
    x_min = 0
    x_max = (temples[-1]-temples[0])/K//2+1
    return binary_search_inversion(temples,K,x_min,x_max)
    
_,K = map(int,raw_input().split())
temples = [int(v) for v in raw_input().split()]
temples.sort()
print(solve(temples,K))
# assert solve([0,4,50,56,100,108], 3) == 4
# assert solve([0,4,50,56,100,108], 1) == 54
# assert solve([0,2], 1) == 1
# assert solve([0,2], 2) == 0
# assert solve([0,1,2], 1) == 1
# assert solve([0,1,2], 2) == 1