#include <algorithm>
#include <cmath>
#include <ctype.h>
#include <fstream>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdio.h>
#include <string.h>
#include <string>
#include <vector>
using namespace std;
#define li long long int
#define rep(i, to) for (li i = 0; i < ((li)(to)); i++)
#define pb push_back
#define sz(v) ((li)v.size())
#define bit(n) (1ll << (li)(n))

#define MAX 100005
li LEFT[MAX], RIGHT[MAX];
li mini[MAX], maxi[MAX];
li num[MAX];
vector<li> E[MAX];
vector<pair<li, double>> ans;

void make(li pos) {
  if (sz(E[pos])) {
    make(E[pos][0]);
    make(E[pos][1]);
    LEFT[pos] = maxi[E[pos][0]];
    RIGHT[pos] = mini[E[pos][1]];
    mini[pos] = mini[E[pos][0]];
    maxi[pos] = maxi[E[pos][1]];
    return;
  }
  LEFT[pos] = RIGHT[pos] = mini[pos] = maxi[pos] = num[pos];
}

void cal(li pos, li r, double depth, double sum) {
  if (sz(E[pos])) {
    cal(E[pos][0], num[pos], depth + 1, sum + RIGHT[pos]);
    cal(E[pos][1], r, depth + 1, sum + LEFT[pos]);
    return;
  }
  ans.pb(make_pair(r, sum / depth));
}

int main() {
  li n, root;
  cin >> n;
  rep(i, n) {
    li a;
    cin >> a >> num[i];
    if (a == -1)
      root = i;
    else
      E[a - 1].pb(i);
  }
  rep(i, n) if (sz(E[i]) && num[E[i][1]] < num[E[i][0]]) swap(E[i][0], E[i][1]);
  make(root);
  cal(root, bit(60), 0, 0);
  sort(ans.begin(), ans.end());
  cin >> n;
  rep(i, n) {
    li a;
    cin >> a;
    printf("%0.20lf\n",
           lower_bound(ans.begin(), ans.end(), make_pair(a, 0.0))->second);
  }
}
