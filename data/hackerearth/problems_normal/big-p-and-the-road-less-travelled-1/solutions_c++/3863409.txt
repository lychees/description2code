//https://www.hackerearth.com/problem/algorithm/big-p-and-the-road-less-travelled-1/

#include<iostream>
#include<vector>
#include<stack>
using namespace std;

stack<int> s;
vector<int>  adj[10000];
vector<int> parent[10000];
bool visited[10000];


void topological_sort(int cur) {
  visited[cur] = true;
  for(vector<int>::iterator it = adj[cur].begin(); it != adj[cur].end(); ++it) {
    if(!visited[*it])
      topological_sort(*it);
  }
  s.push(cur);
}

int countpaths(int N) {
  int paths[10000];
  paths[0] = 1;
  s.pop();

  while(!s.empty()) {
    int cur = s.top();
    s.pop();

    int p = 0;
    for(vector<int>::iterator it = parent[cur].begin(); it != parent[cur].end(); it++) {
      p += paths[*it];
    }
    paths[cur] = p;
  }

  return paths[N - 1];
}

int main() {
  int N;
  cin>>N;
  
  int a, b;
  cin>>a>>b;
  while(a !=0 && b != 0) {
    adj[a - 1].push_back(b - 1);
    parent[b - 1].push_back(a - 1);
    cin>>a>>b;
  }

  topological_sort(0);
  cout<<countpaths(N)<<endl;
  
}
