#include <bits/stdc++.h>

using namespace std;
#define MP make_pair
#define PB push_back
#define LL long long
#define int LL
#define st first
#define nd second
#define FI st
#define SE nd
#define FOR(i,a,b) for(int i = (a); i <= (b); i++)
#define RE(i,n) FOR(i,1,n)
#define R(i,n) FOR(i,0,(int)(n)-1)
#define REP(i,n) R(i,n)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#define PII pair<int,int>
#define VI vector<int>
template<class C> void mini(C&a4, C b4){a4=min(a4,b4);}
template<class C> void maxi(C&a4, C b4){a4=max(a4,b4);}

template<class TH> void _dbg(const char *sdbg, TH h){cerr<<sdbg<<"="<<h<<"\n";}
template<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a){
  while(*sdbg!=',')cerr<<*sdbg++;cerr<<"="<<h;_dbg(sdbg+1,a...);
}

#ifdef LOCAL
#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)
#define debugv(C) {for(auto&c:C)cerr<<c<<",";cerr<<endl;}
#else
#define debug(...) (__VA_ARGS__)
#define debugv(C) {}
#define cerr if(0)cout
#endif
#define MAX 50001
#define y2 y2_dupa
int ilr[MAX],ill[MAX];
int wyn;
int t[MAX];
struct zz{
  int x,y,nr,zn;
};
vector<zz> zap;
int sq;
bool qzap(zz a,zz b){
  if(a.y/sq != b.y/sq){
    return a.y < b.y;
  }
  if((a.y/sq)%2 == 0){
    return a.x < b.x;
  }else
    return a.x > b.x;  
}
void addl(int i){
  int war = t[i];
  ill[war]++;
  wyn += ilr[war];
}

void addr(int i){
  int war = t[i];
  ilr[war]++;
  wyn += ill[war];
}
void reml(int i){
  int war = t[i];
  ill[war]--;
  wyn -= ilr[war];
}
void remr(int i){
  int war = t[i];
  ilr[war]--;
  wyn -= ill[war];
}
int n;
int res[MAX];
int q;
#undef int
int main(){
#define int LL
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  cout<<fixed<<setprecision(10);
  cin >> n;
  R(i,n){
    cin >> t[i];
  }
  cin >> q;
  R(i,q){
    int x1,y1,x2,y2;
    cin >> x1 >>x2 >>y1 >>y2;
    zap.PB({x2,y2,i,1});
    zap.PB({x1-1,y2,i,-1});
    zap.PB({x2,y1-1,i,-1});
    zap.PB({x1-1,y1-1,i,1});
  }
  while(sq*sq <=n){
    sq++;
  }
  sort(ALL(zap),qzap);
  int akl = 0;
  int akr = 0;
  R(i,SZ(zap)){
    while(zap[i].x < akl){
      akl--;
      reml(akl);
    }
    while(zap[i].x > akl){
      addl(akl);
      akl++;
    }
    while(zap[i].y < akr){
      akr--;
      remr(akr);
    }
    while(zap[i].y > akr){
      addr(akr);
      akr++;
    }
   // debug(zap[i].nr, zap[i].zn, zap[i].x, zap[i].y);
    res[zap[i].nr] += zap[i].zn * wyn;
  }
  R(i,q){
    cout << res[i] << "\n";
  }
  return 0;
}