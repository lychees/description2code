#include<bits/stdc++.h>
//#include<iostream>
//#include<stdio.h>


using namespace std;

#define ll int
#define lll long long int
#define s(a) scanf("%d",&a)
#define slll(a) scanf("%lld",&a)
#define fr(i,n) for(i=0;i<n;i++)
#define fra(i,a,n) for(i=a;i<n;i++)
//#define N 100010
#define inf lll_MAX
#define MOD 1000000007
#define SET(v,i) memset(v, i, sizeof(v))

/*#define gc getchar_unlocked

void scanlll(lll &x)
{
    register lll c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}

ll gcd(ll a,ll b)
{
   //cout<<a<<" "<<b<<endl;
   if(b==0)
   return a;
   return gcd(b,a%b);
}*/
/*
struct node
{
  ll rank0,rank1,pos;
};

bool cmp(node a,node b)
{
  if(a.rank0==b.rank0)
    return a.rank1<b.rank1;

  return a.rank0<b.rank0;
}*/
/*int cmpqsort (const void * a, const void * b)
{
  if(((node*)a)->rank0==((node*)b)->rank0)
    return ( ((node*)a)->rank1 - ((node*)b)->rank1 );

    return ( ((node*)a)->rank0 - ((node*)b)->rank0 );


}*/
/*
struct comp
{
    bool operator()(const node a, const node b)
    {
        return a.r >b.r;
    }
};*/
/*
#define INF (1<<20)
#define pii pair< int, int >
#define pb(x) push_back(x)
#define MAX 100001
struct comp {
    bool operator() (const pii &a, const pii &b) {
        return a.second > b.second;
    }
};*/

/*
ll poww(ll a, ll b)
{

  ll x = 1, y = a;
    while(b > 0) {
        if(b%2 == 1) {
            x=(x*y);
           // if(x>MOD) x%=MOD;
        }
        y = (y*y);
        //if(y>MOD) y%=MOD;
        b /= 2;
    }
    return x;
}
*/
/*
bool prime[1000010];

void primer()
{
    memset(prime,1,sizeof(prime));
   prime[1]=0;

   for(i=2;i*i<=1000000;i++)
   {
     //cout<<i;
      if(prime[i])
      {
         for(j=i*i;j<=1000000;j+=i)
         {
            prime[j]=0;
            //cout<<"j"<<j;
         }
      }
   }

}*/
struct node
{
   ll next[2];
   vector<int>v;
   node()
   {
       next[0]=next[1]=-1;
   }
}trie[5000010];;


int main()
{
   ll n,q,i;
   s(n); s(q);
   ll a[n+2],cur,sz,j,val,l,r,x,pos,ans;

   fr(i,n)
   {
       s(a[i]);
   }

    sz=1;
   fr(i,n)
   {
       cur=0;
       for(j=20;j>=0;j--)
       {
           val = (bool)(a[i]&(1<<j));
           //cout<<val<<" ";
           if(trie[cur].next[val]==-1)
           {
               trie[cur].next[val]=sz++;
             //  cout<<"hh"<<" ";
           }


           cur=trie[cur].next[val];
           trie[cur].v.push_back(i);
           //cout<<cur<<" "<<sz<<endl;
       }


   }
   /*
   fr(i,25)
   {
       fr(j,trie[i].v.size())
       cout<<trie[i].v[j]<<" ";
       cout<<endl;
   }*/

   fr(i,q)
   {
       s(l); s(r); s(x);
       l--;r--;
       cur=0;
       ans=0;
       vector<int>::iterator low;
       for(j=20;j>=0;j--)
       {
           val = (bool)(x&(1<<j));

           if(trie[cur].next[1-val]==-1)
           {
               cur = trie[cur].next[val];

               continue;
           }
           low = lower_bound(trie[trie[cur].next[1-val]].v.begin(),trie[trie[cur].next[1-val]].v.end(),r);
           pos = low-trie[trie[cur].next[1-val]].v.begin();
           //cout<<pos<<" "<<val<<" ";
           if(pos==trie[trie[cur].next[1-val]].v.size() || trie[trie[cur].next[1-val]].v[pos]!=r)
           pos--;
           //cout<<j<<" "<<pos<<" ";
           if(pos>=0 && trie[trie[cur].next[1-val]].v[pos]>=l)
           {
               cur = trie[cur].next[1-val];
               ans+=(1<<j);
           }
           else
           {
               cur = trie[cur].next[val];
           }
           //cout<<cur<<" "<<ans<<endl;



       }
       cout<<ans<<"\n";
   }
}
