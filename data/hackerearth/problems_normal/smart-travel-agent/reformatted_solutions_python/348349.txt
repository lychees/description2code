from heapq import heappush, heappop


def min_path(lst, s, d, t):
    h = []
    heappush(h, [0, [s]])
    processed = range(len(lst))
    while len(h) > 0:
        node = heappop(h)
        cost = node[0]
        path = node[1][:]
        if processed[path[-1]] == -1:
            continue
        if processed[path[-1]] == d:
            return path, -cost
        for x, y in lst[path[-1]]:
            path.append(x)
            if cost != 0:
                new_cost = min(-cost, y)
            else:
                new_cost = y
            heappush(h, [-new_cost, path])
            path = node[1][:]
        processed[node[1][-1]] = -1


n, r = map(int, raw_input().split())
lst = [[] for i in range(n+1)]
for i in range(r):
    c1, c2, p = map(int, raw_input().split())
    lst[c1].append((c2, p))
    lst[c2].append((c1, p))

s, d, t = map(int, raw_input().split())
path, cost = min_path(lst, s, d, t)
print ' '.join([str(i) for i in path])
print t/(cost-1)+1
