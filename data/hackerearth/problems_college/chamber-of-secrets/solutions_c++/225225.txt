#include <bits/stdc++.h>
using namespace std;

#define MAX 100000
#define MOD 1000000007
#define sd(x) scanf("%d", &x)
#define sld(x) scanf("%lld", &x)
#define LL long long int

struct no {
    LL lsum, rsum, msum, sum;
};

no tree[ 4 * MAX + 1 ], tree2[4 * MAX + 1];
LL arr[ MAX + 1 ], arr2[MAX + 1];

void init( LL node, LL i, LL j ) {
    if ( i == j ) {
        tree[ node ] = ( ( no ) { arr[ i ], arr[ i ], arr[ i ], arr[ i ] } );
    }
    else {
        init( node * 2, i, ( i + j ) / 2 );
        init( node * 2 + 1, ( i + j ) / 2 + 1, j );
        no left = tree[ node * 2 ], right = tree[ node * 2 + 1 ];
        tree[ node ].lsum = max( left.lsum, left.sum + right.lsum );
        tree[ node ].rsum = max( right.rsum, right.sum + left.rsum );
        tree[ node ].msum = max( left.msum, max( right.msum, left.rsum + right.lsum ) );
        tree[ node ].sum = left.sum + right.sum;
    }
}

void init2( LL node, LL i, LL j ) {
    if ( i == j ) {
        tree2[ node ] = ( ( no ) { arr2[ i ], arr2[ i ], arr2[ i ], arr2[ i ] } );
    }
    else {
        init2( node * 2, i, ( i + j ) / 2 );
        init2( node * 2 + 1, ( i + j ) / 2 + 1, j );
        no left = tree2[ node * 2 ], right = tree2[ node * 2 + 1 ];
        tree2[ node ].lsum = max( left.lsum, left.sum + right.lsum );
        tree2[ node ].rsum = max( right.rsum, right.sum + left.rsum );
        tree2[ node ].msum = max( left.msum, max( right.msum, left.rsum + right.lsum ) );
        tree2[ node ].sum = left.sum + right.sum;
    }
}



no query( LL node, LL a, LL b, LL i, LL j ) {
    if ( i == a && j == b ) {
        return tree[ node ];
    }
    if ( j <= ( a + b ) / 2 ) {
        return query( node * 2, a, ( a + b ) / 2, i, j );
    }
    if ( i > ( a + b ) / 2 ) {
        return query( node * 2 + 1, ( a + b ) / 2 + 1, b, i, j );
    }
    no left = query( node * 2, a, ( a + b ) / 2, i, ( a + b ) / 2 );
    no right = query( node * 2 + 1, ( a + b ) / 2 +  1, b, ( a + b ) / 2 + 1, j );
    return ( ( no ) {
                max( left.lsum, left.sum + right.lsum ),
                max( right.rsum, right.sum + left.rsum ),
                max( left.msum, max( right.msum, right.lsum + left.rsum ) ),
                left.sum + right.sum } );
}

no query2( LL node, LL a, LL b, LL i, LL j ) {
    if ( i == a && j == b ) {
        return tree2[ node ];
    }
    if ( j <= ( a + b ) / 2 ) {
        return query2( node * 2, a, ( a + b ) / 2, i, j );
    }
    if ( i > ( a + b ) / 2 ) {
        return query2( node * 2 + 1, ( a + b ) / 2 + 1, b, i, j );
    }
    no left = query2( node * 2, a, ( a + b ) / 2, i, ( a + b ) / 2 );
    no right = query2( node * 2 + 1, ( a + b ) / 2 +  1, b, ( a + b ) / 2 + 1, j );
    return ( ( no ) {
                max( left.lsum, left.sum + right.lsum ),
                max( right.rsum, right.sum + left.rsum ),
                max( left.msum, max( right.msum, right.lsum + left.rsum ) ),
                left.sum + right.sum } );
}

inline void Solve(){
    LL i, N, q, op, l, r, x, y, z, w;
    sld(N); sld(q);
    for ( i = 0; i < N; ++i ) {
        scanf( "%lld", arr + i );
        arr2[i] = (i + 1) * arr[i];
    }
    init( 1, 0, N - 1 );
    init2(1, 0, N - 1);
    LL ans;
    while(q--){
         sld(w); sld(x); sld(y); sld(z);
        //cout<<x + y - 1<<" "<<x + z - 1<<endl;
        ans = (w - x) * (query( 1, 0, N - 1, x + y - 1, x + z - 1).msum);
        ans %= MOD;
        ans +=  (query2( 1, 0, N - 1, x + y - 1, x + z - 1 ).msum);
        ans %= MOD;
        printf( "%lld\n", ans );
    }
    return;
}

int main() {
    LL t;
    sd(t);
    while(t--){
        Solve();
    }
    return 0;
}
