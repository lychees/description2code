#include<bits/stdc++.h>
#define nl '\n'
#define pri 31
#define M 1000000007
#define M1 1000000009
#define MAX 100000
#define pb push_back
typedef long long ll;
using namespace std;
ll pre_hash[4*MAX + 5],suff_hash[4*MAX + 5],pre_hash1[4*MAX + 5],suff_hash1[4*MAX + 5];string s,ss;
ll poww(ll x,ll y,ll MOD){
	if(y==0) return 1;
	if(y==1) return (ll)x%MOD;
	ll z = poww(x,y/2,MOD);
	if(y%2==0) return (ll)((ll)z*z)%MOD;
	else return (ll)((ll)((ll)z*z)%MOD * x%MOD)%MOD;
}
void constructPre(int low,int high,int pos)
{
	if(low == high){
		pre_hash[pos]=((ll)((int)s[low])*poww(pri,low,M))%M;
		return;
	}
	int mid=(low+high)/2;
	constructPre(low,mid,2*pos + 1);
	constructPre(mid+1,high,2*pos + 2);
	pre_hash[pos]=((ll)pre_hash[2*pos + 1]+pre_hash[2*pos +2])%M;
}
void constructSuff(int low,int high,int pos)
{
	if(low == high){
		suff_hash[pos]=((ll)((int)ss[low])*poww(pri,low,M))%M;
		return;
	}
	int mid=(low+high)/2;
	constructSuff(low,mid,2*pos + 1);
	constructSuff(mid+1,high,2*pos + 2);
	suff_hash[pos]=((ll)suff_hash[2*pos + 1]+suff_hash[2*pos +2])%M;
}
ll queryPre(int ql,int qh,int l,int h,int p){
	if(ql<=l && qh>=h)		//total overlap
		return pre_hash[p];
	if(ql>h || qh<l)	//no overlap
		return 0;
	int mid=(l+h)/2;
	return ((ll)queryPre(ql,qh,l,mid,2*p +1)+queryPre(ql,qh,mid+1,h,2*p +2))%M;
}
ll querySuff(int ql,int qh,int l,int h,int p){
	if(ql<=l && qh>=h)		//total overlap
		return suff_hash[p];
	if(ql>h || qh<l)	//no overlap
		return 0;
	int mid=(l+h)/2;
	return ((ll)querySuff(ql,qh,l,mid,2*p +1)+querySuff(ql,qh,mid+1,h,2*p +2))%M;
}
void upPre(int pos,char ch,int l,int h,int p){
	if(l == h){
		pre_hash[p] = ((ll)((int)ch)*poww(pri,l,M))%M;
		return;
	}
	int mid = (l+h)/2;
	if(pos<=mid)
		upPre(pos,ch,l,mid,2*p + 1);
	else upPre(pos,ch,mid+1,h,2*p + 2);
	pre_hash[p]=((ll)pre_hash[2*p + 1] + pre_hash[2*p + 2])%M;
}
void upSuff(int pos,char ch,int l,int h,int p){
	if(l == h){
		suff_hash[p] = ((ll)((int)ch)*poww(pri,l,M))%M;
		return;
	}
	int mid = (l+h)/2;
	if(pos<=mid)
		upSuff(pos,ch,l,mid,2*p + 1);
	else upSuff(pos,ch,mid+1,h,2*p + 2);
	suff_hash[p]=((ll)suff_hash[2*p + 1] + suff_hash[2*p + 2])%M;
}
void constructPre1(int low,int high,int pos)
{
	if(low == high){
		pre_hash1[pos]=((ll)((int)s[low])*poww(pri,low,M1))%M1;
		return;
	}
	int mid=(low+high)/2;
	constructPre1(low,mid,2*pos + 1);
	constructPre1(mid+1,high,2*pos + 2);
	pre_hash1[pos]=((ll)pre_hash1[2*pos + 1]+pre_hash1[2*pos +2])%M1;
}
void constructSuff1(int low,int high,int pos)
{
	if(low == high){
		suff_hash1[pos]=((ll)((int)ss[low])*poww(pri,low,M1))%M1;
		return;
	}
	int mid=(low+high)/2;
	constructSuff1(low,mid,2*pos + 1);
	constructSuff1(mid+1,high,2*pos + 2);
	suff_hash1[pos]=((ll)suff_hash1[2*pos + 1]+suff_hash1[2*pos +2])%M1;
}
ll queryPre1(int ql,int qh,int l,int h,int p){
	if(ql<=l && qh>=h)		//total overlap
		return pre_hash1[p];
	if(ql>h || qh<l)	//no overlap
		return 0;
	int mid=(l+h)/2;
	return ((ll)queryPre1(ql,qh,l,mid,2*p +1)+queryPre1(ql,qh,mid+1,h,2*p +2))%M1;
}
ll querySuff1(int ql,int qh,int l,int h,int p){
	if(ql<=l && qh>=h)		//total overlap
		return suff_hash1[p];
	if(ql>h || qh<l)	//no overlap
		return 0;
	int mid=(l+h)/2;
	return ((ll)querySuff1(ql,qh,l,mid,2*p +1)+querySuff1(ql,qh,mid+1,h,2*p +2))%M1;
}
void upPre1(int pos,char ch,int l,int h,int p){
	if(l == h){
		pre_hash1[p] = ((ll)((int)ch)*poww(pri,l,M1))%M1;
		return;
	}
	int mid = (l+h)/2;
	if(pos<=mid)
		upPre1(pos,ch,l,mid,2*p + 1);
	else upPre1(pos,ch,mid+1,h,2*p + 2);
	pre_hash1[p]=((ll)pre_hash1[2*p + 1] + pre_hash1[2*p + 2])%M1;
}
void upSuff1(int pos,char ch,int l,int h,int p){
	if(l == h){
		suff_hash1[p] = ((ll)((int)ch)*poww(pri,l,M1))%M1;
		return;
	}
	int mid = (l+h)/2;
	if(pos<=mid)
		upSuff1(pos,ch,l,mid,2*p + 1);
	else upSuff1(pos,ch,mid+1,h,2*p + 2);
	suff_hash1[p]=((ll)suff_hash1[2*p + 1] + suff_hash1[2*p + 2])%M1;
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);
	int i,j,t,l,r,q,n;char ch;
	cin>>n>>q;
	cin>>s;
	ss = s;
	reverse(ss.begin(),ss.end());
	constructPre(0,n-1,0);
	constructSuff(0,n-1,0);
	constructPre1(0,n-1,0);
	constructSuff1(0,n-1,0);
	while(q--){
		cin>>t;
		if(t==0){
			cin>>i>>ch;
			upPre(i-1,ch,0,n-1,0);
			upSuff(n-i,ch,0,n-1,0);
			upPre1(i-1,ch,0,n-1,0);
			upSuff1(n-i,ch,0,n-1,0);
		}
		else{
			cin>>l>>r;l--;r--;
			if(((ll)queryPre(l,r,0,n-1,0)*poww(pri,n-1-l,M))%M == ((ll)querySuff(n-1-r,n-1-l,0,n-1,0)*poww(pri,r,M))%M  &&
				((ll)queryPre1(l,r,0,n-1,0)*poww(pri,n-1-l,M1))%M1 == ((ll)querySuff1(n-1-r,n-1-l,0,n-1,0)*poww(pri,r,M1))%M1)
				cout<<"Yes\n";
			else cout<<"No\n";
		}
	}
	return 0;
}
