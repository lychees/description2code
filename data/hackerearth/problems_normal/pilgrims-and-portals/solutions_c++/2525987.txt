
//============================================================================
// Name        : riya.cpp
// Author      : riya1794
//============================================================================

#include<bits/stdc++.h>

using namespace std;

#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))

#define REP(i,a,b) for(LL i=a;i<b;i++)
#define rep(i,b) for(LL i=0;i<b;i++)
#define rep1(i,b) for(LL i=1;i<=b;i++)

#define pdn(n) printf("%d\n",n)
#define pln(n) printf("%ld\n",n)
#define plln(n) printf("%lld\n",n)
#define pn(n) printf("\n")
#define psn(n) printf("%s\n",n)

#define s2ll(n1,n2) scanf("%lld%lld",&n1,&n2)
#define sll(n) scanf("%lld",&n)
#define sl(n) scanf("%ld",&n)
#define sd(n) scanf("%d",&n)
#define ss(n) scanf("%s",n)

#define ass(n,a,b) assert(n>=a&&n<=b)

typedef long long LL;

#define MOD 1000000007
#define mx 1000000009

/* https://www.hackerearth.com/problem/algorithm/pilgrims-and-portals/description/ */
class cmp
{
    public:
    int operator()(const pair<LL,LL> &p1, const pair<LL,LL> &p2)
    {
        return p1.second>p2.second;
    }
};

int main()
{
    LL t,e,a,b,w,s,s1,s2,ans1=mx,ans2=mx,child1,child2,cost=0,cost2=0,ans=mx,i,j,m,k,n;
    LL visit[120];
    sll(t);
    while(t--)
    {
        s2ll(n,m);
        sll(s);
        priority_queue<pair<LL,LL> , vector<pair<LL,LL> > , cmp> q;
        LL dist[120];
        vector<pair<LL,LL> > adj[120];
        //floyd warshall algo
       /* rep1(i,n)
        {
            rep1(j,n)
            {
                if(i!=j)
                    dist[i][j]=mx;
                else
                    dist[i][i]=0;
            }
        }
        rep1(i,m)
        {
            s2ll(a,b);
            sll(w);
            dist[a][b]=w;
            dist[b][a]=w;
        }
        rep1(i,n)
        {
            rep1(j,n)
                dp[i][j]=dist[i][j];
        }
        rep1(k,n)
        {
            rep1(i,n)
            {
                rep1(j,n)
                {
                    dp[i][j]=min(dp[i][j], dp[i][k]+dp[k][j]);
                }
            }
        }
        vector<LL> v;
        rep1(i,s) v.push_back(i);
        do
        {
            cost=0;
            for(i=1;i<s;i++)
                cost+=dp[v[i-1]][v[i]];
            ans=min(ans,cost);
        }while(next_permutation(v.begin()+1 , v.end())); */

        rep1(i,m)
        {
            s2ll(a,b);
            sll(w);
            adj[a].push_back(make_pair(b,w));
            adj[b].push_back(make_pair(a,w));
        }
        rep1(i,n)
        {
            dist[i]=mx;
            visit[i]=0;
        }
        dist[1]=0;
        q.push(make_pair(1,0));
        while(!q.empty())
        {
            LL u = q.top().first;
            LL c= q.top().second;
            q.pop();
            vector<pair<LL,LL> >::iterator it;
            if(dist[u]<c) continue;
            if(u<=s)
            {
                visit[u]=1;
                for(it=adj[u].begin();it!=adj[u].end();it++)
                {
                    if(visit[(*it).first]==0 && dist[(*it).first] >(*it).second)
                    {
                        dist[(*it).first] = (*it).second;
                        q.push(make_pair((*it).first , dist[(*it).first]));
                      //  cout<<(*it).first<<" "<<dist[(*it).first]<<endl;
                    }
                }
            }
            else
            {
                for(it=adj[u].begin();it!=adj[u].end();it++)
                {
                    if(visit[(*it).first]==0 && (dist[(*it).first] > dist[u] + (*it).second))
                    {
                        dist[(*it).first] = dist[u] + (*it).second;
                        q.push(make_pair((*it).first , dist[(*it).first]));
                     //   cout<<(*it).first<<" "<<dist[(*it).first]<<endl;
                    }
                }
            }
        }
        cost=0;
        rep1(i,s) cost+=dist[i];
        plln(cost);
    }
    return 0;
}
