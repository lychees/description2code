#include <bits/stdc++.h>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define x first
#define y second
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define ll long long 
#define ull unsigned long long
#define inf 1000000007
#define mod 1000000007
#define N 50005
#define DBG(x) cerr<<(#x)<<"="<<x<<endl;
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)

template <class T> inline void Max(T &a,T b){if(a<b)a=b;}
template <class T> inline void Min(T &a,T b){if(a>b)a=b;}

vector<pii>g[1005],gg[1005];
int P,n,m;
int t[1005],in[1005];
struct node{
    int u;ll w;
    bool operator <(const node&a)const{
        return w>a.w;
    }
};
map<int,ll>dp[1005];
set<ll>s[1005];
ll to[1005];

int main(){
    int T,i,j,k;
    scanf("%d%d%d",&n,&m,&P);
    for(i=0;i<n;i++)scanf("%d",&t[i]);
    while(m--){
        scanf("%d%d%d",&i,&j,&k);
        g[i].pb(mp(j,k));
        gg[j].pb(mp(i,k));
    }
    if(t[0]==0){
        puts("-1");return 0;
    }
    priority_queue<node>q;
    q.push((node){n-1,0});
    for(i=0;i<n;i++)to[i]=1e18;
    to[n-1]=0;
    while(!q.empty()){
        node e=q.top();q.pop();
        int u=e.u;ll w=e.w;
        if(to[u]!=w)continue;
        for(i=0;i<gg[u].size();i++){
            j=gg[u][i].x,k=gg[u][i].y;
            if(to[j]>to[u]+k){
                to[j]=to[u]+k;
                q.push((node){j,to[j]});
            }
        }
    }
    dp[0][0]=0;
    ll ans=-1;
    q.push((node){0,0+to[0]});
    in[0]=1;
    s[0].insert(0);
    while(!q.empty()){
        node e=q.top();q.pop();
        int u=e.u;ll w=e.w-to[u];
        //cerr<<u<<" "<<w<<"\t";
        ll x=w%P;
        if(dp[u].find(x)==dp[u].end()||dp[u][x]!=w)continue;
        if(u==n-1){ans=w;break;}
        for(i=0;i<g[u].size();i++){
            j=g[u][i].x;k=g[u][i].y;
            ll ww=w+k;
            ll y=ww%P;
            if(y==t[j])continue;
            if(dp[j].find(y)==dp[j].end()){
                if(in[j]<n){
                    in[j]++;
                    dp[j][y]=ww;
                    s[j].insert(-ww);
                    q.push((node){j,ww+to[j]});
                }
                
                else{
                    ll yy=-(*s[j].begin());
                    if(yy>ww){
                        dp[j].erase(yy%P);
                        s[j].erase(s[j].begin());
                        dp[j][y]=ww;
                        s[j].insert(-ww);
                        q.push((node){j,ww+to[j]});
                    }
                }
                
            }
            else if(dp[j][y]>ww){
                s[j].erase(-dp[j][y]);
                dp[j][y]=ww;
                s[j].insert(-ww);
                q.push((node){j,ww+to[j]});
            }
        }
    }
    cout<<ans<<"\n";
    return 0;
}
