// A Dynamic Programming based solution for 0-1 Knapsack problem
#include<stdio.h>
#include<vector>
#include<set>
#include<algorithm>
// A utility function that returns maximum of two integers
int max(int a, int b) { return (a > b)? a : b; }
long long dp[2][2001][2001];

using namespace std;
int main()
{
	long long n,w,val[2001],wt[2001],i;
	vector<pair<int,int> > v;
	scanf("%lld %lld",&n,&w);
	for(i=1;i<=n;i++)
	{
		scanf("%lld %lld",&val[i],&wt[i]);
		v.push_back(make_pair(val[i],wt[i]));
	}
	sort(v.begin(),v.end());
	for(i=1;i<=n;i++)
	{
		val[i]=v[i-1].first;
		wt[i]=v[i-1].second;
	}
    long long j,p,prev,cur;
 	long long prime[11]={1,2,3,5,7,11,13,17,19,23,29};
   // Build table K[][] in bottom up manner
   for(p=0;p<11;p++)
   {
	   for (i =1; i <= n; i++)
	   {
	       for (j = 1; j <= w; j++)
	       {
	           if(!p)
	           {
	           	dp[0][i][j]=max(dp[0][i-1][j],dp[0][i][j-1]);
	           	if(j>=wt[i])
	           		dp[0][i][j]=max(dp[0][i][j],dp[0][i-1][j-wt[i]]+val[i]);
	           }
	           else
	           {
	           	cur=p&1;
	           	prev=1-cur;
	           	dp[cur][i][j]=dp[prev][i][j];
	           	dp[cur][i][j]=max(dp[cur][i][j],dp[cur][i-1][j]);
	           	dp[cur][i][j]=max(dp[cur][i][j],dp[cur][i][j-1]);
	           	if(j>=wt[i])
	           	{
	           		dp[cur][i][j]=max(dp[cur][i][j],dp[cur][i-1][j-wt[i]]+val[i]);
	           		dp[cur][i][j]=max(dp[cur][i][j],dp[prev][i-1][j-wt[i]]+prime[p]*val[i]);
	           	}
	           }
	       }
	   }
   }
    printf("%lld\n",dp[0][n][w]);
    return 0;
}