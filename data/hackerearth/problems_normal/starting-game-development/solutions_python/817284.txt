#def bisect_left(a, x, lo=0, hi=None):
def bisect_left(level_strengths, one_player):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will
    insert just before the leftmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """



    for param in range(N):
        x = one_player[param]
        lo = 0
        hi = len(level_strengths[param])
        while lo < hi:
            mid = (lo+hi)//2
            if level_strengths[param][mid] <= x: lo = mid+1
            else: hi = mid
        yield lo

[N, M, Q] = [int(i) for i in raw_input().split()] # Do not use ' ' !!!
level_strengths = [[0] * M ] * N
players_strengths = [[0] * N ] * Q
for param in range(N):
    level_strengths[param] = [int(i) for i in raw_input().split()] 
for query in range(Q):
    players_strengths[query] = [int(i) for i in raw_input().split()] 
#print "N = %d, M = %d, Q = %d" %(N, M, Q)
#print "level_strengths = {}".format(level_strengths)
#print "players_strengths = {}".format(players_strengths)

for query in range(Q):
    decide_levels = bisect_left(level_strengths, players_strengths[query])
    print min(decide_levels)