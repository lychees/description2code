#include <stdio.h>
#include <assert.h>
#include <queue>
#include <set>
#include <map>
 
typedef unsigned Board[3][3];
typedef unsigned long long ull;
typedef ull State;
struct Node {
	Node(State s_, int d_) : state(s_), depth(d_) { }
	State state;
	int depth;
};
std::map<State, int> visited;
 
#define MAKE_STATE_FROM_NTUPLE(a00,a01,a02,a10,a11,a12,a20,a21,a22) \
	((static_cast<ull>(a00) << 32)						\
	 | (static_cast<ull>(a01) << 28)					\
	 | (static_cast<ull>(a02) << 24)					\
	 | (static_cast<ull>(a10) << 20)					\
	 | (static_cast<ull>(a11) << 16)					\
	 | (static_cast<ull>(a12) << 12)					\
	 | (static_cast<ull>(a20) << 8)						\
	 | (static_cast<ull>(a21) << 4)						\
	 | (static_cast<ull>(a22) << 0))
 
#define MAKE_STATE(b) \
	MAKE_STATE_FROM_NTUPLE(b[0][0],b[0][1],b[0][2],b[1][0],b[1][1],b[1][2],b[2][0],b[2][1],b[2][2])
 
#define MAKE_BOARD(st, brd)	do {				\
	brd[0][0] = ((st) >> 32) & 0xf;				\
	brd[0][1] = ((st) >> 28) & 0xf;				\
	brd[0][2] = ((st) >> 24) & 0xf;				\
	brd[1][0] = ((st) >> 20) & 0xf;				\
	brd[1][1] = ((st) >> 16) & 0xf;				\
	brd[1][2] = ((st) >> 12) & 0xf;				\
	brd[2][0] = ((st) >> 8) & 0xf;				\
	brd[2][1] = ((st) >> 4) & 0xf;				\
	brd[2][2] = ((st) >> 0) & 0xf;				\
	} while(0)
 
#define IS_PRIME(v)								\
	((v) == 2 || (v) == 3 || (v) ==  5 || (v) ==  7 || (v) ==  11 || (v) ==  13 || (v) ==  17)
 
#define ENQUEUE_IF_FEASIBLE(r1,c1,r2,c2) do {					\
		int sum = b[r1][c1]+b[r2][c2];							\
		if(IS_PRIME(sum)) {										\
			using namespace std; swap(b[r1][c1], b[r2][c2]);	\
			State snew = MAKE_STATE(b);							\
			swap(b[r1][c1], b[r2][c2]);							\
			if(visited.find(snew) == visited.end()) {			\
				visited[snew] = depth;							\
				Q.push(Node(snew, depth));						\
			}													\
		}														\
	} while(0)
 
State read_input(void) {
	Board b;
	for(int j = 0; j < 3; ++j) for(int k = 0; k < 3; ++k) scanf(" %u", &b[j][k]);
	return MAKE_STATE(b);
}
 
int solve(State state) {
	std::map<State, int>::const_iterator j = visited.find(state);
	return j == visited.end() ? -1 : j->second;
}
 
void make_graph(void) {
	std::queue<Node> Q;
	State start_state = MAKE_STATE_FROM_NTUPLE(1,2,3,4,5,6,7,8,9);
	Q.push(Node(start_state, 0));
	visited[start_state] = 0;
 
	while(!Q.empty()) {
		State s = Q.front().state;
		int depth = Q.front().depth;
		Q.pop();
 
		Board b;
		MAKE_BOARD(s, b);
		++depth;
 
		ENQUEUE_IF_FEASIBLE(0,0,0,1);
		ENQUEUE_IF_FEASIBLE(0,1,0,2);
		ENQUEUE_IF_FEASIBLE(1,0,1,1);
		ENQUEUE_IF_FEASIBLE(1,1,1,2);
		ENQUEUE_IF_FEASIBLE(2,0,2,1);
		ENQUEUE_IF_FEASIBLE(2,1,2,2);
 
		ENQUEUE_IF_FEASIBLE(0,0,1,0);
		ENQUEUE_IF_FEASIBLE(1,0,2,0);
		ENQUEUE_IF_FEASIBLE(0,1,1,1);
		ENQUEUE_IF_FEASIBLE(1,1,2,1);
		ENQUEUE_IF_FEASIBLE(0,2,1,2);
		ENQUEUE_IF_FEASIBLE(1,2,2,2);
	}
}
 
int main(int argc, char *argv[]) {
	int ngames = 0;
	make_graph();
	// printf("Graphsize: %u\n", static_cast<unsigned>(visited.size()));
	scanf(" %d", &ngames);
	for(int g = 0; g < ngames; ++g) {
		printf("%d\n", solve(read_input()));
	}
	return 0;
}
 