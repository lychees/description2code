/* Man Mohan Mishra aka m17
   IIIT - Allahabad */
#include <cstdio>
#include <cmath>
#include <cstring>
#include <climits>
#include <cstdlib>
#include <cctype>
#include <iostream>
#include <algorithm>
#include <utility>
#include <string>
#include <vector>
#include <map>
#include <list>
#include <stack>
#include <queue>
#include <set>
#include <iterator>

#define MOD 1000000007
#define INF 1000000000000000000
#define PI acos(-1)

using namespace std;

long long GCD (long long a,long long b) {
	if (b == 0) return a;
	return(a % b == 0 ? b : GCD(b,a % b));
}

long long POW (long long base,long long exp) {
	long long val;
	val = 1;
	while (exp > 0) {
		if (exp % 2 == 1) {
			val = (val * base) % MOD;
		}
		base = (base * base) % MOD;
		exp = exp / 2;
	}
	return val;
}

int a[100005];
int b[100005];
int ll[100005];
int rr[100005];
long long inv;
vector <int> v;
vector <int> temp;

void merge (int p,int q,int r) {
	int n,m,i,j,k;
	n = q - p + 1;
	m = r - q;
	for (i = 0; i < n; i++) {
		ll[i] = a[p + i];
	}
	ll[n] = INT_MAX;
	for (i = 0; i < m; i++) {
		rr[i] = a[q + i + 1];
	}
	rr[m] = INT_MAX;
	i = 0;
	j = 0;
	for (k = p; k <= r; k++) {
		if (ll[i] <= rr[j]) {
			a[k] = ll[i];
			i++;
		} else {
			a[k] = rr[j];
			j++;
			inv = inv + (q - p - i + 1);
		}
	}
}

void merge_sort(int p,int r) {
	int q;
	if (p < r) {
		q = (p + r) / 2;
		merge_sort(p,q);
		merge_sort(q + 1,r);
		merge(p,q,r);
	}
}

bool is_all_equal (int n) {
	int i;
	for (i = 1; i < n; i++) {
		if (a[i] != a[0]) return false;
	}
	return true;
}

int main()
{
	int t;
	scanf("%d",&t);
	while (t --) {
		int n,i,j,num,low,high,mid,v1,v2,sz,mn;
		long long mx;
		scanf("%d",&n);
		for (i = 0; i < n; i++) {
			scanf("%d",&a[i]);
			b[i] = a[i];
		}
		if (is_all_equal(n)) {
			printf("0 0\n");
			continue;
		}
		inv = 0;
		merge_sort(0,n - 1);
		mx = inv;
		v.clear();
		v.push_back(0);
		for (i = 0; i < n - 1; i++) {
			num = b[i];
			low = 0;
			high = n - 1;
			v1 = -1;
			while (low <= high) {
				mid = (low + high) / 2;
				if (a[mid] < num) {
					if (mid == n - 1 || a[mid + 1] >= num) {
						v1 = mid;
						break;
					} else {
						low = mid + 1;
					}
				} else {
					high = mid - 1;
				}
			}
			low = 0;
			high = n - 1;
			v2 = -1;
			while (low <= high) {
				mid = (low + high) / 2;
				if (a[mid] > num) {
					if (mid == 0 || a[mid - 1] <= num) {
						v2 = mid;
						break;
					} else {
						high = mid - 1;
					}
				} else {
					low = mid + 1;
				}
			}
			if (v1 != -1) {
				inv = inv - (v1 + 1);
			}
			if (v2 != -1) {
				inv = inv + (n - v2);
			}
			if (inv > mx) {
				mx = inv;
				v.clear();
				v.push_back(i + 1);
			} else if (inv == mx) {
				v.push_back(i + 1);
			}
		}
		for (i = 0; i < min(1000,n); i++) {
			mn = INT_MAX;
			sz = v.size();
			for (j = 0; j < sz; j++) {
				mn = min(mn,b[(v[j] + i) % n]);
			}
			temp.clear();
			for (j = 0; j < sz; j++) {
				if (b[(v[j] + i) % n] == mn) {
					temp.push_back(v[j]);
				}
			}
			v.clear();
			sz = temp.size();
			for (j = 0; j < sz; j++) {
				v.push_back(temp[j]);
			}
		}
		printf("%d %lld\n",v[0],mx);
	}
	return 0;
}