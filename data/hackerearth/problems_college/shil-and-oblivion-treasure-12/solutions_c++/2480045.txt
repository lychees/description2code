#include<bits/stdc++.h>
using namespace std;
typedef long long int LL;
typedef int ll;
typedef set<int> si;
typedef long long Long;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<Long>vl;
typedef pair<int,int>pii;
typedef pair<Long,Long>pll;
typedef pair<string,int>psi;
typedef pair<double,double>pdd;
//#define get getchar_unlocked
//#define put putchar_unlocked
#define get getchar
#define put(c) printf("%c",c)
#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define sz size()
#define ln length()
#define repstl(i, s) for (__typeof((s).end())i=(s).begin();i!=(s).end();++i)
#define PI 3.1415926535897932384626433832795
#define S2 1.41421356237309504880168872420969807856967187537694807317667
#define S3 1.73205080756887729352744634150587236694280525381038062805580
#define FO freopen ("out.txt", "w", stdout)
#define FI freopen ("in.txt", "r", stdin)
#define ref(i,a,n) for(int i=a;i<=n;i++)
#define reb(i,n,a) for(int i=n;i>=a;i--)
#define rep(i,n) for(int i=0;i<n;i++)
#define all(a) a.begin(),a.end()
#define pc(c) printf("%c",c)
#define ps printf(" ")
#define pn printf("\n")
#define l(a) 2*a+1
#define r(a) 2*a+2
#define left(a,b) a,(a+b)/2
#define right(a,b) (a+b)/2+1,b
#define mid(a,b) (a+b)/2

inline char skipwhitespace() { 
    char ch = get();
    while(ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t') 
        ch = get();
    return ch;
}

void gi(ll &x) {
    register ll c = get(); x = 0;
    ll sn=1;
    for(;(c<48 || c>57);c = get()) 
    if(c=='-') sn=-1;
    for(;c>47 && c<58;c = get()) {
        x = (x<<1) + (x<<3) + c - 48;
    }
    x*=sn;
}

void gii(LL &x) {
    register LL c = get(); x = 0;
    LL sn=1;
    for(;(c<48 || c>57);c = get()) 
    if(c=='-') sn=-1;
    for(;c>47 && c<58;c = get()) {
        x = (x<<1) + (x<<3) + c - 48;
    }
    x*=sn;
}

void wi(ll n) {
    ll sign = n >= 0 ? 1 : -1;
    n = n>0 ? n : -n;
    char buf[10];
    ll i = 9;
    if(!n) buf[i--] = 48;
    while(n) {
        buf[i--] = n % 10 + 48;
        n /= 10;
    }
    if(sign < 0) put('-');
    while(++i < 10) put(buf[i]);
}
 
void wii(LL n)
{
    LL sign = n >= 0 ? 1 : -1;
    n = n>0 ? n : -n;
    char buf[25];
    LL i = 24;
    if(!n) buf[i--] = 48;
    while(n) {
        buf[i--] = n % 10 + 48;
        n /= 10;
    }
    if(sign < 0) put('-');
    while(++i < 25) put(buf[i]);
}

ll gs(char *s)
{
    char ch=skipwhitespace();
    ll n=0;
    while( (ch != '\n' && ch != ' ' && ch != '\t') )
    {
        s[n++] = ch;
        ch = get();
    }
    s[n] = 0;
    return n;
}

void ws(char *s)
{
    char *p = s;
    while(*p) {
        put(*p);
        p++;
    }
}

//int dx[]={1,0,-1,0};int dy[]={0,1,0,-1}; //4 Direction
//int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction
//int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction
//int dx[]={2,1,-1,-2,-1,1};int dy[]={0,1,1,0,-1,-1}; //Hexagonal Direction

#define M 1000000007
#define N 10004
ll arr[N],prime[N]={0},p[N],fact[N],k=0;

typedef struct { ll ans,cnt[170]; } nod;
nod a[N<<2];

void pre() {
	rep(i,N) fact[i]=i;
	for(int i=2;i<=1000;i++) if(fact[i]==i) for(int j=2*i;j<=1000;j+=i) if(fact[j]==j) fact[j]=i;
	for(int i=2;i*i<=1000;i++) if(!prime[i]) for(int j=2*i;j<=1000;j+=i) prime[j]=1;
	for(int i=2;i<=1000;i++) if(!prime[i]) p[k]=i,prime[i]=k++;
}

ll POW(ll a,ll b) {
	ll ans=1;
	while(b) {
		if(b&1) ans=(ans*1ll*a)%M;
		b>>=1; a=(a*1ll*a)%M;
	}
	return ans;
}

void build(ll nn,ll s,ll e) {
	if(s==e) {
		rep(i,k) a[nn].cnt[i]=0;
		while(arr[s]!=1) {
			a[nn].cnt[prime[fact[arr[s]]]]++;
			arr[s]/=fact[arr[s]];
		}
		return ;
	}
	build(l(nn),left(s,e));
	build(r(nn),right(s,e));
	rep(i,k) a[nn].cnt[i]=max(a[l(nn)].cnt[i],a[r(nn)].cnt[i]);
}

void update(ll nn,ll s,ll e,ll id) {
	if(s==e) {
		rep(i,k) a[nn].cnt[i]=0;
		while(arr[s]!=1) {
			a[nn].cnt[prime[fact[arr[s]]]]++;
			arr[s]/=fact[arr[s]];
		}
		return ;
	}
	ll m=mid(s,e);
	if(id<=m) update(l(nn),left(s,e),id);
	else update(r(nn),right(s,e),id);
	rep(i,k) a[nn].cnt[i]=max(a[l(nn)].cnt[i],a[r(nn)].cnt[i]);
}

nod query(ll nn,ll s,ll e,ll l,ll r) {
	if(s==l && r==e) return a[nn];
	ll m=mid(s,e);
	if(r<=m) return query(l(nn),left(s,e),l,r);
	if(l>m) return query(r(nn),right(s,e),l,r);
	nod aa,bb,cc;
	aa=query(l(nn),left(s,e),l,m);
	bb=query(r(nn),right(s,e),m+1,r);
	rep(i,k) cc.cnt[i]=max(aa.cnt[i],bb.cnt[i]);
	return cc;
}

int main() {
	pre();
	ll n,q;
	gi(n);
	rep(i,n) gi(arr[i]);
	build(0,0,n-1);
	gi(q);
	while(q--) {
		ll c,x,y,tans=1;
		gi(c);
		if(c==1) {
			gi(x); gi(y); arr[x-1]=y;
			update(0,0,n-1,x-1);
		} else {
			gi(x); gi(y);
			nod ans=query(0,0,n-1,x-1,y-1);
			rep(i,k) tans=(tans*1ll*POW(p[i],ans.cnt[i]))%M;
			wi(tans); pn;
		}
	}
	return 0;
}