#include <bits/stdc++.h>
using namespace std;

#define REPU(i, a, b) for (int i = (a); i < (b); ++i)
#define REPD(i, a, b) for (int i = (a); i > (b); --i)
#define MEM(a, x) memset(a, x, sizeof(a))
#define ALL(a) a.begin(), a.end()
#define UNIQUE(a) a.erase(unique(ALL(a)), a.end())
#define DEBUG(x) cout << #x << " = " << x << endl

typedef long long ll;
const int MOD = 1000000007;

template<class T> inline T tmin(T a, T b) { return (a < b) ? a : b; }
template<class T> inline T tmax(T a, T b) { return (a > b) ? a : b; }
template<class T> inline void amax(T &a, T b) { if (b > a) a = b; }
template<class T> inline void amin(T &a, T b) { if (b < a) a = b; }
template<class T> inline T tabs(T a) { return (a > 0) ? a : -a; }
template<class T> T gcd(T a, T b) { while (b != 0) { T c = a; a = b; b = c % b; } return a; }

typedef pair<int, int> P;
const int N = 400005;
int n, k;
int rk[N], tmp[N], sa[N], lcp[N], f[N], g[N], pos[N];
string s;

bool compare_sa(int i, int j) {
	if (rk[i] != rk[j]) return rk[i] < rk[j];
	else {
		int ri = i + k < n ? rk[i + k] : -1;
		int rj = j + k < n ? rk[j + k] : -1;
		return ri < rj;
	}
}

void construct_sa() {
	REPU(i, 0, n) {
		sa[i] = i;
		rk[i] = s[i];
	}
	for (k = 1; k <= n; k *= 2) {
		sort(sa, sa + n, compare_sa);
		tmp[sa[0]] = 0;
		REPU(i, 1, n) tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);
		REPU(i, 0, n) rk[i] = tmp[i];
		if (tmp[n - 1] == n - 1) break;
	}
}

void construct_lcp() {
	int h = 0;
	REPU(i, 0, n) {
		if (rk[i] == 0) continue;
		int j = sa[rk[i] - 1];
		for (; j + h < n && i + h < n; ++h) {
			if (s[j + h] != s[i + h]) break;
		}
		lcp[rk[i] - 1] = h;
		if (h > 0) h--;
	}
}

struct SegmentTree {
	const int INF = static_cast<int>(1e9);
	vector<P> node;
	
	void init(int _size) {
		int tot = 1;
		while (tot <= _size) tot <<= 1;
		tot <<= 1;
		node.resize(tot);
	}
	
	void build(int ind, int l, int r) {
		if (r - l == 1) {
			node[ind] = P(lcp[l], l); return;
		}
		int m = (l + r) >> 1, c1 = ind + ind, c2 = c1 | 1;
		build(c1, l, m);
		build(c2, m, r);
		node[ind] = min(node[c1], node[c2]);
	}
	
	P query(int ind, int l, int r, int st, int en) {
		if (st <= l && r <= en) return node[ind];
		if (l >= en || r <= st) return P(INF, -1);
		int m = (l + r) >> 1, c1 = ind + ind, c2 = c1 | 1;
		P vl = query(c1, l, m, st, en);
		P vr = query(c2, m, r, st, en);
		return min(vl, vr);
	}
};

SegmentTree segtree;

ll solve(int l, int r, int level) {
	if (r <= l) return 0;
	if (r - l == 1) {
		if (l + 1 < n && pos[sa[l]] + pos[sa[r]] == 1 && lcp[l] >= level) return lcp[l] - level + 1;
		return 0;
	}
	ll ret = 0;
	P p = segtree.query(1, 0, n, l, r);
	if (p.first >= level) {
		ll x = f[r - 1] - (l ? f[l - 1] : 0);
		if (pos[sa[r]] == 0) x++;
		ll y = g[r - 1] - (l ? g[l - 1] : 0);
		if (pos[sa[r]] == 1) y++;
		ret = x * y *(p.first + 1 - level) + solve(l, r, p.first + 1);
	}
	else {
		ret = solve(l, p.second, level) + solve(p.second + 1, r, level);
	}
	//printf("%d %d %d %lld\n", l, r, level, ret);
	return ret;
}

int main(int argc, char *argv[]) {
	ios_base::sync_with_stdio(false);
	
	int tn, tm;
	string st;
	
	MEM(pos, -1);
	
	s = "";
	cin >> tn;
	REPU(i, 0, tn) {
		cin >> st;
		if (i) s += '{';
		int ind = s.size();
		s += st;
		REPU(j, 0, st.size()) pos[ind + j] = 0;
	}
	s += '$';
	cin >> tm;
	REPU(i, 0, tm) {
		cin >> st;
		if (i) s += '}';
		int ind = s.size();
		s += st;
		REPU(j, 0, st.size()) pos[ind + j] = 1;
	}
	
	n = s.size();
	//cout << s << endl;
	
	construct_sa(); construct_lcp();
	
	segtree.init(n);
	segtree.build(1, 0, n);
	
	//REPU(i, 0, n) printf("%d%c", lcp[i], " \n"[i == n - 1]);
	//REPU(i, 0, n) printf("%d%c", sa[i], " \n"[i == n - 1]);
	//REPU(i, 0, n) printf("%d%c", pos[sa[i]], " \n"[i == n - 1]);
	
	REPU(i, 0, n) {
		if (i) f[i] = f[i - 1], g[i] = g[i - 1];
		if (pos[sa[i]] == 0) f[i]++;
		if (pos[sa[i]] == 1) g[i]++;
	}
	
	cout << solve(0, n, 1) << endl;
	
	return 0;
}
