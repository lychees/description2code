from collections import deque


def bfs(s, n, graph):
    q = deque([(s, 0)])
    visited = set([s])

    while (len(q)):
        node, level = q.popleft()
        if node == n:
            return level
        for neighbor in graph[node]:
            if neighbor not in visited:
                q.append((neighbor, level + 1))
                visited.add(node)


tc = int(raw_input())
for i in range(tc):
    n, m = map(int, raw_input().split())
    graph = {}
    for j in range(m):
        x, y = map(int, raw_input().split())
        if x in graph:
            graph[x] = graph[x] + [y]
        else:
            graph[x] = [y]
        if y in graph:
            graph[y] = graph[y] + [x]
        else:
            graph[y] = [x]
        # graph[x] = graph.get(x, []) + [y]
        # graph[y] = graph.get(y, []) + [x]
    print bfs(1, n, graph)
