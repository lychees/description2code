#include <bits/stdc++.h>
#define sp(z) 				setprecision(z)
#define sv(z) 				sort(z.begin(),z.end())
#define F 					first
#define S 					second
#define pb 					push_back
#define mp 					make_pair
#define ll 					long long
#define ld 					long double
#define fre(y,q,s) 			for(int y=q;y>=s;y--)
#define fr(y,q,s) 			for(int y=q;y<s;y++)
#define f(y,z) 				for(int y=0;y<z;y++)
#define fe(y,z) 			for(int y=1;y<=z;y++)
#define matrix(arr,n,m)		vector<vector<ll> > arr(n,vector<ll>(m,0))
using namespace std;
ll lmin(ll a,ll b){ return (a<b)?a:b; } ll lmax(ll a,ll b){ return (a>b)?a:b; }
ld dmin(ld a,ld b){ return (a<b)?a:b; } ld dmax(ld a,ld b){ return (a>b)?a:b; }
ll gcd(ll a,ll b){ return (b==0)?a:gcd(b,a%b); } ll lcm(ll a, ll b) { return (a*b)/gcd(a,b); }
ll modpow(ll a, ll n, ll mod){ ll res=1; while(n){ if(n&1)res=(res*a)%mod; a=(a*a)%mod; n>>=1; } return res; }
ll lpow(ll a, ll n){ ll res=1; while(n){ if(n&1)res*=a; a*=a; n>>=1; } return res; }
ld dpow(ld a, ll n){ ld res=1; while(n){ if(n&1)res*=a; a*=a; n>>=1; } return res; }
/* ********************** Main Code starts from here ********************** */
ll dp[3][2000];
ll mod = (ll)1e9 + 7;
void pre(){
	dp[0][0] = 1;
	fe(i, 1000){
		fe(j, 4){
			if(i - j >= 0){
				dp[0][i] = dp[0][i] + dp[0][i - j];
				if(dp[0][i] >= mod){
					dp[0][i] -= mod;
				}
			}
		}
	}
}
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	
	pre();
	
	
	
	
	
	int t, n, m;
	ll temp;
	cin >> t;
	while(t--){
		cin >> n >> m;
		
		fe(i, m){
			dp[1][i] = modpow(dp[0][i], n, mod);
		}
		
		
		
		memset(dp[2], 0, sizeof(dp[2]));
		dp[2][1] = 1;
		fr(i, 2, m + 1){
			dp[2][i] = dp[1][i];
			temp = 0;
			fr(j, 1, i){
				temp += (dp[2][j] * dp[1][i - j]) % mod;
				if(temp >= mod){
					temp -= mod;
				}
			}
			dp[2][i] -= temp;
			if(dp[2][i] >= mod){
				dp[2][i] -= mod;
			}
			if(dp[2][i] < 0){
				dp[2][i] += mod;
			}
		}
		cout << dp[2][m] << endl;
	}
	
	return 0;
}
