#include <cmath>
#include <bits/stdc++.h>
#include <math.h>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
void multiply(ll F[2][2], ll M[2][2],ll mod);
void power(ll F[2][2], ll n,ll mod);
ll gcd(ll a, ll b) {
    return b == 0 ? a : gcd(b, a % b);
}
ll multmod(ll base,ll exponent,ll modulo)
{
	ll ans=0;
	while(exponent>0)
	{
		while(exponent%2==0)
		{
			base+=base;
			base%=modulo;
			exponent/=2;
		}
		exponent--;
		ans+=base;
		ans%=modulo;
	}
	return ans;
}

ll fibo(ll n,ll mod)
{
	ll F[2][2] = {{1,1},{1,0}};
  if (n == 0)
    return 0;
  power(F, n-1,mod);
  return ( F[0][0]);
}
void power(ll F[2][2], ll n,ll mod)
{
  if( n == 0 || n == 1)
      return;
  ll M[2][2] = {{1,1},{1,0}};
 
  power(F, n/2,mod);
  multiply(F, F,mod);
 
  if (n%2 != 0)
     multiply(F, M,mod);
}
 
void multiply(ll F[2][2], ll M[2][2],ll mod)
{
	ll x,y,z,w;
	if(mod>=1500000000){
  x =  multmod(F[0][0],M[0][0],mod) + multmod(F[0][1],M[1][0],mod);
  y =  multmod(F[0][0],M[0][1],mod) + multmod(F[0][1],M[1][1],mod);
  z =  multmod(F[1][0],M[0][0],mod) + multmod(F[1][1],M[1][0],mod);
  w =  multmod(F[1][0],M[0][1],mod) + multmod(F[1][1],M[1][1],mod);}
  else{
  x =  F[0][0]*M[0][0] + F[0][1]*M[1][0];
  y =  F[0][0]*M[0][1] + F[0][1]*M[1][1];
  z =  F[1][0]*M[0][0] + F[1][1]*M[1][0];
  w =  F[1][0]*M[0][1] + F[1][1]*M[1][1];
  }
 
  F[0][0] = x%mod;
  F[0][1] = y%mod;
  F[1][0] = z%mod;
  F[1][1] = w%mod;
}
int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int tc;
    scanf("%d",&tc);
    ll n,M,hcf=1;
    M=1000000007;
    scanf("%lld",&n);
    hcf=n;
    tc--;
    while(tc--)
    {
        scanf("%lld",&n);
        hcf=gcd(n,hcf);
        //cout<<hcf<<endl;
    }
    printf("%lld\n",(fibo(hcf,M)%M));
    return 0;
}
