#include <bits/stdc++.h>
#include <set>
#include <algorithm>
#define inf 100000000

using namespace std;

int n,m;

struct graph {
	int d;
	int x;
	int y;
	int v;
}g[1003][1003];

struct B
{
  bool operator()(const graph& lhs, const graph& rhs) {
    return lhs.d < rhs.d;
  }
};

multiset <graph, B> ms;

int ar[1003][1003];

void mark_v (int i, int j, int dis)
{
	if (i > n || i < 1 || j < 1 || j > m || g[i][j].v == 1)
		return;
	
	graph in;
	g[i][j].x = i;
	g[i][j].y = j;
	if (g[i][j].d > dis + ar[i][j]) {
		g[i][j].d = dis + ar[i][j];
		in = g[i][j];
	    ms.insert (in);
	}
}

int main ()
{
	int t;
	scanf ("%d",&t);
	while (t--)
	{
		scanf ("%d %d",&n,&m);
		int i,j,flag = 0;
		int di,dj,tm;
		for (i = 1 ; i <= n ; i++)
		{
			for (j = 1 ; j <= m ; j++)
			{
				g[i][j].d = inf;
				cin >> ar[i][j];
			}
		}
		scanf ("%d %d %d",&di,&dj,&tm);


		mark_v (1,1,0);
		while (ms.size () != 0)
		{
			graph p;
			multiset <graph, B>::iterator it;
			it = ms.begin ();
			p = *it;
			ms.erase (it);
			int dis = p.d;
			g[p.x][p.y].v = 1;
			
			if (g[di][dj].v == 1) break;
			
			mark_v (p.x + 1, p.y, dis);
			mark_v (p.x-1,p.y,dis);
			mark_v (p.x,p.y-1,dis);
			mark_v (p.x,p.y+1,dis);
		}

	//	printf ("dis %d\n",g[di][dj].d);
		
		if (g[di][dj].d > tm)	printf ("NO\n");
		else printf ("YES\n%d\n",tm-g[di][dj].d);

		ms.clear ();
		for (i = 1 ; i <= n ; i++)
			for (j = 1 ; j <= m ; j++)
				g[i][j].v = 0;
	}

	return 0;
}
