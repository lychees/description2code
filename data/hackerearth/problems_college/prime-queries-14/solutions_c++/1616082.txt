//    Author : Nishanth Vijayan IIT Ropar,India.
//
//	  Spoj 		  : http://www.spoj.com/users/nishanth_v/
//	  HackerEarth : http://www.hackerearth.com/users/nishanththegr8/
//	  Facebook	  : https://www.facebook.com/NishanthTheGr8
//    Motto       : The Less You Give A Fuck, The Happier You'll Be. :)


#include <iostream>
#include <cstdio>
#include <map>
#include <set>
#include <vector>
#include <stack>
#include <list>
#include <algorithm>
#include <utility>
#include <cmath>
#include <string>
#include <cstring>


#define ABS(x) ((x)<0?-(x):(x))
#define pnl printf("\n");
#define REP(i,n) for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b) for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b) for(__typeof(b) i=(a);i<=(b);++i)
#define FOREACH(i,s) for(__typeof((s).begin()) i=(s).begin();i!=(s).end();i++)
#define UNIQUE(v) sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b) memset(a,b,sizeof(a))

#define pi acos(-1)
#define inf 0x3f3f3f3f

#define MEMSET_INF 127 // about 2B
#define MEMSET_HALF_INF 63 // about 1B
#define LLI long long 
#define gc getchar_unlocked
#define pc putchar_unlocked
#define MAX 2097251
#define SIZE 1000000
using namespace std;

typedef pair<LLI, LLI> ii;
typedef vector<LLI, LLI> vi;

//Fast Input & Output

LLI scanint()
{register int c = gc();LLI x = 0;int neg = 0;
for(;((c<48 || c>57) && c != '-');c = gc());
if(c=='-') {neg=1;c=gc();}
for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
if(neg) x=-x;return x;}
/*
void writeint (LLI n)
{LLI N = n, rev, count = 0;rev = N;
if (N == 0) { pc('0'); pc('\n'); return ;}
while ((rev % 10) == 0) { count++; rev /= 10;} 
rev = 0;
while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;} 
while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
while (count--) pc('0');}
*/


long arr[SIZE];
long tree[MAX];
long A[78499],B[100010];
/**
 * Build and init tree
 */
void build_tree(long node, long a, long b) {
    if(a > b) return; // Out of range
  	
  	if(a == b) { // Leaf node
  		//	cout<<node<<" is a leaf node of tree value = "<<arr[a]<<endl;
    		tree[node] = B[arr[a]]; // Init value
		return;
	}
	
	build_tree((node<<1), a, ((a+b)>>1)); // Init left child
	build_tree((node<<1)+1, 1+((a+b)>>1), b); // Init right child
	
	tree[node] = max(tree[(node<<1)], tree[(node<<1)+1]); // Init root value
}


long query_tree(long node, long a, long b, long i, long j) {
	
	if(a > b || a > j || b < i) return -1*inf; // Out of range

	if(a >= i && b <= j) 
		return tree[node];

	long q1 = query_tree((node<<1), a, ((a+b)>>1), i, j); // Query left child
	long q2 = query_tree(1+(node<<1), 1+((a+b)>>1), b, i, j); // Query right child

	long res = max(q1, q2);

	return res;
}

/**
 * Increment elements within range [i, j] with value value
 */
void update_tree(long node, long a, long b, long i, long j, long value) {
    
	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return;
    
  	if(a == b) { // Leaf node
    		tree[node] = value;
    		return;
	}

	update_tree(node*2, a, (a+b)/2, i, j, value); // Updating left child
	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value); // Updating right child

	tree[node] = max(tree[node*2], tree[node*2+1]); // Updating root with max value
}


int main(){

long long i,j,k,flag,t,n,m;
float sq;
A[0] =2;A[1]=3;k =2;
FILL(B,-1);

B[2]=2;B[3]=3;
for(i=5;i<=100000;i+=2){
	
	flag=0;
	sq = sqrt(i);
	if(i%2==0 || i%3==0){flag=1;}
	
	else{
	for(j=0;j<k && A[j]<=sq;j++){
		if(A[j]!=0 &&i%A[j]==0){ flag=1; break; }
	}}
	
	if (flag==0)
		{A[k] = i;B[i]=i;k++;}
}

LLI N,M,l,r,q;
cin>>N>>M;
FOR(e,0,N)cin>>arr[e];

build_tree(1,0,N-1);

FOR(i,0,M){
	q=scanint();l=scanint()-1;r=scanint()-1;
	if(q==1){
		cout<<query_tree(1,0,N-1,l,r)<<endl;
	}
	else{
		update_tree(1,0,N-1,l,l,B[r+1]);
	}
	
}



return 0;
}