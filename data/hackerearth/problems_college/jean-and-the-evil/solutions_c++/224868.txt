#include <bits/stdc++.h>
using namespace std;

#define MAX 1000000
#define sd(x) scanf("%d", &x)

struct no {
    int lsum, rsum, msum, sum;
};

no tree[ 4 * MAX + 1 ];
int sums[ MAX + 1 ], arr[ MAX + 1 ];

void init( int node, int i, int j ) {
    if ( i == j ) {
        tree[ node ] = ( ( no ) { arr[ i ], arr[ i ], arr[ i ], arr[ i ] } );
    }
    else {
        init( node * 2, i, ( i + j ) / 2 );
        init( node * 2 + 1, ( i + j ) / 2 + 1, j );
        no left = tree[ node * 2 ], right = tree[ node * 2 + 1 ];
        tree[ node ].lsum = max( left.lsum, left.sum + right.lsum );
        tree[ node ].rsum = max( right.rsum, right.sum + left.rsum );
        tree[ node ].msum = max( left.msum, max( right.msum, left.rsum + right.lsum ) );
        tree[ node ].sum = left.sum + right.sum;
    }
}

no query( int node, int a, int b, int i, int j ) {
    if ( i == a && j == b ) {
        return tree[ node ];
    }
    if ( j <= ( a + b ) / 2 ) {
        return query( node * 2, a, ( a + b ) / 2, i, j );
    }
    if ( i > ( a + b ) / 2 ) {
        return query( node * 2 + 1, ( a + b ) / 2 + 1, b, i, j );
    }
    no left = query( node * 2, a, ( a + b ) / 2, i, ( a + b ) / 2 );
    no right = query( node * 2 + 1, ( a + b ) / 2 +  1, b, ( a + b ) / 2 + 1, j );
    return ( ( no ) {
                max( left.lsum, left.sum + right.lsum ),
                max( right.rsum, right.sum + left.rsum ),
                max( left.msum, max( right.msum, right.lsum + left.rsum ) ),
                left.sum + right.sum } );
}

inline void Solve(){
    int i, N, q, op, l, r;
    sd(N);
    for ( i = 0; i < N; ++i ) {
        scanf( "%d", arr + i );
    }
    init( 1, 0, N - 1 );
    printf( "%d\n", query( 1, 0, N - 1, 0, N - 1 ).msum );
    return;
}

int main() {
    int t;
    sd(t);
    while(t--){
        Solve();
    }
    return 0;
}
