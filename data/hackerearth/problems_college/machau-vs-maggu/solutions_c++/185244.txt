#include<bits/stdc++.h>

using namespace std;

#define sd(x) scanf("%d", &x)
#define X first
#define Y second
#define pii pair<int,int>
#define MAXN 3000000
#define MP make_pair
#define PB push_back

pii a, b;
vector<pii> bk;
int x[MAXN], y[MAXN];
map<int,int> mx, my;
map< pii , int > goi;
set< pii > abks;
bool vis[MAXN] = {false};
vector< pii > vx[MAXN], vy[MAXN], go;
vector<int> adj[MAXN];
queue<int> Q;

int main(){
    int n, m, minx, maxx, miny, maxy, i, j, dx, dy, nx, ny, goia, goib, k;
    sd(n); sd(m); sd(a.X); sd(a.Y); sd(b.X); sd(b.Y);
    minx = min(a.X, b.X);
    maxx = max(a.X, b.X);
    miny = min(a.Y, b.Y);
    maxy = max(a.Y, b.Y);
	for(i = 0; i < m; i++){
    	sd(x[i]); sd(y[i]);
    	if(minx <= x[i] && x[i] <= maxx){
    		if(miny <= y[i] && y[i] <= maxy){
    			bk.PB(MP(x[i], y[i]));
    		}
    	}
    }
	m = bk.size();
	for(i = 0; i < m; i++){
		x[i] = bk[i].X;
		y[i] = bk[i].Y;
	}
    x[m] = a.X;
    x[m + 1] = b.X;
    y[m] = a.Y;
    y[m + 1] = b.Y;
	sort(x, x + m + 2);
	sort(y, y + m + 2);
	mx.clear();
	my.clear();
	nx = 1;
    mx[x[0]] = nx;
    for(i = 1; i < m + 2; i++){
    	if(x[i] != x[i - 1]){
    		nx++;
    		if(x[i] > x[i - 1] + 1){
    			nx++;		
    		}
    		mx[x[i]] = nx;
    	}
    }
    ny = 1;
    my[y[0]] = ny;
    for(i = 1; i < m + 2; i++){
    	if(y[i] != y[i - 1]){
    		ny++;
    		if(y[i] != y[i - 1] + 1){
    			ny++;
    		}
    		my[y[i]] = ny;
    	}
    }
    for(i = 0; i < m; i++){
    	bk[i].X = mx[bk[i].X];
    	bk[i].Y = my[bk[i].Y];
    	abks.insert(bk[i]);
    	//cout<<bk[i].X<<" "<<bk[i].Y<<endl;
    }
    for(i = 0; i < nx + 2; i++){
    	abks.insert(MP(i, ny + 1));
    	abks.insert(MP(i, 0));
    }
    for(i = 1; i <= ny; i++){
    	abks.insert(MP(0, i));
    	abks.insert(MP(nx + 1, i));
    }
    a.X = mx[a.X];
    a.Y = my[a.Y];
    b.X = mx[b.X];
    b.Y = my[b.Y];
    if(abks.find(a) != abks.end() || abks.find(b) != abks.end()){
    	cout<<"MAGGU FOREVER"<<endl;
    	return 0;
    }
    for(i = 0; i < m; i++){
    	for(dx = -1; dx <= 1; dx++){
    		for(dy = -1; dy <= 1; dy++){
    			if(dx != 0 || dy != 0){
    				if(dx == 0 || dy == 0){
	    				if(abks.find(MP(bk[i].X + dx, bk[i].Y + dy)) == abks.end()){
	    					go.PB(MP(bk[i].X + dx, bk[i].Y + dy));
	    					//cout<<bk[i].X<<" "<<bk[i].Y<<" "<<dx<<" "<<dy<<endl;
	    				}	
    				}
    			}
    		}
    	}
    }
    for(i = 1; i <= nx; i++){
    	if(abks.find(MP(i, 1)) == abks.end()){
    		go.PB(MP(i, 1));
    	}
    	if(abks.find(MP(i, ny)) == abks.end()){
    		go.PB(MP(i, ny));
    	}
    }
	for(i = 1; i <= ny; i++){
    	if(abks.find(MP(1, i)) == abks.end()){
    		go.PB(MP(1, i));
    	}
    	if(abks.find(MP(nx, i)) == abks.end()){
    		go.PB(MP(nx, i));
    	}
    }
    //cout<<nx<<" "<<ny<<endl;
    go.PB(a);
    go.PB(b);
    j = 0;
    goia = -1;
    goib = -1;
    for(i = go.size() - 1; i >= 0; i--){
    	if(go[i] == a){
    		if(goia != -1){
    			continue;
    		}
			goia = j;
    	}
    	if(go[i] == b){
    		if(goib != -1){
    			continue;
    		}
    		goib = j;
    	}
    	//cout<<go[i].X<<" "<<go[i].Y<<" "<<j<<endl;
		vx[go[i].X].PB(MP(go[i].Y, j));
		vy[go[i].Y].PB(MP(go[i].X, j));
		j++;
    }
    n = j;
    //cout<<nx<<endl;
    for(i = 1; i <= nx; i++){
    	//cout<<i<<endl;
    	sort(vx[i].begin(), vx[i].end());
    	//for(j = vx[i].size() - 1; j >= 0; j--){
    		//cout<<i<<" "<<vx[i][j].X<<" "<<vx[i][j].Y<<endl;
    	//}
    	for(j = vx[i].size() - 1; j >= 0; j--){
    		//cout<<j<<endl;
			//cout<<vx[i][j].Y<<" "<<vx[i][j + 1].Y<<endl;
			for(k = j - 1; k >= 0; k--){
    			//cout<<k<<endl;
				if(vx[i][k].X != vx[i][j].X){
    				break;
    			}
    		}
    		if(k == -1){
    			break;
    		}
			y[0] = vx[i][k].X;
			y[1] = vx[i][j].X;
			if(y[0] <= y[1] - 2){
				if(abks.find(MP(i, y[0] + 1)) == abks.end()){
					adj[vx[i][j].Y].PB(vx[i][k].Y);
    				adj[vx[i][k].Y].PB(vx[i][j].Y);	
				}
			}
			else{
				adj[vx[i][j].Y].PB(vx[i][k].Y);
    			adj[vx[i][k].Y].PB(vx[i][j].Y);
			}
			j = k + 1;
    	}
    }
    for(i = 1; i <= ny; i++){
    	sort(vy[i].begin(), vy[i].end());
    	//for(j = vx[i].size() - 1; j >= 0; j--){
    		//cout<<i<<" "<<vy[i][j].X<<" "<<vy[i][j].Y<<endl;
    	//}
		for(j = vy[i].size() - 1; j >= 0; j--){
    		//cout<<vy[i][j].Y<<" "<<vy[i][j + 1].Y<<endl;
    		for(k = j - 1; k >= 0; k--){
    			if(vy[i][k].X != vy[i][j].X){
    				break;
    			}
    		}
    		if(k == -1){
    			break;
    		}
			x[0] = vy[i][k].X;
    		x[1] = vy[i][j].X;
    		if(x[0] <= x[1] - 2){
    			if(abks.find(MP(x[0] + 1, i)) == abks.end()){
    				adj[vy[i][j].Y].PB(vy[i][k].Y);
    				adj[vy[i][k].Y].PB(vy[i][j].Y);
    			}
    		}
    		else{
    			adj[vy[i][j].Y].PB(vy[i][k].Y);
    			adj[vy[i][k].Y].PB(vy[i][j].Y);
    		}
    		j = k + 1;
    	}
    }
    /*
    for(i = 0; i < n; i++){
    	for(j = 0; j < adj[i].size(); j++){
    		cout<<i<<" "<<adj[i][j]<<endl;
    	}
    }
    */
    Q.push(goia);
    vis[goia] = true;
	while(!Q.empty()){
		i = Q.front();
		//cout<<i<<endl;
		if(i == goib){
			break;
		}
		Q.pop();
		for(j = adj[i].size() - 1; j >= 0; j--){
			if(vis[adj[i][j]] == false){
				Q.push(adj[i][j]);
				vis[adj[i][j]] = true;
			}
		}
	}
	if(vis[goib] == true){
		cout<<"YAY MACHAU"<<endl;
	}
	else{
		cout<<"MAGGU FOREVER"<<endl;
	}
	return 0;
}

/*
5 9 1 1 5 5
1 2 2 2 3 2 4 2
2 4 3 4 4 4 5 4
3 3

5 8 1 1 5 5
1 2 2 2 3 2 4 2
2 4 3 4 4 4 5 4

1000000000 0 1000000000 1000000000 1 1

3 3 1 1 3 3
1 2 2 1 2 2

3 3 1 1 3 3
1 2 2 2 2 3
*/