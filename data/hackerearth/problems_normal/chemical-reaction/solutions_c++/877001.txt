#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <climits>
#include <cmath>
#include <cfloat>
#include <cstdio>
#include <functional>
#include <algorithm>

using namespace std;

class BinaryIndexedTree_1_indexed{
	void init(const vector<int> &A){
		for(int i=0; i<N; i++){
			add(i+1, A[i]);
		}
	}
	
public:
	vector<int> T;
	int N;
	
	BinaryIndexedTree_1_indexed(const int n) : T(n+1,0), N(n){
		
	}
	BinaryIndexedTree_1_indexed(const vector<int> &A) : T(A.size()+1,0), N(A.size()){
		init(A);
	}

	//caution : position "i" must be 1-indexed
	void add(int i, const int x){
		while(i <= T.size()){
			T[i] += x;
			i += i & -i;
		}
	}

	//get sums [0,i]
	int get_sum(int i){
		int ret=0;
		while(i>0){
			ret += T[i];
			i -= i & -i;
		}
		return ret;
	}

	//get sums [from,to]
	int get_sums_range(const int from, const int to){
		return get_sum(to) - get_sum(from-1);
	}

	//get at [i]
	int get_at(const int i){
		return get_sum(i) - get_sum(i-1);
	}

	void print(){
		for(int i=0; i<T.size(); i++){
			cerr << T[i] << " ";
		}
		cerr << endl;
	}
	
	int lower_bound(int val){
		if(val<=0) return 0;
		int x = 0;
		int k = 1;
		while((k<<1) <= N) k<<=1;
		
		for( ; k>0; k>>=1){
			if( x+k <= N && T[x+k] < val ){
				val -= T[x+k];
				x += k;
			}
		}
		return x+1;
	}

};

//(lb,ub]
int find_pos(BinaryIndexedTree_1_indexed &BIT, int val){
	int lb = 0;
	int ub = BIT.N;
	while(ub-lb>1){
		int mid = (lb+ub)/2;
		int x = BIT.get_sum(mid);
		if(val <= x){
			ub = mid;
		}else{
			lb = mid;
		}
	}
	return ub;
}

char s[500000+1][15];

int main(){
	int T;
	scanf("%d", &T);
	for(int q=0; q<T; ++q){
		int N;
		scanf("%d", &N);
		
		for(int i=0; i<N; ++i){
			scanf("%s", s[i]);
		}
		vector<int> t(N);
		for(int i=0; i<N; ++i){
			scanf("%d", &t[i]);
		}

		BinaryIndexedTree_1_indexed BIT(N);
		for(int i=0; i<N; ++i){
			BIT.add(i+1, 1);
		}

		int time = 0;
		
		for(int i=0; i<N-1; ++i){
			int x;
			scanf("%d", &x);

			//pos is 1-indexed
			int pos = BIT.lower_bound(x);
			
			time = max(time, t[pos-1]);
			printf("%s %d\n", s[pos-1], time);

			BIT.add(pos, -1);

		}
		int x = 1;
		int pos = find_pos(BIT, x);
		time = max(time, t[pos-1]);
		printf("%s %d\n", s[pos-1], time);
	}
	return 0;
}