#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef vector<long long> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
typedef pair<long long,long long> pii;
typedef vector<pii > vii;
typedef vector<pair<long long, pair<long long, long long> > > viii;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
typedef vector<vii> vvii;

#define pb push_back
#define mp make_pair
#define X first
#define Y second
#define MEM(a,b) memset(a,(b),sizeof(a))
#define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define all(a) a.begin(),a.end()
#define loop(x,a,b) for(long long (x) = (a);(x)<(b);(x)++)
#define rep(x,n)   for(long long (x)=0;(x)<(n);(x)++)
#define present(c,x) ((c).find(x) != (c).end()) 
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define ain(a,n) long long ((a)[(n)]); for(long long i=0; i<(n); i++) cin>>((a)[i])  
#define MAXN 200005


int md;


struct Matrix {
  vector<vector<long long> > mat;
  int n;
  Matrix(int n = 0, bool identity = false) : n(n)
  {
    mat.resize(n);
    for(int i=0; i<n; i++)  mat[i] = vector<long long> (n, 0);
    if(identity)  {
      for(int i=0; i<n; i++)
        mat[i][i] = 1;
    }
  }
  vector <long long>& operator[] (int i) { return mat[i]; }

 
  Matrix operator * (Matrix b)
  {
    Matrix ret(n);
    for(int i=0; i<n; i++)  {
      for(int j=0; j<n; j++)  {
        for(int k=0; k<n; k++)  {
          ret[i][j] += (*this)[i][k] * b[k][j];
          ret[i][j] += md;
          ret[i][j] %= md;
          // pr(ret[i][j]);
        }
      }
    }
    return ret;
  }
  Matrix operator + (Matrix x)
  {
    Matrix ret(n);
    for(int i=0; i<n; i++)  {
      for(int j=0; j<n; j++)  {
        ret[i][j] = (*this)[i][j] + x[i][j];
        if(ret[i][j] >= md)  {
          ret[i][j] -= md;
        }
        if(ret[i][j] < 0) {
          ret[i][j] += md;
        }
      }
    }
    return ret;
  }

  

  int operator == (Matrix x)
  {
    for(int i=0; i<n; i++)  
      for(int j=0; j<n; j++)  
        if((*this)[i][j] != x[i][j])
          return 0;

    return 1;
  }


  Matrix operator - (Matrix x)
  {
    Matrix ret(n);
    for(int i=0; i<n; i++)  {
      for(int j=0; j<n; j++)  {
        ret[i][j] = (*this)[i][j] - x[i][j];
        if(ret[i][j] >= md)  {
          ret[i][j] -= md;
        }
        if(ret[i][j] < 0) {
          ret[i][j] += md;
        }
      }
    }
    return ret;
  }

 

  // void print()
  // {
  //   prdd(mat,(mat).size(),(mat[0]).size());
  // }

   void operator = (Matrix x)
  {
    this->n = x.n;
    (this->mat).resize(n);
    for(int i=0; i<n; i++)  {
      (this->mat)[i] = x[i];
    }

  }

  void operator += (Matrix x)
  {
    for(int i=0; i<n; i++)  {
      for(int j=0; j<n; j++)  {
        (*this)[i][j] = (*this)[i][j] + x[i][j];
        if((*this)[i][j] >= md)  {
          (*this)[i][j] -= md;
        }
        if((*this)[i][j] < 0) {
          (*this)[i][j] += md;
        }
      }
    }
  }

};

Matrix power(Matrix a, long long p)
{
  int n = a.n;
  Matrix ret(n, true);
  while (p > 0)
  {
    if (p % 2 == 1) {
      ret = ret * a;
    }
    p /= 2;
    a = a * a;
  }
  return ret;
}

int arr[200100];
Matrix a[200100];
Matrix st[600100];
Matrix temp(2);


void update(ll node, ll l, ll r, ll id, Matrix val)
{
	ll mid = (l+r)/2;
	ll lc = 2*node + 1;
	ll rc = 2*node + 2;
	if(l==r)
	{
		st[node] = val;
		return;
	}
	if(id <= mid)
		update(lc,l,mid,id,val);
	else
		update(rc,mid+1,r,id,val);
	st[node] = st[lc]+st[rc];
}
 
Matrix query(ll node,ll l,ll r,ll s,ll e)
{
	ll mid = (l+r)/2;
	ll lc = 2*node + 1;
	ll rc = 2*node + 2;
	if(s==l and r == e)
		return st[node];
 
	if(e<=mid)
		return query(lc,l,mid,s,e);
	else if(s>mid)
		return query(rc,mid+1,r,s,e);
	else
		return query(lc,l,mid,s,mid)+query(rc,mid+1,r,mid+1,e);
}


// Driver program to test above functions
int main()
{
    ll n, m, type, l, r;
    md = 10;
    cin >> n >> m >> md;
     temp[0][0] = 0;
	temp[0][1] = 0;
	temp[1][0] = 0;
	temp[1][1] = 0;
    

      rep(i, 200005)
      {
      	a[i] = temp;
      }
      rep(i, 600005)
      {
      	st[i] = temp;
      }
    rep(i, n)
    {
    	cin >> arr[i];
    	arr[i]%=md;
    }

     Matrix x(2), tempx(2);
     x[0][0] = 1;
     x[0][1] = 1;
     x[1][0] = 1;
     x[1][1] = 0;

     a[0][0][0] = (arr[0]*x[0][0])%md;
	a[0][0][1] = (arr[0]*x[0][1])%md;
	a[0][1][0] = (arr[0]*x[1][0])%md;
	a[0][1][1] = 0;
     update(0, 0, n-1, 0, a[0]);
     tempx = x;
     loop(i, 1, n)
     {
     	a[i][0][0] = (arr[i]*x[0][0])%md;
     	a[i][0][1] = (arr[i]*x[0][1])%md;
     	a[i][1][0] = (arr[i]*x[1][0])%md;
     	a[i][1][1] = (arr[i]*x[1][1])%md;
     	update(0, 0, n-1, i, a[i]);
     	// tempx.print();
     	x = x*tempx;
     }
     Matrix inv(2);
     inv[0][0] = 0;
     inv[0][1] = 1;
     inv[1][0] = 1;
     inv[1][1] = -1;

     while(m--)
     {	
	    cin >> type >> l >> r;
	    if(type == 2)
	    {	
	    	Matrix ans(2);
	    	// ans[0][0] = 1;
		    ans = query(0, 0, n-1, l-1, r-1) * power(inv, l-1);
		    // ans.print();
		    cout << ans[0][0]%md << "\n";
	    }
	    else
	    {
	    	Matrix mul = power(tempx, l-1);
	    	mul[0][0] = (mul[0][0]*r)%md;
	    	mul[0][1] = (mul[0][1]*r)%md;
	    	mul[1][0] = (mul[1][0]*r)%md;
	    	mul[1][1] = (mul[1][1]*r)%md;
	    	update(0, 0, n-1, l-1, mul);
	    }
	    // ans.print();
     }


    return 0;
}