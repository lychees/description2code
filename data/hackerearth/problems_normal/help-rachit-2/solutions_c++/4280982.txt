#include<bits/stdc++.h>
using namespace std;
#define MAX 100000000
#define ld long double
bitset<MAX> lp;
inline long long mulmod(long long a,long long b,long long mod)
{
		long long x=0,y=a;

		while(b>0)
		{
				if(b & 1)
						x=(x+y)%mod;
				y=(y<<1)%mod;
				b>>=1;
		}
		return x;
}

long long modexp(long long a,long long b,long long mod)
{
		long long x=1,y=a;

		while(b>0)
		{
				if(b & 1)
						x=x*y%mod;
				y=y*y%mod;
				b>>=1;
		}
		return x;
}

inline bool Fermat(long long p,int iterations){
		if(p == 1){ // 1 isn't prime
				return false;
		}
		srand(time(NULL));
		for(int i=0;i<iterations;i++){
				// choose a random integer between 1 and p-1 ( inclusive )
				long long a = rand()%(p-1)+1; 
				// modulo is the function we developed above for modular exponentiation.
				if(modexp(a,p-1,p) != 1){ 
						return false; /* p is definitely composite */
				}
		}
		return true; /* p is probably prime */
}
void siever(void)
{
		int i,j;
		//pr = 0;
		for(i=2;i<MAX;++i)
		{
				if(lp[i] == 0)
				{
						//primes[pr++]=i;
						for(j=i+i;j<MAX;j+=i)
						{
								lp[j]=1;
						}
				}
		}
}
inline bool isp(int n)
{
		if(n < MAX) return lp[n] == 0;
		return Fermat(n,5);
}
ld res[10000];
void pre(void)
{
		cout<<fixed;
		cout<<setprecision(6);
		int n;
		int m;
		int a,b,c,d;
		int tot = 1;
		int ps = 0;
		ld num,den,ans;
		for(n=3;n<10000;n+=2)
		{
				m = (n+1)/2;
				a = (n-1)*(n-1)+1;
				b = 4*m*m - 10*m + 7;
				c = n*n;
				d = 4*m*m - 6*m + 3;
				tot+=4;
				if(isp(a)) ps++;
				if(isp(b)) ps++;
				if(isp(d)) ps++;
				//cout<<"a="<<a<<" b="<<b<<" c="<<c<<" d="<<d<<endl;
				//cout<<"ps="<<ps<<endl;
				num = ps;
				den = tot;
				ans = num/den;
				res[n]=ans*100.0;
				//cout<<"ps="<<ps<<" "<<res[n]<<endl;

		}
}
int main()
{
		ios_base::sync_with_stdio(false);
		siever();
		pre();
		//cout<<"done\n";
		cout<<fixed;
		cout<<setprecision(6);
		int t;
		cin>>t;
		while(t--)
		{
		  int n;
		  cin>>n;
		  cout<<res[n]<<endl;
		}

		return 0;
}


