

    #include <bits/stdc++.h>
    using namespace std ;
    #define LL long long int
    #define ft first
    #define sd second
    #define PII pair<int,int>
    #define MAXN 1000001
    #define mp make_pair
    #define f_in(st) freopen(st,"r",stdin)
    #define f_out(st) freopen(st,"w",stdout)
    #define sc(x) scanf("%d",&x)
    #define scll(x) scanf("%lld",&x)
    #define pr(x) printf("%d\n",x)
    #define pb push_back
    #define MOD 1000000007
    #define inf INT_MAX/2
    #define ASST(X,L,R) assert(X >= L && X <= R)
    int N,Q ;
    vector<int> A ;
    int power(int a,int b){
        int res = 1 ;
        while(b){
            if(b%2){
                res = (1LL * res * a) % MOD ;
            }
            b /= 2 ;
            a = (1LL * a * a) % MOD ;
        }
        return res ;
    }
    int less_than_X(int X){
        X -- ;
        int c = upper_bound(A.begin(),A.end(),X)-A.begin() ;
        return power(2,c) ;
    }
    int less_than_equals_to_X(int X){
        int c = upper_bound(A.begin(),A.end(),X)-A.begin() ;
        return power(2,c) ;
    }
    int main(){
        sc(N) ;
        sc(Q) ;
        ASST(N,1,500000) ;
        ASST(Q,1,500000) ;
        A.resize(N) ;
        for(int i=0;i<N;i++){
            sc(A[i]) ;
            ASST(A[i],1,1000000000) ;
        }
        sort(A.begin(),A.end()) ;
        char ch ;
        int X;
        int total_subsets = power(2,N) ;
        while(Q--){
            cin >> ch ;
            sc(X) ;
            assert(ch == '>' || ch == '<' || ch == '=') ;
            ASST(X,1,1000000000) ;
            int ans = 0 ;
            switch(ch){
                case '<' : pr(less_than_X(X)) ;
                            break ;
                case '>' : ans = less_than_equals_to_X(X) ;
                           ans = total_subsets - ans ;
                           if( ans < 0 )
                                ans += MOD ;
                           pr(ans) ;
                            break ;
                case '=' : ans = less_than_equals_to_X(X) ;
                           ans -= less_than_X(X) ;
                           if( ans < 0 )
                                ans += MOD ;
                           pr(ans) ;
                            break ;
            }
        }
        return 0 ;
    }

