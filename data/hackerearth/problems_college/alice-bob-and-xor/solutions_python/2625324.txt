'''
This problem is easily solved if pattern of XOR operations is observed carefully.
The function 'help_xor' calculates the XOR total run from [0,a], if we look at following
table of 4-bit numbers: 0000 -- 0  [a]
						0001 -- 1  [1]
						0010 -- 3  [a+1]
						0011 -- 0  [0]
						0100 -- 4  [a]
						0101 -- 1  [1]
						0110 -- 7  [a+1]
						0111 -- 0  [0]
						1000 -- 8  [a]
where the first column is binary representation and then the decimal result and its relation to
its index(a) into the XOR list. As all upper bits cancel and the lowest two bits cycle every 4.
So, for range[l,r]; we can use 'help_xor' to find XOR for [0,b] and [0,a-1]. Since any value XOR'd
to itself is 0, the 'help_xor(l-1)' just cancels out all the values in XOR run less than 'l',
leaving with the XOR of range[l,r].
'''

def help_xor(a):
    res = [a, 1, a + 1, 0]
    return res[a % 4]


for t in range(int(raw_input())):
    l, r = [int(x) for x in raw_input().split()]
    print(help_xor(r) ^ help_xor(l - 1))
