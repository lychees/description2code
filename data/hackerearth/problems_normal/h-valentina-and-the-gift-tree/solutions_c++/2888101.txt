#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
const int oo = 1e9 + 7;

int n, q, a[N], cost[N], cHead[N], pos[N], dist[N], chain[N], child[N];
struct Node{
    ll l, r, sum, best;
    Node() {};
    Node(ll L, ll R, ll Sum, ll Best) {
        l = L, r = R, sum = Sum, best = Best;
    }
} node[N*4];
int anc[N][20], c, base;
vector<int> e[N];

void dfs(int u, int prev){
    child[u] = 1;
    for (int i = 0; i < e[u].size(); ++i){
        int v = e[u][i];
        if (v != prev){
            anc[v][0] = u;
            dist[v] = dist[u] + 1;
            dfs(v, u);
            child[u] += child[v];
        }
    }
}

void hld(int u, int prev, int val){
    if (cHead[c] == -1) cHead[c] = u;
    chain[u] = c;
    cost[base] = val;
    pos[u] = base++;
    int next = -1;
    for (int i = 0; i < e[u].size(); ++i){
        int v = e[u][i];
        if (v != prev && (next == -1 || child[v] > child[next]))
            next = v;
    }
    if (next != -1) hld(next, u, a[next]);
    for (int i = 0; i < e[u].size(); ++i){
        int v = e[u][i];
        if (v != prev && v != next) ++c, hld(v, u, a[v]);
    }
}

Node combine(Node L, Node R){
    ll l = L.l;
    ll r = R.r;
    ll s = L.sum + R.sum;
    l = max(l, L.sum + R.l);
    r = max(r, R.sum + L.r);
    ll b = max(L.best, max(R.best, L.r + R.l));
    return Node(l, r, s, b);
}

void build(int id, int left, int right){
    if (left == right){
        node[id] = Node(cost[left],cost[left],cost[left],cost[left]);
        return;
    }
    int mid = (left + right) >> 1;
    build(id*2, left, mid);
    build(id*2+1, mid+1, right);
    node[id] = combine(node[id*2], node[id*2+1]);
}

Node get(int id, int left, int right, int u, int v){
//    cout << left << ' '<< right << ' ' << u << ' ' << v << endl;
    if (u <= left && right <= v)
        return node[id];
    int mid = (left + right) >> 1;
    if (mid >= v) return get(id*2, left, mid, u, v);
    if (mid < u) return get(id*2+1, mid+1, right, u, v);
    Node l = get(id*2, left, mid, u, v);
    Node r = get(id*2+1, mid+1, right, u, v);
    return combine(l, r);
}

Node hldq(int lo, int hi, bool ok){
//    cout << pos[lo] << ' ' << pos[hi] << endl;
//    cout << lo << ' ' << hi << endl;
    Node ans = Node(-oo, -oo, -oo, -oo);
    bool init = true;
    int head = cHead[chain[hi]];
    while (1){
        int curHead = cHead[chain[lo]];

        if (curHead == head){
//            cout << "ok2" << ' ' << lo << ' ' << hi << ' ' << ans.l << ' ' << ans.r << endl;
//            cout << pos[hi] + 1 << ' ' << pos[lo] << endl;
            if (!ok && pos[hi] + 1 <= pos[lo]) {
                if (init) ans = get(1, 0, n - 1, pos[hi] + 1, pos[lo]), init = false;
                else ans = combine(get(1, 0, n - 1, pos[hi] + 1, pos[lo]), ans);
            }
            else if (ok) {
                if (init) ans = get(1, 0, n - 1, pos[hi], pos[lo]), init = false;
                else ans = combine(get(1, 0, n - 1, pos[hi], pos[lo]), ans);
            }
            break;
        }
//        cout << "ok" << endl;
//        cout << curHead << ' ' << lo << ' ' << ans.best  << endl;
        if (!ok) {
            if (init) ans = get(1, 0, n - 1, pos[curHead], pos[lo]), init = false; else
            ans = combine(get(1, 0, n - 1, pos[curHead], pos[lo]), ans);
        }
        else {
            if (init) ans = get(1, 0, n - 1, pos[curHead], pos[lo]), init = false; else
            ans = combine(get(1, 0, n - 1, pos[curHead], pos[lo]), ans);
        }
        lo = anc[curHead][0];
//        cout << anc[1][0] << "ok" << endl;
    }
//    cout << ans.l << ' ' << ans.r << endl;
//    cout << ans.l << ' ' << ans.r << endl;
    return ans;
}

int lca(int u, int v){
    if (dist[u] > dist[v]) swap(u, v);
    for (int i = 17; i >= 0; --i)
        if (dist[v] - dist[u] >= 1 << i) v = anc[v][i];
    if (u == v) return u;
    for (int i = 17; i >= 0; --i)
        if (anc[v][i] != anc[u][i]){
            v = anc[v][i];
            u = anc[u][i];
        }
    return anc[u][0];
}

Node query(int u, int v){
//    cout << u << ' ' << v << endl;
    int an = lca(u, v);
    Node ans1 = hldq(u, an, 0);
    swap(ans1.l, ans1.r);
//    cout << ans1.l << ' ' << ans1.r << ' ' << ans1.best << ' ' << ans1.sum << endl;
    Node ans2 = hldq(v, an, 1);
//    cout << ans2.l << ' ' << ans2.r << ' ' << ans2.best << ' ' << ans2.sum << endl;
    return combine(ans1, ans2);
}

int main(){
//    ios_base::sync_with_stdio(false);
//    freopen("input.txt", "r", stdin);
//    freopen("output.txt", "w", stdout);
    scanf("%d", &n);
    for (int i = 1; i < n; ++i){
        int u, v; scanf("%d%d", &u, &v);
        --u, --v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for (int i = 0; i < n; ++i)
        scanf("%d", &a[i]), cHead[i] = -1;
    dfs(0, 0);
    hld(0, 0, a[0]);
    for (int i = 1; i < 18; ++i)
        for (int j = 0; j < n; ++j)
            anc[j][i] = anc[anc[j][i-1]][i-1];
//    for (int i = 0; i < n; ++i) cout << cost[i] << ' '; cout << endl;
//    cout << endl;
    build(1, 0, n - 1);
//    cout << get(1, 0, n - 1, 3, 4).best << endl;
    scanf("%d", &q);
//    cout << q << endl;
    for (int i = 0; i < q; ++i){
        int u, v;
        scanf("%d%d", &u, &v);
        printf("%lld\n", query(u - 1, v - 1).best);
    }
//    cout << get(1, 0, n - 1, 0, 1).best << endl;
//    cout << cost[4] << endl;
//    for (int i = 0; i < n; ++i)
//        cout << pos[i] << ' ';
//    cout << endl;
//    for (int i = 0; i < n; ++i)
//        cout << cost[i] << ' ';
//    cout << endl;
//    for (int i = 0; i < n; ++i)
//        cout << cost[i] << ' ';
//    cout << pos[3] << ' ' << pos[4] << endl;
//    cout << hldq(1, 0, 1).r << endl;
}
