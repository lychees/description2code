 //You are weak? Why? Because You lack Hatred. - Itachi
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <list>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <queue>
#include <set>
using namespace std;

#define MAX 200005
#define MAXN 100005
#define MOD 1000000007
#define INF 1e9

int bit[MAXN];

#define MOD 1000000007
long long power(long long n, long long m)
{
    if(m==0) return 1;
    long long x=power(n,m/2);
    if(m%2==0) return (x*x)%MOD;
    else return (((x*x)%MOD)*n)%MOD;
}

int query(int indx)
{
    int sum = 0;
    while (indx) {
        sum += bit[indx];
        indx -= (indx & -indx);
    }
    return sum;
}

void update(int indx, int x)
{
    while (indx < MAXN) {
        bit[indx] += x;
        indx += (indx & -indx);
    }
}

int main()
{
    memset(bit, 0, sizeof(bit));
    int n;
    scanf("%d", &n);
    int a[MAX];
    for (int i = 1; i <= 2*n; i++){
        scanf("%d", &a[i]);
    }
    if (n == 1) {
        printf("1\n");
        return 0;
    }
    long long multiplier1 = power(2, n-2);
    long long answer = 0;
    for (int i = 1; i <= 2*n; i++) {
        int lessElements = query(a[i]-1);
        int equalElements = query(a[i]) - query(a[i]-1) ;
        int greaterElements = (i-1) - lessElements - equalElements;
        answer += (lessElements * 1);
        answer %= MOD;
        answer += (greaterElements * 3);
        answer %= MOD;
        answer += (equalElements * 2);
        answer %= MOD;
        update(a[i], 1);
    }
    answer *= multiplier1;
    answer %= MOD;
    printf("%d\n", answer);
}
