#pragma comment(linker, "/STACK:102400000,102400000")
#include <iostream>
#include <algorithm>
#include <stdio.h>
#include <string.h>
#include <vector>
#include <map>
#include <assert.h>
#include <cmath>
#include <queue>
#include <set>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
#define all(x) x.begin(),x.end()
#define SZ(x) (int)(x.size())
#define rep(i,a,b) for(int i=a;i<b;i++)
#define per(i,a,b) for(int i=b-1;i>=a;i--)
#define inf 1000000007
#define mod 1000000007
#define x first
#define y second
#define pi acos(-1.0)
#define DBG(x) cerr<<(#x)<<"="<<x<<"\n";
//#define dprintf(...) 
#define hash _hash
//#define dprintf(...) fprintf(outFile,__VA_ARGS__)
 
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)
#define ull unsigned long long
#define ll long long
#define N 500010


template <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}
template <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}
 
//FILE* outFile;
 
inline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}


int pow(int a,int b){
    int ans=1;
    while(b){
        if(b&1)ans=ans*(ll)a%mod;
        a=(ll)a*a%mod;b>>=1;
    }
    return ans;
}

int cnt,st[N],ed[N],d[N],top[N],tot,root[N],f[N],ch[N];
vi g[N];
ll a[N];
void dfs1(int u){
    f[u]=1;
    FOREACH(it,g[u]){
        int j=*it;
        d[j]=d[u]+1;
        dfs1(j);
        if(ch[u]==0||f[ch[u]]<f[j])ch[u]=j;
        f[u]+=f[j];
    }
}
void dfs(int u,int fa,int p){
    st[u]=++cnt;top[u]=p;f[u]=fa;
    if(ch[u])dfs(ch[u],u,p);
    FOREACH(it,g[u]){
        int j=*it;
        if(j!=ch[u])dfs(j,u,j);
    }
    ed[u]=cnt;
}

struct node{
    int l,r;
    ll s,c;
    void init(){
        l=r=s=c=0;
    }
}t[N*18];
int build(int l,int r){
    int q=++tot;t[q].init();
    if(l==r)return q;
    int m=(l+r)>>1;
    t[q].l=build(l,m);
    t[q].r=build(m+1,r);
    return q;
}
void up(int p){
    t[p].s=t[t[p].l].s+t[t[p].r].s;
    t[p].c=t[t[p].l].c+t[t[p].r].c;
}
ll ans,ans1;
int upd(int p,int l,int r,int x,ll v1,int v2){
    int q=++tot;t[q]=t[p];
    if(l==r){
        t[q].s+=v1,t[q].c+=v2;
        return q;
    }
    int m=(l+r)>>1;
    if(x<=m)t[q].l=upd(t[p].l,l,m,x,v1,v2);
    else t[q].r=upd(t[p].r,m+1,r,x,v1,v2);
    up(q);
    return q;
}
void query(int p,int l,int r,int x,int y){
    if(l>=x&&r<=y){
        ans+=t[p].s;
        ans1+=t[p].c;
        return;
    }
    int m=(l+r)>>1;
    if(x<=m)query(t[p].l,l,m,x,y);
    if(y>m)query(t[p].r,m+1,r,x,y);
}
int rt,n;
void query(int x){
    int y;
    while(top[x]!=0){
        query(root[rt],1,n,st[top[x]],st[x]);
        x=f[top[x]];
    }
    query(root[rt],1,n,st[0],st[x]);
}
int main(){
    //freopen("A.in","r",stdin);
    //freopen("A.out","w",stdout);
    int j,k,i,ca=0,T,m;
    scanf("%d%d",&n,&m);
    rep(i,1,n){
        scanf("%d",&j);j--;
        g[j].pb(i);
    }
    dfs1(0);
    dfs(0,0,0);
    rep(i,0,n)g[i].clear();
    rep(i,0,n)scanf("%d",&j),j--,g[j].pb(i);
    rep(i,0,m)scanf("%lld",&a[i]);
    root[0]=build(1,n);
    int Q;
    scanf("%d",&Q);
    rep(i,0,Q){
        int D,x;
        scanf("%d%d%d",&j,&x,&D);j--;
        root[i+1]=upd(root[i],1,n,st[j],x-1LL*d[j]*D,D);
    }
    rep(i,0,m){
        int l=1,r=Q;
        while(l<=r){
            int x=(l+r)>>1;
            ll sum=0;rt=x;
            FOREACH(it,g[i]){
                ans=0,ans1=0;
                query(*it);
                sum+=ans+1LL*d[*it]*ans1;
                if(sum>=a[i])break;
            }
            //cerr<<x<<" "<<sum<<"\n";
            if(sum>=a[i])r=x-1;
            else l=x+1;
        }
        if(r+1<=Q)printf("%d\n",r+1);
        else puts("rekt");
    }
    //cerr<<1.*clock()/CLOCKS_PER_SEC<<"s\n";
    return 0;
}