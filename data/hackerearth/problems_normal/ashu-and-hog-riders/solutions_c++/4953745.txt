/*	I will not win immediately,
 *	but I will win definitely...
 */
#include<bits/stdc++.h>
#define opt				ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define li				long int
#define lli				long long int
#define sd(n)				scanf("%d",&n)
#define sld(n)				scanf("%ld",&n)
#define slld(n)				scanf("%lld",&n)
#define pd(n)				printf("%d\n",n)
#define pld(n)				printf("%ld\n",n)
#define plld(n)				printf("%lld\n",n)
#define pn                  printf("\n")
#define rep(i,a,b)			for(i=a;i<b;i++)
#define repr(i,a,b)			for(i=a;i>b;i--)
#define repi(i,v)			for(i=v.begin();i!=v.end();i++)
#define vi				vector<int>
#define vli				vector<li>
#define vlli				vector<lli>
#define pb				push_back
#define pob				pop_back
#define all(v)				v.begin(),v.end()
#define sz				size()
#define lb				lower_bound
#define ub				upper_bound
#define elif				else if
#define mp				make_pair
#define pa				pair<int,int>
#define vpp				vector<pair<li,li> >
#define F				first
#define S				second
#define mod				1000000007
#define itr				iterator
using namespace std;
li power(li a, li b){
		li ans=1L;
		while(b){
				if(b&1)
						ans=(ans*a)%mod;
                a=(a*a)%mod;
                b>>=1;
		}
		return ans;
}
li mmi(li n){
		return power(n,mod-2);
}
/**************************MAIN CODE BEGINS NOW!**************************/

int adj[1002][1002];
int visited[1002][1002];
int nodes;

void bfs(int a, int b){
        queue<pa > q;
        q.push(mp(a,b));
        visited[a][b]=1;
        nodes++;
        int i,j;
        while(!q.empty()){
                int x=q.front().F;
                int y=q.front().S;
                q.pop();
                rep(i,-1,2){
                        if(!visited[x+i][y] && adj[x+i][y]){
                                nodes++;
                                visited[x+i][y]=1;
                                q.push(mp(x+i,y));
                        }
                }
                rep(i,-1,2){
                        if(!visited[x][y+i] && adj[x][y+i]){
                                nodes++;
                                visited[x][y+i]=1;
                                q.push(mp(x,y+i));
                        }
                }
        }
}

int main(){
        int i,j,n;
        sd(n);
        memset(adj,0,sizeof(adj));
        memset(visited,0,sizeof(visited));
        rep(i,1,n+1){
                rep(j,1,n+1)
                        sd(adj[i][j]);
        }
        int ans=INT_MIN;
        rep(i,1,n+1){
                rep(j,1,n+1){
                        if(!visited[i][j] && adj[i][j]==1){
                                nodes=0;
                                bfs(i,j);
                                ans=max(nodes,ans);
                        }
                }
        }
        pd(ans);
        return 0;
}
