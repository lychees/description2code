#include <iostream>

using namespace std;
typedef long long LL;
#define MOD 1000003

class MATRIX{

public:
	LL M[4][4] = {{0}};
	void reset();
	MATRIX mult(MATRIX);
	MATRIX mpow(LL);
	void print();
};

MATRIX I;

void MATRIX::reset(){

	for(int i=0; i<4; i++){
		M[0][i]=1;
		if(i!=0) M[1][i]=1;
	}
	M[2][1]=1;
	M[3][2]=1;
}
void MATRIX::print(){

	for(int i=0; i<4; i++){
		for(int j=0; j<4; j++) cout << M[i][j] << " ";
		cout << endl;
	}
}

MATRIX MATRIX::mult(MATRIX S){

	MATRIX H;
	for(int i=0; i<4; i++){
		for(int j=0; j<4; j++){
			for(int k=0; k<4; k++){
				H.M[i][j]+=M[i][k]*S.M[k][j];
				H.M[i][j] = (H.M[i][j]%MOD);	
			}		
		}
	}
	return H;
}
MATRIX MATRIX::mpow(LL n){

	if(n==0) { return I;}
	if(n==1) return *this;
	
	MATRIX H = mpow(n/2);
	
	if(n%2==0) return H.mult(H);
	else return (H.mult(H)).mult(*this);
}

int main()
{

	int T;
	cin >> T;
	
	while(T--){
	
		LL a,b,c,n;
		cin >> a >> b >> c >> n;
		
		if(n == 1) cout << a % MOD << endl;
		else if(n == 2) cout << (a+b)%MOD << endl;
		else if(n == 3) cout << (a+b+c)%MOD << endl;
		else{
			
				LL sum = (((a+b)%MOD)+c)%MOD;
				MATRIX G;
				G.reset();
				MATRIX A = G.mpow(n-3);
				LL ans = ( (A.M[0][0]*sum)%MOD + (A.M[0][1]*c)%MOD + (A.M[0][2]*b)%MOD + (A.M[0][3]*a)%MOD) % MOD;
				cout << ans << endl;
		}			
	}
    return 0;
}
