#include <iostream>                                                             //kruskal algo for maximum spanning tree
#include<bits/stdc++.h>
using namespace std;
long n,m;
vector<pair<long,pair<long,long> > > adj;
long p[5200];
bool comp(pair<long,pair<long,long> > a,pair<long,pair<long,long> > b)
{
    if(a.first>b.first)
        return true;
    else
        return false;
}
long root(long a)
{
    while(a!=p[a])
    {
        p[a]=p[p[a]];
        a=p[a];
    }
    return a;
}
void unionop(long a,long b)
{
    long lp=root(a);
    long rp=root(b);
    p[lp]=rp;
}
long long kruskal()
{
    long long ans=0;
    long cost,a,b,i;
    pair<long,pair<long,long> > pa1,pa2;
    for(i=0;i<m;i++)
    {
        pa1=adj[i];
        cost=pa1.first;
        a=pa1.second.first;
        b=pa1.second.second;
        if(root(a)==root(b))
            continue;
        else
        {
            ans=ans+cost;
            unionop(a,b);
        }
    }
    return ans;
}
int main()
{
    int te;
    long i,a,b,c;
    long long ans;
    pair<long,long> pa;
    scanf("%d",&te);
    while(te--)
    {
        scanf("%ld %ld",&n,&m);
        adj.clear();
        for(i=1;i<=n;i++)
            p[i]=i;
        for(i=0;i<m;i++)
        {
            scanf("%ld %ld %ld",&a,&b,&c);
            pa=make_pair(a,b);
            adj.push_back(make_pair(c,pa));
        }
        sort(adj.begin(),adj.end(),comp);
        ans=kruskal();
        printf("%lld\n",ans);
    }
    return 0;
}
