#include <bits/stdc++.h>
using namespace std;

#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)
#define FILL(A,val) memset(A,val,sizeof(A))
#define ITER(it,a) for(__typeof(a.begin()) it=a.begin();it!=a.end();++it)
#define DBG1(a) cerr<<#a<<"="<<(a)<<"\n"
#define DBG2(a,b) cerr<<#a<<"="<<(a)<<", "<<#b<<"="<<(b)<<"\n"

#define ALL(V) V.begin(),V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair

typedef long long LL;
typedef unsigned long long ULL;
typedef vector<int> VI;
typedef pair<int, int> PII;

const double PI = acos(-1.0);
const int INF = 1000 * 1000 * 1000 + 7;
const LL LINF = 1LL * INF * INF;

const int MAX = 100005;
bool mark[MAX];

int sz[MAX];

vector<PII> g[MAX];
VI centr[MAX];
VI dCentr[MAX];
VI mx[MAX];
multiset<int> vals[MAX];

void dfsSZ(int v,int p,int c,int h)
{
	sz[v] = 1;
	if(c!=-1)
	{
		centr[v].PB(c);
		dCentr[v].PB(h);
	}

	FOR(i,0,SZ(g[v]))
	{
		int to = g[v][i].first;
		if(to == p) continue;
		if(mark[to])continue;
		dfsSZ(to,v,c,max(h,g[v][i].second));

		sz[v] += sz[to];
	}
}


void build(int v,int pr,int ed)
{
	//cerr<<v<<endl;
	dfsSZ(v,v,pr,ed);

	int szAll = sz[v];
	int p = v;
	while(true)
	{
		int w=-1;
		FOR(i,0,SZ(g[v]))
		{
			int to = g[v][i].first;
			if(to == p || mark[to])continue;
			if(sz[to]*2>szAll)w=to;
		}
		if(w == -1)break;
		p = v;
		v = w;
	}

	mark[v] = true;
	centr[v].PB(v);
	dCentr[v].PB(0);

	FOR(i,0,SZ(g[v]))
	{
		int to = g[v][i].first;
		if(!mark[to])
		{
			build(to,v,g[v][i].second);
		}
	}
}

void upd(int v,bool add)
{
	FOR(i,0,SZ(centr[v]))
	{
		int val = dCentr[v][i];
		int c = centr[v][i];

		if(add)
		{
			vals[c].insert(val);
		}
		else
		{
			vals[c].erase(vals[c].find(val));
		}
	}
}

int get(int v)
{
	int ans = INF;
	FOR(i,0,SZ(centr[v]))
	{
		int c = centr[v][i];
		if(vals[c].size())
		{
			ans = min(ans,max(*vals[c].begin(),dCentr[v][i]));
		}
	}
	if(ans == INF)ans = -1;
	return ans;
}

vector<pair<int,PII> > e;

struct DSU
{
	int p[MAX];
	int sz[MAX];

	void init(int n)
	{
		FOR(i,0,n)p[i]=i,sz[i]=1;
	}

	int get(int x)
	{
		return x==p[x]?x:p[x]=get(p[x]);
	}

	bool unite(int a,int b)
	{
		a=get(a);
		b=get(b);
		if(a==b)return 0;

		if(sz[a]<sz[b])swap(a,b);

		sz[a]+=sz[b];
		p[b]=a;

		return true;
	}
} dsu;
int main() {
	//freopen("in.txt","r",stdin);
	ios::sync_with_stdio(0);cin.tie(0);

	int n,m;
	cin>>n>>m;
	dsu.init(n);
	FOR(i,0,m)
	{
		int a,b,c;
		cin>>a>>b>>c;
		--a;--b;
		e.PB(MP(c,MP(a,b)));
	}
	sort(ALL(e));
	FOR(i,0,m)
	{
		int a = e[i].second.first;
		int b = e[i].second.second;
		int c = e[i].first;

		if(dsu.unite(a,b))
		{
			g[a].PB(MP(b,c));
			g[b].PB(MP(a,c));
		}
	}

	FOR(i,0,n)
		if(!mark[i])
			build(i,-1,-1);

	/*FOR(i,0,n)
	{
		cerr<<i<<": ";
		FOR(j,0,SZ(centr[i]))
		{
			cerr<<centr[i][j]<<" "<<dCentr[i][j]<<"; ";
		}
		cerr<<endl;
	}*/
	int q;
	cin>>q;
	FOR(i,0,q)
	{
		char t;
		int v;
		cin>>t>>v;
		--v;
		if(t == '+')
		{
			upd(v,1);
		}
		else if(t=='-')
		{
			upd(v,0);
		}
		else //?
		{
			cout<<get(v)<<"\n";
		}
	}

	return 0;
}
