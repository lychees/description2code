//Kyokai no Kanata //
#include<bits/stdc++.h>

using namespace std;

typedef long long int LL;
typedef pair<LL,LL> II;
typedef vector<II> VII;
typedef vector<int> VI;
typedef vector< VI > VVI;

#define PB push_back
#define MP make_pair
#define F first
#define S second
#define SZ(a) (int)(a.size())
#define ALL(a) a.begin(),a.end()
#define SET(a,b) memset(a,b,sizeof(a))

#define si(n) scanf("%d",&n)
#define dout(n) printf("%d\n",n)
#define sll(n) scanf("%lld",&n)
#define lldout(n) printf("%lld\n",n)
#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)

#define TRACE

#ifdef TRACE
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)
template <typename Arg1>
void __f(const char* name, Arg1&& arg1){
  cerr<<name<<" : "<<arg1<<endl;
}
template <typename Arg1, typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
  const char* comma=strchr(names+1,',');
  cerr.write(names,comma-names)<<" : "<<arg1<<" | ";__f(comma+1,args...);
}
#else
#define trace(...)
#endif
LL INF=std::numeric_limits<LL>::max();
char SV[10005];
VI PP,PN[10005];
LL DP[2002][10002];
void sieve(int M)
{
  for(int i=2;i*i<=M;i++)
    if(!SV[i])
      for(int j=i*i;j<=M;j+=i)
        SV[j]=1;
  for(int i=2;i<=M;i++)
    if(!SV[i]) PP.PB(i);
  for(int i=2;i<=M;i++)
    for(auto p:PP)
      if(!(i%p)){
        PN[p].PB(i);
        break;
      }
}
LL P,Q,R,X,Y,Z,S,W;
LL A[10005],B[10005];
void input(int M)
{
  LL m=1000000003; 
  for(int i = 0; i < M; i++){
    S = (((P * ((S * S)%m))%m) +(( Q * S)%m) + R)%m;
      A[i + 1] = S;
  }
  for(int i = 0; i < M; i++){
    W = (((X *(( W * W)%m))%m) + ((Y * W)%m) + Z)%m;
      B[i + 1] = W;
  }
}
II minpair(int p,int i)
{
  II ret=MP(INF,INF);
  for(auto v:PN[p])
  {
    if(ret.F>=DP[i][v]+B[v])
      ret.S=ret.F,ret.F=DP[i][v]+B[v];
    else if(ret.S>DP[i][v]+B[v])
      ret.S=DP[i][v]+B[v];
  }
  return ret;
}
int main()
{
  int N,M,i,j;si(N);si(M);
  sieve(M);
  scanf("%lld %lld %lld %lld",&S,&P,&Q,&R) ;   
  scanf("%lld %lld %lld %lld",&W,&X,&Y,&Z) ;  
  for(i=1;i<N;i++)
  {
    input(M);
    DP[i+1][1]=DP[i][1]+A[1];
    for(j=2;j<=M;j++)
      DP[i+1][1]=min(DP[i+1][1],DP[i][j]+B[j]);
    for(auto p:PP)
    {
      II ret=minpair(p,i);
      for(auto v:PN[p])
      {
        if(ret.F==DP[i][v]+B[v])
          DP[i+1][v]=min(DP[i][v]+A[v],ret.S);
        else
          DP[i+1][v]=min(DP[i][v]+A[v],ret.F);
      }
    }
  }
  LL ans=INF;
  for(i=1;i<=M;i++)
    ans=min(ans,DP[N][i]);
  lldout(ans);
  return 0;
}

