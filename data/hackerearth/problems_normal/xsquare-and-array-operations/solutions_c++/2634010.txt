#include<bits/stdc++.h>
#define sc(n) scanf("%d",&n);
#define pr(n) printf("%lld\n",n);
#define ll long long
#define pii pair<int,int>
#define ft first
#define sd second
#define mp make_pair
using namespace std;
int arr[100001],a[262145][2];
void build_tree(int p,int r,int node)
{
    int q=(p+r)/2,n=node*2;
    if(p==r)
    {
        a[node][0]=arr[p];
        a[node][1]=p;
        return ;
    }
    build_tree(p,q,n+1);
    build_tree(q+1,r,n+2);
    if(a[n+1][0] > a[n+2][0])
    {
        a[node][0]=a[n+1][0];
        a[node][1]=a[n+1][1];
    }
    else
    {
        a[node][0]=a[n+2][0];
        a[node][1]=a[n+2][1];
    }
}
void query_tree(int p,int r,int i,int j,int node,pii & pr)
{
    int q=(p+r)/2,n=node*2;
    if(i>r || j<p)
        return ;
    if(p>=i && r<=j)
    {
        if((pr.ft == -1) || (pr.ft < a[node][0]))
        {
            pr=mp(a[node][0],a[node][1]);
        }
        return ;
    }
    query_tree(p,q,i,j,n+1,pr);
    query_tree(q+1,r,i,j,n+2,pr);
}
ll int solve(int p,int r,int n)
{
    ll int r1,r2;
    pii x (-1,0);
    if(p>r)
        return -1;
    if(p==r)
        return 0;
    query_tree(0,n-1,p,r,0,x);
    r1=solve(p,x.sd-1,n);
    //cout<<x.sd<<' '<<arr[x.sd]<<endl;
    if(r1!=-1)
        r1+=arr[x.sd];
    else
        r1=0;
    r2=solve(x.sd+1,r,n);
    if(r2!=-1)
        r2+=arr[x.sd];
    else
        r2=0;
    return r1+r2;
}
int main()
{
    int t,n;
    sc(t);
    while(t--)
    {
        sc(n);
        for(int i=0;i<n;i++)
            sc(arr[i]);
        build_tree(0,n-1,0);
        pr(solve(0,n-1,n));
    }
    return 0;
}
