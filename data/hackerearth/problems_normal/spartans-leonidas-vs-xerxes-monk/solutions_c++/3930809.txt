#include <bits/stdc++.h>
using namespace std;
int lft(int x){
	return x*2+1;
}
int ryt(int x){
	return x*2+2;
}
int tree[3][2000005];
long long arr[100005];
struct lol{
	int a,b,c;	
};
void build(int x,int l,int r){
	if(l == r){
		tree[0][x] = tree[1][x] = tree[2][x] = 1;
	}else{
		int mid = (l+r)/2;
		build(lft(x),l,mid);
		build(ryt(x),mid+1,r);
		int &a1 = tree[0][lft(x)],b1 = tree[1][lft(x)],c1 = tree[2][lft(x)];
		int &a2 = tree[0][ryt(x)],b2 = tree[1][ryt(x)],c2 = tree[2][ryt(x)];
		tree[0][x] = a1;
		tree[1][x] = b2;
		tree[2][x] = 0;
		if( arr[mid] < arr[mid+1] && a1 == mid-l+1)tree[0][x] = a1+a2;
		if( arr[mid] < arr[mid+1] && b2 == r-mid)tree[1][x] = b2+b1;
		if( arr[mid] < arr[mid+1] )tree[2][x] = b1 + a2;
		tree[2][x] = max(tree[2][x],max(tree[0][x],tree[1][x]));
		tree[2][x] = max(tree[2][x],max(c1,c2));
	}
}
void update(int x,int l,int r,int ind){
	if(l == r){
		tree[0][x] = 1;
		tree[1][x] = 1;
		tree[2][x] = 1;
	}else{
		
		int mid = (l+r)/2;
		if(mid >= ind)update(lft(x),l,mid,ind);
		else update(ryt(x),mid+1,r,ind);
		
		int &a1 = tree[0][lft(x)],&b1 = tree[1][lft(x)],&c1 = tree[2][lft(x)];
		int &a2 = tree[0][ryt(x)],&b2 = tree[1][ryt(x)],&c2 = tree[2][ryt(x)];
		tree[0][x] = a1;
		tree[1][x] = b2;
		tree[2][x] = 0;
		if( arr[mid] < arr[mid+1] && a1 == mid-l+1)tree[0][x] = a1+a2;
		if( arr[mid] < arr[mid+1] && b2 == r-mid)tree[1][x] = b2+b1;
		if( arr[mid] < arr[mid+1] )tree[2][x] = b1 + a2;
		tree[2][x] = max(tree[2][x],max(tree[0][x],tree[1][x]));
		tree[2][x] = max(tree[2][x],max(c1,c2));
	}
}
lol query(int x,int l,int r,int a,int b){
	if(l > b || r < a)return {0,0,0};
	if(l == r){
		return {1,1,1};
	}else if(l >= a && r <= b){
		return {tree[0][x], tree[1][x], tree[2][x]};
	}else{
		
		int mid = (l+r)/2;
		lol l1 = query(lft(x),l,mid,a,b);
		lol l2 = query(ryt(x),mid+1,r,a,b);
		if(l1.a == 0)return l2;
		if(l2.a == 0)return l1;
		//cout << l << " " << r << " " << a1 << " " << b1 << " " << a2 << " " << b2<<endl;
		lol l3 = {l1.a,l2.b,0};
		if( arr[mid] < arr[mid+1] && l1.a == mid-max(l,a)+1)l3.a = l1.a+l2.a;
		if( arr[mid] < arr[mid+1] && l2.b == r-min(mid+1,b)+1)l3.b = l2.b+l1.b;
		if( arr[mid] < arr[mid+1] )l3.c = l1.b + l2.a;
		l3.c = max(l3.c,max(l3.a,l3.b));
		l3.c = max(l3.c,max(l1.c,l2.c));
		return l3;
	}
}
int main()
{
	int n,q;
	int T;
	cin >> T;
	while(T--){
		scanf("%d%d",&n,&q);
		for(int i = 0 ; i < n ; i++){
			scanf("%lld",&arr[i]);
		}
		build(0,0,n-1);
		while(q--){
			int c,l,r;
			scanf("%d%d%d",&c,&l,&r);
			if(c){
				arr[l-1] += r;
				update(0,0,n-1,l-1);
			}else{
				printf("%d\n",query(0,0,n-1,l-1,r-1).c);
			//	cout << query(0,0,n-1,1,2).a<<endl;
			//	cout << query(0,0,n-1,1,2).b<<endl;
			}
		}
	}
    return 0;
}
