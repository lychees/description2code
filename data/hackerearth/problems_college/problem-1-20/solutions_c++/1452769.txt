#include <iostream>
#include <vector>
#include <cstdio>
#include <sstream>
#include <map>
#include <string>
#include <algorithm>
#include <queue>
#include <cmath>
#include <set>
#include "assert.h"
using namespace std;

#define EPS 1e-6

class xy{
	
public:
	double x;
	double y;

	xy(){

	}
	
	xy(double xx, double yy){
		x = xx;
		y = yy;
	}

	xy(const xy &v){
		x = v.x;
		y = v.y;
	}

	xy& operator=(const xy &v){
		x = v.x;
		y = v.y;
		return *this;
	}

	xy operator+(const xy &v) const{
		return xy(this->x+v.x, this->y+v.y);
	}
	xy operator+(const double &v) const{
		return xy(this->x+v, this->y+v);
	}
	
	xy operator-(const xy &v) const{
		return xy(this->x-v.x, this->y-v.y);
	}
	
	xy operator-(const double &v) const{
		return xy(this->x-v, this->y-v);
	}
	
	void operator+=(const xy &v){
		x+=v.x;
		y+=v.y;
	}
	void operator-=(const xy &v){
		x-=v.x;
		y-=v.y;
	}
	bool operator<(const xy &v) const{
		if(x!=v.x) return x < v.x;
		return y < v.y;
	}
	bool operator>(const xy &v) const{
		if(x!=v.x) return x > v.x;
		return y > v.y;
	}

};
//for sorting
bool comp_xy(const xy &a, const xy &b){
	if(a.x != b.x) return a.x < b.x;
	return a.y < b.y;
}

//u,v : vector O = (0,0)
double cross(const xy &u, const xy &v){
	return u.x*v.y - u.y*v.x;
}

//u,v : vector O = (0,0)
double dot(const xy &u, const xy &v){
	return u.x*v.x + u.y*v.y;
}

//distance between two points
double dist_p_p(const xy &a, const xy &b){
	return sqrt( fabs(dot(a-b, a-b)) );
}

//distance between a point and a line segment
double dist_p_ls(const xy &p, const xy &s1, const xy &s2){
	xy vl = s2 - s1;
	xy vp = p - s1;

	return fabs( cross(vl, vp) / sqrt( dot(vl, vl) ) );
}

//zero -> p1
int ccw(xy p1, xy p2, xy p3){
	p2 -= p1;
	p3 -= p1;
	double c = cross(p2,p3);
	if( c > EPS /* c > 0 */) return +1;			//counter-clockwise
	if( c < -EPS /* c < 0 */) return -1;		//clock-wise
	if( dot(p2,p3) < -EPS) return +2;			//on segment : p3-p1-p2
	if( dot(p3,p3) < dot(p2,p2) +EPS ) return -2;	//on segment : p1-p3-p2
	return 0;
}

//segment p1-p2, p3-p4
bool inter_ss(xy p1, xy p2, xy p3, xy p4){
	return ( (ccw(p1,p2, p3) * ccw(p1,p2, p4) <= 0) && (ccw(p3,p4, p1) * ccw(p3,p4, p2) <= 0 ) ) ;
}

bool comp_x(xy &a, xy &b){
	if(a.x < b.x) return true;
	return false;
}
bool comp_y(xy &a, xy &b){
	if(a.y < b.y) return true;
	return false;
}

bool contain(xy &&lb, xy &&rt, xy &s1, xy &s2){
	if(comp_x(lb, s1) && (!comp_x(rt, s1)) && comp_y(lb, s1) && (!comp_y(rt, s1))){
		return true;
	}
	if(comp_x(lb, s2) && (!comp_x(rt, s2)) && comp_y(lb, s2) && (!comp_y(rt, s2))){
		return true;
	}
	return false;
}

bool inter_rec_seg(xy &&lb, xy &&rt, xy &s1, xy &s2){
	bool intersect = false;
	xy lt(lb.x, rt.y);
	xy rb(rt.x, lb.y);
	if(inter_ss(lb,lt, s1,s2)) return true;
	if(inter_ss(lt,rt, s1,s2)) return true;
	if(inter_ss(rt,rb, s1,s2)) return true;
	if(inter_ss(rb,lb, s1,s2)) return true;
	return false;
}

bool solve(){
	int K,P;
	if(cin >> K >> P){
		vector<pair<int,int>> i_lb(K);
		vector<pair<int,int>> i_rt(K);
		vector<xy> lb(K);
		vector<xy> rt(K);
		vector<long long> area(K,0);
		vector<long long> crossing_type(K, 1);
		long long ans_a = 0;
		long long ans_b = 0;
	
		//set<pair<xy,xy>> s;
		for(int i=0; i<K; i++){
			int x1,x2,y1,y2;
			scanf("%d%d%d%d", &x1,&y1,&x2,&y2);
	
			i_lb[i] = {x1,y1};
			i_rt[i] = {x2,y2};
	
			lb[i] = xy(x1,y1);
			rt[i] = xy(x2,y2);
	
			area[i] = 1LL*abs(x2-x1) * abs(y2-y1);
		}
	
		auto on_the_boundary_or_contain = [&](int j, int x, int y){
			if(i_lb[j].first <= x && x <= i_rt[j].first &&
				 i_lb[j].second  <= y && y <= i_rt[j].second){
				if(i_lb[j].first  == x || i_rt[j].first == x || 
					i_lb[j].second  == y || i_rt[j].second == y) return 3;
				else  return 2;
			}
			return 1;
		};
	
		for(int i=0; i<P; i++){
			int x1,x2,y1,y2;
			scanf("%d%d%d%d", &x1,&y1,&x2,&y2);
			xy p(x1,y1);
			xy q(x2,y2);
			for(int j=0; j<K; j++){
				int a = on_the_boundary_or_contain(j, x1, y1);
				int b = on_the_boundary_or_contain(j, x2, y2);
				if((a*b)%2==0){
					//contain
					crossing_type[j] *= 0;
				}else if((a*b)%3==0){
					//on the boundary
					crossing_type[j] *= 2;
				}else if( inter_rec_seg(lb[j]-1e-2, rt[j]+1e-2, p, q) ){
					crossing_type[j] *= 2;
				}
			}
		}
		for(int i=0; i<K; i++){
			if(crossing_type[i] == 1) continue;
			(crossing_type[i]==0?ans_a:ans_b) += area[i];
		}
		cout << ans_a << " " << ans_b << endl;
		return true;
	}
	return false;
}



int main(){
	int T;
	cin >> T;
	while(1){
		if(solve() == false) break;
	}
	return 0;
}