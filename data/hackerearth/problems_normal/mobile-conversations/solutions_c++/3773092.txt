/**
  * Task: https://www.hackerearth.com/problem/algorithm/mobile-conversations/
  * Solution: sort. greedy.
  **/

#include <algorithm>
#include <cstdio>
#include <vector>
#include <utility>

int main()
{
    int n;
    scanf("%d", &n);

    std::vector<std::pair<int, int>> profit; profit.reserve(n);
    std::vector<std::pair<int, int>> loss; loss.reserve(n);
    for ( int i = 0; i < n; ++i )
    {
        int t, x;
        scanf("%d %d", &t, &x);

        if ( t <= x )   profit.push_back({t, x});
        else            loss.push_back({t, x});
    }

    auto cmp1 = [](const std::pair<int, int>& lhs, const std::pair<int, int>& rhs) -> bool
    { return lhs.first < rhs.first; };
    std::sort(profit.begin(), profit.end(), cmp1);

    auto cmp2 = [](const std::pair<int, int>& lhs, const std::pair<int, int>& rhs) -> bool
    { return lhs.second > rhs.second || lhs.second == rhs.second && lhs.first < rhs.first; };
    std::sort(loss.begin(), loss.end(), cmp2);

    unsigned long long answer = 0;
    long long cur = 0;
    for ( const auto& p : profit )
    {
        answer += std::max(0LL, p.first - cur);
        cur = std::max(0LL + p.first, cur);

        cur -= p.first;
        cur += p.second;
        // printf("cur:%lld p:(%d %d) answer:%llu\n", cur, p.first, p.second, answer);
    }
    for ( const auto& p : loss )
    {
        answer += std::max(0LL, p.first - cur);
        cur = std::max(0LL + p.first, cur);

        cur -= p.first;
        cur += p.second;
        // printf("cur:%lld p:(%d %d) answer:%llu\n", cur, p.first, p.second, answer);
    }

    printf("%llu\n", answer);

    return 0;
}
