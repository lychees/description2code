"""
calculate ncr%p where p is prime using inverse modulo

1)nck = n*(n-1)*(n-2)...(n-k+1)
        ---------------------- = num/den
        1*2*............k
        
2)nck = num*den^-1

3)nck%p = ((num%p)*(den^-1%p))%p

4)den^-1 = den^(p-2)=den^b

4)nck%p = ((num%p)*(den^b%p))%p


5)we know that (a^b)%c = ((a%c)^b)%c;den^b%p = ((den%p)^b)%p

6)nck%p = ((num%p)*((den%p)^b)%p)%p

7)now calculate num%p and den%p  easily using (a*b)%p = (a%p*b%p)%p

8)after den%p = a has been calculated we compute now (a^b)%p using fast modular exponention

"""


'''
precompute works as follows
Firstly, we denote the multiplicative inverse of x mod p as inv(x,p).

1) use dp method to calculation x! mod p for x=1 ~ n (1<=n<p, p is some prime)
2) calculate inv(n!,p) utilize Extended Euclidean algorithm. but here we do by by fact that inv(a)%p ,if p is prime then inv(a) = a^p-2
3) use dp again to calculate inv(x!,p) for x=n-1 ~ 1 with the fact inv(x!,p) * x = inv((x-1)!, p)
4) now, if we want to now inv(x,p) for some x in [1,n], we only need to calculate (x-1)! * inv(x!,p)


'''
def modpow(a,x,p):
    #calculates a^x mod p in logarithmic time.
    res= 1
    while(x>0):
        if (x%2 ==1):
            res*=a
            res%=p
        a = a*a
        a%=p
        x=x/2
    return res
        
def modInverse(a,p):
     #calculates the modular multiplicative of a mod p.
    #(assuming p is prime).
    return modpow(a,p-2,p)



def comp(n,r,fact,ifact,M):
    ret = (fact[n]*ifact[r])%M
    ret *=ifact[n-r]
    ret = ret%M
    return ret
    
    


def precompute(fact,ifact,N,M):
    fact[0] = 1

    for i in range(1,N):
        fact[i] = (i*fact[i-1])%M

    ifact[N-1] = modInverse(fact[N-1],M) 

    j= N-2
    while(j>=0):
        ifact[j]= ((j+1)*ifact[j+1])%M
        j-=1

    
        
N = 100005
M = 1000000007
fact  = [0]*N
ifact = [0]*N
precompute(fact,ifact,N,M)


T = int(raw_input())
for t in range(T):
    n,k = [int(x) for x in raw_input().split()]
   
    strength = [int(x) for x in raw_input().split()]
    strength.sort()
    res = 0
    i=0
    for i in range(n-k+1):
        ncr = comp(n-i-1,k-1,fact,ifact,M)
        ncr = (ncr*strength[i])%M
        res = (res +ncr)%M
    print res
        
