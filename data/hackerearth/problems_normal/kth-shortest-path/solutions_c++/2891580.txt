#include <bits/stdc++.h>
 
using namespace std;
 
#define MAXN         123456
#define HODOR        long long int
#define INF          1234567890
#define PI           3.141592653589793
#define rep(i, a, b) for(int i = (a); i < (b); ++i)
#define dwn(i, a, b) for(int i = (a); i >= (b); --i)
#define REP(c, it)   for( typeof( (c).begin()) it = (c).begin();  it != (c).end(); ++it)
#define DWN(c, it)   for( typeof( (c).end()) it = (c).end()-1;  it >= (c).begin(); --it)
#define ss(n)        scanf("%s",n)
#define FILL(x,y)    memset(x,y,sizeof(x))
#define pb           push_back
#define mp           make_pair
#define ALL(v)       v.begin(), v.end()
#define sz(a)        ((int)a.size())
#define SET(v, i)    (v | (1 << i))
#define TEST(v, i)   (v & (1 << i))
#define TOGGLE(v, i) (v ^ (1 << i))
#define gc           getchar_unlocked
#define pc           putchar_unlocked
 
template<typename X> inline void inp(X &n ) {
   register int ch=gc();int sign=1;n=0;
   while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=gc();}
   while(  ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=gc();
   n=n*sign;
}
 
template<typename X> inline void out(X a) {
   char snum[20]; int i=0,sign=0;
   if(a<0) sign=1,a=-a;
   do {snum[i++]=a%10+48; a=a/10; }while(a!=0);
   if(sign) pc('-');
   for(i--;i>=0;pc(snum[i--]));
   pc('\n');
}

#define testcases(tc)  int tc,t; for(inp(t),tc=1;tc<=t;++tc)

int n, m, mat[100+10][100+10], dp[100+10][100+10][100+10], q, x, y, k;
char str[100];

void solve() {
	dp[0][0][0] = mat[0][0];
	// Initialise 0th row
	bool flag = false;
	rep(c, 1, n) {
		if ( mat[0][c] == INF )
			flag = true;
		if ( !flag )
			dp[0][c][0] = mat[0][c]+dp[0][c-1][0];
	}
	flag = false;
	// Initialise 0th col
	rep(r, 1, m) {
		if ( mat[r][0] == INF )
			flag = true;
		if ( !flag )
			dp[r][0][0] = mat[r][0] + dp[r-1][0][0];
	}

	rep(i, 1, m) {
		rep(j, 1, n) {
			int x, y, z;
			if ( mat[i][j] == INF )
				continue;
			for (x = y = z = 0; dp[i-1][j][x] != INF && dp[i][j-1][y] != INF && z < 105;) {
				if ( dp[i-1][j][x] < dp[i][j-1][y] )
					dp[i][j][z++] = dp[i-1][j][x++] + mat[i][j];
				else
					dp[i][j][z++] = dp[i][j-1][y++] + mat[i][j];
			}
			if ( z < 105 ) {
				if ( dp[i-1][j][x] != INF ) {
					while( dp[i-1][j][x] != INF && z < 105 )
						dp[i][j][z++] = dp[i-1][j][x++] + mat[i][j];
				} else if ( dp[i][j-1][y] != INF ) {
					while( dp[i][j-1][y] != INF && z < 105 )
						dp[i][j][z++] = dp[i][j-1][y++] + mat[i][j];
				}
			}
		}
	}
}

int main() {
   testcases(tc) {
   	inp(m), inp(n);
   	rep(i, 0, m)	rep(j, 0, n) rep(k, 0, 105) dp[i][j][k] = INF;
   	rep(i, 0, m)  rep(j, 0, n) {
   		scanf("\n%s", str);
   		if ( str[0] != '#' )
   			sscanf(str, "%d", &mat[i][j]);
   		else
   			mat[i][j] = INF;
   	}
   	inp(q), solve();
   	rep(i, 0, q) {
   		inp(x), inp(y), inp(k);
   		if ( mat[x][y] == INF )
   			printf("Obstacle\n");
   		else if ( dp[x][y][k-1] == INF )
   			printf("Not so many paths\n");
   		else
   			printf("%d\n", dp[x][y][k-1]);
   	}
   }
   return 0;
}