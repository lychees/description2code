	#include <bits/stdc++.h>

	using namespace std;

	typedef vector<int> vi;
	typedef vector<vi> vvi;
	typedef pair<int,int> ii;
	typedef map<int,int> mii;


	// Input macros
	#define s(n)                        cin >> n
	#define sc(n)                       scanf("%c",&n)
	#define ss(n)                       scanf("%s",n)
	#define ll 							long long 				
	// Useful constants
	#define INF                         (int)1e9
	#define EPS                         1e-9
	// Useful hardware instructions
	#define bitcount                    __builtin_popcount
	#define gcd                         __gcd
	// Useful container manipulation / traversal macros
	#define forall(i,a,b)        		for(int i=a;i<b;i++)
	#define sz(a) 						int((a).size())
	#define pb 							push_back
	#define all(c) 						(c).begin(),(c).end()
	#define tr(c,i) 					for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++)
	#define cpresent(c,x) 				(find(all(c),x) != (c).end())		// for set/maps
	#define present(c,x) 				((c).find(x) != (c).end()) 		// for vectors
	#define fillA(arr,a,b,v)              forall(i,a,b) arr[i]  = v
	#define fillV(a,v)                    memset(a, v, sizeof a)
	#define maX(a,b)                     ( (a) > (b) ? (a) : (b))
	#define miN(a,b)                     ( (a) < (b) ? (a) : (b))
	#define checkbit(n,b)                ( (n >> b) & 1)
	#define DREP(a)                      sort(all(a)); a.erase(unique(all(a)),a.end())
	#define INDEX(arr,ind)               (lower_bound(all(arr),ind)-arr.begin())
	#define fi 						     first
	#define se 							 second
	#define printA(arr,a,b) forall(i,a,b) cout << arr[i] << (i==(b-1)?'\n':' ')
	#define printV(a) printA(a,0,a.size())
	#define pf(n)	cout << n << endl;
	#define pff(n)	cout << fixed << setprecision(10) << n << endl;


	int main ()
	{

	int n,m;
	s(n); s(m);
	ll a[n+1];
	vi adj[n+1];
	forall(i,1,n+1){s(a[i]);}
	int curr = 0;
	int team[n+1];
	fillA(team,0,n+1,-1);
	forall(i,0,m){
		int u,v; s(u);s(v);
		// pf(i);
		// pf(u); pf(v);
		// pf(team[u]); pf(team[v]);
		// if(team[u] >= 0){
		// 	pf("here");
		// 	printV(adj[team[u]]);
		// 	// printV(adj[team[v]]);
		// }
		// if(team[v] >= 0){
		// 	// printV(adj[team[u]]);
		// 	printV(adj[team[v]]);
		// }
		// printA(team,1,5);
		if (team[u] != team[v]){
			int s1,s2;
			if(team[u] >= 0)
				s1 = sz(adj[team[u]]);
			else
				s1 = 0;
			if(team[v] >= 0)
				s2 = sz(adj[team[v]]);
			else
				s2 = 0;
			if ( s1 != 0 && s2 != 0){
				if(s1 < s2){
					vi temp = adj[team[u]];
					adj[team[u]].erase(all(adj[team[u]]));
					forall(j,0,s1){
						adj[team[v]].pb(temp[j]);
						team[temp[j]] = team[v];
					}
					
				}
				else{
					vi temp = adj[team[v]];
					adj[team[v]].erase(all(adj[team[v]]));	
					forall(j,0,s2){
						adj[team[u]].pb(temp[j]);
						team[temp[j]] = team[u];
					}
					
				}
			}
			else{
				if(team[v] >= 0){
					adj[team[v]].pb(u);
					team[u] = team[v];
				}
				else{

					adj[team[u]].pb(v);
					team[v] = team[u];	
				}

			}	

		}
		else{
			if(team[u] == -1){
				team[u] = curr;
				team[v] = curr;
				if(u != v)
					{adj[curr].pb(u);adj[curr].pb(v); curr += 1;}
				else
					{adj[curr].pb(u); curr += 1;}

			}
		}
	}

	// printA(team,1,n+1);
	vi mo[curr];
	ll team_k[curr];
	fillA(team_k,0,curr, -1);
	forall(i,1,n+1){
		if(team[i] >= 0){
			if(team_k[team[i]] < a[i] ){
				team_k[team[i]] = a[i];
				mo[team[i]].erase(all(mo[team[i]]));
				mo[team[i]].pb(i);
			}
			else{
				if(team_k[team[i]] == a[i] ){
					team_k[team[i]] = a[i];
					mo[team[i]].pb(i);
				}
			}
		}	
	}
	// printA(team_k,0,curr);
	// printV(mo[0]);
	ll out=1;
	ll divi = 1e9 + 7;
	forall(i,0,curr){
		if(sz(mo[i]) > 0){
			out = (out*sz(mo[i]));
			out = out % divi ;
		}
	}

	pf(out);

	return 0;
	}