#include <iostream>
#include <stdio.h>
using namespace std;
int oneDigit(long num)
{
    // comparison operation is faster than division operation.
    // So using following instead of "return num / 10 == 0;"
    return (num >= 0 && num < 10);
}
bool isPalUtil(long num, long* dupNum)
{
    // Base case (needed for recursion termination): This statement
    // mainly compares the first digit with the last digit
    if (oneDigit(num))
        return (num == (*dupNum) % 10);
 
    // This is the key line in this method. Note that all recursive
    // calls have a separate copy of num, but they all share same copy
    // of *dupNum. We divide num while moving up the recursion tree
    if (!isPalUtil(num/10, dupNum))
        return false;
 
    // The following statements are executed when we move up the
    // recursion call tree
    *dupNum /= 10;
 
    // At this point, if num%10 contains i'th digit from beiginning,
    // then (*dupNum)%10 contains i'th digit from end
    return (num % 10 == (*dupNum) % 10);
}
 
// The main function that uses recursive function isPalUtil() to
// find out whether num is palindrome or not
int isPal(long num)
{
    // If num is negative, make it positive
    if (num < 0)
       num = -num;
 
    // Create a separate copy of num, so that modifications made
    // to address dupNum don't change the input number.
    long *dupNum = new long(num); // *dupNum = num
 
    return isPalUtil(num, dupNum);
}
bool checkprime(long n)
{
	if(n == 1)
	return 0;
	if(n == 2)
	return 1;
	for(long i = 2;i*i<=n;i++)
	{
		if(n % i == 0)
		return 0;
	}
	return 1;
}
long solve(long n)
{
	while(1)
	{
		if(checkprime(n))
		{
			if(isPal(n))
			return n;
		}
		n++;
	}
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
    	long n;
    	scanf("%ld",&n);
    	long x = solve(n);
    	printf("%ld\n",x);
    }
    return 0;
}
