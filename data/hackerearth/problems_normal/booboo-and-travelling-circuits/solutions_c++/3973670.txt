#include <bits/stdc++.h>

#define pb push_back
#define f first
#define s second
#define mp make_pair
#define sz(a) int((a).size())
#ifdef _WIN32
#  define I64 "%I64d"
#else
#  define I64 "%lld"
#endif
#define fname "."
#define pi pair < int, int >
#define pp pop_back

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;

const int MAX_N = (int)2e5 + 123;
const double eps = 1e-6;
const int mod = 1000000003;
const ll inf = (ll)1e18 + 123;

using namespace std;

int n, m;
int a[2002][10002], b[2002][10002];
int vl, p, q, r;
ll dp[2][10002];

int lp[10002];
bool pr[10002];

void init(int x) {
	for (int i = 2; i <= x; i++) {
		if (pr[i])
			continue;
		lp[i] = i;
		if (1ll * i * i <= x)
			for (int j = i * i; j <= x; j += i)
				if (!pr[j])
					pr[j] = 1, lp[j] = i;
	}
}

ll val[10002];

int main() {
	#ifdef Nick
	freopen(fname"in", "r", stdin);
	freopen(fname"out", "w", stdout);
	#endif
	scanf("%d%d", &n, &m);
	scanf("%d%d%d%d", &vl, &p, &q, &r);
	for (int i = 0; i < n * m; i++) {
		vl = (p * 1ll * (1ll * vl * vl % mod) + 1ll * q * vl + r) % mod;
		a[(i / m) + 1][(i % m) + 1] = vl;
	}
	scanf("%d%d%d%d", &vl, &p, &q, &r);
	for (int i = 0; i < n * m; i++) {
		vl = (p * 1ll * (1ll * vl * vl % mod) + 1ll * q * vl + r) % mod;
		b[(i / m) + 1][(i % m) + 1] = vl;
	}
	init(m);
	for (int i = 1, now = 1; i < n; i++, now ^= 1) {
		for (int j = 1; j <= m; j++)
			dp[now ^ 1][j] = inf, val[j] = inf;
		for (int j = 1; j <= m; j++) {
			dp[now ^ 1][j] = min(dp[now ^ 1][j], dp[now][j] + a[i][j]);
			if (lp[j] != 0 && val[lp[j]] != inf)
				dp[now ^ 1][j] = min(dp[now ^ 1][j], val[lp[j]]);
			if (lp[j] != 0)
				val[lp[j]] = min(val[lp[j]], dp[now][j] + b[i][j]);
		}	
		for (int j = 1; j <= m; j++)
			val[j] = inf;
		ll mini = inf;
		for (int j = m; j > 0; j--) {
			dp[now ^ 1][j] = min(dp[now ^ 1][j], dp[now][j] + a[i][j]);
			if (lp[j] != 0 && val[lp[j]] != inf)
				dp[now ^ 1][j] = min(dp[now ^ 1][j], val[lp[j]]);
			if (lp[j] != 0)
				val[lp[j]] = min(val[lp[j]], dp[now][j] + b[i][j]);
			if (j == 1)
				dp[now ^ 1][j] = min(dp[now ^ 1][j], mini);
			mini = min(mini, dp[now][j] + b[i][j]);
		}	

	}
	ll ans = inf;
	for (int i = 1; i <= m; i++)
		ans = min(ans, dp[n % 2][i]);
	printf(I64, ans);
	return 0;
}
