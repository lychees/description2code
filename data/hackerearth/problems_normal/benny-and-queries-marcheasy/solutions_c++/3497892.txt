#include <iostream>
#include <cstdio>
using namespace std;
int a[20000000][2],ww[23],sz[20000000],type,root[1000000],m,ind[20000000];
int ans,n,v,l,r,x,num,q;
void add(int prev_root, int now_root, int x) {
    for (int i=22;i>=0;i--) {
        int edge=(x & (1 << i));
        if (edge!=0) edge=1;
        v++;
        ww[i]=now_root;
        ind[v]=n;
        a[now_root][edge]=v;
        a[now_root][1-edge]=a[prev_root][1-edge];
        sz[now_root]=sz[a[now_root][1-edge]];
        now_root=v;
        prev_root=a[prev_root][edge];
    }
    sz[now_root]+=sz[prev_root]+1;
    for (int i=0;i<=22;i++) sz[ww[i]]=sz[a[ww[i]][0]]+sz[a[ww[i]][1]];
 }
void findxor(int v, int l, int x) {
    for (int i=22;i>=0;i--) {
        int edge=(x & (1 << i));
        if (edge!=0) edge=1;
        if (ind[a[v][1-edge]]>=l) {
            v=a[v][1-edge];
            ans+=(1-edge)*(1 << i);
        }
        else {
            v=a[v][edge];
            ans+=edge*(1 << i);
        }
     }
}
int main() {
        scanf("%d%d",&num,&q);
        for(int i=0;i<num;i++){
            scanf("%d",&x);
            n++;
            v++;
            root[n]=v;
            ind[v]=n;
            add(root[n-1],root[n],x);
        }
        for(int i=0;i<q;i++){
            scanf("%d%d%d",&l,&r,&x);
            ans=0;
            findxor(root[r],l,x);
            printf("%d\n",ans^x);
        }
    
    return 0;
}
