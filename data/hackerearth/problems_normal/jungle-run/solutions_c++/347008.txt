#include<bits/stdc++.h>

using namespace std;

int minDistance(int *dist, bool *sptSet, int size)
{
	int min = INT_MAX, min_index;
	for(int i=0; i<size; i++)
		if(sptSet[i] == false && dist[i] <= min)
			min = dist[i], min_index = i;

	return min_index;
}

int dijkstra(vector< list<int> > *graph, int src, int dest, int size)
{
	int dist[size];
	bool sptSet[size];

	for(int i=0; i<size; i++)
		dist[i] = INT_MAX, sptSet[i] = false;

	dist[src] = 0;
	for(int count = 0; count < size; count++)
	{
				

		int u = minDistance(dist, sptSet, size);
		if(u == dest)
			return dist[u];
		sptSet[u] = true;
		list<int>::iterator p = (*graph)[u].begin();
		while(p != (*graph)[u].end())
		{
			if(!sptSet[*p] && dist[u]+1 < dist[*p])
				dist[*p] = dist[u]+1;
			p++;
		}

	}
}

int main()
{
	int n,src,dest,count=0;
	cin >> n;

	char arr[n][n];
//	int graph[30*30][30*30];
	vector< list<int> > graph(n*n);

	for(int i=0; i<n; i++)
		for(int j=0; j<n; j++)
			cin >> arr[i][j];

//	for(int i=0; i<(900); i++)
//		for(int j=0; j<(900); j++)
//			graph[i][j] = 0;
	
	for(int i=0; i<n; i++)
	{
		for(int j=0; j<n; j++)
		{

			if(arr[i][j] != 'T')
			{
				if(arr[i][j] == 'S')
					src = count;
				else if(arr[i][j] == 'E')
					dest = count;

			if(j+1 < n && arr[i][j+1] != 'T')
			{
				graph[count].push_back(count+1);
				graph[count+1].push_back(count);
//				graph[count][count+1] = 1;
//				graph[count+1][count] = 1;
			}
			if(i+1 < n && arr[i+1][j] != 'T')
			{
				graph[count].push_back(count+n);
				graph[count+n].push_back(count);
//				graph[count][count+n] = 1;
//				graph[count+n][count] = 1;
			}
			}
			count++;
		}
	}
/*	for(int i=0; i<(n*n); i++)
	{
		list<int>::iterator p = graph[i].begin();
		while(p != graph[i].end())
		{
			cout << *p << "    " ;
			p++;
		}
	}*/

	cout << dijkstra(&graph, src, dest, n*n) << endl;
}
