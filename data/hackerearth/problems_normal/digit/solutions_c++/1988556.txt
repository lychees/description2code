// Author: thecodekaiser
#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
#define MXN 15
#define MXS 140
 
char cad[1000];
unordered_map < ll, ll> dp[MXN][MXS];
int len, X, Y;
ll A, B, K;
 
ll rec(int digits, int sum, ll mod)
{
	if(digits == len)
	{
		if(sum >= X and sum <= Y and mod == 0)
		{
	//		cout << "SUM: " << sum << " MOD: " << mod << endl;
			return 1LL;
		}
		else
			return 0LL;
	}
 
	if(dp[digits][sum].find(mod) != dp[digits][sum].end())
		return dp[digits][sum][mod];
 
	ll ans = 0, new_mod;
	int new_sum;
	for(int i = 0; i <= 9; i++)
	{
		new_sum = sum + i;
		new_mod = (mod * 10) + i;
		if(new_mod >= K) while(new_mod >= K) new_mod -= K;
 
		ans += rec(digits+1, new_sum, new_mod);
	}
 
	dp[digits][sum].insert(pair<ll,ll>(mod, ans));
 
	return dp[digits][sum][mod];
}
 
 
ll val(ll num)
{
	ll ans = 0;
	sprintf(cad, "%lld", num);
	len = strlen(cad);
 
	int remain = 0;
	int sum = 0, new_sum;
	ll mod = 0, new_mod;
 
	for(int i = 0; i < len; i++)
		for(int j = 0; j <= 140; j++)
			dp[i][j].clear();
 
	for(int i = 0; i < len; i++)
	{
		int digit = cad[i] - '0';
		for(int d = 0; d < digit; d++)
		{
			new_sum = sum + d;
			new_mod = (mod * 10) + d;
			if(new_mod >= K) while(new_mod >= K) new_mod -= K;
 
			ans += rec(remain+1, new_sum, new_mod);
		}
 
		sum += digit;
		remain++;
		mod = (mod * 10 + digit);
		if(mod >= K) while(mod >= K) mod -= K;
 
	}
//	cout << endl;
 
	return ans;
}
 
ll digit_sum(ll val)
{
	ll sum = 0, dig;
	while(val > 0)
	{
		dig = val % 10;
		val /= 10;
		sum += dig;
	}
 
	return sum;
}
 
void solve()
{
	scanf("%lld %lld %d %d %lld", &A, &B, &X, &Y, &K);
 
 
	if(K <= 5000)
	{
		Y = min(130, Y);
 
		cout << val(B+1) - val(A) << endl;
	}
	else
	{
		int ctr = 0;
		ll ans_bata = (A/K) * K;
		while(ans_bata <= B)
		{
			ll chk = digit_sum(ans_bata);
			if(chk >= X && chk <= Y && ans_bata >= A)
			{
				ctr += 1;
			}
			ans_bata += K;
		}
		cout << ctr << endl;
	}
	return;
}
 
int main()
{
	solve();
 
	return 0;
}