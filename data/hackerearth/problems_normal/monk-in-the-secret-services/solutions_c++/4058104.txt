#include <iostream>
#include <vector>
#include <utility>
#include <queue>
using namespace std;
vector<vector<int> > graph,path;
vector<int> dist,visited;
int n;
struct compare
{
	bool operator()(const pair<int,int> &a,const pair<int,int> &b)
	{
		return a.first>b.first;
	}
};
int dijkstra(int s)
{
	dist.clear();
	visited.clear();
	dist.resize(n+1,1e9);
	visited.resize(n+1,0);
	dist[s]=0;
	int res=0;
	priority_queue<pair<int,int>,vector<pair<int,int> >,compare> pq1;
	pq1.push(make_pair(0,s));
	int p1;
	while(!pq1.empty())
	{
		int d=pq1.top().first;
		int node=pq1.top().second;
		pq1.pop();
		if(!visited[node])
		{
			visited[node]=1;
			for(p1=1;p1<=n;p1++)
			{
				if(dist[p1]>dist[node]+graph[p1][node])
				{
					dist[p1]=dist[node]+graph[p1][node];
					pq1.push(make_pair(dist[p1],p1));
				}
			}
		}
	}
	for(p1=1;p1<=n;p1++)
		res+=dist[p1];
	return res;
}
int main()
{
    int p1,p2,p3,t,m,z,y,c,s,a,h,result,x;
    cin>>t;
    while(t--)
    {
    	graph.clear();
    	cin>>n>>m;
    	graph.resize(n+1,vector<int> (n+1,1e9));
    	while(m--)
    	{
    		cin>>x>>y>>c;
    		graph[x][y]=min(graph[x][y],c);
    		graph[y][x]=min(graph[y][x],c);
    	}
    	cin>>s>>a>>h;
    	for(p1=1;p1<=n;p1++)
    		graph[p1][p1]=0;
    	for(p3=1;p3<=n;p3++)
    		for(p1=1;p1<=n;p1++)
    			for(p2=1;p2<=n;p2++)
    				graph[p1][p2]=min(graph[p1][p2],graph[p1][p3]+graph[p3][p2]);
    	result=0;
    	int res;
    	for(p1=1;p1<=n;p1++)
    	{
    		if(p1==s||p1==a||p1==h)
    			continue;
    		res=graph[s][p1]+2*graph[a][p1]+graph[h][p1];
    		result=max(result,res);
    	}
    	cout<<result<<endl;
    }
    return 0;
}
