/**
* Change is impossible in this fog of ignorance.
*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <climits>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <cassert>
#include <cmath>
using namespace std;

#define trace(x) {cerr << #x << "=" << x <<endl;}
#define trace2(x, y) {cerr << #x << "=" << x << " " << #y << "=" << y <<endl;}
#define track(x) {cerr << #x << ":" << endl; for (int q = 0; q < x.size(); q++) {cerr << x[q] << " ";} cerr << endl;}
#define trackarr(x, n) {cerr << #x << ":" << endl; for (int q = 0; q < n; q++) {cerr << x[q] << " ";} cerr << endl;}
#define trackvv(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) { cerr << "i:" << i << endl; for (int j = 0; j < x[i].size(); j++){cerr << x[i][j] << " ";} cerr << endl;} cerr << endl;}
#define trackcr(x) {cerr << #x << ":" << endl; for (auto i = x.begin(); i != x.end(); i++) {cerr << *i << " ";} cerr << endl;}
template <typename Tk, typename Tv> ostream& operator<<(ostream& os, const pair<Tk, Tv> &p){os << "{" << p.first << ',' << p.second << "}";return os;}

typedef long long ll;

const int MAX = 100050;
const int MOD = 1000000000+7;
const int INF = 1000000000;

bool isvisited[MAX];
int pos[MAX], child[MAX];
int size = 0;

int dfs(vector<vector<int> > &T, int u){
    isvisited[u] = 1;
    int count = 1;
    pos[u] = size++;
    for (vector<int>::iterator i = T[u].begin(); i != T[u].end(); i++) {
        if (!isvisited[*i]) {
            count += dfs(T, *i);
        }
    }
    child[pos[u]] = count;
    return count;
}

long long st[4*MAX];

ll query(int node, int ll, int rl, int ql, int qr){
    if (ll >= ql && rl <= qr) return st[node];
    else if (rl < ql || ll > qr) return 0;
    long long left = query(2*node+1, ll, (ll+rl)/2, ql, qr);
    long long right = query(2*node+2, (ll+rl)/2 + 1, rl, ql, qr);
    return left + right;
}

ll update(int node, int ll, int rl, int q, int val){
    if (rl < q || ll > q) return st[node];
    if (q == ll && q == rl) st[node] = val;
    else {
        long long left = update(2*node+1, ll, (ll+rl)/2, q, val);
        long long right = update(2*node+2, (ll+rl)/2 + 1, rl, q, val);
        st[node] = left + right;
    }
    return st[node];
}

int main() {
    int n,m;
    scanf("%d%d", &n, &m);
    ll a[100005];
    for (int i = 0; i < n; i++) {
        scanf("%lld", &a[i]);
    }
    vector<vector<int> > T(n);
    for (int i = 0; i < n-1; i++) {
        int a, b;
        scanf("%d%d", &a, &b);
        a--, b--;
        T[a].push_back(b);
        T[b].push_back(a);
    }
    dfs(T, 0);

    for (int i = 0; i < n; i++) {
        update(0, 0, n-1, pos[i], a[i]);
    }

    /*for (int i = 0; i < 4*n; i++) {
        cout << st[i] << " ";
    }
    cout << endl;
    */

    while (m--) {
        char s[2];
        scanf("%s", s);
        if (s[0]=='Q') {
            int x;
            scanf("%d", &x);
            x--;
            ll answer = query(0, 0, n-1, pos[x], pos[x]+child[pos[x]]-1);
            printf("%lld\n", answer);
        } else {
            int x;
            long long v;
            scanf("%d%lld", &x, &v);
            x--;
            update(0, 0, n-1, pos[x], v);
        }
    }
}
