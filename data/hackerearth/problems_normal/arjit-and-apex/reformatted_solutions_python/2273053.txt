
from bisect import bisect_left


def binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi
    # print a
    hi = hi if hi is not None else len(a)  # hi defaults to len(a)
    pos = bisect_left(a, x, lo, hi)          # find insertion position
    return (pos if pos != hi and a[pos] == x else -1)  # don't walk off the end


def linear_search(a, x):
    for i in xrange(len(a)):
        if a[i] == x:
            return i
    return -1


T = int(raw_input())
while (T != 0):
    line = raw_input().strip().split(' ')
    M = int(line[0])
    N = int(line[1])
    sn = []
    pn = []
    while (M != 0):
        temp = raw_input().strip().split(' ')
        sn.append(int(temp[0]))
        pn.append(int(temp[1]))
        M = M-1
    sc = []
    pc = []
    while (N != 0):
        temp = raw_input().strip().split(' ')
        sn.append(int(temp[0]))
        pc.append(int(temp[1]))
        N = N-1
    temp = raw_input().strip().split(' ')
    G = int(temp[0])
    H = int(temp[1])
    good_count = 0
    great_count = 0
    # pdb.set_trace()
    # sc.sort()
    # found_matches = []
    for item in sn:
        index = linear_search(sc, item)
        if index == -1:
            continue
        else:
            # found_matches.append(index)
            del sc[index]
            good_count = good_count+1
            if pn[index] == pc[index]:
                great_count = great_count + 1

    if great_count >= H:
        print "Great"
    elif good_count >= G:
        print "Good"
    else:
        print ":("
    T = T-1
