/*
Tom and Jerry are wonderful characters. They are always running and make us laugh.

Right now, they are in a grid of houses and Jerry is running away from Tom. The grid of houses is represented as 0 and 1, where 0 means that Jerry can enter the house, and 1 means Jerry can't. Jerry can only move horizontally or vertically. Also, Jerry doesn't enter the same house more than once.

Jerry started running from the house at (1,1) which is the top-left house in the grid and have to reach (N,N) which the bottom-right house in the grid. You have find the number of ways in which Jerry can reach the destination house where he can be safe.

Input Format

First line is an integer N ( N <= 100), which is the size of the grid. N lines follow, each containing N space separated numbers which are either '0' or '1'.

Output format

Print a single line showing the number of ways in which Jerry can reach from (1,1) to (N,N).

Sample Input (Plaintext Link)
9
0 0 0 0 0 0 0 0 0
0 1 0 1 0 1 0 1 0
0 0 0 0 0 0 0 0 0
0 1 0 1 0 1 0 1 0
0 0 0 0 0 0 0 0 0
0 1 0 1 0 1 0 1 0
0 0 0 0 0 0 0 0 0
0 1 0 1 0 1 0 1 0
0 0 0 0 0 0 0 0 0
Sample Output (Plaintext Link) : 8512
*/

//Practice Problems / Tom & Jerry
#include <cstdlib>
#include <stdio.h>
#include <cstring>
#include <vector>
#include <cmath>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <sstream>
#include <string>
#define FOR(i,n) for(i=0;i<n;i++)
#define FORI(i,a,n) for(i=a;i<n;i++)
#define FORC(it,C) for(it=C.begin();it!=C.end();it++)
#define sd(x) scanf("%d",&x)
#define sl(x) scanf("%lld",&x)
#define print(x) printf("%d\n",x)
#define MAX 2000004
#define MOD 1000000007
#define N 101
using namespace std;

typedef long long int ll;
typedef vector<vector<int> > matrix;

int path_count=0;
int n;
matrix visited(N,vector<int>(N) );
matrix A(N,vector<int>(N) );

void NoOfPaths(int i,int j)
{
    //cout<<"Hello\n";
    if((i==n-1) && (j==n-1))
    {
        path_count++;
        return;
    }

    visited[i][j]=1;

    if((j+1)<n && A[i][j+1]==0 && visited[i][j+1]==0)
    NoOfPaths(i,j+1);

    if((j-1)>=0 && A[i][j-1]==0 && visited[i][j-1]==0)
    NoOfPaths(i,j-1);

    if((i+1)<n && A[i+1][j]==0 && visited[i+1][j]==0)
    NoOfPaths(i+1,j);

    if((i-1)>=0 && A[i-1][j]==0 && visited[i-1][j]==0)
    NoOfPaths(i-1,j);

    visited[i][j]=0;
    return ;
}

int main()
{
    sd(n);
    int i=0,j=0;
    FOR(i,n)
    FOR(j,n)
    {
        sd(A[i][j]);
        visited[i][j]=0;
    }

    NoOfPaths(0,0);
    printf("%d\n",path_count);
    /*FOR(i,n)
    {
        FOR(j,n)
        printf("%d ",A[i][j]);
        printf("\n");
    }*/
    return 0;
}
