// A O(Logn) complexity program to count set bits in all numbers from 1 to n
#include <stdio.h>
#include<bits/stdc++.h>
#define ll long long int
using namespace std;


/* Returns position of leftmost set bit. The rightmost
   position is considered as 0 */
unsigned ll getLeftmostBit (ll n)
{
   ll m = 0;
   while (n  > 1)
   {
      n = n >> 1;
      m++;
   }
   return m;
}

/* Given the position of previous leftmost set bit in n (or an upper
   bound on leftmost position) returns the new position of leftmost
   set bit in n  */
unsigned ll getNextLeftmostBit (ll n, ll m)
{
   unsigned ll temp = 1 << m;
   while (n  < temp)
   {
      temp = temp >> 1;
      m--;
   }
   return m;
}

// The main recursive function used by countSetBits()
unsigned ll _countSetBits(unsigned ll n, ll m);

// Returns count of set bits present in all numbers from 1 to n
unsigned ll countSetBits(unsigned ll n)
{
   // Get the position of leftmost set bit in n. This will be
   // used as an upper bound for next set bit function
   ll m = getLeftmostBit (n);

   // Use the position
   return _countSetBits (n, m);
}

unsigned ll _countSetBits(unsigned ll n, ll m)
{
    // Base Case: if n is 0, then set bit count is 0
    if (n == 0)
       return 0;

    /* get position of next leftmost set bit */
    m = getNextLeftmostBit(n, m);

    // If n is of the form 2^x-1, i.e., if n is like 1, 3, 7, 15, 31,.. etc,
    // then we are done.
    // Since positions are considered starting from 0, 1 is added to m
    if (n == ((unsigned ll)1<<(m+1))-1)
        return (unsigned ll)(m+1)*(1<<m);

    // update n for next recursive call
    n = n - (1<<m);
    return (n+1) + countSetBits(n) + m*(1<<(m-1));
}
int main(){
ll n;
cin>>n;
while(n--){
    ll a,b;
    cin>>a>>b;
    ll m=countSetBits(a-1);
    ll n=countSetBits(b);
    cout<<n-m<<endl;
}
return 0;
}
