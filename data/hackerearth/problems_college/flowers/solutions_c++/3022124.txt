#include<iostream>
using namespace std;
typedef int T;
void quickSort(T arr[], int start, int end);
T partition(T arr[], int start, int end);
int main()
{
	int n,k;
	cin>>n>>k;
	int i;
	int cost[1000];
	for(i=0;i<n;i++)
	cin>>cost[i];
	quickSort(cost,0,n-1);
	long long answer=0;
	int x=0;
	int tmp=0;
	while(1)
	{
		if(n>=k)
		{
		for(i=tmp;i<tmp+k;i++)
		answer=answer+((x+1)*cost[i]);
		n=n-k;
		//cout<<n<<endl;
	    }
		else
		{
		for(i=tmp;i<tmp+n;i++)
		answer=answer+((x+1)*cost[i]);
		n=0;
	    }
	    if(n==0)
		break;
		tmp=tmp+k;
		x++;
	}
	cout<<answer;
}
void quickSort(int arr[], int start, int end)
{
    if (start < end)        //test for base case start == end
    {
        // Partition the array and get the pivot point.
        int p = partition(arr, start, end);

        // Sort the portion before the pivot point.
        quickSort(arr, start, p - 1);

        // Sort the portion after the pivot point.
        quickSort(arr, p + 1, end);
	}
	return;                 //base case
}

//***********************************************************
// partition() rearranges the entries in the array arr from *
// start to end so all values greater than or equal to the  *
// pivot are on the right of the pivot and all values less  *
// than are on the left of the pivot.                       *
//***********************************************************
T partition(T arr[], int start, int end)
{
    // The pivot element is taken to be the element at
    // the start of the subrange to be partitioned.
    T pivotValue = arr[start];
    T pivotPosition = start;

    // Rearrange the rest of the array elements to
    // partition the subrange from start to end.
    for (int pos = start + 1; pos <= end; pos++)
    {
        if (arr[pos] > pivotValue)
        {
            // arr[pos] is the "current" item.
            // Swap the current item with the item to the
            // right of the pivot element.
            swap(arr[pivotPosition + 1], arr[pos]);
            // Swap the current item with the pivot element.
            swap(arr[pivotPosition], arr[pivotPosition + 1]);
            // Adjust the pivot position so it stays with the
            // pivot element.
            pivotPosition ++;
        }
	}
    return pivotPosition;
}
