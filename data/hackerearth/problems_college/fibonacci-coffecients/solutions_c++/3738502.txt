#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <map>
#define INF_MAX 2147483647
#define INF_MIN -2147483647
#define INF_LL 9223372036854775807LL
#define INF 2000000000
#define PI acos(-1.0)
#define inf INT_MAX
using namespace std;
typedef long long int ll;
ll mod;
ll N;
ll arr[2000040];
ll tree[2000010][2][2] , qtree[2000010][2][2];
ll forone[2][2] = {{0,1},{1,-1}};
ll invalid_range[2][2] = {{0,0},{0,0}} , I[2][2] = {{1,0},{0,1}};
void matmult(ll a[][2],ll b[][2],ll c[][2])//multiply matrix a and b. put result in c
{
    ll i,j,k;
    for(i=0;i<2;i++)
    {
        for(j=0;j<2;j++)
        {
            c[i][j]=0;
            for(k=0;k<2;k++)
            {
                c[i][j]+=(1LL*(a[i][k]%mod)*(b[k][j]%mod))%mod;
                c[i][j]=c[i][j]%mod;
            }
        }
    }
 
}
void matpow(ll Z[][2],ll n,ll ans[][2])
//find ( Z^n )% M and return result in ans
{ 
    ll temp[2][2];
    ans[0][0]=1;
    ans[1][0]=0;
    ans[0][1]=0;
    ans[1][1]=1;
    ll i,j;
    while(n>0)
    {
        if(n&1)
        {
            matmult(ans,Z,temp);
            for(i=0;i<2;i++)
                for(j=0;j<2;j++)
                    ans[i][j]=temp[i][j];
        }
        matmult(Z,Z,temp);
        for(i=0;i<2;i++)
            for(j=0;j<2;j++)
                Z[i][j]=temp[i][j];
        n=n/2;
    }
    return;
     
} 
void build_tree(ll node , ll a , ll b){
	 ll sqrZ[2][2] = {{2,1},{1,1}};
	 ll Z[2][2]={{1,1},{1,0}}, I[2][2]={{1,0},{0,1}};//modify matrix a[][] for other recurrence relations
	if(a>b)
		return;	//out of range	
	 ll result[2][2];
	if(a==b)
	{
		if(a>1)
			matpow(Z , a  , tree[node]);
		else{
			for(ll i=0;i<2;i++){
				for(ll j=0;j<2;j++)
					tree[node][i][j] = Z[i][j];
			}
		}
		for(ll i=0;i<2;i++){
			for(ll j=0;j<2;j++)
				tree[node][i][j] = (1ll * arr[a]*tree[node][i][j])%mod;
		}
		return;
	}
	ll lnode , rnode;
	lnode = (node<<1);
	rnode = lnode + 1;
	build_tree(lnode , a , (a+b)/2);
	build_tree(rnode , (a+b)/2+1 , b);
	for(ll i=0;i<2;i++)
	{
		for(ll j=0;j<2;j++)
			tree[node][i][j] = 0;
	}
	for(ll i=0;i<2;i++){
		for(ll j=0;j<2;j++){
			tree[node][i][j] += ((tree[lnode][i][j]%mod) + (tree[rnode][i][j]%mod))%mod;
			if(tree[node][i][j] >= mod)
				tree[node][i][j] = (tree[node][i][j]%mod);
		}
	}
}
void update_tree(ll node, ll a, ll b, ll i, ll j, ll value) {
    ll sqrZ[2][2] = {{2,1},{1,1}};
	ll Z[2][2]={{1,1},{1,0}}, I[2][2]={{1,0},{0,1}};//modify matrix a[][] for other recurrence relations
	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return;    
  	if(a == b){ // Leaf node and valid one
  		if(a>1)
			matpow(Z , a  , tree[node]);
		else{
			for(ll i=0;i<2;i++){
				for(ll j=0;j<2;j++)
					tree[node][i][j] = forone[i][j];
			}
		}

		for(ll i=0;i<2;i++){
			for(ll j=0;j<2;j++)
				tree[node][i][j] = (1ll* value*tree[node][i][j])%mod;
		}

    	return;
	} 
	ll lnode , rnode; 
	lnode = (node<<1);
	rnode = lnode + 1; 
	update_tree(lnode , a, (a+b)/2, i, j, value); // Updating left child
	update_tree(rnode , 1+(a+b)/2, b, i, j, value); // Updating right child 
	for(ll i=0;i<2;i++)
	{
		for(ll j=0;j<2;j++)
			tree[node][i][j] = 0;
	}
	for(ll i=0;i<2;i++){
		for(ll j=0;j<2;j++){
			tree[node][i][j] += ((tree[lnode][i][j]%mod) + (tree[rnode][i][j]%mod))%mod;
			if(tree[node][i][j] >= mod)
				tree[node][i][j] = (tree[node][i][j]%mod);
		}
	}
 
}
void query_tree(ll node, ll a, ll b, ll i, ll j) {
	ll sqrZ[2][2] = {{2,1},{1,1}};
	if(a > b || a > j || b < i){
		
		for(ll i=0;i<2;i++)
		{
			for(ll j=0;j<2;j++)
				qtree[node][i][j] = 0;
		}
		return;
	} 
	if(a >= i && b <= j) // Current segment is totally within range [i, j]
	{		
		for(ll i=0;i<2;i++)
		{
			for(ll j=0;j<2;j++)
				qtree[node][i][j] = tree[node][i][j];
		}
		return; 
	}
	ll lnode , rnode; 
	lnode = (node<<1);
	rnode = lnode + 1; 
	query_tree(lnode , a, (a+b)/2, i, j); // Updating left child
	query_tree(rnode , 1+(a+b)/2, b, i, j); // Updating right child 
	for(ll i=0;i<2;i++){
		for(ll j=0;j<2;j++)
			qtree[node][i][j] = 0;
	}
	for(ll i=0;i<2;i++){
		for(ll j=0;j<2;j++){
			qtree[node][i][j] += ((qtree[lnode][i][j]%mod) + (qtree[rnode][i][j]%mod))%mod;
			if(qtree[node][i][j] >= mod)
				qtree[node][i][j] = (qtree[node][i][j]%mod);
		}
	}
	return;	
}
int  main()
{	
ll Q;
ll temp1[2][2] , temp2[2][2];
scanf("%lld %lld %lld",&N,&Q,&mod);
for(ll i=1;i<=N;i++)
	scanf("%lld",&arr[i]);
build_tree(1 , 1 , N);
ll Z[2][2]={{1,1},{1,0}};
ll a , b;
ll  flag;
ll ans = 0;
while(Q--)
{
	cin >> flag >> a >> b;
	if(flag==1){
		update_tree(1 , 1 , N , a , a , b );
	}
	else if(flag==2)	
	{
		query_tree(1 , 1 , N , a , b);
		ll inverse_Z[2][2] = {{0,1},{1,-1}};
		matpow(inverse_Z ,a , temp2);
		matmult(qtree[1] , temp2 , temp1);
		ll answer = temp1[0][0];
		while(answer<0)
			answer+=mod;
		printf("%lld\n" , answer);
	}
}
return 0;
}




