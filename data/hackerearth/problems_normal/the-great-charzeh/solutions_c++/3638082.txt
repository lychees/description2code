#include <bits/stdc++.h>
#define sz(x) (int((x).size()))
#define pb push_back
#define eb emplace_back
#define all(x) (x).begin(), (x).end()
template<typename T> bool domax(T &a, T b) { return (b > a ? (a = b, true) : false); }
template<typename T> bool domin(T &a, T b) { return (b < a ? (a = b, true) : false); }
typedef long long ll;

const int maxn = 305, max = 605;

// from e-maxx.ru
struct flow {
    struct edge {
        int a, b, cap, flow;
    };

    int n, s, t, d[max], ptr[max], q[max];
    std::vector<edge> e;
    std::vector<int> g[max];

    void add_edge (int a, int b, int cap) {
        edge e1 = { a, b, cap, 0 };
        edge e2 = { b, a, 0, 0 };
        g[a].push_back ((int) e.size());
        e.push_back (e1);
        g[b].push_back ((int) e.size());
        e.push_back (e2);
    }

    bool bfs() {
        int qh=0, qt=0;
        q[qt++] = s;
        memset (d, -1, n * sizeof d[0]);
        d[s] = 0;
        while (qh < qt && d[t] == -1) {
            int v = q[qh++];
            for (size_t i=0; i<g[v].size(); ++i) {
                int id = g[v][i],
                    to = e[id].b;
                if (d[to] == -1 && e[id].flow < e[id].cap) {
                    q[qt++] = to;
                    d[to] = d[v] + 1;
                }
            }
        }
        return d[t] != -1;
    }

    int dfs (int v, int flow) {
        if (!flow)  return 0;
        if (v == t)  return flow;
        for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {
            int id = g[v][ptr[v]],
                to = e[id].b;
            if (d[to] != d[v] + 1)  continue;
            int pushed = dfs (to, std::min (flow, e[id].cap - e[id].flow));
            if (pushed) {
                e[id].flow += pushed;
                e[id^1].flow -= pushed;
                return pushed;
            }
        }
        return 0;
    }

    int dinic() {
        int flow = 0;
        for (;;) {
            if (!bfs())  break;
            memset (ptr, 0, n * sizeof ptr[0]);
            while (int pushed = dfs (s, 1e9))
                flow += pushed;
        }
        return flow;
    }
};


int n, m, a[maxn], f[maxn+maxn];

bool go(int k) {
    flow x;
    x.n = n+n+2;
    x.s = n+n;
    x.t = n+n+1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) if (f[i + a[j]] <= k) x.add_edge(i, n+j, 1);
        x.add_edge(x.s, i, 1);
        x.add_edge(n+i, x.t, 1);
    }
    return x.dinic() == n;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++) scanf("%d", a+i);
    for (int i = 0; i < n+m-1; i++) scanf("%d", f+i);
    int l = 0, h = 2e9;
    while (l < h) {
        int m = (l+h)/2;
        if (go(m)) h = m;
        else l = m+1;
    }
    printf("%d\n", l);
}

