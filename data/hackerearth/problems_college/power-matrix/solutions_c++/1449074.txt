#include<iostream>
#include<vector>

using namespace std;

class matrix
{	

	private:
		vector<vector<long long> > M;
	public:
		matrix(){}
		
		matrix(int rSize,int cSize)
		{
			M.assign(rSize,vector<long long>(cSize));	
		}

		void assign(int rSize,int cSize)
		{
			M.assign(rSize,vector<long long>(cSize));	
		}
		
		vector<long long>& operator[](int i)
		{
			return M[i];
		}
		
		
		int rowSize() const
		{
			return M.size();
		}
		int columnSize() const
		{
			if(M.size()==0)
				return 0;
			else
				return M[0].size();
		}
		matrix operator *(matrix B) //assumes matricces are multiplicable
		{
			matrix &A=*this;
			matrix temp(A.rowSize(),B.columnSize());
			
			for(int i=0;i<temp.rowSize();i++){
			
				for(int j=0;j<temp.columnSize();j++){
				
					for(int k=0;k<B.rowSize();k++){
					
						temp[i][j]+=A[i][k]*B[k][j];
						temp[i][j]%=1000000007;
					}
				}
			}
			
			return temp;
		}
		
		matrix operator %(int MOD)
		{
			matrix temp(rowSize(),columnSize());
			for(int i=0;i<rowSize();i++)
				for(int j=0;j<columnSize();j++)
					temp[i][j]=M[i][j]%MOD;
			return temp;
		}
		void clear()
		{
			M.clear();
		}
		
		static matrix identity(int i)
		{
			matrix X;
			X.assign(i,i);
			for(int j=0;j<i;j++)
				X[j][j]=1;	
			return X;
		}
};

matrix p(matrix n,long long m,int MOD)
{
    if(m==0) 
		return matrix::identity(n.rowSize());
    
    matrix x=p(n,m/2,MOD);
    if(m%2==0) 
               return (x*x)%MOD;
    else
               return (((x*x)%MOD)*n)%MOD;
}


int main()
{
	int t;
	cin>>t;
	while(t--){
		long long M,N;
		cin>>M>>N;
		matrix T(M,M);
		T.assign(M,M);
		for(int i=0;i<T.rowSize();i++)
			for(int j=0;j<T.columnSize();j++)
				cin>>T[i][j];
		matrix ans=p(T,N,1000000007);
		
		for(int i=0;i<M;i++){
			for(int j=0;j<M;j++){
				cout<<ans[i][j]<<" ";
			}
			cout<<"\n";
		}
	}
	
	
	
	
	
	
		
}