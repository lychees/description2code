#include<bits/stdc++.h>
#include <math.h>
using namespace std;

template< class T > inline T _abs(const T n) { return (n < 0 ? -n : n); }
template< class T > inline T _max(const T a, const T b) { return (!(a < b) ? a : b); }
template< class T > inline T _min(const T a, const T b) { return (a < b ? a : b); }
template< class T > inline void _setmax(T &a, const T b) { if(a < b) a = b; }
template< class T > inline void _setmin(T &a, const T b) { if(b < a) a = b; }
template< class T > inline T _sqr(const T x) { return x * x; }

const double EPS = 1e-9;
const double PI = acos(-1.0);
const int INF = 0x7f7f7f7f;
const int TMAX = 1 << 18;

#define MOD 1000000007
#define MAX 100007
#define ll long long
#define rep2(i,a,b) for(int i = a; i < b; i++)
#define rep1(i,n) for(int i = 0; i < n; i++)
#define repll2(i,a,b) for(ll i = a; i < b; i++)
#define repll1(i,n) for(ll i = 0; i < n; i++)
#define slld(t) scanf("%lld",&t)
#define sld(t) scanf("%ld",&t)
#define sd(t) scanf("%d",&t)
#define pd(t) printf("%d\n",t)
#define plld(t) printf("%lld\n",t)
#define pcc pair<char,char>
#define pii pair< int, int >
#define psi pair< string, int >
#define pll pair<ll,ll>
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define mp(a,b) make_pair(a,b)
//#define F first
//#define S second
#define pb1(x) push_back(x);
#define pb2(x) pop_back(x);
/*
  
#define gc getchar_unlocked
inline void read(ll &x){

        x=0;
        register char c=gc();
        for(;c<'0' || c>'9';c=gc());
         for(;c>='0' && c<='9';c=gc())
          x=(x<<3)+(x<<1)+(c-'0');
      }
inline void write(ll x){

         register char buffor[35];
         register ll i=0;
         do{
               buffor[i++]=(x%10)+'0';
               x/=10;
            } while(x);
           i--;
            while(i>=0) putchar_unlocked(buffor[i--]);
            putchar_unlocked('\n');
       }
*/
ll getSum(ll BITree[], ll index)
{
    ll sum = 0; // Initialize result
 
    // Traverse ancestors of BITree[index]
    while (index > 0)
    {
        // Add current element of BITree to sum
        sum += BITree[index];
 
        // Move index to parent node in getSum View
        index -= index & (-index);
    }
    return sum;
}
 
// Updates a node in Binary Index Tree (BITree) at given index
// in BITree.  The given value 'val' is added to BITree[i] and
// all of its ancestors in tree.
void updateBIT(ll BITree[], ll n, ll index, ll val)
{
    // Traverse all ancestors and add 'val'
    while (index <= n)
    {
       // Add 'val' to current node of BI Tree
       BITree[index] += val;
 
       // Update index to that of parent in update View
       index += index & (-index);
    }
}
 
// Converts an array to an array with values from 1 to n
// and relative order of smaller and greater elements remains
// same.  For example, {7, -90, 100, 1} is converted to
// {3, 1, 4 ,2 }
void convert(ll arr[], ll n)
{
    // Create a copy of arrp[] in temp and sort the temp array
    // in increasing order
    ll temp[n];
    for (ll i=0; i<n; i++)
        temp[i] = arr[i];
    sort(temp, temp+n);
 
    // Traverse all array elements
    for (ll i=0; i<n; i++)
    {
        // lower_bound() Returns poller to the first element
        // greater than or equal to arr[i]
        arr[i] = lower_bound(temp, temp+n, arr[i]) - temp + 1;
    }
}
 
// Returns inversion count arr[0..n-1]
ll getInvCount(ll arr[], ll n)
{
    ll invcount = 0; // Initialize result
 
     // Convert arr[] to an array with values from 1 to n and
     // relative order of smaller and greater elements remains
     // same.  For example, {7, -90, 100, 1} is converted to
    //  {3, 1, 4 ,2 }
    convert(arr, n);
 
    // Create a BIT with size equal to maxElement+1 (Extra
    // one is used so that elements can be directly be
    // used as index)
    ll BIT[n+1];
    for (ll i=1; i<=n; i++)
        BIT[i] = 0;
 
    // Traverse all elements from right.
    for (ll i=n-1; i>=0; i--)
    {
        // Get count of elements smaller than arr[i]
        invcount += getSum(BIT, arr[i]-1);
 
        // Add current element to BIT
        updateBIT(BIT, n, arr[i], 1);
    }
 
    return invcount;
}
typedef struct stru{
       ll sec,fir;
}S;

 
bool comp(const S &A,const S &B) {
       
       return A.fir < B.fir;
}

S po[100001];
ll p[100001];
ll  miu[100001], cnt = 0;
ll a[100000], n;
ll has[1000001];
vector<ll> cont[100001];
ll cont2[100001];
ll ar[100001];
int  main()
{
	
	slld(n);
	
	ll Max = 1;
	for (ll i = 0; i < n; ++ i) 
	{
		scanf("%lld", a + i);
		Max = max(Max, a[i]); 
		cont[a[i]].push_back(i);
	}
	rep2(i,1,Max+1)
	{
		ll ele=0;
		for(ll j=i;j<=Max;j+=i)
		{
			ll ku=0,siz=cont[j].size();
			while(ku<siz)
			{
				po[ele].fir=cont[j][ku];
				po[ele].sec=j;
				ku++;
				ele++;
			}
		//	cout<<"jnf "<<j<<" "<<cont[j]<<endl;
		}
		sort(po,po+ele,comp);
		for(ll yt=0;yt<ele;yt++)
		{
			ar[yt]=po[yt].sec;
		}
		cont2[i]=getInvCount(ar, ele);
		//cout<<i<<" nhkjghd "<<cont2[i]<<endl;
	}
	miu[1] = 1;
	for (ll i = 2; i <= Max; ++ i) {
		if (! p[i]) p[cnt ++] = i, miu[i] = - 1;
		for (ll j = 0; j < cnt && p[j] * i <= Max; ++ j) {
			p[p[j] * i] = 1;
			miu[p[j] * i] = - miu[i];
			if (i % p[j] == 0) {
				miu[i * p[j]] = 0;
				break; 
			}
		}
	}	
 
//	for (ll i = 0; i < n; ++ i) {
//		for (ll j = 1; j * j <= a[i]; ++ j) 
//			if (a[i] % j == 0) {
//				has[j] ++;
//				if (j * j != a[i]) has[a[i] / j] ++; 
//			}
//	}
 
	long long ans = 0;
 
	for (ll i = 1; i <= Max; ++ i)
		if ( miu[i]) ans += 1ll * miu[i] * cont2[i] ;
 
	cout << ans << endl; 
	
}
