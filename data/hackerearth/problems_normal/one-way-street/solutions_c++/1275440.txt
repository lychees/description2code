#include<bits/stdc++.h>
using namespace std ;
const int maxn = 10005 ;
int chainHead[maxn] , chainInd[maxn]  , chainsize[maxn] , chainpos[maxn] ,  pos[maxn] , totchain , c  , trsz[maxn] , pa[maxn][18] , par[maxn]
, depth[maxn];
vector < int > g[maxn] ;
int n ;

void hld( int node , int p )
{
    if ( chainHead[totchain] == -1)
        chainHead[totchain] = node ;


    pos[node] = c++ ; // for segment tree
    chainInd[node] = totchain ; // in which chain node present
    chainpos[node] = chainsize[totchain] ;
    chainsize[totchain]++ ; // size of chain increases by 1
    int ind = -1 , maxi = -1 ;

    for ( int j = 0  ; j < g[node].size() ; j++)
    {
        int v = g[node][j] ;
        if ( v != p )
        {
            if ( trsz[v] > maxi )
            {
                maxi  = trsz[v] ;
                ind = j ;
            }
        }

    }

    if ( ind != - 1)
    hld( g[node][ind]  , node ) ;  // expand the chain

    for ( int j = 0  ; j < g[node].size() ; j++)
    {

        int v = g[node][j] ;
        if ( ( v != p ) && ( j != ind ) )
        {
            totchain++ ;
            hld( v , node ) ;
        }

    }
}

int  lca ( int u , int v  )
{
    if ( depth[u] < depth[v] )
    swap ( u , v ) ;

   int diff = depth[u] - depth[v] ;

   for ( int i = 15 ; i > -1 ; i--)
     {
         if ( ( 1 << i ) <= ( depth[u] - depth[v] ) )
         u = pa[u][i] ;
     }
     if ( u == v )
            return u ;

     for ( int i = 15 ; i > -1 ; i--)
     {
         if( pa[u][i] != pa[v][i] )
         {
             u = pa[u][i] ;
             v = pa[v][i] ;
         }
     }

     if ( u == v ) return u ;
     return pa[u][0] ;

}

void callca()
{

    for( int i = 1 ; i <= n ; i++ )
        for ( int j = 0 ; j < 16 ; j++)
        pa[i][j] = -1 ;


    for ( int i = 1 ; i <= n ; i++)
        pa[i][0] = par[i] ;

    for ( int j = 1 ; j < 16 ; j++)
    {
        for ( int i = 1 ; i <= n ; i++)
        {
            if ( pa[i][j-1] != -1)
            pa[i][j] = pa[pa[i][j-1]][j-1] ;
        }
    }
}



void dfs ( int root , int p , int dep )
{
    par[root] = p ;
    depth[root] = dep ;
    trsz[root] = 1 ;
    for ( int j = 0 ; j < g[root].size() ; j++)
    {
        int v = g[root][j] ;
        if ( v != p )
        {
            dfs(v , root , dep + 1 ) ;
            trsz[root] += trsz[v] ;
        }
    }
}




int main()
{
    int fr , from , to , a, b , t , ans , cas ;
    c = 0 , totchain = 0 ;
    scanf("%d" , &cas ) ;
    while ( cas--)
    {


    scanf("%d" , &n) ;
    for ( int i = 1 ; i <= n ; i++)
        g[i].clear() ;

    for ( int i = 1 ; i < n ; i++)
    {
        scanf("%d%d" ,&fr , &to) ;
        g[fr].push_back(to) ;
        g[to].push_back(fr) ;
    }

    for ( int i = 1 ; i <= n ; i++) depth[i] = 0 ;

    dfs( 1 , -1 , 0 ) ;

    callca() ;
  //  hld( 0 , -1) ;
    scanf("%d" , &t) ;

    while ( t-- )
    {
        ans = 0 ;
        scanf("%d%d" ,&from , &to) ;
        int c1 = lca( from , to ) ;
        if ( c1 == from )
        {
          ans = ( 2 * abs( depth[from] - depth[to]) ) - 1  ;
        }
        else if ( c1 == to )
        {
            ans = ( 2 * abs( depth[from] - depth[to]) );

        }
        else
        {
            ans =  2 * abs( depth[from] - depth[c1]) ;
            ans += 2 * abs( depth[to] - depth[c1]) - 1 ;
        }
        cout << ans << endl ;
    }

    }
    return 0 ;
}

