#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <ctime>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>

using namespace std;

#define dbg(x) cout << #x << " = " << (x) << endl
#define dbg2(x,y) cout << #x << " = " << (x) << ", " << #y << " = " << (y) << endl
#define dbg3(x,y,z) cout << #x << " = " << (x) << ", " << #y << " = " << (y) << ", " << #z << " = " << (z) << endl

template<class T> inline T cabs(T x) { return x > 0 ? x : (-x); }
template<class T> inline T gcd(T x, T y) { return (y == 0) ? x : gcd(y, x % y); }

#define out(x) cout << (x) << endl
#define out2(x,y) cout << (x) << " " << (y) << endl
#define out3(x,y,z) cout << (x) << " " << (y) << " " << (z) << endl

const int maxN = 9;
#define N maxN
const int Mod  = 1000000007;

long long num; int ba[3][3], p[9], q[9];

struct node {
    int mat[maxN][maxN];
    inline void setZero() {
        for(int i = 0, j; i < N; i ++) {
            for(j = 0; j < N; j ++) {
                mat[i][j] = 0;
            }
        }
    }
    inline void setUnit() {
        for(int i = 0, j; i < N; i ++) {
            for(j = 0; j < N; j ++) {
                mat[i][j] = 0;
            } mat[i][i] = 1;
        }
    }
    inline void setBase() {
        for(int a = 0; a < N; a ++) {
            int i = a / 3, j = a % 3;
            for(int b = 0; b < N; b ++) {
                int x = b / 3, y = b % 3;
                mat[a][b] = cabs(i - x) + cabs(j - y) + cabs(i + j - x - y);
            }
        }
    }
} ei; node t[50];

inline void eMulti(node x, node &y, node &z)
{
    static int i, j, k;
    for(i = 0; i < N; i ++) {
        for(j = i; j < N; j ++) {
            z.mat[i][j] = 0;
            for(k = 0; k < N; k ++) {
                if( x.mat[i][k] && y.mat[k][j] ) {
                    z.mat[i][j] += ((long long)x.mat[i][k] * y.mat[k][j]) % Mod;
                    if( z.mat[i][j] > Mod ) z.mat[i][j] -= Mod;
                }
            }
            z.mat[j][i] = z.mat[i][j];
        }
    }
}

inline void calc()
{
    static int i, j, k;
    for(i = 0; i < 3; i ++) {
        for(j = 0; j < 3; j ++) {
            q[3 * i + j] = ba[i][j];
        }
    }
    for(i = 0; num > 0; num >>= 1, i ++) {
        if( num & 1 ) {
            for(j = 0; j < 9; j ++) p[j] = q[j];
            for(j = 0; j < 9; j ++) {
                q[j] = 0;
                for(k = 0; k < 9; k ++) {
                    q[j] += ((long long)t[i].mat[j][k] * p[k]) % Mod;
                    if( q[j] > Mod ) q[j] -= Mod;
                }
            }
        }
    }
    for(i = 0; i < 3; i ++) {
        for(j = 0; j < 3; j ++) {
            if( j ) printf(" ");
            printf("%d", q[3 * i + j]);
        } printf("\n");
    }
}

int main()
{
    //freopen("data.in", "r", stdin);
    t[0].setBase();
    for(int i = 1; i < 48; i ++)
        eMulti(t[i - 1], t[i - 1], t[i]);
    int nt, i, j;
    scanf("%d", &nt);
    for(; nt > 0; nt --) {
        scanf("%lld", &num);
        for(i = 0; i < 3; i ++) {
            for(j = 0; j < 3; j ++) {
                scanf("%d", &ba[i][j]);
            }
        }
        calc();
    }
    return 0;
}
