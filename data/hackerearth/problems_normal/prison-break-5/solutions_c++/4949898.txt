#include <iostream>

using namespace std;

int counter=0;
int N;
int A[20][20];
bool visited[20][20];

void initialise()
      {
          for(int i=1;i<=N;i++)
             for(int j=1;j<=N;j++)
                visited[i][j]=false;    //everything marked unvisited
      }

void dfs(int x,int y)
     {
         //cout<<x<<" "<<y<<" "<<N<<endl;
         if((x==N)&&(y==N))         // Base case to increment the no. of ways after prisoner reaches the end
            {
                ++counter;
                //initialise();
            }
         else
         {
         visited[x][y]=true;      // Every way has a different if statement associated with it, and everything
                                  // except the parent node gets false again
             if((visited[x][y+1]==false)&&(y<=N-1)&&(A[x][y+1]==0))
             {
                 //visited[x][y+1]=true;
                 dfs(x,y+1);
             }
             if((visited[x+1][y]==false)&&(x<=N-1)&&(A[x+1][y]==0))
             {
                 //visited[x+1][y]=true;
                 dfs(x+1,y);
             }
             if((visited[x-1][y]==false)&&(x>=2)&&(A[x-1][y]==0))
             {
                 //visited[x-1][y]=true;
                 dfs(x-1,y);
             }
             if((visited[x][y-1]==false)&&(y>=2)&&(A[x][y-1]==0))
             {
                 //visited[x][y-1]=true;
                 dfs(x,y-1);
             }
                  visited[x][y]=false;  // everything except parent gets unvisited
         }
     }
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        cin>>N;
        for(int i=1;i<=N;i++)
            for(int j=1;j<=N;j++)
               cin>>A[i][j];
        initialise();
        /*for(int i=1;i<=N;i++)
        {
            for(int j=1;j<=N;j++)
               cout<<visited[i][j]<<" ";
         cout<<endl;
        }*/
        if((A[0][0]==1)||(A[N][N]==1))
            counter=0;
        else
        {
            dfs(1,1);
        }
        cout<<counter<<endl;
        counter=0;
    }
}
