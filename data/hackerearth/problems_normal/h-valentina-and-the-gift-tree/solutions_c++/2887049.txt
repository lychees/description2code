#include<bits/stdc++.h>

using namespace std;

#define rep(i,j) for(int i=0;i<(j);++i)
#define rrep(i,j) for(int i=j-1;i>=0;--i)
#define reps(i,j,k) for(int i=(j);i<=(k);++i)
#define X first
#define Y second
#define pb push_back
#define all(X) X.begin(),X.end()
const int MOD=1e18+7;
typedef pair<int,int> pii;
typedef long long ll;
typedef vector<vector<int>> Graph;

struct Seg{
  ll l,r,whole,all;
  Seg(ll v=-MOD){
    l=r=whole=all=v;
  }
  static Seg e;
};
Seg Seg::e=Seg();

Seg operator+(const Seg &l,const Seg &r){
  if(l.all==-MOD) return r;
  if(r.all==-MOD) return l;
  Seg re;
  re.l=max(l.l,l.whole+r.l); 
  re.r=max(r.r,r.whole+l.r);
  re.whole=l.whole+r.whole;
  re.all=max({l.all ,r.all ,l.r+r.l ,re.l, re.r, re.whole});
  return re;
}

void pr(Seg t){
  cout<<"{"<<t.l<<","<<t.whole<<","<<t.r<<":"<<t.all<<"}"<<endl;
}
class Lca{
public:
  vector<int> dep,cld;
  Graph par;
  vector<vector<Seg>> sum;
  const int LOGN=18;
  void dfs(const Graph &g,int root){
    int n=g.size();
    vector<int> vst(n);
    stack<int> st; st.push(root);
    while(!st.empty()){
      int v=st.top(); st.pop();
      if(vst[v]==1){
	vst[v]=2;
	rep(i,g[v].size()) if(g[v][i]!=par[v][0])
	  cld[v]+=cld[g[v][i]]+1;
      }else if(vst[v]==0){
	st.push(v);
	vst[v]=1;
	rep(i,g[v].size()) if(!vst[g[v][i]]){
	  dep[g[v][i]]=dep[v]+1;
	  par[g[v][i]][0]=v;
	  st.push(g[v][i]);
	}
      }
    }
  }

  Lca(const Graph &g,const vector<Seg> &vals){
    int n=g.size();
    par.resize(n,vector<int>(LOGN,-1));
    dep.resize(n); cld.resize(n); dfs(g,0);
    sum.resize(n,vector<Seg>(LOGN,Seg()));
    rep(i,n) sum[i][0]=vals[i];
    rep(i,LOGN-1) rep(v,n){
      if(par[v][i]>=0)
	sum[v][i+1]=sum[v][i]+sum[par[v][i]][i];
      par[v][i+1]=par[v][i]<0?-1:par[par[v][i]][i];
    }
  }
  int anc(int v,int n){
    Seg re;
    rep(i,LOGN) if(n>>i&1){
      re=re+sum[v][i];
      if((v=par[v][i])<0) break;
    }
    return v;
  }
  int LCA(int v,int w){
    if(dep[v]>dep[w]){
      swap(v,w);
    }
    w=anc(w,dep[w]-dep[v]);
    rrep(i,LOGN)
      if(par[v][i]!=par[w][i]){
	v=par[v][i];
	w=par[w][i];
      }
    return v==w?v:par[v][0];
  }

  Seg solve(int p,int v,int clopen=0){
    int d=dep[v]-dep[p]+1-clopen;
    //cout<<p<<","<<v<<":"<<d<<endl;
    Seg re;
    if(d<0) return re;
    rep(i,LOGN) if(d>>i&1){
      re=re+sum[v][i];
      v=par[v][i];
      //cout<<v;pr(re);
    }
    return re;
  }
};


int main(){
  ios_base::sync_with_stdio(0);
  int n;
  scanf("%d",&n);
  int x,y;
  Graph g(n);
  rep(i,n-1){
    scanf("%d%d",&x,&y); --x ;--y;
    g[x].pb(y);
    g[y].pb(x);
  }
  vector<Seg> vs(n);
  rep(i,n){
  scanf("%d",&x);
    vs[i]=Seg(x);
  }
  Lca h(g,vs);
  int q;
  scanf("%d",&q);
  while(q--){
    scanf("%d%d",&x,&y); --x ;--y;
    int p=h.LCA(x,y);
    Seg re;
    if(x==p){
      re=h.solve(x,y);
    }else if(y==p){
      re=h.solve(y,x);
    }else{
      Seg l=h.solve(p,x),r=h.solve(p,y,1);
      //pr(l); pr(r);
      swap(r.r,r.l);
      re=l+r;
    }
    //cout<<p<<endl;    pr(re);
    assert(re.all>-MOD);
    printf("%lld\n",re.all);
  }
  return 0;
}
