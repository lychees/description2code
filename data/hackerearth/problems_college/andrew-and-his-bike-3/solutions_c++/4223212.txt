#include<bits/stdc++.h>
#include <math.h>
using namespace std;

template< class T > inline T _abs(const T n) { return (n < 0 ? -n : n); }
template< class T > inline T _max(const T a, const T b) { return (!(a < b) ? a : b); }
template< class T > inline T _min(const T a, const T b) { return (a < b ? a : b); }
template< class T > inline void _setmax(T &a, const T b) { if(a < b) a = b; }
template< class T > inline void _setmin(T &a, const T b) { if(b < a) a = b; }
template< class T > inline T _sqr(const T x) { return x * x; }

const double EPS = 1e-9;
const double PI = acos(-1.0);
const int INF = 0x7f7f7f7f;
const int TMAX = 1 << 18;

#define MOD 1000000007
#define MAX 100007
#define ll long long
#define rep2(i,a,b) for(int i = a; i < b; i++)
#define rep1(i,n) for(int i = 0; i < n; i++)
#define repll2(i,a,b) for(ll i = a; i < b; i++)
#define repll1(i,n) for(ll i = 0; i < n; i++)
#define slld(t) scanf("%lld",&t)
#define sld(t) scanf("%ld",&t)
#define sd(t) scanf("%d",&t)
#define pd(t) printf("%d\n",t)
#define plld(t) printf("%lld\n",t)
#define pcc pair<char,char>
#define pii pair< int, int >
#define psi pair< string, int >
#define pll pair<ll,ll>
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define mp(a,b) make_pair(a,b)
#define F first
#define S second
#define pb1(x) push_back(x);
#define pb2(x) pop_back(x);
/*

#define gc getchar_unlocked
inline void read(int &x){

        x=0;
        register char c=gc();
        for(;c<'0' || c>'9';c=gc());
         for(;c>='0' && c<='9';c=gc())
          x=(x<<3)+(x<<1)+(c-'0');
      }
inline void write(int x){

         register char buffor[35];
         register int i=0;
         do{
               buffor[i++]=(x%10)+'0';
               x/=10;
            } while(x);
           i--;
            while(i>=0) putchar_unlocked(buffor[i--]);
            putchar_unlocked('\n');
       }
*/
bool visited[100005];
int ans[100005];
class graph
{
	int V;// number of vertices
	
	list<int>adj[100001];//pointer to array  contyaining adjency matrix
	int dfsUntil(int v);
	public:
		graph(int v);//constructo
		void addEdge(int v,int w);
		void dfs(int v,int roo);//dfs tranversal rechable from v
};
graph::graph(int v)
{
	this->V=v;
}
void graph::addEdge(int v,int w)
{
	adj[v].push_back(w);//add wto v,s list
	adj[w].push_back(v);
}
int graph::dfsUntil(int v)
{   
int count=1;
	visited[v]=true;
	//cout<<v<<" ";
	list<int>::iterator i;
	for(i=adj[v].begin();i!=adj[v].end();++i)//please see here by changin i++->++i
	{
		if(!visited[*i])
		{
		    count+=dfsUntil(*i);
		}
	}
	ans[v]=count;
	return count;
}
void graph::dfs(int v,int root)
{
	for(int i=0;i<=v;i++)
	{
		visited[i]=false;
	}
	dfsUntil(root);
}
int main()
{
	int n,A,visited_node,parentNode,childNode;//n-number of node,m-number of edge 
    //scanf("%intd",&t);
	//for(int i=0;i<t;i++)

		scanf("%d",&n);
		graph g(n);//contructor
		for(int j=0;j<n-1;j++)
		{
			scanf("%d %d",&parentNode,&childNode);
		//	cin>>parentNode>>childNode;
			g.addEdge(parentNode,childNode);
		}
		g.dfs(n,1);
		printf("%d ",ans[1]-1);
		for(ll j=2;j<=n;j++)
		{
			printf("%d ",ans[j]);
		}
		printf("\n");

}