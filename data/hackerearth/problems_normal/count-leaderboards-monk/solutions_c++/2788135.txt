/* Problem asks us to find total number of global leaderboards possible when there are N contestants and the contestants are divided into rooms ...There are many possibilities like all contestants in one room,a single contestant in one room and so on.....

  Since finding out the combinations of different rooms in which contestants can be put is difficult...We have a different approach

Let L(N) be the number of global leaderboards possible when there are n contestants..

    L(1)=1 
  
    Now if a new contestant arrives,we can make him share room with A contestants where 0<=A<=N ....Total ways of selecting A candidates binomial(N,A) .Suppose he is in room with A contestants then number of possible leaderboards in that room will be (A+1)!

Total number of global leaders with A+1 contestants = binomial(N,A)*(A+1)! 

    Now we have (N-A) contestants waiting to get their room..

    Possible arrangements/global leaderboards of N-A contestants will be L(N-A) 

   L(N+1)=summation for A=0 to A=N (binomial(N,A)*(A+1)!*L(N-A)

   Thus we have obtained our recurrence relation., base case is L(1)=1.

*/

#include<bits/stdc++.h>
using namespace std;

#define MOD 1000000007

int main(){

   int n,k;
   
   long long binomial[1002][1002]={0},L[1002]={0},fact[1002]={0};

   L[1]=1;

   for(int i=0;i<=1001;++i){

       binomial[i][0]=binomial[i][i]=1;
       int k=i>>1;
       for(int j=1;j<=k;++j){
 
          binomial[i][j]=binomial[i][i-j]=(binomial[i-1][j]+binomial[i-1][j-1])%MOD;

       } 

   }

   fact[0]=1;

   for(int i=1;i<=1001;++i){

        fact[i]=i*fact[i-1];
        fact[i]%=MOD;

   }

   L[0]=1;
 
   L[1]=1;
 
   for(int i=2;i<=1001;++i){


        for(int A=0;A<=i;++A){

            long long ways=(binomial[i-1][A]*fact[A+1])%MOD;

            ways=(ways*L[i-1-A])%MOD;

            L[i]+=ways;   

            L[i]%=MOD;

        }

   }
   


   scanf("%d %d",&n,&k);

  
   printf("%lld\n",(L[n]*binomial[n][k])%MOD);


   return 0;
}
  
