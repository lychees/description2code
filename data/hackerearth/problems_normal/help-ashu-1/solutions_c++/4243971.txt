#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
int n, q, a[maxn];

typedef struct segmenttree
{
	int odd;
	int even;
}segmenttree;
segmenttree st[4*maxn],s1;

void merge(segmenttree &p,segmenttree &left,segmenttree &right)
{
	p.odd=left.odd+right.odd;
	p.even=left.even+right.even;
}
void buildst(int index,int ss,int se)
{
	if(ss==se)
	{
		if(a[ss]%2==0)
		{
		
		st[index].even=1;
		st[index].odd=0;
		return;
		}
		else{
		
		st[index].even=0;
		st[index].odd=1;
		return;}
	}
	int mid=(ss+se)>>1;
	buildst(2*index,ss,mid);
	buildst(2*index+1,mid+1,se);
	merge(st[index],st[2*index],st[2*index+1]);
}
void update(int idx,int ss,int se, int pos, int v){
      	if( ss == se ) {
        	a[ss] = v;
        		if(a[ss]%2==0)
		{
		
		st[idx].even=1;
		st[idx].odd=0;
		}
		else{
		
		st[idx].even=0;
		st[idx].odd=1;}
        	return;
      	}	
      	int mid = ( ss + se ) >> 1;
      	if( pos <= mid )
			update(2*idx, ss, mid, pos, v);
		else
        	update(2*idx+1, mid+1, se, pos, v);
	    merge(st[idx], st[2*idx], st[2*idx+1]);
    }
segmenttree query(int idx,int ss,int se,int l,int r){
		if( l > se || r < ss ) return s1;
		if( l <= ss && se <= r ) return st[idx];
		int mid = ( ss + se ) >> 1;
		segmenttree L = query(2*idx, ss, mid, l, r);
		segmenttree R = query(2*idx+1, mid+1, se, l, r);
		segmenttree res;
      	merge(res, L, R);
      	return res;
	}
int main()
{
	int t,i,x,y;
	segmenttree s;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	cin>>q;
	buildst(1,1,n);
	//cout<<"r";
	while(q--)
	{
		cin>>t>>x>>y;
		if(t==0)
		{
			update(1,1,n,x,y);
		}
		else if(t==1)
		{
			s=query(1,1,n,x,y);
			cout<<s.even<<"\n";
		}
		else
		{
			s=query(1,1,n,x,y);
			cout<<s.odd<<"\n";
		}
	}
	/*cout<<"\n";
	for(i=1;i<=n;i++)
	cout<<a[i]<<" ";*/
	return 0;
}