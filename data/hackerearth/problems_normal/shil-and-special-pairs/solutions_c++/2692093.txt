#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned char uchar;

#define MAX_INT (int)0x7fffffff
#define MIN_INT (int)0x80000000
#define MAX_UINT (uint)0xffffffff

#define TTi template<typename T> inline
TTi T SQR(T x) { return x * x; }

#define CONCAT3_NX(x, y, z) x ## y ## z
#define CONCAT3(x, y, z) CONCAT3_NX(x, y, z)
#define VAR(name) CONCAT3(__tmpvar__, name, __LINE__)
#define TYPE(x) __typeof(x)

#define FOR(i, s, n)  for (TYPE(n) i=(s),   VAR(end)=(n);  i <  VAR(end);  i++)
#define RFOR(i, s, n) for (TYPE(n) i=(n)-1, VAR(end)=(s);  i >= VAR(end);  i--)
#define FORN(i, n)    FOR(i, 0, n)
#define RFORN(i, n)   RFOR(i, 0, n)
#define FOREACH(i, v) for (auto& i: v)

#define MP(a, b) make_pair(a, b)
#define WHOLE(x) (x).begin(),(x).end()
#define SZ(x) ((int)(x).size())
#define POPST(stack) (stack).top();(stack).pop();
#define POPQ(queue) (queue).front();(queue).pop();
#define CONTAINS(v, x) (find(WHOLE(v), (x)) != v.end())
#define SORT(v) (sort(WHOLE(v)))

#define LIMIT(x, lim) {if (x > lim) x = lim;}
TTi T MIN(T x, T y) { return (x < y) ? x : y; }
TTi T MAX(T x, T y) { return (x > y) ? x : y; }
TTi T ABS(T x) { return (x > 0) ? x : -x; }
TTi void UPDATE_MIN(T &x, T y) {if (y < x) {x = y;}}
TTi void UPDATE_MAX(T &x, T y) {if (x < y) {x = y;}}
TTi int ARGMAX(T cont) { return max_element(cont.begin(), cont.end()) - cont.begin(); }
TTi int ARGMIN(T cont) { return min_element(cont.begin(), cont.end()) - cont.begin(); }

vector<string> split(const string& s, char c) {
    vector<string> v; stringstream ss(s); string x;
    while (getline(ss, x, c)) v.emplace_back(x); return move(v);
}
template<typename T, typename... Args>
inline string arrStr(T arr, int n) {
    stringstream s;
    s << "[";
    FORN(i, n - 1) s << arr[i] << ",";
    s << arr[n - 1] << "]";
    return s.str();
}

// #ifndef ONLINE_JUDGE
#ifdef JUDGE_LOCAL
    #define EPR(args...)   if (DEBUG) {fprintf(stderr, args);}
    #define EARR(arr, n)   if (DEBUG) {FORN(i, n) fprintf(stderr, "%d, ", arr[i]);}
    #define EVEC(arr)      if (DEBUG) {FORN(i, arr.size()) fprintf(stderr, "%d, ", arr[i]);}
    #define EVARS(args...) if (DEBUG) { __evars_begin(__LINE__); __evars(split(#args, ',').begin(), args);}

    inline void __evars_begin(int line) { cerr << "#" << line << ": "; }
    inline void __evars(vector<string>::iterator it) {cerr << endl;}

    TTi void __evars_out_var(vector<T> val) {
        cerr << arrStr(val, val.size());
    }
    TTi void __evars_out_var(T* val) {
        cerr << arrStr(val, 10);
    }
    TTi void __evars_out_var(T val) {
        cerr << val;
    }
    template<typename T, typename... Args>
    inline void __evars(vector<string>::iterator it, T a, Args... args) {
        cerr << it->substr((*it)[0] == ' ', it->length()) << "=";
        __evars_out_var(a);
        cerr << "; ";
        __evars(++it, args...);
    }
#else
    #define EPR(args...) 1
    #define EARR(args...) 1
    #define EVEC(args...) 1
    #define EVARS(args...) 1
#endif

template<class T> inline string TOSTR(const T & x) { stringstream ss; ss << x; return ss.str(); }
#define DIE(args...) {printf(args);exit(0);}
#define PR(x) cout << (x) << endl
#define PRF(x) cout << fixed << setprecision(10) << x << endl

inline int gcd(int a, int b) { return a ? gcd(b % a, a) : b; }
inline LL gcd(LL a, LL b) { return a ? gcd(b % a, a) : b; }
inline LL powmod(LL a, LL p, LL m) { LL r = 1; while (p) { if (p & 1) r = r*a%m; p>>=1; a=a*a%m; } return r; }

struct pairhash {
    template <typename T, typename U>
    std::size_t operator() (const std::pair<T, U> &x) const {
        return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);
    }
};

template <typename K, typename V>
V GetWithDef(const std::unordered_map <K,V> & m, const K & key, const V & defval ) {
    auto it = m.find(key);
    return (it == m.end()) ? defval : it->second;
}

template <typename K, typename V>
void SetDef(std::unordered_map <K,V> & m, const K & key, const V & defval ) {
    auto it = m.find(key);
    if (it == m.end()) m[key] = defval;
}

const int MOD = 1000 * 1000 * 1000 + 7;
const double PI = 3.1415926535897932384626433832795l;



// -----------------------------------------------------------------
// CODE
// -----------------------------------------------------------------

#define DEBUG 1
#define MAXN 200123

int N, Q, D;

struct BIT {
    // TODO: add modular version
    vector<int> bit;
    int N;
    void init(int N) {
        this->N = N;
        bit.assign(N + 1, 0);
    }

    void add_to_i(int x, int val) {
        for (; x <= N; x += x&-x)
            bit[x] += val;
    }
    void set_i(int x, int val) {
        add_to_i(x, val - get(x));
    }
    int sum_prefix(int x) {
        int sum = 0;
        for (; x > 0; x -= x&-x)
            sum += bit[x];
        return sum;
    }
    int sum_range(int l, int r) {
        assert (l <= r);
        return sum_prefix(r) - sum_prefix(l - 1);
    }
    int get(int i) {
        return sum_range(i, i);
    }
};


int arr[MAXN];
int iarr[MAXN];
// (l, (r, i))
pair<int, pair<int, int>> qs[MAXN];
int ans[MAXN] = {};
BIT allends;
BIT curends;

int main() {
    ios_base::sync_with_stdio(0);

    cin >> N >> Q >> D;
    allends.init(N);
    curends.init(N);

    FOR(i, 1, N + 1) {
        cin >> arr[i];
        iarr[arr[i]] = i;
    }
    FOR(i, 1, N + 1) {
        int start = max(1, arr[i] - D);
        int end = min(N, arr[i] + D);
        for(int p2 = start; p2 <= end; p2++) {
            if (p2 == arr[i])
                continue;
            int i2 = iarr[p2];
            if (i2 > i) {
                allends.add_to_i(iarr[p2], 1);
                EVARS(i, arr[i], i2, arr[i2]);
            }
        }
    }

    FORN(i, Q) {
        cin >> qs[i].first >> qs[i].second.first;
        qs[i].second.second = i;
    }

    sort(qs, qs + Q);

    int prev_l = 1;
    int prev_r = 1;

    FORN(i, Q) {
        int l = qs[i].first;
        int r = qs[i].second.first;
        int qi = qs[i].second.second;

        while (prev_l < l) {
            // EVARS(prev_l);
            int p = arr[prev_l];
            int start = max(1, p - D);
            int end = min(N, p + D);
            for(int p2 = start; p2 <= end; p2++) {
                // EVARS(prev_l, p, p2, iarr[p2]);
                if (p2 == p)
                    continue;
                int i2 = iarr[p2];
                if (i2 > prev_l) {
                    // EVARS(prev_l, p, i2, p2);
                    curends.add_to_i(i2, 1);
                }
            }
            prev_l++;
        }
        int curans = allends.sum_range(l, r) - curends.sum_range(l, r) + (r - l + 1);
        ans[qi] = curans;
        int r_allends = allends.sum_range(l, r);
        int r_curends = curends.sum_range(l, r);
        EVARS(qi, l, r, curans, r_allends, r_curends);

        prev_r = r;
        prev_l = l;
    }

    FORN(i, Q) {
        PR(ans[i]);
    }

    /*
    cin >> t;
    FORN(_it, t) {
        cin >> N;
        FORN(i, N) cin >> arr[i];
    }
    */
    return 0;
}
