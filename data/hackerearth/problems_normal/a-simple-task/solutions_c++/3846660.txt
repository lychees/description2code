//WRONG ON 2 TESTCASES
//problematic generation of divisors --> missing some ><
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <queue>
#include <deque>
#include <bitset>
#include <iterator>
#include <list>
#include <stack>
#include <map>
#include <set>
#include <utility>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>

#include <ctime>
using namespace std;

#define SCD(t) scanf("%d",&t)
#define SCLD(t) scanf("%ld",&t)
#define SCLLD(t) scanf("%lld",&t)
#define SCC(t) scanf("%c",&t)
#define SCS(t) scanf("%s",t)
#define SCF(t) scanf("%f",&t)
#define SCLF(t) scanf("%lf",&t)
#define PRD(t) printf("%d",t)
#define PRLD(t) printf("%ld",t)
#define PRLLD(t) printf("%lld",t)
#define PRC(t) printf("%c",t)
#define PRS(t) printf("%s",t)
#define PRF(t) printf("%f",t)
#define PRLF(t) printf("%lf",t)
#define nl printf("\n")
#define space printf(" ")
#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)
#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)
#define REP(i, j) FOR(i, 0, j, 1)
#define RREP(i, j) RFOR(i, j, 0, 1)

#define clear(a) memset((a),0,sizeof(a))
#define mem(x,val) memset((x),(val),sizeof(x));
#define rite(x) freopen(x,"w",stdout);
#define read(x) freopen(x,"r",stdin);
#define all(x) x.begin(),x.end()
#define sz(x) ((int)x.size())
#define sqr(x) ((x)*(x))
#define tl(x) (int)ceil(x) //round up to int
#define tx(x) (int)floor(x) //round down to int

#define ins insert
#define MP make_pair
#define pb push_back
#define clr clear()
#define xx first
#define yy second

#define inf (1<<30)
#define eps 1e-9
#define pi 3.1415926535897932384626433832795
#define mod 1000000007

typedef long long ll;
typedef unsigned long long ull;
typedef string st;

typedef vector<int> vi;
typedef vector<st> vs;
typedef map<int,int> mii;
typedef map<st,int> msi;
typedef set<int> si;
typedef set<st> ss;
typedef pair<int,int> pii;
typedef vector<pii> vpii;


bitset <5000001> bs; // 10^7
vector <int> primes;

vector< pii >factors;
set <int> divisors;

void sieve(int upperbound);
void generateDivisors(int starting_number, int multiply_from_index );
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a%b);
    }


int main() {

//    read("input1.txt");
//    rite("output1.txt");
//    freopen("input2.txt","r",stdin);
//    freopen("output2.txt","w",stdout);
    int n;
    int val[100];
    scanf("%d",&n);
    for (int i = 0; i < n ; ++i ) scanf("%d",&val[i]);

    sort(val,val+n);//sort in increasing order
    for (int i = 0 ; i < n ; ++i ) val[i] = val[i+1] - val[i];
    int g;
    if ( n == 2) g = val[0];
    else {
        g = gcd(val[0],val[1]);
        for ( int i = 2 ; i < n - 1; ++i) g = gcd(g,val[i]);
        }

    //integer factorization of g
    sieve( tx(sqrt(g)) );
    int expo;
    int prime;
    for ( int i = 0 ; i < primes.size() ; ++i) {
            expo = 0;
            prime = primes[i];
            while ( g % prime == 0) {
                expo += 1;
                g /= prime;
                }
            if (expo > 0) factors.pb(MP(prime,expo));
        }
    if ( g > 1) factors.pb(MP(g,1));

    //generate all numbers divisible by g

//my attempted code to generate all divisors --> faulty algorithm, unable to generate all
//    int temp;
//    for ( int i = 0 ; i < factors.size() ; ++i) {
//        divisors.ins(factors[i]);
//        temp = factors[i];
//        for (int j = i+1 ; j < factors.size(); ++j) {
//            temp *= factors[j];
//            divisors.ins(temp);
//            }
//        }
    generateDivisors(1,0);

    //print answer
    set <int>::iterator it;
    for (it = divisors.begin(); it != divisors.end() ; ++it ) printf("%d ",*it);
    printf("\n");

    return 0;
    }

void sieve (int upperbound) {

    bs.set(); // set all bits to 1 --> presume it is prime before checking
    bs[0] = bs[1] = 0; // 0 and 1 are not prime numbers

//cross out multiples of 2: 2*2 , 2*3 , 2*4, 2*4 ...
    for(int j = 2*2  ; j <= upperbound;  j+= 2) bs[j] = 0;
    primes.push_back(2); // add 2 to the list of prime numbers
//starting from 3
    for ( int i = 3 ; i <= upperbound ; ++i) {
        if (bs[i]) { // if bs[i] == true

            for ( int j = i*i ; j <= upperbound ; j += 2*i ) {
                // an improvement over j++
                bs[j] = 0;
                }
            primes.push_back( i );//using long long data type uses too much space??
            }
        }
    }

void generateDivisors(int base, int index){
    int j , k; //counters
    int x;
    for ( j = index ; j < factors.size(); ++j){
        x = factors[j].xx * base;
        for ( k = 0; k <factors[j].yy ; ++k){
            divisors.ins(x);
            generateDivisors(x,j+1);
            x *= factors[j].xx;
        }
    }
}
