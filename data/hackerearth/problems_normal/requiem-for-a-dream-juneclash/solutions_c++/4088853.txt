#include <iostream>
#include <stdio.h>
#include <stdint.h>
#include <vector>
#include <utility>
#include <queue>

using namespace::std;

struct info
{
	info() : last(-1), sm(0), bst(0), prefix(0), suffix(0) {}

	int last;

	int64_t sm;
	int64_t bst;
	int64_t prefix;
	int64_t suffix;
};

void fill(int N, vector<pair<int, int> > &pt, vector<vector<info> > &P)
{
	int m = 18;
	for (int i = 0; i < N; i++)
		P[i].resize(m, info());

	for (int i = 0; i < N; i++)
	{
		info in;
		in.last = i;

		in.sm = 0;
		in.bst = 0;
		in.prefix = 0;
		in.suffix = 0;

		P[i][0] = in;

		if (pt[i].first != -1)
		{
			int64_t w = pt[i].second;
			in.last = pt[i].first;
			
			in.sm = w;
			in.bst = ((w > 0) ? w : 0);
			in.prefix = ((w > 0) ? w : 0);
			in.suffix = ((w > 0) ? w : 0);

			P[i][1] = in;
		}
	}

	for (int h = 2; h < m; h++)
	{	
		for (int i = 0; i < N; i++)
		{
			int x = P[i][h - 1].last;
			if (x == -1)
			{
				P[i][h] = P[i][h - 1];
				continue;
			}

			int y = pt[x].first;
			int64_t w = pt[x].second;

			if (y == -1)
			{
				P[i][h] = P[i][h - 1];
				P[i][h].last = -1;

				continue;
			}

			P[i][h].last = P[y][h - 1].last;
			P[i][h].sm = P[i][h - 1].sm + w + P[y][h - 1].sm;

			P[i][h].prefix = max(P[i][h - 1].prefix, P[i][h - 1].sm + w + P[y][h - 1].prefix);
			P[i][h].suffix = max(P[y][h - 1].suffix, P[y][h - 1].sm + w + P[i][h - 1].suffix);

			P[i][h].bst = max(max(P[i][h - 1].bst, P[y][h - 1].bst), P[i][h - 1].suffix + w + P[y][h - 1].prefix);
		}	
	}
}

void merge(info &in1, info &in2)
{
	int64_t sm = in1.sm;
	int64_t bst = in1.bst;
	int64_t prefix = in1.prefix;
	int64_t suffix = in1.suffix;

	in1.sm = sm + in2.sm;
	in1.prefix = max(prefix, sm + in2.prefix);
	in1.suffix = max(in2.suffix, in2.sm + suffix);
	in1.bst = max(max(bst, in2.bst), suffix + in2.prefix);
}

int64_t get(int x, int y, vector<int> &ht, vector<pair<int, int> > &pt, vector<vector<info> > &P)
{
        if (ht[x] < ht[y])
        {
                int tmp = x;
                x = y;
                y = tmp;
        }

        //std::cout << "x = " << x << "  y = " << y << std::endl;

	info lt;
	info rt;	

        // go up to equal height
        if (ht[x] > ht[y])
        {
                int step = 0;
                while (true)
                {
                        if (P[x][step].last == -1)
                                break;

                        if (ht[P[x][step].last] < ht[y])
                                break;

                        step++;
                }

                step--;

		lt = P[x][step];
                x = P[x][step].last;

                while (true)
                {
                        if (ht[x] == ht[y])
                                break;

			int64_t w = pt[x].second;

                        x = pt[x].first;
                        int z = P[x][step].last;

			// update for this edge
			int64_t sm = lt.sm;
			int64_t bst = lt.bst;
			int64_t prefix = lt.prefix;
			int64_t suffix = lt.suffix;

			lt.sm = sm + w;
			lt.prefix = max(prefix, sm + w);
			lt.suffix = max((int64_t) 0, w + suffix);
			lt.bst = max(bst, w + suffix);

                        if ((z != -1) && (ht[z] >= ht[y]))
                        {
				merge(lt, P[x][step]);			
                                x = z;
                        }

                        step--;
                }
        }

        //std::cout << "xxx: x = " << x << "  y = " << y << std::endl;

        // go up simultaneously
        if (x != y)
        {
                int step = 0;
                while (true)
                {
                        if (P[x][step].last == P[y][step].last)
                                break;

                        step++;
                }

                step--;
		merge(lt, P[x][step]);
		merge(rt, P[y][step]);

                x = P[x][step].last;
                y = P[y][step].last;

                //std::cout << "yyy: " << x << "  " << y << "  " << step << std::endl;

                while (x != y)
                {
                        //std::cout << "zzz: " << x << "  " << y << "  " << step << "  " << P[x][step].elm << "  " << P[y][step].elm << std::endl;
                        {
				int64_t w = pt[x].second;
			
				int64_t sm = lt.sm;
				int64_t bst = lt.bst;
				int64_t prefix = lt.prefix;
				int64_t suffix = lt.suffix;

				lt.sm = sm + w;
				lt.prefix = max(prefix, sm + w);
				lt.suffix = max((int64_t) 0, w + suffix);
				lt.bst = max(bst, w + suffix);
				
				w = pt[y].second;
			
				sm = rt.sm;
				bst = rt.bst;
				prefix = rt.prefix;
				suffix = rt.suffix;

				rt.sm = sm + w;
				rt.prefix = max(prefix, sm + w);
				rt.suffix = max((int64_t) 0, w + suffix);
				rt.bst = max(bst, w + suffix);
                        }

                        x = pt[x].first;
                        y = pt[y].first;

			if (x == y)
				break;

                        if (P[x][step].last != P[y][step].last)
                        {
				merge(lt, P[x][step]);
				merge(rt, P[y][step]);

                                x = P[x][step].last;
                                y = P[y][step].last;
                        }

                        step--;
                }
        }

	int64_t ans = max(lt.bst, rt.bst);
	ans = max(ans, lt.suffix + rt.suffix);

	return ans;
}

int main()
{
	int N, Q;
	scanf("%d", &N);
	scanf("%d", &Q);

	vector<vector<pair<int, int> > > adj(N, vector<pair<int, int> >());
	for (int i = 0; i < (N - 1); i++)
	{
		int u, v, w;
		scanf("%d", &u);
		scanf("%d", &v);
		scanf("%d", &w);

		u--;
		v--;

		adj[u].push_back(make_pair(v, w));
		adj[v].push_back(make_pair(u, w));
	}

	vector<int> ht(N, -1);
	vector<pair<int, int> > pt(N, make_pair(-1, -1));

	vector<bool> visited(N, false);
	queue<int> q;
	
	q.push(0);
	visited[0] = true;
	ht[0] = 0;

	while (!q.empty())
	{
		int x = q.front();
		q.pop();

		for (int i = 0; i < adj[x].size(); i++)
		{
			int y = adj[x][i].first;
			int w = adj[x][i].second;

			if (visited[y])
				continue;

			ht[y] = 1 + ht[x];
			pt[y].first = x;
			pt[y].second = w;

			visited[y] = true;
			q.push(y);
		}
	}

	vector<vector<info> > P(N);
	fill(N, pt, P);

	for (int iter = 0; iter < Q; iter++)
	{
		int u, v;
		scanf("%d", &u);
		scanf("%d", &v);

		u--;
		v--;

		int64_t ans = get(u, v, ht, pt, P);

		printf("%lld\n", ans);
	}

	return 0;
}
