#include<bits/stdc++.h>
using namespace std;
#define INF 1000000000
#define ll long long
ll *id, cnt, *sz;
map<ll,ll> mp;  //use this map to map indexes with data.
void init(ll N)
{
    cnt = N;
	id = new ll[N+1];
	sz = new ll[N+1];
    for(ll i=1; i<=N; i++)
    {
        id[i] = i;
	    sz[i] = 1;
	}
}
ll find(ll p)
{
    ll root = p;
    while (root != id[root])
        root = id[root];
    while (p != root) {
        ll newp = id[p];
        id[p] = root;
        p = newp;
    }
    return root;
}
// Replace sets containing x and y with their union.
void merge(ll x, ll y)
{
    ll i = find(x);
    ll j = find(y);
    if (i == j) return;
    // make smaller root point to larger one
    if(sz[i]<sz[j])
    {
        id[i]=j;
        sz[j]+=sz[i];
    }
    else
    {
        id[j]=i;
        sz[i]+=sz[j];
    }
    cnt--;
}
void destroy()
{
    delete []id;
	delete []sz;
}
const ll MAX = 1000000;
pair <long long, pair<ll, ll> > p[MAX];
ll nodes,edges;
long long kruskal(ll shrine)
{
    ll x, y;
    ll count=0,i=0;
    long long cost, minimumCost = 0;
    while(count!=shrine-1)
    {
        x = p[i].second.first;
        y = p[i].second.second;
        cost = p[i].first;
        if(find(x) != find(y))
        {
            //cout<<x<<" "<<y<<"\n";
            minimumCost += cost;
            merge(x, y);
            count++;
        }
        i++;
    }
    return minimumCost;
}
bool comp(const pair <long long, pair<ll, ll> > &a,const pair <long long, pair<ll, ll> > &b)
{
    return a.first<b.first;
}
int main()
{
    ll t,n,m,k,i,j,A[200][200],x,y,c,shrine;
    cin>>t;
    while(t--)
    {
        cin>>n>>m>>shrine;
        init(n);
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                A[i][j]=INF;
            }
            A[i][i]=0;
        }
        for(i=1;i<=m;i++)
        {
            cin>>x>>y>>c;
            A[x][y]=c;
            A[y][x]=c;
        }
        for(k=1;k<=n;k++)
        {
            for(i=1;i<=n;i++)
            {
                for(j=1;j<=n;j++)
                {
                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);
                }
            }
        }
        edges=0;
        for(i=1;i<=shrine;i++)
        {
            for(j=i+1;j<=shrine;j++)
            {
                p[edges++]=make_pair(A[i][j],make_pair(i,j));
            }
        }
        sort(p,p+edges,comp);

        ll ans=kruskal(shrine);
        cout<<ans<<"\n";
    }
    return 0;
}
