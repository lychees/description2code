    #include <bits/stdc++.h>
    using namespace std;
    #define pb push_back
    #define m_p make_pair
    #define F first
    #define S second
    #define For(i,a,b) for(int i=a;i<b;i++)
    #define Fore(i,a,b) for(int i=a;i<=b;i++)
    #define rFor(i,a,b) for(int i=a;i>b;i--)
    #define rFore(i,a,b) for(int i=a;i>=b;i--)
    #define tr(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)
    #define all(a) a.begin(),a.end()
    #define mem(a,b) memset(a,b,sizeof(a))
    typedef long long int lli;
    typedef pair<int,int> pii;
    typedef pair<int,pii> pi3;
    typedef pair<pii,pii> pi4;
    typedef vector<int> vi;
    typedef vector<pii> vpii;
    void sc(int& a){scanf("%d",&a);}
    void sc(lli& a){scanf("%lld",&a);}
    void sc(int& a,int& b){sc(a);sc(b);}
    void sc(lli& a,lli& b){sc(a);sc(b);}
    void sc(int& a,int& b,int& c){sc(a,b);sc(c);}
    void sc(lli& a,lli& b,lli& c){sc(a,b);sc(c);}
    void prl(int a){printf("%d\n",a);}
    void prl(lli a){printf("%lld\n",a);}
    void prl(){printf("\n");}
    void prs(int a){printf("%d ",a);}
    void prs(lli a){printf("%lld ",a);}
    int mod =1000000007;
    lli modpow(lli a, lli b, lli mod){lli res=1;while(b>0){if(b&1)res=(res*a)%mod;a=(a*a)%mod;b=b/2;}return res%mod;}
    lli pow(lli a, lli b){lli res=1;while(b>0){if(b&1)res=(res*a);a=(a*a);b=b/2;}return res;}
    #define inf INT_MAX
    #define N 200100
    char s[N];
    pi3 tree[N*4];  //p.F=rev, p.S.F=forward edge, p.S.S=backward edge
     
    void build(int node, int start, int end)
    {
        if(start+1==end){
            if(s[start]=='>') tree[node].S.F++;
            else tree[node].S.S++;
        }
        else{
            build(2*node,start,(start+end)/2);
            build(2*node+1,(start+end)/2,end);
            tree[node].S.F=tree[2*node].S.F+tree[2*node+1].S.F;
            tree[node].S.S=tree[2*node].S.S+tree[2*node+1].S.S;
        }
    }
    void updateRange(int node, int start, int end, int l, int r)
    {
    	//cout<<node<<" "<<start<<" "<<end<<endl;
        tree[node].F%=2;
        if(tree[node].F){
        	swap(tree[node].S.F,tree[node].S.S);
        }
        if(2*node+1<N*4){
        	tree[2*node].F+=tree[node].F;
        	tree[2*node+1].F+=tree[node].F;
        }
        tree[node].F=0;
        if(start>=l and end<=r){
        	tree[node].F++;
        	tree[node].F%=2;
    	    if(tree[node].F){
    	    	swap(tree[node].S.F,tree[node].S.S);
    	    }
    	    if(2*node+1<N*4){
    	    	tree[2*node].F+=tree[node].F;
    	    	tree[2*node+1].F+=tree[node].F;
    	    }
    	    tree[node].F=0;
        }
        else if(end<=l or start>=r) return;
        else{
        	updateRange(2*node,start,(start+end)/2,l,r);
        	updateRange(2*node+1,(start+end)/2,end,l,r);
        	tree[node].S.F=tree[2*node].S.F+tree[2*node+1].S.F;
            tree[node].S.S=tree[2*node].S.S+tree[2*node+1].S.S;
        }
    }
    pi3 merge(pi3 x, pi3 y)
    {
    	return make_pair(0,make_pair(x.S.F+y.S.F,x.S.S+y.S.S));
    }
    pi3 queryRange(int node, int start, int end, int l, int r)
    {
        tree[node].F%=2;
        if(tree[node].F){
        	swap(tree[node].S.F,tree[node].S.S);
        }
        if(2*node+1<N*4){
        	tree[2*node].F+=tree[node].F;
        	tree[2*node+1].F+=tree[node].F;
        }
        tree[node].F=0;
        if(start>=l and end<=r) return tree[node];
        if(end<=l or start>=r) return make_pair(0,make_pair(0,0));
        int mid=(start+end)/2;
        pi3 x=queryRange(2*node,start,mid,l,r);
        pi3 y=queryRange(2*node+1,mid,end,l,r);
        return make_pair(0,make_pair(x.S.F+y.S.F,x.S.S+y.S.S));
    }
     
    int main()
    {
    	int t,m,d,n,q,x,y,l,r,z,ans;
    	sc(n,q);
    	scanf("%s",s+1);
    	build(1,1,n);
    	while(q--){
    		sc(z,l,r);
    		if(z==2){
    			if(l==r) {prl(0);}
    			else if(l>r){
    				swap(l,r);
    				prl(queryRange(1,1,n,l,r).S.F);
    			}
    			else {prl(queryRange(1,1,n,l,r).S.S);}
    		}
    		else updateRange(1,1,n,l,r);
    	}	
    }