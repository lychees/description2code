#include<cstdio>
#include<iostream>
using namespace std;
int t[800005]={0};
int lazy[800005]={0};
void build(int a[],int v,int tl,int tr)
{
    if(tl==tr)
    t[v]=a[tl];
    else
    {
        int tm=(tl+tr)/2;
        build(a,2*v,tl,tm);
        build(a,2*v+1,tm+1,tr);
        t[v]=t[2*v]+t[2*v+1];
    }
}

void update_tree(int node, int a, int b, int i, int j) {

  	if(lazy[node] != 0) { // This node needs to be updated
   		t[node] = (b-a+1) - t[node]; // Update it

		if(a != b) {
			lazy[node*2] = !lazy[node*2]; // Mark child as lazy
    			lazy[node*2+1] = !lazy[node*2+1]; // Mark child as lazy
		}

   		lazy[node] = 0; // Reset it
  	}

	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return ;

  	if(a >= i && b <= j) { // Segment is fully within range
    		t[node] = (b-a+1) - t[node];

		if(a != b) { // Not leaf node
			lazy[node*2] = !lazy[node*2];
			lazy[node*2+1] = !lazy[node*2+1];
		}

    		return;
	}
	//i,j=a,b st,en=a,b
	update_tree(node*2, a, (a+b)/2, i, j); // Updating left child
	update_tree(1+node*2, 1+(a+b)/2, b, i, j); // Updating right child

	t[node] = t[node*2] + t[node*2+1]; // Updating root with max value
}
int query_tree(int node, int a, int b, int i, int j) {

	if(a > b || a > j || b < i) return 0; // Out of range

	if(lazy[node] != 0) { // This node needs to be updated
		t[node] = b-a+1-t[node]; // Update it

		if(a != b) {
			lazy[node*2] = !lazy[node*2]; // Mark child as lazy
			lazy[node*2+1] = !lazy[node*2+1]; // Mark child as lazy
		}

		lazy[node] = 0; // Reset it
	}

	if(a >= i && b <= j) // Current segment is totally within range [i, j]
		return t[node];

	int q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child
	int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); // Query right child

	int res = q1 +q2; // Return final result

	return res;
}
int main()
{
    int n,m,k,s,i,e,a[200005];
    char ch[200005];
    scanf("%d%d",&n,&m);
    scanf("%s",&ch);
    for(i=0;i<n-1;i++)
    {
    	if(ch[i]=='<')
    	a[i+1]=0;
    	else
    	a[i+1]=1;
    }
    build(a,1,1,n-1);
    while(m--)
    {
        scanf("%d%d%d",&k,&s,&e);
        if(k==1)
        {
            //for(int i=s;i<=e;i++)
            update_tree(1,1,n-1,s,e-1);
        }
        if(k==2)
        {
        	if(e<s)
        	{
        		printf("%d\n",query_tree(1,1,n-1,e,s-1));
        		continue;
        	}
        	else
        	printf("%d\n",e-s-query_tree(1,1,n-1,s,e-1));
        }
    }
    return 0;
}
