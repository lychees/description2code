#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
#include<map>
#include<queue>
#include<cassert>
#define PB push_back
#define MP make_pair
#define sz(v) (in((v).size()))
#define forn(i,n) for(in i=0;i<(n);++i)
#define forv(i,v) forn(i,sz(v))
#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)
#define all(v) (v).begin(),(v).end()
using namespace std;
typedef int in;
typedef vector<in> VI;
typedef vector<VI> VVI;
queue<in> qx,qy;
VVI vis;
vector<string> cc;
VVI d={{0,1},{1,0},{0,-1},{-1,0}};
VVI comp1={{0,1},{1,0},{0,0},{0,0}};
VVI comp2={{1,1},{1,1},{1,0},{0,1}};
in ncol(){
  in n=sz(cc)-1;
  in m=sz(cc[0])-1;
  vis=VVI(n,VI(m,0));
  in rs=0;
  vis[0][0]=1;
  qx.push(0);
  qy.push(0);
  in cx,cy;
  in nx,ny;
  bool isok;
  while(!qx.empty()){
    cx=qx.front();
    qx.pop();
    cy=qy.front();
    qy.pop();
    forn(i,4){
      nx=cx+d[i][0];
      ny=cy+d[i][1];
      if(nx<0 || ny<0 || nx>=n || ny>=m)
	continue;
      isok=(cc[cx+comp1[i][0]][cy+comp1[i][1]]!=cc[cx+comp2[i][0]][cy+comp2[i][1]]);
      rs+=isok;
      if(!isok)
	continue;
      if(vis[nx][ny])
	continue;
      vis[nx][ny]=1;
      qx.push(nx);
      qy.push(ny);
    }
  }
  return rs;
}
void gog(){
  in n,m;
  cin>>n>>m;
  cc.resize(n+2);
  cc[0]=cc[n+1]=string(m+2,'#');
  string tp;
  string ht=string(1,'#');
  forn(i,n){
    cc[i+1]=ht;
    cin>>tp;
    cc[i+1]+=tp;
    cc[i+1]+=ht;
  }
  in tfr=0;
  in cr;
  forn(i,n+1){
    forn(j,m+1){
      cr=0;
      cr+=(cc[i][j]!=cc[i+1][j]);
      cr+=(cc[i][j+1]!=cc[i+1][j+1]);
      cr+=(cc[i][j]!=cc[i][j+1]);
      cr+=(cc[i+1][j]!=cc[i+1][j+1]);
      tfr+=cr;
    }
  }
  if(tfr==ncol())
    cout<<"YES";
  else
    cout<<"NO";
  cout<<"\n";
}
int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);
  in t;
  cin>>t;
  forn(zz,t)
    gog();
  return 0;
}
