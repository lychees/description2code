#include<iostream>
using namespace std;
#define MAXDIM 51
#define MOD 1000000007
#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)
#define ll long long
#define ull unsigned ll
long long get_uint() {
  long long n;
  int c;
  while( (c = getchar()) < '0') {
    ;
  }
  n = c - '0';
  while( (c = getchar()) >= '0')
    n = n * 10 + (c - '0');
  return n;
}
void put_uint(long long n) {
  unsigned char stack[30];
  int top = 0;
  if(n == 0) {
    putchar('0');
  } else {
    while(n > 0) {
      stack[top++] = n % 10 + '0';
      n /= 10;
    }
    while(top > 0) {
      putchar(stack[--top]);
    }
  }
  putchar('\n');
}

//http://www.codechef.com/viewsolution/4865139
struct llModMatrix{
  int r, c, mod; ll limit; ll **data;
  void malloc(int r, int c, int mod){int i;this->r=r;this->c=c;this->mod=mod;limit=((1ULL<<63)-1)-(ull)(mod-1)*(mod-1);data=(ll**)std::malloc(sizeof(ll*)*r);data[0]=(ll*)std::malloc(sizeof(ll)*r*c);REP(i,1,r)data[i]=data[i-1]+c;}
  void* malloc(int r, int c, int mod, void *workMemory){int i;this->r=r;this->c=c;this->mod=mod;limit=((1ULL<<63)-1)-(ull)(mod-1)*(mod-1);data=(ll**)workMemory;data[0]=(ll*)(data+r);REP(i,1,r)data[i]=data[i-1]+c;return (void*)(data[0]+r*c);}
  void free(void){std::free(data[0]);std::free(data);}
  void setIdentity(){int i,j;rep(i,r)rep(j,c){data[i][j]=0;if(i==j)data[i][j]=1;}}
  void setZero(){int i,j;rep(i,r)rep(j,c)data[i][j]=0;}
  void operator=(llModMatrix &a){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c)data[i][j]=a.data[i][j];}
  void operator+=(llModMatrix &a){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]+=a.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  void operator-=(llModMatrix &a){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]-=a.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  //void mixed(void){int i,j;rep(i,r)rep(j,c){if(data[i][j]<0)data[i][j]+=mod;if(data[i][j]&&rand()%2)data[i][j]-=mod;}}
  //void add(llModMatrix &a, llModMatrix &b){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]=a.data[i][j]+b.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  //void sub(llModMatrix &a, llModMatrix &b){int i,j;r=a.r;c=a.c;rep(i,r)rep(j,c){data[i][j]=a.data[i][j]-b.data[i][j];if(data[i][j]>=mod)data[i][j]-=mod;if(data[i][j]<=-mod)data[i][j]+=mod;}}
  void mul(llModMatrix &a, llModMatrix &b){int i,j,k;r=a.r;c=b.c;setZero();rep(i,r)rep(k,a.c)if(a.data[i][k])rep(j,c){data[i][j]+=a.data[i][k]*b.data[k][j];if(data[i][j]>=limit||data[i][j]<=-limit)data[i][j]%=mod;}rep(i,r)rep(j,c)if(data[i][j]>=mod||data[i][j]<=-mod)data[i][j]%=mod;}
  void pow(llModMatrix &a, ull b, void *workMemory){llModMatrix t1,t2;r=c=a.r;workMemory=t1.malloc(r,c,mod,workMemory);workMemory=t2.malloc(r,c,mod,workMemory);setIdentity();t1=a;while(b){if(b&1){t2=*this;this->mul(t2,t1);}t2.mul(t1,t1);t1=t2;b>>=1;}}
};
int m,n;
int main() {
    //int w;
    //w = get_uint();
    
    int T;
    scanf("%d",&T);
    //int T = 380;
    int I,J;
    long long N;
    while(T--){
        m = get_uint();
        n = get_uint();
        llModMatrix M,pw;
    	void *mem = malloc(100000000);
    	mem = M.malloc(m,m,MOD,mem);
    	mem = pw.malloc(m,m,MOD,mem);
   		M.r = m;
    	M.c = m;
    	pw.r = m;
   	    pw.c = m;
        for(int i=0;i<m;i++)
        for(int j=0;j<m;j++)
        M.data[i][j] = get_uint();
        //I--,J--;
        //N = get_uint();
       // cout << m << ", " << n << endl;
        pw.pow(M,n,mem);
        //put_uint(pw.data[I][J]);
        for(int i=0;i<m;i++){
        	for(int j=0;j<m;j++){
        		printf("%lld ",pw.data[i][j]);
        	}
        	printf("\n");
        }
    }
    return 0;
}










