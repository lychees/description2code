#include <iostream>
#include <list>
#include <stack>
using namespace std;
int level[10000]={0};
int a[1000];

int yo=0;
class graph
{
	
	int v,c;
	int ans[1000];
	list<int> *adj;
	void topologicalu(int s,bool visited[],stack<int> &Stack);
	void fill(int v,bool visited[],stack<int> &Stack);
	void dfsutil(int s,bool visited[]);
	public:
	graph(int v)
	{
		this->v=v;
		c=0;
		ans[1000]={0};
		adj=new list<int>[v];
		
	}
	void add(int v,int s)
	{
		adj[v].push_back(s);
		
	}
	void topologicalsort();
	void bfs(int s);
	void printSCC();
	graph gettranspose();
};
void graph::dfsutil(int s,bool visited[])
{
	visited[s]=true;
c+=a[s];
//cout<<c<<endl;
	list<int> ::iterator i;
	for(i=adj[s].begin();i!=adj[s].end();i++)
	{
		if(!visited[*i])
		{
			dfsutil(*i,visited);
		}
	}
	yo=c;
};
graph graph::gettranspose()
{
	graph gr(v);
	
	for(int i=0;i<v;i++)
	{
		list<int>:: iterator j;
		for(j=adj[i].begin();j!=adj[i].end();j++)
		{
			gr.adj[*j].push_back(i);
		}
	}
	return gr;
}

void graph::topologicalu(int s,bool visited[],stack<int> &Stack)
{
	visited[s]=true;
	list<int>::iterator i;
	for(i=adj[s].begin();i!=adj[s].end();i++)
	{
		if(!visited[*i])
		{
			topologicalu(*i,visited,Stack);
		}
	}
	Stack.push(s);
}
void graph::topologicalsort(){
	
	stack<int> Stack;
	bool *visited= new bool[v];
	for(int i=0;i<v;i++)
	visited[i]=false;
	
	for(int i=0;i<v;i++)
	{
		if(!visited[i])
		topologicalu(i,visited,Stack);
	}
	
	while(Stack.empty()==false)
	{
		cout<<Stack.top()<<" ";
		Stack.pop();
	}
}
void graph::printSCC()
{
	stack<int> Stack;
	bool *visited =new bool[v];
	
	for(int i=0;i<v;i++)
	{
		visited[i]=false;
	}
	for(int i=0;i<v;i++)
	{
		if(!visited[i])
		topologicalu(i,visited,Stack);
	}
	graph gr=gettranspose();
		for(int i=0;i<v;i++)
	{
		visited[i]=false;
	}
int max=0,y=0;
	while(Stack.empty()==false)
	{
		int f=Stack.top();
		Stack.pop();

		if(visited[f]==false)
		{
		
	gr.dfsutil(f,visited);
//	cout<<c<<endl;
	int yoy=yo-y;
	
	y=yo;
	if(max<yoy)
	max=yoy;
	

		}
		
	}

cout<<max<<endl;
	
}
void graph::bfs(int s)
{
	list<int> queue;
		bool *visited= new bool[v];
	for(int i=0;i<v;i++)
	visited[i]=false;
	
	list<int> ::iterator i;
	queue.push_back(s);
	visited[s]=true;
	level[s]=1;
	while(!queue.empty())
	{
		s=queue.front();
	//	cout<<s<<" ";
		queue.pop_front();
	
		for(i=adj[s].begin();i!=adj[s].end();i++)
		{
			if(!visited[*i])
			{
				queue.push_back(*i);
			
				visited[*i]=true;
			}
		}
	}

	
}

int main() {
 int t;
 cin>>t;
 while(t--)
 {
 	int n,m;
 	cin>>n>>m;
 
 	graph g(n);
 	
 	for(int i=0;i<n;i++)
 	{
 		cin>>a[i];
 	}
 	while(m--)
 	{
 		int a1,b1;
 		cin>>a1>>b1;
 		g.add(a1,b1);
 	
 		
 	}
 	g.printSCC();
// cout<<max<<endl;
 	
 }
 
	return 0;
}