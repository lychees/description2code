#include<bits/stdc++.h>
#define FOR(i,a,b) for (int i=(a),_b=(b);i<=_b;i=i+1)
#define REP(i,n) for (int i=0,_n=(n);i<_n;i=i+1)
using namespace std;
const int fstVal[]={1,1,2,2,2};
const int mulVal[][5]={{0,1,0,0,0},
                       {1,1,0,0,0},
                       {0,0,0,2,4},
                       {0,0,2,2,2},
                       {0,0,0,0,1}};
const int mod=(int)1e9+7;
struct Matrix {
    int m,n;
    int d[5][5];
    Matrix() {
        m=n=0;
        memset(d,0,sizeof d);
    }
    Matrix(int _m,int _n) {
        m=_m;n=_n;
        memset(d,0,sizeof d);
    }
    Matrix operator * (const Matrix &a) const {
        int x=m;
        int y=n;
        int z=a.n;
        Matrix res(x,z);
        REP(i,x) REP(j,y) REP(k,z) res.d[i][k]=(res.d[i][k]+1LL*d[i][j]*a.d[j][k])%mod;
        return (res);
    }
    Matrix operator ^ (int k) const {
        Matrix res(n,n);
        Matrix mul=*this;
        REP(i,n) REP(j,n) res.d[i][j]=i==j;
        while (k>0) {
            if (k&1) res=res*mul;
            mul=mul*mul;
            k>>=1;
        }
        return (res);
    }
};
int process(void) {
    int n;
    scanf("%d",&n);
    if (n==1) return (2);
    Matrix fst(1,5),mul(5,5);
    REP(i,5) fst.d[0][i]=fstVal[i];
    REP(i,5) REP(j,5) mul.d[i][j]=mulVal[i][j];
    fst=fst*(mul^(n-1));
    return (fst.d[0][4]);
}
int main(void) {
    int t;
    scanf("%d",&t);
    REP(zz,t) printf("%d\n",process());
    return 0;
}
