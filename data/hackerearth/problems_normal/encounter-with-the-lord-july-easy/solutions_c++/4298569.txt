
#include <bits/stdc++.h>
using namespace std;

#if !ONLINE_JUDGE
#include "debug.h"
#else
#endif

typedef long long int LL;
typedef unsigned long long LLU;
typedef long double LD;

#define INF 1500000000000000000LL
#define MOD 1000000007
#define F first
#define S second
#define PB push_back
#define MK make_pair
#define LEN(vale) strlen(vale)
#define SZ(vale) (int)vale.size()
#define SQ(A) ((A)*(A))
#define FI(i,fa,fb) for(int i=fa;i<fb;++i)
#define FD(i,fa,fb) for(int i=fa;i>fb;--i)
#define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) 
#define bits(vale) __builtin_popcount(vale)
#define VT vector

#define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val;
#define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val;

#define ALL(a) a.begin(),a.end()
#define LB (lower_bound)
#define UB (upper_bound)

#define SI(vale) scanf("%d",&vale)
#define PI(vale) printf("%d\n",vale)
#define PIS(vale) printf("%d ",vale)
#define SL(vale) scanf("%lld",&vale)
#define PL(vale) printf("%lld\n",vale)
#define PLS(vale) printf("%lld ",vale)
#define SS(vale) scanf("%s",vale)
#define PS(vale) printf("%s\n",vale)
#define SLD(vale) scanf("%Lf",&vale)
#define PLD(vale) printf("%0.12Lf\n",vale)
#define NL printf("\n")
#define TCS() int testcase; SI(testcase);while(testcase--) 

typedef pair<int,int> PR;
bool deb = false;
const int N = 211;
int n;
int dp[N][N];
#define Pot(u,v) (d[u] + pi[u] - pi[v])
int cap[N][N];
int cost[N][N];
int fnet[N][N], adj[N][N], deg[N];
int par[N], d[N];
int pi[N];

void refresh() {
     FI(i,0,202) {
          FI(j,0,202) {
               cost[i][j] = 0,cap[i][j] = 0,fnet[i][j] = 0,adj[i][j] = 0;
          }
     }
     FI(i,0,202) 
          pi[i] = 0,par[i] = 0,d[i] = 0;
}

bool dijkstra( int n, int s, int t ) {
     for( int i = 0; i < n; i++ ) d[i] = MOD, par[i] = -1;
     d[s] = 0;
     par[s] = -n - 1;
     while( 1 ) {
          int u = -1, bestD = MOD;
          for( int i = 0; i < n; i++ ) if( par[i] < 0 && d[i] < bestD )
               bestD = d[u = i];
          if( bestD == MOD ) break;
          par[u] = -par[u] - 1;
          for( int i = 0; i < deg[u]; i++ ) {
               int v = adj[u][i];
               if( par[v] >= 0 ) continue;
               if( fnet[v][u] && d[v] > Pot(u,v) - cost[v][u] ) 
                    d[v] = Pot( u, v ) - cost[v][u], par[v] = -u-1;

               if( fnet[u][v] < cap[u][v] && d[v] > Pot(u,v) + cost[u][v] ) 
                    d[v] = Pot(u,v) + cost[u][v], par[v] = -u - 1;
          }
     }
     for( int i = 0; i < n; i++ ) if( pi[i] < MOD ) pi[i] += d[i];
     return par[t] >= 0;
}

int mcmf3( int n, int s, int t, int &fcost ) {
     memset(deg,0,sizeof(deg));
     for( int i = 0; i < n; i++ )
          for( int j = 0; j < n; j++ ) 
               if( cap[i][j] || cap[j][i] ) adj[i][deg[i]++] = j;
     memset(fnet,0,sizeof(deg));
     memset(pi,0,sizeof(deg));
     int flow = fcost = 0;
     while( dijkstra( n, s, t ) ) {
          int bot = MOD;
          for( int v = t, u = par[v]; v != s; u = par[v = u] )
               bot = min(bot,fnet[v][u] ? fnet[v][u] : ( cap[u][v] - fnet[u][v] ));
          for( int v = t, u = par[v]; v != s; u = par[v = u] )
               if( fnet[v][u] ) { fnet[v][u] -= bot; fcost -= bot * cost[v][u]; }
               else { fnet[u][v] += bot; fcost += bot * cost[u][v]; }
          flow += bot;
     }
     return flow;
}

int solve(int &flow,int &fcost) {
     flow = mcmf3(202,0,201,fcost);
     return flow;
}

int main(){
     //clock_t tStart = clock();
     int t,m,k;
     TCS(){
          SI(n),SI(m),SI(k);
          refresh();
          FI(i,1,202) FI(j,1,n+1) dp[i][j] = MOD;
          FI(i,0,m) {
               int u,v,w;
               SI(u),SI(v),SI(w);
               dp[u][v] = min(dp[u][v],w);
               dp[v][u] = min(dp[v][u],w);
          }
          FI(i,1,n+1) dp[i][i] = 0;
          FI(k,1,n+1) {
               FI(i,1,n+1) {
                    FI(j,1,n+1) {
                         dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);
                    }
               }
          }
          FI(i,1,k+1) cap[0][i] = 1;
          FI(i,1,k+1) cost[0][i] = 0;

          FI(i,1,k+1) {
               FI(j,n-k+1,n+1) {
                    cap[i][j] = 1;
                    cost[i][j] = min((int)1e4,dp[i][j]);
               }
          }
          FI(j,n-k+1,n+1) cost[j][201] = 0,cap[j][201] = 1;
          int fcost = 0,flow = 0;
          flow = solve(flow,fcost);
          PI(fcost);
     }


     //exectime();  
     return 0;        
}


