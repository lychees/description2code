#include <algorithm>
#include <functional>
#include <utility>
#include <queue>
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <complex>

#define FOR(i, n) for(lli i = 0; i < (lli)(n); ++i)
#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)
#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)

#define X(A) get<0>(A)
#define Y(A) get<1>(A)
#define Z(A) get<2>(A)

#define mp make_pair
#define mt make_tuple
#define pb push_back

//------------------------------------------------------------------------------

using namespace std;
using lli = long long int;
using llu = long long unsigned;

using pii = tuple<lli, lli>;
using ppii = tuple<pii, pii>;
using piii = tuple<lli, lli, lli>;
using vi = vector<lli>;
using vii = vector<pii>;
using viii = vector<piii>;
using vvi = vector<vi>;
using vvii = vector<vii>;
using vviii = vector<viii>;

//------------------------------------------------------------------------------

template <typename T>
inline void hash_combine (size_t& seed, const T& val){
  seed ^= hash<T>()(val) + 0x9e3779b9 + (seed<<6) + (seed>>2);
}

template <typename T, typename... Ts>
void hash_combine (size_t& seed, const T& val, const Ts&... args){
  hash_combine(seed,val);
  hash_combine(seed,args...);
}

void hash_combine (size_t&){}

template <typename... Ts>
size_t hash_val (const Ts&... args){
  size_t seed = 0;
  hash_combine (seed, args...);
  return seed;
}

//------------------------------------------------------------------------------

template<class A, class B>
ostream& operator<<(ostream& s, pair<A, B> const& a){
  return s << "(" << X(a) << "," << Y(a) << ")";
}

template<class A, class B>
ostream& operator<<(ostream& s, tuple<A, B> const& a){
  return s << "(" << X(a) << "," << Y(a) << ")";
}

template<class A, class B, class C>
ostream& operator<<(ostream& s, tuple<A, B, C> const& a){
  return s << "(" << X(a) << "," << Y(a) << "," << Z(a) << ")";
}

template<class T>
ostream& operator<<(ostream& s, vector<T> const& a){
  FOR(i, a.size()){
    s << a[i];
    if(i != (lli)a.size()-1) s << " ";
  }
  return s;
}

//------------------------------------------------------------------------------

using cpx = complex<double>;
double cossenos[524288+100], senos[524288+100];
cpx angle(int dir, int i) {
  return cpx(cossenos[i], dir*senos[i]);
}

void FFT(cpx *in, cpx *out, int step, int size, int dir) {
  if(size < 1) return;
  if(size == 1) {
    out[0] = in[0];
    return;
  }
  FFT(in, out, step * 2, size / 2, dir);
  FFT(in + step, out + size / 2, step * 2, size / 2, dir);
  for(int i = 0 ; i < size / 2 ; i++) {
    cpx even = out[i];
    cpx odd = out[i + size / 2];
    out[i] = even + angle(dir, i*step)*odd; //even + EXP(dir * two_pi * i / size) * odd;
    out[i + size / 2] = even + angle(dir, i*step+524288/2)*odd; //even + EXP(dir * two_pi * (i + size / 2) / size) * odd;
  }
}

// ---

int main(int, char**){
  ios::sync_with_stdio(false);
  for (int i = 0; i <= 524288; i++) {
    cossenos[i] = cos(2*M_PI*i/524288);
    senos[i] = sin(2*M_PI*i/524288);
  }
  lli n; cin >> n;
  lli r = 0;
  vector<cpx> A(524288, cpx(0, 0));
  vector<cpx> B(524288, cpx(0, 0));
  FOR(i, n){
    lli x; cin >> x;
    if(A[131072+x].real() > 0) r = 1;
    A[131072+x] = cpx(1, 0);
    B[131072-x] = cpx(1, 0);
  }
  vector<cpx> C(524288, cpx(0, 0));
  vector<cpx> D(524288, cpx(0, 0));
  // FFT
  FFT(A.data(), C.data(), 1, 524288, 1);
  FFT(B.data(), D.data(), 1, 524288, 1);
  FOR(i, 524288) C[i] = C[i]*D[i];
  FFT(C.data(), A.data(), 1, 524288, -1);

  FORU(i, 262145, 524287) {
    if(A[i].real() > 1000) {
      r += 1;
    }
  }
  cout << r << endl;

  return 0;
}
