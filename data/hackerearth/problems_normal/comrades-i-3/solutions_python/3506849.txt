def bfs(x):
    b=[False]*(n+1)# an array of false flags to keep track of vertices visited
    #memo=[-1]*(n+1)
    global memo,component_id,root
    #found=False
    c=0
    q=[]
    q.append(x)
    component_id[x]=c
    #root=0
    memo[x]=0
    while len(q)!=0 :
        #t=s[-1]
        top=q.pop()
        #print "top",top
        #l=t
        b[top]=True
        #q.pop(0)
        for j in G[top]:
            if memo[j]==-2 :
                
                    memo[j]=1+memo[top]
                    if root<memo[j]:
                        root=memo[j]
                    b[j]=True
                    q.append(j)
                    component_id[j]=top
                
                    
def trail(i,j):
    global component_id,p
    found=False
    while memo[i]>=memo[j] and not found:
        if j==component_id[i]:
            found=True
        i=component_id[i] 
    return found          
t=input()

while t!=0:
 n=int(raw_input())
 m=map(int,raw_input().split())
 G=[[] for i in xrange(n+1)]
 root=0
 memo=[-2]*(n+1)
 component_id=[-2]*(n+1)
 memo[0]=-1
 component_id[0]=-1
 p=0
 for i in xrange(n):
     if m[i]==0:
         p=i+1
     G[i+1].append(m[i])
     G[m[i]].append(i+1)
 #print p    
 #print G    
 bfs(p)
 #print memo
 #print component_id
 #print root
 query=int(raw_input())
 for _ in xrange(query):
     x,y=map(int,raw_input().split())
     if memo[x]-memo[y]>0:
        if root==n-1:
            print memo[x]-memo[y]-1
        else:    
             
        
          if trail(x,y)==True:
            print memo[x]-memo[y]-1
          else:
            print -1    
                 
     else:
          print -1 
             
 #print memo
 #print component_id
 t-=1   
 
    #print memo[i]    