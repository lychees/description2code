/*******************
  	Rahul Bhati
	CHARUSAT UNIVERSITY
	***********************/

#include <bits/stdc++.h>

using namespace std;

/* Time saving techniques :D */

typedef long long ll;
typedef unsigned long long ull;
typedef vector <int> vi;
typedef pair< int ,int > pii;
typedef istringstream iss;
typedef ostringstream oss;

#define pb              push_back
#define mp              make_pair
#define ff              first
#define ss              second
#define sz              size()
#define ln              length()
#define rep(i,n)        for(int i=0;i<n;i++)
#define fu(i,a,n)       for(int i=a;i<=n;i++)
#define fd(i,n,a)       for(int i=n;i>=a;i--)
#define foreach(it,v)   for( __typeof((v).begin())it = (v).begin() ; it != (v).end() ; it++ )
#define all(a)          a.begin(),a.end()
#define INF             (int)1e9
#define EPS             (1e-9)
#define INF_MAX         2147483647
#define INF_MIN         -2147483647
#define pi              acos(-1.0)
#define dbg(x)          { cout<< #x << ": " << (x) << endl; }
#define dbg2(x,y)       { cout<< #x << ": " << (x) << " , " << #y << ": " << (y) << endl; }
#define mset(a, s)      memset(a, s, sizeof (a))
#define Read(r)         freopen(r, "r", stdin)
#define Write(w)        freopen(w, "w", stdout)
#define N               100007

// Segmented Tree :D
vi add[N];
int tin[N],tout[N];
int tim;
void dfs(int cur,int par){
    int i;
    tin[cur] = ++tim;
    for(i=0;i<add[cur].size();i++){
        int nxt = add[cur][i];
        if(nxt != par){
            dfs(nxt,cur);
        }
    }
    tout[cur] = tim;
}

struct node{
    int cnt;
    int lazy;
}t[4*N];

void create(int node,int s,int e){
    if(s == e){
        t[node].cnt = 1;
        t[node].lazy = 0;
        return;
    }
    int m = (s+e)/2;
    int c = 2*node;
    create(c,s,m);
    create(c+1,m+1,e);
    t[node].cnt = t[c].cnt + t[c+1].cnt;
}

void update(int node,int s,int e,int x,int y,int v){
    if(s > e)
        return;
    int m = (s+e)/2;
    int c = 2*node;
    if(t[node].lazy){
        if(t[node].lazy == 1)
            t[node].cnt = 0;
        else
            t[node].cnt = e - s + 1;
        if(s != e){
            t[c].lazy = t[c+1].lazy = t[node].lazy;
        }
        t[node].lazy = 0;
    }
    if(s > y || e < x)
        return;
    if(x <= s && e <= y){
        if(v == 1)
            t[node].cnt = 0;
        else
            t[node].cnt = e - s + 1;
        if(s != e){
            t[c].lazy = t[c+1].lazy = v;
        }
        return;
    }
    update(c,s,m,x,y,v);
    update(c+1,m+1,e,x,y,v);
    t[node].cnt = t[c].cnt + t[c+1].cnt;
}
int query(int node,int s,int e,int x,int y){
    if(s > e || s > y || e < x)
        return 0;
    int m = (s+e)/2;
    int c = 2*node;
    if(t[node].lazy){
        if(t[node].lazy == 1)
            t[node].cnt = 0;
        else
            t[node].cnt = e - s + 1;
        if(s != e){
            t[c].lazy = t[c+1].lazy = t[node].lazy;
        }
        t[node].lazy = 0;
    }
    if(x <= s && e <= y){
        return t[node].cnt;
    }
    return query(c,s,m,x,y) + query(c+1,m+1,e,x,y);
}
int main(){
    //Read("input.in");
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n,i;
    cin>>n;
    int root = -1;
    for(i=1;i<=n;i++){
        int j;
        cin>>j;
        if(j == 0)
            root = i;
        else
            add[j].pb(i);
    }
    dfs(root,0);
	create(1,1,n);
    int q;
    cin>>q;
    while(q--){
        int op,u;
        cin>>op>>u;
        if(op <= 2){
            update(1,1,n,tin[u]+1,tout[u],3-op);
        }
        else{
            int ans = query(1,1,n,tin[u]+1,tout[u]);
            cout<<ans<<endl;
        }
    }
    return 0;
}

