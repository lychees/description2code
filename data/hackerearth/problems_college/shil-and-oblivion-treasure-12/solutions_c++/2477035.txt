#include<iostream>
#include<vector>
#include<map>
#
using namespace std;
#define pb push_back
#define mp make_pair
#define ft first
#define sd second
#define mem(a,v) memset(a,v,sizeof(a))
#define ll long long int
typedef pair<int, int> PII;
//int query(int nn,int a,int b,int l,int r,int p);
const ll mod = 1000000007;

ll power(ll a, ll n)
{   ll ans=1;
while(n)
{
	if(n&1)
	ans=(ans*a)%mod;
	a=(a*a)%mod;
	n=n/2;
}
return ans;
}

 const int lmt = 10005;
 struct node{
    int freq[1005];
};
node tree[4*lmt];
int in[10005];
int expo[1005][1005];
vector<int> primes;

ll inv(ll a){
    ll ans = power(a,mod-2);
    return ans;
}

void factorise(int x){
    int tmp = x;
    int cnt = 0;
    if(x%2==0){
        cnt=0;
        while(x%2==0){
            cnt++;
            x = x/2;
        }
        expo[tmp][2] = cnt;
    }
    for(int i=3;i*i<=x;i+=2){
        if(x%i==0){
            cnt = 0;
            while(x%i==0){
                cnt++;
                x = x/i;
            }
            expo[tmp][i] = cnt;
        }
    }
    if(x>1)
        expo[tmp][x] = 1;
    return;
}

void pre(){
    for(int i=1;i<=1000;i++)
        factorise(i);
}

void getprime(){
    for(int i=1;i<=1000;i++){
        bool ok = true;
        for(int j=2;j*j<=i;j++){
            if(i%j==0){
                ok = false;
                break;
            }
        }
        if(ok) primes.pb(i);
    }
}

void create(int nn,int a,int b){
    if(a>b) return;
    if(a==b){
        for(int i=1;i<=1000;i++)
            tree[nn].freq[i] = expo[in[a]][i];
        return;
    }
    int mid = (a+b)>>1;
    int lt = nn<<1;
    int rt = lt+1;
    create(lt,a,mid);
    create(rt,mid+1,b);
    for(int i=1;i<=1000;i++)
            tree[nn].freq[i] = max(tree[lt].freq[i],tree[rt].freq[i]);
    return;
}

void update(int nn,int a,int b,int p,int x){
    if(a>b || p<a || p>b) return;
    if(a==b){
        in[a] = x;
        for(int i=1;i<=1000;i++)
            tree[nn].freq[i] = expo[in[a]][i];
        return;
    }
    int mid = (a+b)>>1;
    int lt = nn<<1;
    int rt = lt+1;
    update(lt,a,mid,p,x);
    update(rt,mid+1,b,p,x);
    for(int i=1;i<=1000;i++)
            tree[nn].freq[i] = max(tree[lt].freq[i],tree[rt].freq[i]);
    return;
}

int query(int nn,int a,int b,int l,int r,int p){
    if(a>b || b<l || a>r) return 0;
    if(l<=a && b<=r){
//        if(p==2){
//            cout<<"return for "<<a<<":"<<b<<endl;
//            for(int i=1;i<=5;i++)
//                cout<<tree[nn].freq[i]<<endl;
//        }
        return tree[nn].freq[p];
    }
    int mid = (a+b)>>1;
    int lt = nn<<1;
    int rt = lt+1;
    int ans1 = query(lt,a,mid,l,r,p);
    int ans2 = query(rt,mid+1,b,l,r,p);
    ans1 = max(ans1,ans2);
//    if(p==2){
//     cout<<"return for "<<a<<" : "<<b<<" - "<<ans1<<endl;
//    }
    return ans1;
}
void print(int nn,int a,int b);
int main()
{   int n,q,l,r,ch;
    pre();
    getprime();
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&in[i]);
    create(1,0,n-1);
    scanf("%d",&q);
    while(q--){
        scanf("%d %d %d",&ch,&l,&r);
       // print(1,0,n-1);
        if(ch==1){
            l--;
            update(1,0,n-1,l,r);
        }
        else{
            l--;
            r--;
            ll ans = 1;
            for(int i=0;i<primes.size();i++){
                int cnt = query(1,0,n-1,l,r,primes[i]);
         //       cout<<primes[i]<<" : "<<cnt<<endl;
                ans = (ans*power(primes[i],cnt))%mod;
            }
           cout<<ans<<endl;
        }

    }

	return 0;
}
void print(int nn,int a,int b){
    if(a>b) return;
    cout<<"for "<<a<<" : "<<b<<endl;
     for(int i=1;i<=5;i++)
        cout<<i<<" : "<<tree[nn].freq[i]<<endl;
    if(a==b){
        return;
    }
    int mid = (a+b)>>1;
    int lt = nn<<1;
    int rt = lt+1;
    print(lt,a,mid);
    print(rt,mid+1,b);
}