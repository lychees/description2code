#include <bits/stdc++.h>
// iostream is too mainstream
#include <cstdio>
// bitch please
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <cmath>
#include <iomanip>
#include <time.h>
#define dibs reserve
#define OVER9000 1234567890
#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)
#define tisic 47
#define soclose 1e-8
#define chocolate win
// so much chocolate
#define patkan 9
#define ff first
#define ss second
#define abs(x) ((x < 0)?-(x):x)
#define uint unsigned int
#define dbl long double
#define pi 3.14159265358979323846
using namespace std;
// mylittledoge

struct node {
	int z,k;
	long long val,mod;
	int son[2];
	};

struct intervalac {
	vector<node> T;

	void constI(int akt) {
		node n =T[akt];
		if(n.k-n.z == 1) return;
		for(int i =0; i < 2; i++) {
			if(i == 0) n.k =(n.z+n.k)/2;
			else {n.z =n.k; n.k =T[akt].k;}
			T[akt].son[i] =T.size();
			T.push_back(n);
			constI(T.size()-1);}
		}

	intervalac(int N) {
		node n;
		n.son[0] =n.son[1] =-1;
		n.z =0, n.k =N;
		n.val =n.mod =0;
		T.dibs(2*N);
		T.push_back(n);
		constI(0);}

	void upd(int akt) {
		node n =T[akt];
		if(n.mod == 0) return;
		for(int i =0; i < 2; i++) if(n.son[i] != -1)
			T[n.son[i]].mod +=n.mod;
		T[akt].val +=n.mod*(n.k-n.z);
		T[akt].mod =0;}

	void put(int akt, int zac, int kon, long long val) {
		upd(akt);
		node n =T[akt];
		if(n.z >= kon || zac >= n.k) return;
		if(zac == n.z && kon == n.k) {
			T[akt].mod +=val;
			upd(akt);
			return;}
		put(n.son[0],zac,min(kon,T[n.son[0]].k),val);
		put(n.son[1],max(zac,T[n.son[1]].z),kon,val);
		T[akt].val =T[n.son[0]].val+T[n.son[1]].val;}

	long long get(int akt, int zac, int kon) {
		upd(akt);
		node n =T[akt];
		if(n.k <= zac || kon <= n.z) return 0;
		if(n.z == zac && n.k == kon) return n.val;
		long long ret =0;
		if(n.son[0] != -1) ret +=get(n.son[0],zac,min(kon,T[n.son[0]].k));
		if(n.son[1] != -1) ret +=get(n.son[1],max(zac,T[n.son[1]].z),kon);
		return ret;}
	};


int main() {
	cin.sync_with_stdio(0);
	cin.tie(0);
	cout << fixed << setprecision(10);
	int N;
	cin >> N;
	vector<int> A(N);
	for(int i =0; i < N; i++) cin >> A[i];
	
	map<int,int> last;
	intervalac I(N);
	long long ans =0, akt =0, mod =1000000007;
	I.put(0,0,N,1);

	for(int i =N-1; i >= 0; i--) {
		auto it =last.find(A[i]);
		int y =(it == end(last))?N:it->ss;
		last[A[i]] =i;
		akt +=I.get(0,i,y);
		I.put(0,i,y,2);
		akt %=mod;
		ans +=akt;}

	ans %=mod;
	if(ans < 0) ans +=mod;
	cout << ans << "\n";
	return 0;}

// look at my code
// my code is amazing
