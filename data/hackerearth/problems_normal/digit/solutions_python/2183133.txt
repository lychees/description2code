A, B, X, Y, K=map(int,raw_input().split())

def digsum(x):
	r=0
	while x>0:
		r+=x%10
		x/=10
	return r	
	#return sum(map(int,str(x)))

def simpleCount(l,r):
	if r<=l: return 0
	cnt=0
	incr=0
	if l%K: incr=K-l%K
	
	for x in xrange(l+incr,r,K):
		s=digsum(x)
		if X<=s<=Y:cnt+=1
	return cnt
if K>1.e5 or B-A<=2000000:
	print simpleCount(A,B+1)	
	exit()

FAC=1000000
maxDIGSUM=6*9+1
B+=1

mods=[[0]*K for i in range(maxDIGSUM)]
for i in range(FAC):
	mods[digsum(i)][i%K]+=1

for i in range(1,maxDIGSUM):
	for j in range(K):
		mods[i][j]+=mods[i-1][j]
	
res=0
last =A-(A%FAC)+FAC;
#assert last%FAC==0
res=simpleCount(A,last)
first=B-(B %FAC)
res+=simpleCount(first,B)
#assert first%FAC==0
#assert A<=last 
#assert last<first
#assert first<=B
#print A/FAC,last/FAC,first/FAC,B/FAC
su=digsum(last)-1
i=(last/FAC)%10
for x in xrange(last,first,FAC):
	m=x%K
	if m==0: m=K
	if i%10:
		su=su+1
	else:
		if i%100:
			su=su-8
		else:	
			if i%10000:
				if i%1000:
					su=su-17
				else: 
					su=su-26
			else:	
				su=digsum(x)
	i+=1
	if su<=Y:
		y=min(Y-su,maxDIGSUM-1)
		res+=mods[y][K-m]
	if su<=X-1:
		y=min(X-su-1,maxDIGSUM-1)
		res-=mods[y][K-m]
print res	
