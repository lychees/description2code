
#pragma comment(linker, "/STACK:1024000000,1024000000") 
#include <iostream> 
#include <stdlib.h> 
#include <ctime> 
#include <cmath> 
#include <stdio.h> 
#include <vector> 
#include <algorithm> 
#include <queue> 
#include <string.h> 
#include <map> 
#include <set> 
#include <assert.h>
#define x first 
#define y second 
#define pb push_back 
#define mp make_pair 
#define vi vector<int> 
#define pii pair<int,int> 
#define ll long long 
#define inf 1000000007 
#define mod 1000000007 
#define all(x) x.begin(),x.end() 
#define N 100010 
#define pi 3.141592653 
#define DBG(x) cerr<<#x<<"="<<x<<"\n"; 
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) 
using namespace std; 
   

int s[N];
struct node
{
    int ch[2],v;
    void init()
    {
        memset(ch,0,sizeof(ch));v=0;
    }
}t[N*20];
int sz=0,now,vis[N*20][2],dp[N*20][2];
void add(int v)
{
    int p=1;
    for(int i=29;i>=0;i--)
    {
        int j=v>>i&1;t[p].v++;
        if(t[p].ch[j]==0)
        {
            sz++;t[sz].init();t[p].ch[j]=sz;
        }
        p=t[p].ch[j];
    }
    t[p].v++;
}
int query(int x,int v,int r,int p,int f)
{
    if(p==0)return 0;
    if(x==-1){return t[p].v;}
    if(f)return t[p].v;
    int j=v>>x&1,k=r>>x&1;
    if(j&&k)return query(x-1,v,r,t[p].ch[1],1)+query(x-1,v,r,t[p].ch[0],0);
    if(!j&&!k)return query(x-1,v,r,t[p].ch[0],0);
    if(j&&!k)return query(x-1,v,r,t[p].ch[1],0);
    return query(x-1,v,r,t[p].ch[0],1)+query(x-1,v,r,t[p].ch[1],0);
}
ll ans[11];pii q[11];
int main() 
{ 
    int T,i,j,k,n,m;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        sz=1;t[sz].init();add(0);
        for(i=0;i<n;i++)
        {
            scanf("%d",&j);s[i+1]=j^s[i];
        }
        scanf("%d",&m);
        for(i=0;i<m;i++)scanf("%d%d",&q[i].x,&q[i].y),ans[i]=0;
            
            for(i=1;i<=n;i++)
            {
                for(j=0;j<m;j++)
                {
                    now++;
                    ans[j]+=query(29,s[i],q[j].y,1,0);
                    if(q[j].x)now++,ans[j]-=query(29,s[i],q[j].x-1,1,0);
                }
                add(s[i]);
            }
        for(i=0;i<m;i++)cout<<ans[i]<<"\n";
    }
}