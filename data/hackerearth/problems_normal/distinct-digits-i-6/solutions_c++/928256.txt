# include <iostream>
# include <algorithm>
# include <cstdio>
# include <cmath>
# include <numeric>
# include <cstdlib>
# include <cstring>
# include <vector>
# include <list>
# include <set>
# include <map>
# include <stack>
# include <queue>
# include <cctype>
# include <climits>
# include <complex>
using namespace std;
typedef long long ll ;
typedef unsigned long long ull;
ll INF = 1e9 ;
typedef pair < int , int > pii ;
typedef  vector < int > vi ;
typedef vector < pii > vpi ;
typedef vector < ll > vl ;
typedef pair < int , pii > tri ;
typedef vector < string > vs ;
typedef vector < vi > mat ;
#define all(a) a.begin(),a.end()
#define si(n) scanf("%d",&n)
#define ss(n) scanf("%s" , n)
#define sl(n) scanf("%lld" , &n)
#define pi(n) printf("%d" , n)
#define ps(n) printf("%s" , n)
#define pl(n) printf("%lld" , n)
#define pnl() printf("\n")
#define fors( i , a , b ) for ( int i = a ; i < b ; i++ )
#define pb push_back
#define ff first
#define mp make_pair
#define sz(a) a.size()
#define fill(a,v)  memset(a,v,sizeof(a))
#define index(arr,ind) (lower_bound(all(arr),ind)-arr.begin())
long long a[100005] ; 
int bit[11][100005] , cd[100005] , n ;
int coundigit( ll num )
{
    int b[10] , ans = 0  ; 
fors(i , 0 , 10)
b[i]  = 0 ;  
    while ( num > 0 )
    {
        b[num%10] = 1 ; 
        num = num / 10 ; 
    }
    fors(i , 0 , 10 )
    {
        if ( b[i])
            ans++ ; 
    }
    return ans ; 
} 

void update ( int idx , int val ,  int cou)
{
while ( idx <= n )
{
    bit[cou][idx] += val  ; 
    idx += ( idx & -(idx)) ; 
}
}

int query ( int idx , int cou )
{
    int ans = 0 ; 
    while ( idx > 0 )
    {
        ans += bit[cou][idx] ; 
        idx -= ( idx & -(idx) ) ; 
    }
    return ans ; 
}

int main()
{
    int  ans , q , type ,  u  , l , r , c ;
    ll v ; 
    si(n) ; 
    fors( i , 1 , (n+1))
    {
        sl(a[i]) ;
        cd[i] = coundigit(a[i]) ;
        update ( i , 1 , cd[i]) ;  
    }
    si(q) ; 
    while ( q-- )
    {
        
       si(type) ; 
       if ( type == 0 )
       {
           si(u) , sl(v) ;
           update ( u , -1 , cd[u]) ; 
           a[u] += v ; 
           cd[u] = coundigit(a[u]) ; 
           update ( u , 1 , cd[u] ) ;  
       }
       else if ( type == 1 )
       {
           si(u) , sl(v) ;
           update ( u , -1 , cd[u]) ; 
           a[u] = v ; 
           cd[u] = coundigit(a[u]) ; 
           update ( u , 1 , cd[u] ) ;   
           
       }
       else
       {
           si(l) , si(r) , si(c) ;
           ans =  query ( r , c ) - query( l - 1 , c) ;  
           pi(ans) , pnl() ; 
       }
    }
    return 0 ;
}

