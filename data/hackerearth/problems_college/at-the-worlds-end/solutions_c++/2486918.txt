#include<bits/stdc++.h>
using namespace std;
typedef struct node sn;
int A[500][500]={0},n,m;
struct node 
{
	int sum,msum;// It keeps a track of the pathh till thecurrent state
	// Sum is the sum of all values in the path and msum is the minimum sum encountered between the path !
};
int _dp[500][500]={0};
node dp[500][500];
sn doit(int x,int y)
{
	if (x<0||y<0)
		return (sn){(INT_MIN/2),INT_MAX>>1};
	if (x==0&&y==0)
		return (sn){0,0};
	if (_dp[x][y]<0) return (sn){0,0};
	
	if (_dp[x][y])
		return dp[x][y];
	sn a=doit(x-1,y);
	sn b=doit(x,y-1);
	int aa=min(A[x][y]+a.sum,a.msum);
	int bb=min(A[x][y]+b.sum,b.msum);
	_dp[x][y]=1;
	if (aa>bb)
	{
		return dp[x][y]=(sn){A[x][y]+a.sum,aa};
	}
	else if (aa<bb)
		return dp[x][y]=(sn){A[x][y]+b.sum,bb};
	else
	{
		return dp[x][y]=(sn){ max(A[x][y]+a.sum,A[x][y]+b.sum) , aa};
	}		
}
int main()
{
	int t;
	scanf("%d",&t);
	while (t--)
	{

		scanf("%d%d",&n,&m);
		int i,j;
		for (i=0;i<n;i++)
			for (j=0;j<m;j++)
			{
				scanf("%d",&A[i][j]);
				_dp[i][j]=0;
			}
		sn ans=doit(n-1,m-1);
		if (ans.msum>0)
			ans.msum=0;
		else
			ans.msum=1-ans.msum;
		printf("%d\n",ans.msum);
	}
	return 0;
}