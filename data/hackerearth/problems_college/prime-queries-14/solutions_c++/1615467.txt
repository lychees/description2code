/*
 * program.cpp
 *
 *  Created on: Dec 30, 2014
 *      Author: anoosh
 */



#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <stack>
#include <vector>
#include <algorithm>
#include <iterator>
#include <set>
#include <map>
#include <cmath>
#include <sstream>
#include <limits>
#include <bitset>

using namespace std;

typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ll, bool> plb;
typedef vector<int> vec;

#define pb push_back
#define mp make_pair
#define f first
#define s second
#define MAX 100005 // 10^5
#define MAX1 1000005 // 10^6
#define INF 10000000000
#define MOD 1000000007 // 10^9+7
#define N 11
#define K 105
#define newline cout << endl;
#define mem(h, val) memset(h, val, sizeof(h))
#define rep(i, a, n) for(i = a; i < n; i++)
#define dash printf("------------------\n")
#define scan(n) scanf("%d", &n)
#define scanl(n) scanf("%lld", &n)
#define print(n) printf("%d", n)
#define printl(n) printf("%lld", n)
#define nl printf("\n")


int A[MAX];
int tree[4*MAX];
int p[MAX1];

void markMultiples(int a)
{
    int i = 2, num;
    while ( (num = i*a) <= (MAX1-1) )
    {
        p[ num-1 ] = 1;
        ++i;
    }
}


void Sieve()
{
    // There are no prime numbers smaller than 2

        mem(p, 0);

        p[0] = 1;

        for (int i=1; i<MAX1; ++i)
        {
            if ( p[i] == 0 )
            {

                markMultiples(i+1); // i+1 is prime
            }
        }
}


// build(1, 0, n-1)

void build(int node, int a, int b) {

	if(a > b) return;

	if(a == b) {
		tree[node] = ((p[A[a]-1] == 0) ? A[a] : -1);
		return;
	}

	build(node<<1, a, (a+b)/2);
	build(node<<1|1, (a+b)/2 + 1, b);

	tree[node] = max(tree[node<<1], tree[node<<1|1]);
}

//query(1, 0, n-1, l, r)

int query(int node, int a, int b, int i, int j) {

	if(a > b || b < i || a > j) return -1;

	if(a >= i && b <= j) return tree[node];

	int q1 = query(node<<1, a, (a+b)/2, i, j);
	int q2 = query(node<<1|1, (a+b)/2 + 1, b, i, j);

	return max(q1, q2);

}

void p_update(int node, int a, int b, int i, int val) {

	if(a > b || a > i || b < i) return;

	if(a == b) {
		A[a] = val;
		tree[node] = ((p[A[a]-1] == 0) ? A[a] : -1);
		return;
	}

	if(i <= (a+b)/2)
		p_update(node<<1, a, (a+b)/2, i, val);
	else
		p_update(node<<1|1, (a+b)/2 + 1, b, i, val);

	tree[node] = max(tree[node<<1], tree[node<<1|1]);
}



int main() {


	int n, q, i; scan(n); scan(q);

	rep(i, 0, n) scan(A[i]);

	Sieve();

	build(1, 0, n-1);

	while(q--) {

		int choice; scan(choice);

		int l, r;scan(l); scan(r);

		if(choice) {

			int ans = query(1, 0, n-1, l-1, r-1);

			print(ans);
			nl;
		}
		else {

			p_update(1, 0, n-1, l-1, r);
		}
	}


	return 0;
}
