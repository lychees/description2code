#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <list>
#include <algorithm>
using namespace std;

#define nln        puts("")                         ///prLLInewline
#define getLLI(a)  scanf("%d",&a);
#define max3(a,b,c) max(a,max(b,c))                  ///3 ta theke max
#define min3(a,b,c) min(a,min(b,c))                  ///3 ta theke min

#define FOR1(i,n)  for(LLI i=1;i<=n;i++)
#define FOR0(i,n)  for(LLI i=0;i<n;i++)                 ///looping
#define FORR(i,n)  for(LLI i=n-1;i>=0;i--)
#define ALL(p)     p.begin(),p.end()

#define SET(p)     memset(p,-1,sizeof(p))
#define CLR(p)     memset(p,0,sizeof(p))            ///memset
#define MEM(p,v)   memset(p,v,sizeof(p))

#define READ(f)    freopen(f, "r", stdin)           /// file
#define WRITE(f)   freopen(f, "w", stdout)

#define SZ(c)      (LLI)c.size()
#define PB(x)      push_back(x)                     ///STL defines
#define MP(x,y)    make_pair(x,y)
#define ff         first
#define ss         second

#define LI         long LLI
#define LLI        long long //LLI
#define f64        long double
#define PI         acos(-1.0)                        ///PI er value

LLI Set(LLI N,LLI pos)
{
    return N=N | (1<<pos);
}
LLI reset(LLI N,LLI pos)
{
    return N= N & ~(1<<pos);
}
bool check(LLI N,LLI pos)
{
    return (bool)(N & (1<<pos));
}
void CI(LLI &_x)
{
    cin>>_x;
//    scanf("%",&_x);
}

void CO(LLI &_x)
{
    cout<<_x;
}

template<typename T> void getarray(T a[],LLI n)
{
    for(LLI i=0; i<n; i++) cin>>a[i];
}
template<typename T> void prLLIarray(T a[],LLI n)
{
    for(LLI i=0; i<n-1; i++) cout<<a[i]<<" ";
    cout<<a[n-1]<<endl;
}

const double EPS=1e-9;                              ///constatnts
const LLI INF=0x7f7f7f7f;

LLI dr8[8]= {1,-1,0,0,1,-1,-1,1};            ///8 direction move
LLI dc8[8]= {0,0,-1,1,1,1,-1,-1};
LLI dr4[4]= {0,0,1,-1};                      ///4 direction move
LLI dc4[4]= {-1,1,0,0};                      ///or adjacent dir.
LLI kn8r[8]= {1,2,2,1,-1,-2,-2,-1};          ///knight moves
LLI kn8c[8]= {2,1,-1,-2,-2,-1,1,2};
LLI gcd(LLI a,LLI b)
{

    if(b==0)return a;
    return gcd(b,a%b);

}
int ans1,ans2,ans3;
map<pair<LLI,LLI>,int>k;
map<LLI,map<LLI,map<LLI,bool> > > found;
void input()
{
    LLI a,b,c;
  cin>>a>>b>>c;
    LLI gc=gcd(a,b);
    gc=gcd(gc,c);
    a/=gc;
    b/=gc;
    c/=gc;

if(found[a][b][c]==1)return;
found[a][b][c]=1;
    if(a==0)ans1++;
    else if(b==0)ans2++;
    else
    {
        LLI g=gcd(a,b);
        a=a/g;
        b=b/g;
        k[MP(a,b)]++;
    }


}
int main()
{
//cout<<gcd(0,9);
    int t;
   cin>>t;

    while(t--)
    {
        ans1=0;
        ans2=0;
        ans3=0;
        k.clear();
        found.clear();
        int n;
        scanf("%d",&n);
        for(int i=0; i<n; i++)
        {

            input();
        }
        map<pair<LLI,LLI>,int>:: iterator it;

        for(it=k.begin(); it!=k.end(); it++)
        {
ans3=max(ans3,it->second);

        }
        cout<<max(max(ans1,ans2),ans3)<<"\n";

    }

}
