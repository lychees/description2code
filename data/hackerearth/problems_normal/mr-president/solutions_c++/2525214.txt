#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <utility>
#include <queue>
#include <functional>

int id[1000001];
using namespace std;
void initialize(int n)
{
    for(int i = 1;i <= n;++i)
        id[i] = i;
}
int root(int x)
{
    while(id[x] != x)
    {
        id[x] = id[id[x]];
        x = id[x];
    }
    return x;
}

void union1(int x, int y)
{
    int p = root(x);
    int q = root(y);
    id[p] = id[q];
}
bool findd(int A,int B)
{
    if( root(A)==root(B) )       //if A and B have same root,means they are connected.
    return true;
    else
    return false;
}
int kruskal(vector<pair<long, pair<int,int>>> p1,int m,long cost,int n)
{
	long min_cost = 0;
	vector<int> v2;
	for(int i = 0;i<m;i++)
	{
		int x = p1[i].second.first;
		int y = p1[i].second.second;
		int z = p1[i].first;
		if(root(x) != root(y))
		{
			union1(x,y);
			min_cost += z;
			v2.push_back(z);
		}
	}
	for(int i = 2;i<=n;i++)
	{
		if(findd(1,i) == false)
		return -1;
	}
	if(min_cost <=cost)
	return 0;
	int k =0;
	for(int i = v2.size()-1;i>=0;i--)
	{
		min_cost = min_cost - v2[i] +1;
		k++;
		if(min_cost<=cost)
		return k;
	}
	return -1;
}

int main()
{
    int n,m;
    long cost;
    scanf("%d%d%ld",&n,&m,&cost);
   /* const int MAX = 1e6 + 5;
typedef pair<long long, int> PII;
bool marked[MAX];
vector <PII> adj[MAX
priority_queue<PII, vector<PII>, greater<PII> > Q;*/
    initialize(n);
    vector<pair<long, pair<int,int>>>p1;
    	int x,y,z;
    	for(int i =0;i<m;i++)
    	{
    	scanf("%d%d%d",&x,&y,&z);
    	p1.push_back(make_pair(z,make_pair(x,y)));
    	
    	}
    	sort(p1.begin(), p1.end());
    int minimumCost = kruskal(p1,m,cost,n);
    cout << minimumCost << endl;
    
    return 0;
}