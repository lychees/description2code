#include<bits/stdc++.h>
using namespace std;
#define S(a) scanf("%d",&a)
#define S2(a,b) scanf("%d%d",&a,&b)
#define SL2(a) scanf("%lld%lld",&a,&b)
#define r5 100005
#define r6 1000055
#define r7 12800005
#define f(i,a,b) for(i=a;i<b;i++)
#define P(a) printf("%d",a)
#define PL(a) printf("%I64d",a)
#define pb push_back
#define nl printf("\n")
#define _s printf(" ")
#define inf INT_MAX
#define X first
#define Y second
typedef long long ll;
typedef pair<int,int> ii;
typedef vector<int> vi;

ll mod = 1000000007;

ll power(ll a, ll n)
{
	if(n==0)
		return 1;
	ll b=power(a, n/2);
	b=(b*b)%mod;
	if(n&1)
		b=(b*a)%mod;
	return b;
}


const int lmt = 10005;
int in[lmt];
int expo[1005][1005];
vector<int> primes;

ll inv(ll a){
    ll ans = power(a,mod-2);
    return ans;
}

void factorise(int x){
    int tmp = x,i,cnt = 0;
    if(x%2==0){
        cnt=0;
        while(x%2==0){
            cnt++;
            x = x/2;
        }
        expo[tmp][2] = cnt;
    }
    for(i=3;i*i<=x;i+=2){
        if(x%i==0){
            cnt = 0;
            while(x%i==0){
                cnt++;
                x = x/i;
            }
            expo[tmp][i] = cnt;
        }
    }
    if(x>1)
        expo[tmp][x] = 1;
    return;
}

void pre(){
    for(int i=1;i<=1000;i++)
        factorise(i);
}

void prime(){
    int i,j;
    for(i=1;i<=1000;i++){
        bool ok = true;
        for(j=2;j*j<=i;j++){
            if(i%j==0){
                ok = false;
                break;
            }
        }
        if(ok) primes.pb(i);
    }
}

struct node{
    int freq[1005];
};

node tree[4*lmt];

void create(int nn,int a,int b){
    int i;
    if(a>b) return;
    if(a==b){
        for(i=1;i<=1000;i++)
            tree[nn].freq[i] = expo[in[a]][i];
        return;
    }
    int m = (a+b)>>1;
    int l = nn<<1;
    int r = l+1;
    create(l,a,m);
    create(r,m+1,b);
    for(int i=1;i<=1000;i++)
            tree[nn].freq[i] = max(tree[l].freq[i],tree[r].freq[i]);
    return;
}


int query(int nn,int a,int b,int l,int r,int p){
    if(a>b || b<l || a>r) return 0;
    if(l<=a && b<=r){
        return tree[nn].freq[p];
    }
    int mid = (a+b)>>1;
    int lt = nn<<1;
    int rt = lt+1;
    int ans1 = query(lt,a,mid,l,r,p);
    int ans2 = query(rt,mid+1,b,l,r,p);
    ans1 = max(ans1,ans2);
    return ans1;
}

void update(int nn,int a,int b,int p,int x){
    int i;
    if(a>b || p<a || p>b) return;
    if(a==b){
        in[a] = x;
        for(i=1;i<=1000;i++)
            tree[nn].freq[i] = expo[in[a]][i];
        return;
    }
    int m = (a+b)>>1;
    int l = nn<<1;
    int r = l+1;
    update(l,a,m,p,x);
    update(r,m+1,b,p,x);
    for(int i=1;i<=1000;i++)
            tree[nn].freq[i] = max(tree[l].freq[i],tree[r].freq[i]);
    return;
}


void print(int nn,int a,int b){
    int i;
    if(a>b) return;
    cout<<"for "<<a<<" : "<<b<<endl;
     for(i=1;i<=5;i++)
        cout<<i<<" : "<<tree[nn].freq[i]<<endl;
    if(a==b){
        return;
    }
    int m = (a+b)>>1;
    int l = nn<<1;
    int r = l+1;
    print(l,a,m);
    print(r,m+1,b);
}

int main()
{   int n,q,l,r,chr,i;
    pre();
    prime();
    S(n);
    for(int i=0;i<n;i++)
        S(in[i]);
    create(1,0,n-1);
    S(q);
    while(q--){
        S2(chr,l);S(r);
        if(chr==1){
            l--;
            update(1,0,n-1,l,r);
        }
        else{
            l--;
            r--;
            ll ans = 1;
            for(i=0;i<primes.size();i++){
                int cnt = query(1,0,n-1,l,r,primes[i]);
                ans = (ans*power(primes[i],cnt))%mod;
            }
            printf("%lld\n",ans);
        }

    }
	return 0;
}
