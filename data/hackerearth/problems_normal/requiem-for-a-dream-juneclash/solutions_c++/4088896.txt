#include <cstdio>
#include <cmath>
#include <iostream>
#include <set>
#include <algorithm>
#include <vector>
#include <map>
#include <cassert>
#include <string>
#include <cstring>
#include <queue>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define S(x) scanf("%d",&x)
#define S2(x,y) scanf("%d%d",&x,&y)
#define P(x) printf("%d\n",x)
#define all(v) v.begin(),v.end()
#define FF first
#define SS second

typedef long long int LL;
typedef pair<int, int > pii;
typedef vector<int > vi;

const int N = 100005;

struct node {
  LL sum, prefix, suffix, ans;
  int p;
};

node P[N][20];
int dep[N];
int n;
vector<pii > g[N];

void dfs(int c, int p, int d) {
  dep[c] = d;
  rep(i,0,g[c].size()) {
    int u = g[c][i].FF;
    if(u != p) {
      P[u][0].p = c;
      P[u][0].sum = g[c][i].SS;
      P[u][0].ans = max(g[c][i].SS, 0);
      P[u][0].prefix = max(g[c][i].SS, 0);
      P[u][0].suffix = max(g[c][i].SS, 0);
      dfs(u, c, d + 1);
    }
  }
}

void pre() {
  P[1][0].p = -1;
  dfs(1,-1,0);

  rep(i,1,20) {
    rep(j,1,n+1) {
      if(P[j][i-1].p == -1 || P[P[j][i-1].p][i-1].p == -1) {
        P[j][i].p = -1;
        continue;
      }
      node &p = P[j][i-1];
      node &pp = P[P[j][i-1].p][i-1];
      P[j][i].p = pp.p;
      P[j][i].sum = p.sum + pp.sum;
      P[j][i].ans = max(max(p.ans, pp.ans), p.suffix + pp.prefix);
      P[j][i].prefix = max(p.prefix, p.sum + pp.prefix);
      P[j][i].suffix = max(pp.suffix, pp.sum + p.suffix);
    }
  }
}

int lca(int x, int y) {
  if(dep[x] < dep[y]) {
    swap(x,y);
  }

  for(int i = 19; i >= 0; i--) {
    if(dep[x] - (1<<i) >= dep[y]) {
      x = P[x][i].p;
    }
  }

  if(x == y) return x;

  for(int i = 19; i >= 0; i--) {
    if(P[x][i].p != P[y][i].p) {
      x = P[x][i].p;
      y = P[y][i].p;
    }
  }
  return P[x][0].p;
}

LL solve(const vector<pii> &a, const vector<pii> &b) {
  LL res = 0;
  LL sm = 0;
  rep(i,0,a.size()) {
    node &p = P[a[i].FF][a[i].SS];
    res = max(res, p.ans);
    res = max(res, sm + p.prefix);
    sm = max(sm + p.sum, p.suffix);
  }

  sm = 0;
  rep(i,0,b.size()) {
    node &p = P[b[i].FF][b[i].SS];
    res = max(res, p.ans);
    res = max(res, sm + p.prefix);
    sm = max(sm + p.sum, p.suffix);
  }

  LL s1,s2;
  s1 = 0, s2 = 0;
  sm = 0;
  for(int i = (int)a.size() - 1; i >= 0; i--) {
    node &p = P[a[i].FF][a[i].SS];
    s1 = max(s1, sm + p.suffix);
    sm += p.sum;
  }

  sm = 0;
  for(int i = (int)b.size() - 1; i >= 0; i--) {
    node &p = P[b[i].FF][b[i].SS];
    s2 = max(s2, sm + p.suffix);
    sm += p.sum;
  }

  return max(res, s1 + s2);
}

int main() {
  int q;
  S2(n,q);
  rep(i,0,n-1) {
    int u,v,x;
    scanf("%d%d%d",&u,&v,&x);
    g[u].push_back(make_pair(v,x));
    g[v].push_back(make_pair(u,x));
  }
  pre();

  while(q--) {
    int u,v;
    S2(u,v);
    vector<pii> a,b;
    int l = lca(u,v);
    for(int i = 19; i >= 0; i--) {
      if(dep[u] - (1<<i) >= dep[l]) {
        a.push_back(make_pair(u,i));
        u = P[u][i].p;
      }
    }

    for(int i = 19; i >= 0; i--) {
      if(dep[v] - (1<<i) >= dep[l]) {
        b.push_back(make_pair(v,i));
        v = P[v][i].p;
      }
    }
    printf("%lld\n",solve(a,b));
  }
  return 0;
}