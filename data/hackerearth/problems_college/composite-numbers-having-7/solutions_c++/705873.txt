#include <iostream>
#include <bitset>   // compact STL for Sieve, more efficient than vector<bool>!
#include <cmath>
#include <cstdio>
#include <map>
#include <unordered_set>
#include <vector>
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef map<int, int> mii;

ll _sieve_size;
bitset<10000010> bs;   // 10^7 should be enough for most cases
//vi primes;   // compact list of primes in form of vector<int>
unordered_set<int> primes;

// first part

void sieve(ll upperbound) {          // create list of primes in [0..upperbound]
  _sieve_size = upperbound + 1;                   // add 1 to include upperbound
  bs.set();                                                 // set all bits to 1
  bs[0] = bs[1] = 0;                                     // except index 0 and 1
  for (ll i = 2; i <= _sieve_size; i++) if (bs[i]) {
    // cross out multiples of i starting from i * i!
    for (ll j = i * i; j <= _sieve_size; j += i) bs[j] = 0;
    primes.insert((int)i);  // also add this vector containing list of primes
} }

bool is7(int n)
{
    while(n>0)
    {
        if(n%10==7)
            return true;
        n/=10;
    }
    return false;
}

int main()
{
    sieve(1000005);
    vector<int> ans(1000005);
    ans[0]=0;
    for(int i =1;i<ans.size();i++)
    {
        if(is7(i)&&primes.find(i)==primes.end())
        {
            ans[i] = 1+ans[i-1];
        }
        else
        {
            ans[i] = ans[i-1];
        }
    }

    /*for(int i =0;i<200;i++)
        cout<<i<<" -> "<<ans[i]<<endl;*/
    int cases;
    scanf("%d",&cases);
    while(cases--)
    {
        int m,n;
        scanf("%d%d",&m,&n);
        int res = (ans[n]-ans[m-1]);
        if(res==0)
            res = -1;
    cout<<res<<endl;

    }



    return 0;
}
