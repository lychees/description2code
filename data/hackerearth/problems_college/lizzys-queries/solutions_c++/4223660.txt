#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 1000000007
#define eps 1e-13
#define PI 3.14159265359
#define N 1000009
#define INF 1000000011
#define INFLL 1000000000000000011
#define space printf(" ")
#define endl printf("\n")
#define vi vector<int>
#define vll vector<long long>
#define vc vector<char>
#define vs vector<string>
#define pii pair<int, int>
#define pll pair<long long, long long>
#define pil pair<int, long long>
#define pli pair<long long, int>
#define pcc pair<char, char>
#define mp make_pair
#define F first
#define S second
#define pb(x) push_back(x)
#define fo(i,a,n) for(int i = (int)(a); i < (int)(n); i++)
#define sd(x) scanf("%d", &(x))
#define pd(x) printf("%d", (x))
#define pdn(x) printf("%d\n", (x))
#define sld(x) scanf("%lld", &(x))
#define pld(x) printf("%lld", (x))
#define pldn(x) printf("%lld\n", (x))
#define slf(x) scanf("%llf", &(x))
#define plf(x) printf("%.9llf", (x))
#define plfn(x) printf("%.9llf\n", (x))
#define sch(x) scanf("%c", &(x))
#define pch(x) printf("%c", (x))
#define pchn(x) printf("%c\n", (x))
#define gtl(x) getline(cin, (x))
#define flsh fflush(stdout)
#define sws ios::sync_with_stdio(false); cin.tie(0)
#define gcd __gcd
#define clr(x) memset(x,0,sizeof(x))
#define all(a) (a).begin(), (a).end()
	
/*ll gcd(ll a, ll b)
{
	if(b == 0)
		return a;
	return gcd(b, a%b);
}*/
	
ll modx(ll Base, ll exponent)
{
	ll ans = 1;
	if(Base == 1)
		return Base;
	while(exponent)
	{
		if(exponent & 1)
			ans = (ans * Base)%mod;
		Base = (Base * Base)%mod;
		exponent = exponent >> 1;
	}
	return ans;
}
	
ll inmodx(ll num)
{
	return (modx(num, mod-2LL));
}
	
bool cmp()
{
	return false;
}
	
ll st[2][2][400009], hs[2][2][100009], p[2][100009], im[2][100009];

void build(int node, int l, int r, int bit)
{
	if(l == r)
	{
		st[bit][0][node] = hs[bit][0][l];
		st[bit][1][node] = hs[bit][1][l];
		return;
	}
	int mid = (l+r)/2;
	build(2*node, l, mid, bit);
	build(2*node+1, mid+1, r, bit);
	st[bit][0][node] = (st[bit][0][2*node] + st[bit][0][2*node+1])%mod;
	st[bit][1][node] = (st[bit][1][2*node] + st[bit][1][2*node+1])%mod;
	return;
}

void update(int node, int l, int r, int index, ll val, int bit)
{
	if(l > r || l > index || r < index)
		return;
	if(index == l && index == r)
	{
		st[bit][0][node] = (st[bit][0][node] + val*p[0][index])%mod;
		st[bit][1][node] = (st[bit][1][node] + val*p[1][index])%mod;
		return;
	}
	int mid = (l+r)/2;
	if(index <= mid)
		update(2*node, l, mid, index, val, bit);
	else
		update(2*node+1, mid+1, r, index, val, bit);
	st[bit][0][node] = (st[bit][0][2*node] + st[bit][0][2*node+1])%mod;
	st[bit][1][node] = (st[bit][1][2*node] + st[bit][1][2*node+1])%mod;
	return;
}

pll query(int node, int l, int r, int p, int q, int bit)
{
	if(l > r || l > q || r < p)
		return mp(0LL, 0LL);
	if(l >= p && r <= q)
	{
		return mp(st[bit][0][node], st[bit][1][node]);
	}
	int mid = (l+r)/2;
	pll a = query(2*node, l, mid, p, q, bit);
	pll b = query(2*node+1, mid+1, r, p, q, bit);
	pll ans = mp((a.F+b.F)%mod, (a.S+b.S)%mod);
	return ans;
}

int main()
{
	sws;
	int n, q, i, l, r, a, j;
	string s;
	ll z;
	pll ans1, ans2, a1, a2;
	char x;
	p[0][0] = p[1][0] = 1LL;
	fo(i,1,100005)
	{
		p[0][i] = (p[0][i-1]*29LL)%mod;
		p[1][i] = (p[1][i-1]*31LL)%mod;
	}
	im[0][0] = im[1][0] = 1LL;
	im[0][1] = inmodx(29LL);
	im[1][1] = inmodx(31LL);
	fo(i,2,100005)
	{
		im[0][i] = (im[0][i-1]*im[0][1])%mod;
		im[1][i] = (im[1][i-1]*im[1][1])%mod;
	}
	cin >> n >> q;
	cin >> s;
	hs[0][0][0] = hs[0][1][0] = 0LL;
	hs[1][0][0] = hs[1][1][0] = 0LL;
	fo(i,1,n+1)
	{
		hs[0][0][i] = (((ll)((int)s[i-1] - 96))*p[0][i])%mod;
		hs[0][1][i] = (((ll)((int)s[i-1] - 96))*p[1][i])%mod;
		hs[1][0][i] = (((ll)((int)s[n-i] - 96))*p[0][i])%mod;
		hs[1][1][i] = (((ll)((int)s[n-i] - 96))*p[1][i])%mod;
	}
	build(1,1,n,0);
	build(1,1,n,1);
	while(q--)
	{
		cin >> a;
		if(a == 0)
		{
			cin >> i >> x;
			z = ((ll)((int)x - (int)s[i-1]) + mod)%mod;
			s[i-1] = x;
			update(1,1,n,i,z,0);
			update(1,1,n,n+1-i,z,1);
		}
		else
		{
			cin >> l >> r;
			pll ans1 = query(1,1,n,l,r,0);
			pll ans2 = query(1,1,n,n+1-r,n+1-l,1);
			a1 = mp((ans1.F*im[0][l])%mod, (ans1.S*im[1][l])%mod);
			a2 = mp((ans2.F*im[0][n+1-r])%mod, (ans2.S*im[1][n+1-r])%mod);
			if(a1 == a2)
				cout << "Yes\n";
			else
				cout << "No\n";
		}
	}
	return 0;
}