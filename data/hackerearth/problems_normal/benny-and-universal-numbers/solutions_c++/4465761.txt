/*
*/

//#pragma comment(linker, "/STACK:16777216")
#define _CRT_SECURE_NO_WARNINGS

#include <fstream>
#include <iostream>
#include <string>
#include <complex>
#include <math.h>
#include <set>
#include <vector>
#include <map>
#include <queue>
#include <stdio.h>
#include <stack>
#include <algorithm>
#include <list>
#include <ctime>
#include <memory.h>
#include <assert.h>

#define y0 sdkfaslhagaklsldk
#define y1 aasdfasdfasdf
#define yn askfhwqriuperikldjk
#define j1 assdgsdgasghsf
#define tm sdfjahlfasfh
#define lr asgasgash
#define norm asdfasdgasdgsd

#define eps 1e-9
#define M_PI 3.141592653589793
#define bs 1000000007
#define bsize 350

using namespace std;

const int INF = 1e9;
const int N = 100031;
const long long LCM = 360360;

int need_rem[1000];

vector<long long> numbers;
int pr[500];

bool prime_check(long long x)
{
	vector<int> dig;
	while (x)
	{
		dig.push_back(x % 10);
		x /= 10;
	}
	reverse(dig.begin(), dig.end());
	for (int i = 0; i + 1 < dig.size(); i++)
	{
		if (pr[dig[i] * 10 + dig[i + 1]] == 0)
			return 1;
	}
	return 0;
}
void dfs(long long val, int dep)
{
	if (dep == 16)
		return;
	if (val%dep != need_rem[dep])
		return;
	if (prime_check(val) == 1)
		numbers.push_back(val);
	for (int ad = 0; ad < 10; ad++)
	{
		dfs(val * 10 + ad, dep + 1);
	}
}

int main(){
	//freopen("fabro.in","r",stdin);
	//freopen("fabro.out","w",stdout);
	//freopen("F:/in.txt", "r", stdin);
	//freopen("F:/output.txt", "w", stdout);
	ios_base::sync_with_stdio(0);
	//cin.tie(0);

	pr[0] = 1;
	pr[1] = 1;
	for (int i = 2; i < 100; i++)
	{
		if (pr[i] == 0)
		{
			for (int j = i * 2; j <= 100; j += i)
				pr[j] = 1;
		}
	}

	for (int i = 1; i <= 15; i++)
	{
		assert(cin >> need_rem[i]);
	}

	for (int i = 1; i <= 9; i++)
		dfs(i, 1);

	sort(numbers.begin(), numbers.end());

	int tests;
	//cout << numbers.size() << endl;

	assert(cin >> tests);

	for (; tests; --tests)
	{
		long long L, R;
//		assert(cin >> L >> R);
		cin >> L >> R;
		cout << upper_bound(numbers.begin(), numbers.end(), R) - lower_bound(numbers.begin(), numbers.end(), L) << endl;
	}

	cin.get(); cin.get();
	return 0;
}