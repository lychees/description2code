#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
#include<algorithm>
#include<climits>
#include<sys/resource.h>

#define mod 1000000007
typedef long long li;
using namespace std;

typedef struct data
{
	li q;
	li r;
} data;

/*class comparison		//for Priority Queue
{
	public : 
	bool operator()(customer a,customer b)
	{
		int pra=0,prb=0;
		pra=a.next;
		prb=b.next;
		if(pra<prb)
			return true;
		else
			return false;
	}
};

int comp(const void *a, const void *b)
{
	data m = *((data *)a);
	data n = *((data *)b);
	if(m.a>n.a)
		return 1;
	else if(m.a<n.a)
		return -1;
	else if(m.a==n.a)
	{
		if(m.d>n.d)
			return 1;
		else
			return -1;
	}
}*/

li exp(li x, li y)
{
	if(y==0)
		return 1;
	li z=0;
	z=exp(x,y/2);
	z=z*z;
	if((y%2)==1)
		z=z*x;
	return z;
}

/*Disjoint-Set Data Structure*/
/*vector<int> L;
void Make_Set(int N,int S[])
{
	L.resize(N);
	int i=0;
	for(i=0;i<N;i++)
	{
		L[S[i]]=S[i]);
	}
}

void union_set(int x, int y)
{
	L[x]=y;
}

int find_set(int x)		//with path compression
{
	if(x==L[x])
		return x;
	int root;
	root=find_set(L[x]);
	L[x]=root;
	return root;
}*/

vector<vector<char> > B;
vector<vector<int> > A;
vector<int> C;
char S[1000005];

int dfs(int v, int p)
{
	int i=0, x=0,fe=0,be=0,flag=0;
    // Mark the current node as visited and print it
    C[v] = 1;
    // Recur for all the vertices adjacent to this vertex
    //printf("V : %d\n",v);
    for (i = 0; i < A[v].size(); ++i)
    {
    	//printf("C : %d\n",A[v][i]);
    	if (C[A[v][i]]==0)
    	{
    		fe=1;
    		x=dfs(A[v][i],v);
    		//printf("x : %d V : %d\n",x,v);
    		if(x==0) 
    			flag=1;
    	}
    	else if(A[v][i]!=p && C[A[v][i]]==1)
    		be=1;
    }
    if(flag==1)
    	return 0;
    if(fe==1 || be==1)
    	return 1;    
    else
    	return 0;	
}

int main()
{
	struct rlimit lim;
	lim.rlim_cur = lim.rlim_max = 200 << 20; // 200MB
	setrlimit(RLIMIT_STACK, &lim);
	long long T=0,M=0,N=0,Z=0,R=0,L=0,I=0,V=0,i=0,j=0,k=0,len=0,end=0,max=0,u=0,v=0,w=0,x=0,y=0,flag=0;
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld",&N,&M);
		R=0;
		flag=0;
		B.resize(N);
		for(i=0;i<N;i++)
		{
			B[i].resize(M);
		}
		V=(N+1)*(M+1);
		A.resize(V+1);
		C.resize(V+1,0);
		for(i=0;i<N;i++)
		{
			scanf("%s",S);
			for(j=0;j<M;j++)
			{
				B[i][j]=S[j];
			}
		}
		for(i=0;i<N;i++) // L to R
		{
			for(j=0;j<M-1;j++)
			{
				if(B[i][j]!=B[i][j+1])
				{
					u=(i*(M+1))+j+2;
					v=((i+1)*(M+1))+j+2;
					A[u].push_back(v);
					A[v].push_back(u);
				}
			}
		}
		for(i=0;i<N-1;i++)	// T to B
		{
			for(j=0;j<M;j++)
			{
				if(B[i][j]!=B[i+1][j])
				{
					u=((i+1)*(M+1))+j+1;
					v=((i+1)*(M+1))+j+2;
					A[u].push_back(v);
					A[v].push_back(u);
				}
			}
		}
		flag=0;
		for(i=1;i<=V;i++)
		{
			if(C[i]==0)
			{
				x=dfs(i,0);
				if(x==1)
				{
					printf("NO\n");
					flag=1;
					break;
				}
			}
		}
		if(flag==0)
			printf("YES\n");	
		A.clear();
		B.clear();
		C.clear();
	}		
	return 0;
}

	
