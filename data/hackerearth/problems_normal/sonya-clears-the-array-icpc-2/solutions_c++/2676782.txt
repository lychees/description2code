#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define MAX 2000000LL
#define LIMIT 10000000000000000LL
bool p[MAX/2];
vector<ll> primes;
ll num[500];
ll mat[500][500];
ll fn[500][500];

void sieve() {
	ll i,j,k;
	primes.push_back(2LL);
	for(i=3;i*i<MAX;i+=2) {
		if(p[i>>1]==false) {
			primes.push_back(i);
			for(j=i*i,k=i+i;j<MAX;j+=k)
				p[j>>1] = true;
		}
	}
	for(;i<MAX;i+=2)
		if(p[i>>1]==false)
			primes.push_back(i);
	return;
}

ll findSteps(ll a,ll b) {
	if(a<=b) {
		auto keya = lower_bound(primes.begin(),primes.end(),a);
		auto keyb = lower_bound(primes.begin(),primes.end(),b);
		int p = keya - primes.begin();
		int q = keyb - primes.begin();
		if(p+1<q)
			p=q-1;
		else if(p+1>q)
			q=p+1;
		ll ans = primes[q]+primes[p]+1-a-b;
		return ans;
	}
	else {
		auto keya = lower_bound(primes.begin(),primes.end(),a);
		auto keyb = lower_bound(primes.begin(),primes.end(),b);
		int p = keya - primes.begin();
		int q = keyb - primes.begin();
			q=p+1;
		ll ans = primes[q]+primes[p]+1-a-b;
		return ans;	
	}
}	

int main() {
	int n,i,j,k;
	sieve();
	scanf("%d",&n);
	for(i=0;i<n;i++)
		scanf("%lld",num+i);
	
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
			mat[i][j] = LIMIT;
	
	for(i=0;i<n;i++) {
		for(j=i+1;j<n;j++) {
			fn[j][i] = findSteps(num[i],num[j]);
			fn[i][j] = findSteps(num[j],num[i]);
		}
	}

	ll s;
	for(i=1;i<n;i++) {
		for(j=i-1;j>=0;j-=2) {
			for(k=j;k<i;k+=2) {
				s = fn[i][k];
				if(i>=k+2) {
					if(k>j)
						mat[i][j] = min(mat[i][j],s+mat[i-1][k+1]+mat[k-1][j]);
					else
						mat[i][j] = min(mat[i][j],s+mat[i-1][k+1]);
				}
				else {
					if(k>j)
						mat[i][j] = min(mat[i][j],s+mat[k-1][j]);
					else
						mat[i][j] = min(mat[i][j],s);	
				}
			}
		}
	}
	printf("%lld\n",mat[n-1][0]);
	return 0;
}

